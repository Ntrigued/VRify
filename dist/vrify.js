var Uh = { exports: {} }, el = {}, Nh = { exports: {} }, tl = { exports: {} };
tl.exports;
var Lp;
function r1() {
  return Lp || (Lp = 1, function(Ur, Ln) {
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function() {
      function gs(Y, Fe) {
        Object.defineProperty(cs.prototype, Y, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              Fe[0],
              Fe[1]
            );
          }
        });
      }
      function is(Y) {
        return Y === null || typeof Y != "object" ? null : (Y = ri && Y[ri] || Y["@@iterator"], typeof Y == "function" ? Y : null);
      }
      function ir(Y, Fe) {
        Y = (Y = Y.constructor) && (Y.displayName || Y.name) || "ReactClass";
        var tt = Y + "." + Fe;
        Ni[tt] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          Fe,
          Y
        ), Ni[tt] = !0);
      }
      function cs(Y, Fe, tt) {
        this.props = Y, this.context = Fe, this.refs = Dt, this.updater = tt || Be;
      }
      function j() {
      }
      function re(Y, Fe, tt) {
        this.props = Y, this.context = Fe, this.refs = Dt, this.updater = tt || Be;
      }
      function v(Y) {
        return "" + Y;
      }
      function C(Y) {
        try {
          v(Y);
          var Fe = !1;
        } catch {
          Fe = !0;
        }
        if (Fe) {
          Fe = console;
          var tt = Fe.error, lt = typeof Symbol == "function" && Symbol.toStringTag && Y[Symbol.toStringTag] || Y.constructor.name || "Object";
          return tt.call(
            Fe,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            lt
          ), v(Y);
        }
      }
      function w(Y) {
        if (Y == null) return null;
        if (typeof Y == "function")
          return Y.$$typeof === Yt ? null : Y.displayName || Y.name || null;
        if (typeof Y == "string") return Y;
        switch (Y) {
          case It:
            return "Fragment";
          case ut:
            return "Portal";
          case Rt:
            return "Profiler";
          case ht:
            return "StrictMode";
          case Tn:
            return "Suspense";
          case wn:
            return "SuspenseList";
        }
        if (typeof Y == "object")
          switch (typeof Y.tag == "number" && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), Y.$$typeof) {
            case cn:
              return (Y.displayName || "Context") + ".Provider";
            case Qt:
              return (Y._context.displayName || "Context") + ".Consumer";
            case Cn:
              var Fe = Y.render;
              return Y = Y.displayName, Y || (Y = Fe.displayName || Fe.name || "", Y = Y !== "" ? "ForwardRef(" + Y + ")" : "ForwardRef"), Y;
            case rn:
              return Fe = Y.displayName || null, Fe !== null ? Fe : w(Y.type) || "Memo";
            case Bn:
              Fe = Y._payload, Y = Y._init;
              try {
                return w(Y(Fe));
              } catch {
              }
          }
        return null;
      }
      function E(Y) {
        return typeof Y == "string" || typeof Y == "function" || Y === It || Y === Rt || Y === ht || Y === Tn || Y === wn || Y === di || typeof Y == "object" && Y !== null && (Y.$$typeof === Bn || Y.$$typeof === rn || Y.$$typeof === cn || Y.$$typeof === Qt || Y.$$typeof === Cn || Y.$$typeof === ae || Y.getModuleId !== void 0);
      }
      function y() {
      }
      function l() {
        if (Ce === 0) {
          fe = console.log, ge = console.info, xe = console.warn, H = console.error, M = console.group, R = console.groupCollapsed, ee = console.groupEnd;
          var Y = {
            configurable: !0,
            enumerable: !0,
            value: y,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Y,
            log: Y,
            warn: Y,
            error: Y,
            group: Y,
            groupCollapsed: Y,
            groupEnd: Y
          });
        }
        Ce++;
      }
      function d() {
        if (Ce--, Ce === 0) {
          var Y = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, {
            log: Et({}, Y, { value: fe }),
            info: Et({}, Y, { value: ge }),
            warn: Et({}, Y, { value: xe }),
            error: Et({}, Y, { value: H }),
            group: Et({}, Y, { value: M }),
            groupCollapsed: Et({}, Y, { value: R }),
            groupEnd: Et({}, Y, { value: ee })
          });
        }
        0 > Ce && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function p(Y) {
        if (he === void 0)
          try {
            throw Error();
          } catch (tt) {
            var Fe = tt.stack.trim().match(/\n( *(at )?)/);
            he = Fe && Fe[1] || "", we = -1 < tt.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < tt.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return `
` + he + Y + we;
      }
      function c(Y, Fe) {
        if (!Y || Oe) return "";
        var tt = Ct.get(Y);
        if (tt !== void 0) return tt;
        Oe = !0, tt = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
        var lt = null;
        lt = Xe.H, Xe.H = null, l();
        try {
          var Ut = {
            DetermineComponentFrameRoot: function() {
              try {
                if (Fe) {
                  var Ye = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(Ye.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(Ye, []);
                    } catch (rt) {
                      var Ke = rt;
                    }
                    Reflect.construct(Y, [], Ye);
                  } else {
                    try {
                      Ye.call();
                    } catch (rt) {
                      Ke = rt;
                    }
                    Y.call(Ye.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (rt) {
                    Ke = rt;
                  }
                  (Ye = Y()) && typeof Ye.catch == "function" && Ye.catch(function() {
                  });
                }
              } catch (rt) {
                if (rt && Ke && typeof rt.stack == "string")
                  return [rt.stack, Ke.stack];
              }
              return [null, null];
            }
          };
          Ut.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var hn = Object.getOwnPropertyDescriptor(
            Ut.DetermineComponentFrameRoot,
            "name"
          );
          hn && hn.configurable && Object.defineProperty(
            Ut.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var zt = Ut.DetermineComponentFrameRoot(), ai = zt[0], jn = zt[1];
          if (ai && jn) {
            var de = ai.split(`
`), _e = jn.split(`
`);
            for (zt = hn = 0; hn < de.length && !de[hn].includes(
              "DetermineComponentFrameRoot"
            ); )
              hn++;
            for (; zt < _e.length && !_e[zt].includes(
              "DetermineComponentFrameRoot"
            ); )
              zt++;
            if (hn === de.length || zt === _e.length)
              for (hn = de.length - 1, zt = _e.length - 1; 1 <= hn && 0 <= zt && de[hn] !== _e[zt]; )
                zt--;
            for (; 1 <= hn && 0 <= zt; hn--, zt--)
              if (de[hn] !== _e[zt]) {
                if (hn !== 1 || zt !== 1)
                  do
                    if (hn--, zt--, 0 > zt || de[hn] !== _e[zt]) {
                      var Ne = `
` + de[hn].replace(
                        " at new ",
                        " at "
                      );
                      return Y.displayName && Ne.includes("<anonymous>") && (Ne = Ne.replace("<anonymous>", Y.displayName)), typeof Y == "function" && Ct.set(Y, Ne), Ne;
                    }
                  while (1 <= hn && 0 <= zt);
                break;
              }
          }
        } finally {
          Oe = !1, Xe.H = lt, d(), Error.prepareStackTrace = tt;
        }
        return de = (de = Y ? Y.displayName || Y.name : "") ? p(de) : "", typeof Y == "function" && Ct.set(Y, de), de;
      }
      function g(Y) {
        if (Y == null) return "";
        if (typeof Y == "function") {
          var Fe = Y.prototype;
          return c(
            Y,
            !(!Fe || !Fe.isReactComponent)
          );
        }
        if (typeof Y == "string") return p(Y);
        switch (Y) {
          case Tn:
            return p("Suspense");
          case wn:
            return p("SuspenseList");
        }
        if (typeof Y == "object")
          switch (Y.$$typeof) {
            case Cn:
              return Y = c(Y.render, !1), Y;
            case rn:
              return g(Y.type);
            case Bn:
              Fe = Y._payload, Y = Y._init;
              try {
                return g(Y(Fe));
              } catch {
              }
          }
        return "";
      }
      function A() {
        var Y = Xe.A;
        return Y === null ? null : Y.getOwner();
      }
      function u(Y) {
        if (le.call(Y, "key")) {
          var Fe = Object.getOwnPropertyDescriptor(Y, "key").get;
          if (Fe && Fe.isReactWarning) return !1;
        }
        return Y.key !== void 0;
      }
      function f(Y, Fe) {
        function tt() {
          _t || (_t = !0, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            Fe
          ));
        }
        tt.isReactWarning = !0, Object.defineProperty(Y, "key", {
          get: tt,
          configurable: !0
        });
      }
      function x() {
        var Y = w(this.type);
        return qt[Y] || (qt[Y] = !0, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        )), Y = this.props.ref, Y !== void 0 ? Y : null;
      }
      function T(Y, Fe, tt, lt, Ut, hn) {
        return tt = hn.ref, Y = {
          $$typeof: st,
          type: Y,
          key: Fe,
          props: hn,
          _owner: Ut
        }, (tt !== void 0 ? tt : null) !== null ? Object.defineProperty(Y, "ref", {
          enumerable: !1,
          get: x
        }) : Object.defineProperty(Y, "ref", { enumerable: !1, value: null }), Y._store = {}, Object.defineProperty(Y._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(Y, "_debugInfo", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: null
        }), Object.freeze && (Object.freeze(Y.props), Object.freeze(Y)), Y;
      }
      function b(Y, Fe) {
        return Fe = T(
          Y.type,
          Fe,
          void 0,
          void 0,
          Y._owner,
          Y.props
        ), Fe._store.validated = Y._store.validated, Fe;
      }
      function D(Y, Fe) {
        if (typeof Y == "object" && Y && Y.$$typeof !== Pt) {
          if (Dn(Y))
            for (var tt = 0; tt < Y.length; tt++) {
              var lt = Y[tt];
              S(lt) && U(lt, Fe);
            }
          else if (S(Y))
            Y._store && (Y._store.validated = 1);
          else if (tt = is(Y), typeof tt == "function" && tt !== Y.entries && (tt = tt.call(Y), tt !== Y))
            for (; !(Y = tt.next()).done; )
              S(Y.value) && U(Y.value, Fe);
        }
      }
      function S(Y) {
        return typeof Y == "object" && Y !== null && Y.$$typeof === st;
      }
      function U(Y, Fe) {
        if (Y._store && !Y._store.validated && Y.key == null && (Y._store.validated = 1, Fe = G(Fe), !ki[Fe])) {
          ki[Fe] = !0;
          var tt = "";
          Y && Y._owner != null && Y._owner !== A() && (tt = null, typeof Y._owner.tag == "number" ? tt = w(Y._owner.type) : typeof Y._owner.name == "string" && (tt = Y._owner.name), tt = " It was passed a child from " + tt + ".");
          var lt = Xe.getCurrentStack;
          Xe.getCurrentStack = function() {
            var Ut = g(Y.type);
            return lt && (Ut += lt() || ""), Ut;
          }, console.error(
            'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
            Fe,
            tt
          ), Xe.getCurrentStack = lt;
        }
      }
      function G(Y) {
        var Fe = "", tt = A();
        return tt && (tt = w(tt.type)) && (Fe = `

Check the render method of \`` + tt + "`."), Fe || (Y = w(Y)) && (Fe = `

Check the top-level render call using <` + Y + ">."), Fe;
      }
      function Z(Y) {
        var Fe = { "=": "=0", ":": "=2" };
        return "$" + Y.replace(/[=:]/g, function(tt) {
          return Fe[tt];
        });
      }
      function W(Y, Fe) {
        return typeof Y == "object" && Y !== null && Y.key != null ? (C(Y.key), Z("" + Y.key)) : Fe.toString(36);
      }
      function ie() {
      }
      function te(Y) {
        switch (Y.status) {
          case "fulfilled":
            return Y.value;
          case "rejected":
            throw Y.reason;
          default:
            switch (typeof Y.status == "string" ? Y.then(ie, ie) : (Y.status = "pending", Y.then(
              function(Fe) {
                Y.status === "pending" && (Y.status = "fulfilled", Y.value = Fe);
              },
              function(Fe) {
                Y.status === "pending" && (Y.status = "rejected", Y.reason = Fe);
              }
            )), Y.status) {
              case "fulfilled":
                return Y.value;
              case "rejected":
                throw Y.reason;
            }
        }
        throw Y;
      }
      function X(Y, Fe, tt, lt, Ut) {
        var hn = typeof Y;
        (hn === "undefined" || hn === "boolean") && (Y = null);
        var zt = !1;
        if (Y === null) zt = !0;
        else
          switch (hn) {
            case "bigint":
            case "string":
            case "number":
              zt = !0;
              break;
            case "object":
              switch (Y.$$typeof) {
                case st:
                case ut:
                  zt = !0;
                  break;
                case Bn:
                  return zt = Y._init, X(
                    zt(Y._payload),
                    Fe,
                    tt,
                    lt,
                    Ut
                  );
              }
          }
        if (zt) {
          zt = Y, Ut = Ut(zt);
          var ai = lt === "" ? "." + W(zt, 0) : lt;
          return Dn(Ut) ? (tt = "", ai != null && (tt = ai.replace(Oi, "$&/") + "/"), X(Ut, Fe, tt, "", function(de) {
            return de;
          })) : Ut != null && (S(Ut) && (Ut.key != null && (zt && zt.key === Ut.key || C(Ut.key)), tt = b(
            Ut,
            tt + (Ut.key == null || zt && zt.key === Ut.key ? "" : ("" + Ut.key).replace(
              Oi,
              "$&/"
            ) + "/") + ai
          ), lt !== "" && zt != null && S(zt) && zt.key == null && zt._store && !zt._store.validated && (tt._store.validated = 2), Ut = tt), Fe.push(Ut)), 1;
        }
        if (zt = 0, ai = lt === "" ? "." : lt + ":", Dn(Y))
          for (var jn = 0; jn < Y.length; jn++)
            lt = Y[jn], hn = ai + W(lt, jn), zt += X(
              lt,
              Fe,
              tt,
              hn,
              Ut
            );
        else if (jn = is(Y), typeof jn == "function")
          for (jn === Y.entries && (vn || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), vn = !0), Y = jn.call(Y), jn = 0; !(lt = Y.next()).done; )
            lt = lt.value, hn = ai + W(lt, jn++), zt += X(
              lt,
              Fe,
              tt,
              hn,
              Ut
            );
        else if (hn === "object") {
          if (typeof Y.then == "function")
            return X(
              te(Y),
              Fe,
              tt,
              lt,
              Ut
            );
          throw Fe = String(Y), Error(
            "Objects are not valid as a React child (found: " + (Fe === "[object Object]" ? "object with keys {" + Object.keys(Y).join(", ") + "}" : Fe) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return zt;
      }
      function Q(Y, Fe, tt) {
        if (Y == null) return Y;
        var lt = [], Ut = 0;
        return X(Y, lt, "", "", function(hn) {
          return Fe.call(tt, hn, Ut++);
        }), lt;
      }
      function O(Y) {
        if (Y._status === -1) {
          var Fe = Y._result;
          Fe = Fe(), Fe.then(
            function(tt) {
              (Y._status === 0 || Y._status === -1) && (Y._status = 1, Y._result = tt);
            },
            function(tt) {
              (Y._status === 0 || Y._status === -1) && (Y._status = 2, Y._result = tt);
            }
          ), Y._status === -1 && (Y._status = 0, Y._result = Fe);
        }
        if (Y._status === 1)
          return Fe = Y._result, Fe === void 0 && console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
            Fe
          ), "default" in Fe || console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,
            Fe
          ), Fe.default;
        throw Y._result;
      }
      function K() {
        var Y = Xe.H;
        return Y === null && console.error(
          `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
        ), Y;
      }
      function ne() {
      }
      function pe(Y) {
        if (fr === null)
          try {
            var Fe = ("require" + Math.random()).slice(0, 7);
            fr = (Ur && Ur[Fe]).call(
              Ur,
              "timers"
            ).setImmediate;
          } catch {
            fr = function(lt) {
              Ei === !1 && (Ei = !0, typeof MessageChannel > "u" && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var Ut = new MessageChannel();
              Ut.port1.onmessage = lt, Ut.port2.postMessage(void 0);
            };
          }
        return fr(Y);
      }
      function be(Y) {
        return 1 < Y.length && typeof AggregateError == "function" ? new AggregateError(Y) : Y[0];
      }
      function Te(Y, Fe) {
        Fe !== Ii - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        ), Ii = Fe;
      }
      function ke(Y, Fe, tt) {
        var lt = Xe.actQueue;
        if (lt !== null)
          if (lt.length !== 0)
            try {
              Ve(lt), pe(function() {
                return ke(Y, Fe, tt);
              });
              return;
            } catch (Ut) {
              Xe.thrownErrors.push(Ut);
            }
          else Xe.actQueue = null;
        0 < Xe.thrownErrors.length ? (lt = be(Xe.thrownErrors), Xe.thrownErrors.length = 0, tt(lt)) : Fe(Y);
      }
      function Ve(Y) {
        if (!ji) {
          ji = !0;
          var Fe = 0;
          try {
            for (; Fe < Y.length; Fe++) {
              var tt = Y[Fe];
              do {
                Xe.didUsePromise = !1;
                var lt = tt(!1);
                if (lt !== null) {
                  if (Xe.didUsePromise) {
                    Y[Fe] = tt, Y.splice(0, Fe);
                    return;
                  }
                  tt = lt;
                } else break;
              } while (!0);
            }
            Y.length = 0;
          } catch (Ut) {
            Y.splice(0, Fe + 1), Xe.thrownErrors.push(Ut);
          } finally {
            ji = !1;
          }
        }
      }
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var st = Symbol.for("react.transitional.element"), ut = Symbol.for("react.portal"), It = Symbol.for("react.fragment"), ht = Symbol.for("react.strict_mode"), Rt = Symbol.for("react.profiler"), Qt = Symbol.for("react.consumer"), cn = Symbol.for("react.context"), Cn = Symbol.for("react.forward_ref"), Tn = Symbol.for("react.suspense"), wn = Symbol.for("react.suspense_list"), rn = Symbol.for("react.memo"), Bn = Symbol.for("react.lazy"), di = Symbol.for("react.offscreen"), ri = Symbol.iterator, Ni = {}, Be = {
        isMounted: function() {
          return !1;
        },
        enqueueForceUpdate: function(Y) {
          ir(Y, "forceUpdate");
        },
        enqueueReplaceState: function(Y) {
          ir(Y, "replaceState");
        },
        enqueueSetState: function(Y) {
          ir(Y, "setState");
        }
      }, Et = Object.assign, Dt = {};
      Object.freeze(Dt), cs.prototype.isReactComponent = {}, cs.prototype.setState = function(Y, Fe) {
        if (typeof Y != "object" && typeof Y != "function" && Y != null)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, Y, Fe, "setState");
      }, cs.prototype.forceUpdate = function(Y) {
        this.updater.enqueueForceUpdate(this, Y, "forceUpdate");
      };
      var $t = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, ei;
      for (ei in $t)
        $t.hasOwnProperty(ei) && gs(ei, $t[ei]);
      j.prototype = cs.prototype, $t = re.prototype = new j(), $t.constructor = re, Et($t, cs.prototype), $t.isPureReactComponent = !0;
      var Dn = Array.isArray, Yt = Symbol.for("react.client.reference"), Xe = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null
      }, le = Object.prototype.hasOwnProperty, ae = Symbol.for("react.client.reference"), Ce = 0, fe, ge, xe, H, M, R, ee;
      y.__reactDisabledLog = !0;
      var he, we, Oe = !1, Ct = new (typeof WeakMap == "function" ? WeakMap : Map)(), Pt = Symbol.for("react.client.reference"), _t, St, qt = {}, ki = {}, vn = !1, Oi = /\/+/g, ui = typeof reportError == "function" ? reportError : function(Y) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var Fe = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof Y == "object" && Y !== null && typeof Y.message == "string" ? String(Y.message) : String(Y),
            error: Y
          });
          if (!window.dispatchEvent(Fe)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", Y);
          return;
        }
        console.error(Y);
      }, Ei = !1, fr = null, Ii = 0, Sr = !1, ji = !1, Cr = typeof queueMicrotask == "function" ? function(Y) {
        queueMicrotask(function() {
          return queueMicrotask(Y);
        });
      } : pe;
      Ln.Children = {
        map: Q,
        forEach: function(Y, Fe, tt) {
          Q(
            Y,
            function() {
              Fe.apply(this, arguments);
            },
            tt
          );
        },
        count: function(Y) {
          var Fe = 0;
          return Q(Y, function() {
            Fe++;
          }), Fe;
        },
        toArray: function(Y) {
          return Q(Y, function(Fe) {
            return Fe;
          }) || [];
        },
        only: function(Y) {
          if (!S(Y))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return Y;
        }
      }, Ln.Component = cs, Ln.Fragment = It, Ln.Profiler = Rt, Ln.PureComponent = re, Ln.StrictMode = ht, Ln.Suspense = Tn, Ln.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Xe, Ln.act = function(Y) {
        var Fe = Xe.actQueue, tt = Ii;
        Ii++;
        var lt = Xe.actQueue = Fe !== null ? Fe : [], Ut = !1;
        try {
          var hn = Y();
        } catch (jn) {
          Xe.thrownErrors.push(jn);
        }
        if (0 < Xe.thrownErrors.length)
          throw Te(Fe, tt), Y = be(Xe.thrownErrors), Xe.thrownErrors.length = 0, Y;
        if (hn !== null && typeof hn == "object" && typeof hn.then == "function") {
          var zt = hn;
          return Cr(function() {
            Ut || Sr || (Sr = !0, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          }), {
            then: function(jn, de) {
              Ut = !0, zt.then(
                function(_e) {
                  if (Te(Fe, tt), tt === 0) {
                    try {
                      Ve(lt), pe(function() {
                        return ke(
                          _e,
                          jn,
                          de
                        );
                      });
                    } catch (Ye) {
                      Xe.thrownErrors.push(Ye);
                    }
                    if (0 < Xe.thrownErrors.length) {
                      var Ne = be(
                        Xe.thrownErrors
                      );
                      Xe.thrownErrors.length = 0, de(Ne);
                    }
                  } else jn(_e);
                },
                function(_e) {
                  Te(Fe, tt), 0 < Xe.thrownErrors.length && (_e = be(
                    Xe.thrownErrors
                  ), Xe.thrownErrors.length = 0), de(_e);
                }
              );
            }
          };
        }
        var ai = hn;
        if (Te(Fe, tt), tt === 0 && (Ve(lt), lt.length !== 0 && Cr(function() {
          Ut || Sr || (Sr = !0, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), Xe.actQueue = null), 0 < Xe.thrownErrors.length)
          throw Y = be(Xe.thrownErrors), Xe.thrownErrors.length = 0, Y;
        return {
          then: function(jn, de) {
            Ut = !0, tt === 0 ? (Xe.actQueue = lt, pe(function() {
              return ke(
                ai,
                jn,
                de
              );
            })) : jn(ai);
          }
        };
      }, Ln.cache = function(Y) {
        return function() {
          return Y.apply(null, arguments);
        };
      }, Ln.cloneElement = function(Y, Fe, tt) {
        if (Y == null)
          throw Error(
            "The argument must be a React element, but you passed " + Y + "."
          );
        var lt = Et({}, Y.props), Ut = Y.key, hn = Y._owner;
        if (Fe != null) {
          var zt;
          e: {
            if (le.call(Fe, "ref") && (zt = Object.getOwnPropertyDescriptor(
              Fe,
              "ref"
            ).get) && zt.isReactWarning) {
              zt = !1;
              break e;
            }
            zt = Fe.ref !== void 0;
          }
          zt && (hn = A()), u(Fe) && (C(Fe.key), Ut = "" + Fe.key);
          for (ai in Fe)
            !le.call(Fe, ai) || ai === "key" || ai === "__self" || ai === "__source" || ai === "ref" && Fe.ref === void 0 || (lt[ai] = Fe[ai]);
        }
        var ai = arguments.length - 2;
        if (ai === 1) lt.children = tt;
        else if (1 < ai) {
          zt = Array(ai);
          for (var jn = 0; jn < ai; jn++)
            zt[jn] = arguments[jn + 2];
          lt.children = zt;
        }
        for (lt = T(Y.type, Ut, void 0, void 0, hn, lt), Ut = 2; Ut < arguments.length; Ut++)
          D(arguments[Ut], lt.type);
        return lt;
      }, Ln.createContext = function(Y) {
        return Y = {
          $$typeof: cn,
          _currentValue: Y,
          _currentValue2: Y,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, Y.Provider = Y, Y.Consumer = {
          $$typeof: Qt,
          _context: Y
        }, Y._currentRenderer = null, Y._currentRenderer2 = null, Y;
      }, Ln.createElement = function(Y, Fe, tt) {
        if (E(Y))
          for (var lt = 2; lt < arguments.length; lt++)
            D(arguments[lt], Y);
        else {
          if (lt = "", (Y === void 0 || typeof Y == "object" && Y !== null && Object.keys(Y).length === 0) && (lt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), Y === null) var Ut = "null";
          else
            Dn(Y) ? Ut = "array" : Y !== void 0 && Y.$$typeof === st ? (Ut = "<" + (w(Y.type) || "Unknown") + " />", lt = " Did you accidentally export a JSX literal instead of a component?") : Ut = typeof Y;
          console.error(
            "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
            Ut,
            lt
          );
        }
        var hn;
        if (lt = {}, Ut = null, Fe != null)
          for (hn in St || !("__self" in Fe) || "key" in Fe || (St = !0, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), u(Fe) && (C(Fe.key), Ut = "" + Fe.key), Fe)
            le.call(Fe, hn) && hn !== "key" && hn !== "__self" && hn !== "__source" && (lt[hn] = Fe[hn]);
        var zt = arguments.length - 2;
        if (zt === 1) lt.children = tt;
        else if (1 < zt) {
          for (var ai = Array(zt), jn = 0; jn < zt; jn++)
            ai[jn] = arguments[jn + 2];
          Object.freeze && Object.freeze(ai), lt.children = ai;
        }
        if (Y && Y.defaultProps)
          for (hn in zt = Y.defaultProps, zt)
            lt[hn] === void 0 && (lt[hn] = zt[hn]);
        return Ut && f(
          lt,
          typeof Y == "function" ? Y.displayName || Y.name || "Unknown" : Y
        ), T(Y, Ut, void 0, void 0, A(), lt);
      }, Ln.createRef = function() {
        var Y = { current: null };
        return Object.seal(Y), Y;
      }, Ln.forwardRef = function(Y) {
        Y != null && Y.$$typeof === rn ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : typeof Y != "function" ? console.error(
          "forwardRef requires a render function but was given %s.",
          Y === null ? "null" : typeof Y
        ) : Y.length !== 0 && Y.length !== 2 && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          Y.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        ), Y != null && Y.defaultProps != null && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var Fe = { $$typeof: Cn, render: Y }, tt;
        return Object.defineProperty(Fe, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return tt;
          },
          set: function(lt) {
            tt = lt, Y.name || Y.displayName || (Object.defineProperty(Y, "name", { value: lt }), Y.displayName = lt);
          }
        }), Fe;
      }, Ln.isValidElement = S, Ln.lazy = function(Y) {
        return {
          $$typeof: Bn,
          _payload: { _status: -1, _result: Y },
          _init: O
        };
      }, Ln.memo = function(Y, Fe) {
        E(Y) || console.error(
          "memo: The first argument must be a component. Instead received: %s",
          Y === null ? "null" : typeof Y
        ), Fe = {
          $$typeof: rn,
          type: Y,
          compare: Fe === void 0 ? null : Fe
        };
        var tt;
        return Object.defineProperty(Fe, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return tt;
          },
          set: function(lt) {
            tt = lt, Y.name || Y.displayName || (Object.defineProperty(Y, "name", { value: lt }), Y.displayName = lt);
          }
        }), Fe;
      }, Ln.startTransition = function(Y) {
        var Fe = Xe.T, tt = {};
        Xe.T = tt, tt._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var lt = Y(), Ut = Xe.S;
          Ut !== null && Ut(tt, lt), typeof lt == "object" && lt !== null && typeof lt.then == "function" && lt.then(ne, ui);
        } catch (hn) {
          ui(hn);
        } finally {
          Fe === null && tt._updatedFibers && (Y = tt._updatedFibers.size, tt._updatedFibers.clear(), 10 < Y && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), Xe.T = Fe;
        }
      }, Ln.unstable_useCacheRefresh = function() {
        return K().useCacheRefresh();
      }, Ln.use = function(Y) {
        return K().use(Y);
      }, Ln.useActionState = function(Y, Fe, tt) {
        return K().useActionState(
          Y,
          Fe,
          tt
        );
      }, Ln.useCallback = function(Y, Fe) {
        return K().useCallback(Y, Fe);
      }, Ln.useContext = function(Y) {
        var Fe = K();
        return Y.$$typeof === Qt && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        ), Fe.useContext(Y);
      }, Ln.useDebugValue = function(Y, Fe) {
        return K().useDebugValue(Y, Fe);
      }, Ln.useDeferredValue = function(Y, Fe) {
        return K().useDeferredValue(Y, Fe);
      }, Ln.useEffect = function(Y, Fe) {
        return K().useEffect(Y, Fe);
      }, Ln.useId = function() {
        return K().useId();
      }, Ln.useImperativeHandle = function(Y, Fe, tt) {
        return K().useImperativeHandle(Y, Fe, tt);
      }, Ln.useInsertionEffect = function(Y, Fe) {
        return K().useInsertionEffect(Y, Fe);
      }, Ln.useLayoutEffect = function(Y, Fe) {
        return K().useLayoutEffect(Y, Fe);
      }, Ln.useMemo = function(Y, Fe) {
        return K().useMemo(Y, Fe);
      }, Ln.useOptimistic = function(Y, Fe) {
        return K().useOptimistic(Y, Fe);
      }, Ln.useReducer = function(Y, Fe, tt) {
        return K().useReducer(Y, Fe, tt);
      }, Ln.useRef = function(Y) {
        return K().useRef(Y);
      }, Ln.useState = function(Y) {
        return K().useState(Y);
      }, Ln.useSyncExternalStore = function(Y, Fe, tt) {
        return K().useSyncExternalStore(
          Y,
          Fe,
          tt
        );
      }, Ln.useTransition = function() {
        return K().useTransition();
      }, Ln.version = "19.0.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }(tl, tl.exports)), tl.exports;
}
var Dp;
function s1() {
  return Dp || (Dp = 1, Nh.exports = r1()), Nh.exports;
}
var Pp;
function o1() {
  if (Pp) return el;
  Pp = 1;
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return function() {
    function Ur(Be) {
      if (Be == null) return null;
      if (typeof Be == "function")
        return Be.$$typeof === O ? null : Be.displayName || Be.name || null;
      if (typeof Be == "string") return Be;
      switch (Be) {
        case T:
          return "Fragment";
        case x:
          return "Portal";
        case D:
          return "Profiler";
        case b:
          return "StrictMode";
        case Z:
          return "Suspense";
        case W:
          return "SuspenseList";
      }
      if (typeof Be == "object")
        switch (typeof Be.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), Be.$$typeof) {
          case U:
            return (Be.displayName || "Context") + ".Provider";
          case S:
            return (Be._context.displayName || "Context") + ".Consumer";
          case G:
            var Et = Be.render;
            return Be = Be.displayName, Be || (Be = Et.displayName || Et.name || "", Be = Be !== "" ? "ForwardRef(" + Be + ")" : "ForwardRef"), Be;
          case ie:
            return Et = Be.displayName || null, Et !== null ? Et : Ur(Be.type) || "Memo";
          case te:
            Et = Be._payload, Be = Be._init;
            try {
              return Ur(Be(Et));
            } catch {
            }
        }
      return null;
    }
    function Ln(Be) {
      return "" + Be;
    }
    function gs(Be) {
      try {
        Ln(Be);
        var Et = !1;
      } catch {
        Et = !0;
      }
      if (Et) {
        Et = console;
        var Dt = Et.error, $t = typeof Symbol == "function" && Symbol.toStringTag && Be[Symbol.toStringTag] || Be.constructor.name || "Object";
        return Dt.call(
          Et,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          $t
        ), Ln(Be);
      }
    }
    function is() {
    }
    function ir() {
      if (ke === 0) {
        Ve = console.log, st = console.info, ut = console.warn, It = console.error, ht = console.group, Rt = console.groupCollapsed, Qt = console.groupEnd;
        var Be = {
          configurable: !0,
          enumerable: !0,
          value: is,
          writable: !0
        };
        Object.defineProperties(console, {
          info: Be,
          log: Be,
          warn: Be,
          error: Be,
          group: Be,
          groupCollapsed: Be,
          groupEnd: Be
        });
      }
      ke++;
    }
    function cs() {
      if (ke--, ke === 0) {
        var Be = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: pe({}, Be, { value: Ve }),
          info: pe({}, Be, { value: st }),
          warn: pe({}, Be, { value: ut }),
          error: pe({}, Be, { value: It }),
          group: pe({}, Be, { value: ht }),
          groupCollapsed: pe({}, Be, { value: Rt }),
          groupEnd: pe({}, Be, { value: Qt })
        });
      }
      0 > ke && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function j(Be) {
      if (cn === void 0)
        try {
          throw Error();
        } catch (Dt) {
          var Et = Dt.stack.trim().match(/\n( *(at )?)/);
          cn = Et && Et[1] || "", Cn = -1 < Dt.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < Dt.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + cn + Be + Cn;
    }
    function re(Be, Et) {
      if (!Be || Tn) return "";
      var Dt = wn.get(Be);
      if (Dt !== void 0) return Dt;
      Tn = !0, Dt = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var $t = null;
      $t = K.H, K.H = null, ir();
      try {
        var ei = {
          DetermineComponentFrameRoot: function() {
            try {
              if (Et) {
                var ge = function() {
                  throw Error();
                };
                if (Object.defineProperty(ge.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(ge, []);
                  } catch (H) {
                    var xe = H;
                  }
                  Reflect.construct(Be, [], ge);
                } else {
                  try {
                    ge.call();
                  } catch (H) {
                    xe = H;
                  }
                  Be.call(ge.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (H) {
                  xe = H;
                }
                (ge = Be()) && typeof ge.catch == "function" && ge.catch(function() {
                });
              }
            } catch (H) {
              if (H && xe && typeof H.stack == "string")
                return [H.stack, xe.stack];
            }
            return [null, null];
          }
        };
        ei.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var Dn = Object.getOwnPropertyDescriptor(
          ei.DetermineComponentFrameRoot,
          "name"
        );
        Dn && Dn.configurable && Object.defineProperty(
          ei.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var Yt = ei.DetermineComponentFrameRoot(), Xe = Yt[0], le = Yt[1];
        if (Xe && le) {
          var ae = Xe.split(`
`), Ce = le.split(`
`);
          for (Yt = Dn = 0; Dn < ae.length && !ae[Dn].includes(
            "DetermineComponentFrameRoot"
          ); )
            Dn++;
          for (; Yt < Ce.length && !Ce[Yt].includes(
            "DetermineComponentFrameRoot"
          ); )
            Yt++;
          if (Dn === ae.length || Yt === Ce.length)
            for (Dn = ae.length - 1, Yt = Ce.length - 1; 1 <= Dn && 0 <= Yt && ae[Dn] !== Ce[Yt]; )
              Yt--;
          for (; 1 <= Dn && 0 <= Yt; Dn--, Yt--)
            if (ae[Dn] !== Ce[Yt]) {
              if (Dn !== 1 || Yt !== 1)
                do
                  if (Dn--, Yt--, 0 > Yt || ae[Dn] !== Ce[Yt]) {
                    var fe = `
` + ae[Dn].replace(
                      " at new ",
                      " at "
                    );
                    return Be.displayName && fe.includes("<anonymous>") && (fe = fe.replace("<anonymous>", Be.displayName)), typeof Be == "function" && wn.set(Be, fe), fe;
                  }
                while (1 <= Dn && 0 <= Yt);
              break;
            }
        }
      } finally {
        Tn = !1, K.H = $t, cs(), Error.prepareStackTrace = Dt;
      }
      return ae = (ae = Be ? Be.displayName || Be.name : "") ? j(ae) : "", typeof Be == "function" && wn.set(Be, ae), ae;
    }
    function v(Be) {
      if (Be == null) return "";
      if (typeof Be == "function") {
        var Et = Be.prototype;
        return re(
          Be,
          !(!Et || !Et.isReactComponent)
        );
      }
      if (typeof Be == "string") return j(Be);
      switch (Be) {
        case Z:
          return j("Suspense");
        case W:
          return j("SuspenseList");
      }
      if (typeof Be == "object")
        switch (Be.$$typeof) {
          case G:
            return Be = re(Be.render, !1), Be;
          case ie:
            return v(Be.type);
          case te:
            Et = Be._payload, Be = Be._init;
            try {
              return v(Be(Et));
            } catch {
            }
        }
      return "";
    }
    function C() {
      var Be = K.A;
      return Be === null ? null : Be.getOwner();
    }
    function w(Be) {
      if (ne.call(Be, "key")) {
        var Et = Object.getOwnPropertyDescriptor(Be, "key").get;
        if (Et && Et.isReactWarning) return !1;
      }
      return Be.key !== void 0;
    }
    function E(Be, Et) {
      function Dt() {
        Bn || (Bn = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          Et
        ));
      }
      Dt.isReactWarning = !0, Object.defineProperty(Be, "key", {
        get: Dt,
        configurable: !0
      });
    }
    function y() {
      var Be = Ur(this.type);
      return di[Be] || (di[Be] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), Be = this.props.ref, Be !== void 0 ? Be : null;
    }
    function l(Be, Et, Dt, $t, ei, Dn) {
      return Dt = Dn.ref, Be = {
        $$typeof: f,
        type: Be,
        key: Et,
        props: Dn,
        _owner: ei
      }, (Dt !== void 0 ? Dt : null) !== null ? Object.defineProperty(Be, "ref", {
        enumerable: !1,
        get: y
      }) : Object.defineProperty(Be, "ref", { enumerable: !1, value: null }), Be._store = {}, Object.defineProperty(Be._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(Be, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.freeze && (Object.freeze(Be.props), Object.freeze(Be)), Be;
    }
    function d(Be, Et, Dt, $t, ei, Dn) {
      if (typeof Be == "string" || typeof Be == "function" || Be === T || Be === D || Be === b || Be === Z || Be === W || Be === X || typeof Be == "object" && Be !== null && (Be.$$typeof === te || Be.$$typeof === ie || Be.$$typeof === U || Be.$$typeof === S || Be.$$typeof === G || Be.$$typeof === be || Be.getModuleId !== void 0)) {
        var Yt = Et.children;
        if (Yt !== void 0)
          if ($t)
            if (Te(Yt)) {
              for ($t = 0; $t < Yt.length; $t++)
                p(Yt[$t], Be);
              Object.freeze && Object.freeze(Yt);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else p(Yt, Be);
      } else
        Yt = "", (Be === void 0 || typeof Be == "object" && Be !== null && Object.keys(Be).length === 0) && (Yt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), Be === null ? $t = "null" : Te(Be) ? $t = "array" : Be !== void 0 && Be.$$typeof === f ? ($t = "<" + (Ur(Be.type) || "Unknown") + " />", Yt = " Did you accidentally export a JSX literal instead of a component?") : $t = typeof Be, console.error(
          "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          $t,
          Yt
        );
      if (ne.call(Et, "key")) {
        Yt = Ur(Be);
        var Xe = Object.keys(Et).filter(function(ae) {
          return ae !== "key";
        });
        $t = 0 < Xe.length ? "{key: someKey, " + Xe.join(": ..., ") + ": ...}" : "{key: someKey}", ri[Yt + $t] || (Xe = 0 < Xe.length ? "{" + Xe.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          $t,
          Yt,
          Xe,
          Yt
        ), ri[Yt + $t] = !0);
      }
      if (Yt = null, Dt !== void 0 && (gs(Dt), Yt = "" + Dt), w(Et) && (gs(Et.key), Yt = "" + Et.key), "key" in Et) {
        Dt = {};
        for (var le in Et)
          le !== "key" && (Dt[le] = Et[le]);
      } else Dt = Et;
      return Yt && E(
        Dt,
        typeof Be == "function" ? Be.displayName || Be.name || "Unknown" : Be
      ), l(Be, Yt, Dn, ei, C(), Dt);
    }
    function p(Be, Et) {
      if (typeof Be == "object" && Be && Be.$$typeof !== rn) {
        if (Te(Be))
          for (var Dt = 0; Dt < Be.length; Dt++) {
            var $t = Be[Dt];
            c($t) && g($t, Et);
          }
        else if (c(Be))
          Be._store && (Be._store.validated = 1);
        else if (Be === null || typeof Be != "object" ? Dt = null : (Dt = Q && Be[Q] || Be["@@iterator"], Dt = typeof Dt == "function" ? Dt : null), typeof Dt == "function" && Dt !== Be.entries && (Dt = Dt.call(Be), Dt !== Be))
          for (; !(Be = Dt.next()).done; )
            c(Be.value) && g(Be.value, Et);
      }
    }
    function c(Be) {
      return typeof Be == "object" && Be !== null && Be.$$typeof === f;
    }
    function g(Be, Et) {
      if (Be._store && !Be._store.validated && Be.key == null && (Be._store.validated = 1, Et = A(Et), !Ni[Et])) {
        Ni[Et] = !0;
        var Dt = "";
        Be && Be._owner != null && Be._owner !== C() && (Dt = null, typeof Be._owner.tag == "number" ? Dt = Ur(Be._owner.type) : typeof Be._owner.name == "string" && (Dt = Be._owner.name), Dt = " It was passed a child from " + Dt + ".");
        var $t = K.getCurrentStack;
        K.getCurrentStack = function() {
          var ei = v(Be.type);
          return $t && (ei += $t() || ""), ei;
        }, console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          Et,
          Dt
        ), K.getCurrentStack = $t;
      }
    }
    function A(Be) {
      var Et = "", Dt = C();
      return Dt && (Dt = Ur(Dt.type)) && (Et = `

Check the render method of \`` + Dt + "`."), Et || (Be = Ur(Be)) && (Et = `

Check the top-level render call using <` + Be + ">."), Et;
    }
    var u = s1(), f = Symbol.for("react.transitional.element"), x = Symbol.for("react.portal"), T = Symbol.for("react.fragment"), b = Symbol.for("react.strict_mode"), D = Symbol.for("react.profiler"), S = Symbol.for("react.consumer"), U = Symbol.for("react.context"), G = Symbol.for("react.forward_ref"), Z = Symbol.for("react.suspense"), W = Symbol.for("react.suspense_list"), ie = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), X = Symbol.for("react.offscreen"), Q = Symbol.iterator, O = Symbol.for("react.client.reference"), K = u.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ne = Object.prototype.hasOwnProperty, pe = Object.assign, be = Symbol.for("react.client.reference"), Te = Array.isArray, ke = 0, Ve, st, ut, It, ht, Rt, Qt;
    is.__reactDisabledLog = !0;
    var cn, Cn, Tn = !1, wn = new (typeof WeakMap == "function" ? WeakMap : Map)(), rn = Symbol.for("react.client.reference"), Bn, di = {}, ri = {}, Ni = {};
    el.Fragment = T, el.jsx = function(Be, Et, Dt, $t, ei) {
      return d(Be, Et, Dt, !1, $t, ei);
    }, el.jsxs = function(Be, Et, Dt, $t, ei) {
      return d(Be, Et, Dt, !0, $t, ei);
    };
  }(), el;
}
var Op;
function a1() {
  return Op || (Op = 1, Uh.exports = o1()), Uh.exports;
}
a1();
var kh = { exports: {} }, Fp;
function l1() {
  return Fp || (Fp = 1, function(Ur, Ln) {
    (function(is, ir) {
      Ur.exports = ir();
    })(self, () => (
      /******/
      (() => {
        var gs = {
          /***/
          "./node_modules/an-array/index.js": (
            /*!****************************************!*\
              !*** ./node_modules/an-array/index.js ***!
              \****************************************/
            /***/
            (j) => {
              var re = Object.prototype.toString;
              j.exports = v;
              function v(C) {
                return C.BYTES_PER_ELEMENT && re.call(C.buffer) === "[object ArrayBuffer]" || Array.isArray(C);
              }
            }
          ),
          /***/
          "./node_modules/as-number/index.js": (
            /*!*****************************************!*\
              !*** ./node_modules/as-number/index.js ***!
              \*****************************************/
            /***/
            (j) => {
              j.exports = function(v, C) {
                return typeof v == "number" ? v : typeof C == "number" ? C : 0;
              };
            }
          ),
          /***/
          "./node_modules/base64-js/index.js": (
            /*!*****************************************!*\
              !*** ./node_modules/base64-js/index.js ***!
              \*****************************************/
            /***/
            (j, re) => {
              re.byteLength = p, re.toByteArray = g, re.fromByteArray = f;
              for (var v = [], C = [], w = typeof Uint8Array < "u" ? Uint8Array : Array, E = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", y = 0, l = E.length; y < l; ++y)
                v[y] = E[y], C[E.charCodeAt(y)] = y;
              C[45] = 62, C[95] = 63;
              function d(x) {
                var T = x.length;
                if (T % 4 > 0)
                  throw new Error("Invalid string. Length must be a multiple of 4");
                var b = x.indexOf("=");
                b === -1 && (b = T);
                var D = b === T ? 0 : 4 - b % 4;
                return [b, D];
              }
              function p(x) {
                var T = d(x), b = T[0], D = T[1];
                return (b + D) * 3 / 4 - D;
              }
              function c(x, T, b) {
                return (T + b) * 3 / 4 - b;
              }
              function g(x) {
                var T, b = d(x), D = b[0], S = b[1], U = new w(c(x, D, S)), G = 0, Z = S > 0 ? D - 4 : D, W;
                for (W = 0; W < Z; W += 4)
                  T = C[x.charCodeAt(W)] << 18 | C[x.charCodeAt(W + 1)] << 12 | C[x.charCodeAt(W + 2)] << 6 | C[x.charCodeAt(W + 3)], U[G++] = T >> 16 & 255, U[G++] = T >> 8 & 255, U[G++] = T & 255;
                return S === 2 && (T = C[x.charCodeAt(W)] << 2 | C[x.charCodeAt(W + 1)] >> 4, U[G++] = T & 255), S === 1 && (T = C[x.charCodeAt(W)] << 10 | C[x.charCodeAt(W + 1)] << 4 | C[x.charCodeAt(W + 2)] >> 2, U[G++] = T >> 8 & 255, U[G++] = T & 255), U;
              }
              function A(x) {
                return v[x >> 18 & 63] + v[x >> 12 & 63] + v[x >> 6 & 63] + v[x & 63];
              }
              function u(x, T, b) {
                for (var D, S = [], U = T; U < b; U += 3)
                  D = (x[U] << 16 & 16711680) + (x[U + 1] << 8 & 65280) + (x[U + 2] & 255), S.push(A(D));
                return S.join("");
              }
              function f(x) {
                for (var T, b = x.length, D = b % 3, S = [], U = 16383, G = 0, Z = b - D; G < Z; G += U)
                  S.push(u(x, G, G + U > Z ? Z : G + U));
                return D === 1 ? (T = x[b - 1], S.push(v[T >> 2] + v[T << 4 & 63] + "==")) : D === 2 && (T = (x[b - 2] << 8) + x[b - 1], S.push(v[T >> 10] + v[T >> 4 & 63] + v[T << 2 & 63] + "=")), S.join("");
              }
            }
          ),
          /***/
          "./node_modules/buffer-equal/index.js": (
            /*!********************************************!*\
              !*** ./node_modules/buffer-equal/index.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! buffer */
                "./node_modules/buffer/index.js"
              ).Buffer;
              j.exports = function(w, E) {
                if (C.isBuffer(w) && C.isBuffer(E)) {
                  if (typeof w.equals == "function") return w.equals(E);
                  if (w.length !== E.length) return !1;
                  for (var y = 0; y < w.length; y++)
                    if (w[y] !== E[y]) return !1;
                  return !0;
                }
              };
            }
          ),
          /***/
          "./node_modules/buffer/index.js": (
            /*!**************************************!*\
              !*** ./node_modules/buffer/index.js ***!
              \**************************************/
            /***/
            (j, re, v) => {
              /*!
               * The buffer module from node.js, for the browser.
               *
               * @author   Feross Aboukhadijeh <https://feross.org>
               * @license  MIT
               */
              const C = v(
                /*! base64-js */
                "./node_modules/base64-js/index.js"
              ), w = v(
                /*! ieee754 */
                "./node_modules/ieee754/index.js"
              ), E = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
              re.Buffer = p, re.SlowBuffer = U, re.INSPECT_MAX_BYTES = 50;
              const y = 2147483647;
              re.kMaxLength = y, p.TYPED_ARRAY_SUPPORT = l(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
              function l() {
                try {
                  const H = new Uint8Array(1), M = {
                    foo: function() {
                      return 42;
                    }
                  };
                  return Object.setPrototypeOf(M, Uint8Array.prototype), Object.setPrototypeOf(H, M), H.foo() === 42;
                } catch {
                  return !1;
                }
              }
              Object.defineProperty(p.prototype, "parent", {
                enumerable: !0,
                get: function() {
                  if (p.isBuffer(this))
                    return this.buffer;
                }
              }), Object.defineProperty(p.prototype, "offset", {
                enumerable: !0,
                get: function() {
                  if (p.isBuffer(this))
                    return this.byteOffset;
                }
              });
              function d(H) {
                if (H > y)
                  throw new RangeError('The value "' + H + '" is invalid for option "size"');
                const M = new Uint8Array(H);
                return Object.setPrototypeOf(M, p.prototype), M;
              }
              function p(H, M, R) {
                if (typeof H == "number") {
                  if (typeof M == "string")
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                  return u(H);
                }
                return c(H, M, R);
              }
              p.poolSize = 8192;
              function c(H, M, R) {
                if (typeof H == "string")
                  return f(H, M);
                if (ArrayBuffer.isView(H))
                  return T(H);
                if (H == null)
                  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof H);
                if (ae(H, ArrayBuffer) || H && ae(H.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ae(H, SharedArrayBuffer) || H && ae(H.buffer, SharedArrayBuffer)))
                  return b(H, M, R);
                if (typeof H == "number")
                  throw new TypeError('The "value" argument must not be of type number. Received type number');
                const ee = H.valueOf && H.valueOf();
                if (ee != null && ee !== H)
                  return p.from(ee, M, R);
                const he = D(H);
                if (he) return he;
                if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof H[Symbol.toPrimitive] == "function")
                  return p.from(H[Symbol.toPrimitive]("string"), M, R);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof H);
              }
              p.from = function(H, M, R) {
                return c(H, M, R);
              }, Object.setPrototypeOf(p.prototype, Uint8Array.prototype), Object.setPrototypeOf(p, Uint8Array);
              function g(H) {
                if (typeof H != "number")
                  throw new TypeError('"size" argument must be of type number');
                if (H < 0)
                  throw new RangeError('The value "' + H + '" is invalid for option "size"');
              }
              function A(H, M, R) {
                return g(H), H <= 0 ? d(H) : M !== void 0 ? typeof R == "string" ? d(H).fill(M, R) : d(H).fill(M) : d(H);
              }
              p.alloc = function(H, M, R) {
                return A(H, M, R);
              };
              function u(H) {
                return g(H), d(H < 0 ? 0 : S(H) | 0);
              }
              p.allocUnsafe = function(H) {
                return u(H);
              }, p.allocUnsafeSlow = function(H) {
                return u(H);
              };
              function f(H, M) {
                if ((typeof M != "string" || M === "") && (M = "utf8"), !p.isEncoding(M))
                  throw new TypeError("Unknown encoding: " + M);
                const R = G(H, M) | 0;
                let ee = d(R);
                const he = ee.write(H, M);
                return he !== R && (ee = ee.slice(0, he)), ee;
              }
              function x(H) {
                const M = H.length < 0 ? 0 : S(H.length) | 0, R = d(M);
                for (let ee = 0; ee < M; ee += 1)
                  R[ee] = H[ee] & 255;
                return R;
              }
              function T(H) {
                if (ae(H, Uint8Array)) {
                  const M = new Uint8Array(H);
                  return b(M.buffer, M.byteOffset, M.byteLength);
                }
                return x(H);
              }
              function b(H, M, R) {
                if (M < 0 || H.byteLength < M)
                  throw new RangeError('"offset" is outside of buffer bounds');
                if (H.byteLength < M + (R || 0))
                  throw new RangeError('"length" is outside of buffer bounds');
                let ee;
                return M === void 0 && R === void 0 ? ee = new Uint8Array(H) : R === void 0 ? ee = new Uint8Array(H, M) : ee = new Uint8Array(H, M, R), Object.setPrototypeOf(ee, p.prototype), ee;
              }
              function D(H) {
                if (p.isBuffer(H)) {
                  const M = S(H.length) | 0, R = d(M);
                  return R.length === 0 || H.copy(R, 0, 0, M), R;
                }
                if (H.length !== void 0)
                  return typeof H.length != "number" || Ce(H.length) ? d(0) : x(H);
                if (H.type === "Buffer" && Array.isArray(H.data))
                  return x(H.data);
              }
              function S(H) {
                if (H >= y)
                  throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + y.toString(16) + " bytes");
                return H | 0;
              }
              function U(H) {
                return +H != H && (H = 0), p.alloc(+H);
              }
              p.isBuffer = function(M) {
                return M != null && M._isBuffer === !0 && M !== p.prototype;
              }, p.compare = function(M, R) {
                if (ae(M, Uint8Array) && (M = p.from(M, M.offset, M.byteLength)), ae(R, Uint8Array) && (R = p.from(R, R.offset, R.byteLength)), !p.isBuffer(M) || !p.isBuffer(R))
                  throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (M === R) return 0;
                let ee = M.length, he = R.length;
                for (let we = 0, Oe = Math.min(ee, he); we < Oe; ++we)
                  if (M[we] !== R[we]) {
                    ee = M[we], he = R[we];
                    break;
                  }
                return ee < he ? -1 : he < ee ? 1 : 0;
              }, p.isEncoding = function(M) {
                switch (String(M).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return !0;
                  default:
                    return !1;
                }
              }, p.concat = function(M, R) {
                if (!Array.isArray(M))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                if (M.length === 0)
                  return p.alloc(0);
                let ee;
                if (R === void 0)
                  for (R = 0, ee = 0; ee < M.length; ++ee)
                    R += M[ee].length;
                const he = p.allocUnsafe(R);
                let we = 0;
                for (ee = 0; ee < M.length; ++ee) {
                  let Oe = M[ee];
                  if (ae(Oe, Uint8Array))
                    we + Oe.length > he.length ? (p.isBuffer(Oe) || (Oe = p.from(Oe)), Oe.copy(he, we)) : Uint8Array.prototype.set.call(he, Oe, we);
                  else if (p.isBuffer(Oe))
                    Oe.copy(he, we);
                  else
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  we += Oe.length;
                }
                return he;
              };
              function G(H, M) {
                if (p.isBuffer(H))
                  return H.length;
                if (ArrayBuffer.isView(H) || ae(H, ArrayBuffer))
                  return H.byteLength;
                if (typeof H != "string")
                  throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof H);
                const R = H.length, ee = arguments.length > 2 && arguments[2] === !0;
                if (!ee && R === 0) return 0;
                let he = !1;
                for (; ; )
                  switch (M) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return R;
                    case "utf8":
                    case "utf-8":
                      return ei(H).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return R * 2;
                    case "hex":
                      return R >>> 1;
                    case "base64":
                      return Xe(H).length;
                    default:
                      if (he)
                        return ee ? -1 : ei(H).length;
                      M = ("" + M).toLowerCase(), he = !0;
                  }
              }
              p.byteLength = G;
              function Z(H, M, R) {
                let ee = !1;
                if ((M === void 0 || M < 0) && (M = 0), M > this.length || ((R === void 0 || R > this.length) && (R = this.length), R <= 0) || (R >>>= 0, M >>>= 0, R <= M))
                  return "";
                for (H || (H = "utf8"); ; )
                  switch (H) {
                    case "hex":
                      return ut(this, M, R);
                    case "utf8":
                    case "utf-8":
                      return be(this, M, R);
                    case "ascii":
                      return Ve(this, M, R);
                    case "latin1":
                    case "binary":
                      return st(this, M, R);
                    case "base64":
                      return pe(this, M, R);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return It(this, M, R);
                    default:
                      if (ee) throw new TypeError("Unknown encoding: " + H);
                      H = (H + "").toLowerCase(), ee = !0;
                  }
              }
              p.prototype._isBuffer = !0;
              function W(H, M, R) {
                const ee = H[M];
                H[M] = H[R], H[R] = ee;
              }
              p.prototype.swap16 = function() {
                const M = this.length;
                if (M % 2 !== 0)
                  throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (let R = 0; R < M; R += 2)
                  W(this, R, R + 1);
                return this;
              }, p.prototype.swap32 = function() {
                const M = this.length;
                if (M % 4 !== 0)
                  throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (let R = 0; R < M; R += 4)
                  W(this, R, R + 3), W(this, R + 1, R + 2);
                return this;
              }, p.prototype.swap64 = function() {
                const M = this.length;
                if (M % 8 !== 0)
                  throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (let R = 0; R < M; R += 8)
                  W(this, R, R + 7), W(this, R + 1, R + 6), W(this, R + 2, R + 5), W(this, R + 3, R + 4);
                return this;
              }, p.prototype.toString = function() {
                const M = this.length;
                return M === 0 ? "" : arguments.length === 0 ? be(this, 0, M) : Z.apply(this, arguments);
              }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(M) {
                if (!p.isBuffer(M)) throw new TypeError("Argument must be a Buffer");
                return this === M ? !0 : p.compare(this, M) === 0;
              }, p.prototype.inspect = function() {
                let M = "";
                const R = re.INSPECT_MAX_BYTES;
                return M = this.toString("hex", 0, R).replace(/(.{2})/g, "$1 ").trim(), this.length > R && (M += " ... "), "<Buffer " + M + ">";
              }, E && (p.prototype[E] = p.prototype.inspect), p.prototype.compare = function(M, R, ee, he, we) {
                if (ae(M, Uint8Array) && (M = p.from(M, M.offset, M.byteLength)), !p.isBuffer(M))
                  throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof M);
                if (R === void 0 && (R = 0), ee === void 0 && (ee = M ? M.length : 0), he === void 0 && (he = 0), we === void 0 && (we = this.length), R < 0 || ee > M.length || he < 0 || we > this.length)
                  throw new RangeError("out of range index");
                if (he >= we && R >= ee)
                  return 0;
                if (he >= we)
                  return -1;
                if (R >= ee)
                  return 1;
                if (R >>>= 0, ee >>>= 0, he >>>= 0, we >>>= 0, this === M) return 0;
                let Oe = we - he, Ct = ee - R;
                const Pt = Math.min(Oe, Ct), _t = this.slice(he, we), St = M.slice(R, ee);
                for (let qt = 0; qt < Pt; ++qt)
                  if (_t[qt] !== St[qt]) {
                    Oe = _t[qt], Ct = St[qt];
                    break;
                  }
                return Oe < Ct ? -1 : Ct < Oe ? 1 : 0;
              };
              function ie(H, M, R, ee, he) {
                if (H.length === 0) return -1;
                if (typeof R == "string" ? (ee = R, R = 0) : R > 2147483647 ? R = 2147483647 : R < -2147483648 && (R = -2147483648), R = +R, Ce(R) && (R = he ? 0 : H.length - 1), R < 0 && (R = H.length + R), R >= H.length) {
                  if (he) return -1;
                  R = H.length - 1;
                } else if (R < 0)
                  if (he) R = 0;
                  else return -1;
                if (typeof M == "string" && (M = p.from(M, ee)), p.isBuffer(M))
                  return M.length === 0 ? -1 : te(H, M, R, ee, he);
                if (typeof M == "number")
                  return M = M & 255, typeof Uint8Array.prototype.indexOf == "function" ? he ? Uint8Array.prototype.indexOf.call(H, M, R) : Uint8Array.prototype.lastIndexOf.call(H, M, R) : te(H, [M], R, ee, he);
                throw new TypeError("val must be string, number or Buffer");
              }
              function te(H, M, R, ee, he) {
                let we = 1, Oe = H.length, Ct = M.length;
                if (ee !== void 0 && (ee = String(ee).toLowerCase(), ee === "ucs2" || ee === "ucs-2" || ee === "utf16le" || ee === "utf-16le")) {
                  if (H.length < 2 || M.length < 2)
                    return -1;
                  we = 2, Oe /= 2, Ct /= 2, R /= 2;
                }
                function Pt(St, qt) {
                  return we === 1 ? St[qt] : St.readUInt16BE(qt * we);
                }
                let _t;
                if (he) {
                  let St = -1;
                  for (_t = R; _t < Oe; _t++)
                    if (Pt(H, _t) === Pt(M, St === -1 ? 0 : _t - St)) {
                      if (St === -1 && (St = _t), _t - St + 1 === Ct) return St * we;
                    } else
                      St !== -1 && (_t -= _t - St), St = -1;
                } else
                  for (R + Ct > Oe && (R = Oe - Ct), _t = R; _t >= 0; _t--) {
                    let St = !0;
                    for (let qt = 0; qt < Ct; qt++)
                      if (Pt(H, _t + qt) !== Pt(M, qt)) {
                        St = !1;
                        break;
                      }
                    if (St) return _t;
                  }
                return -1;
              }
              p.prototype.includes = function(M, R, ee) {
                return this.indexOf(M, R, ee) !== -1;
              }, p.prototype.indexOf = function(M, R, ee) {
                return ie(this, M, R, ee, !0);
              }, p.prototype.lastIndexOf = function(M, R, ee) {
                return ie(this, M, R, ee, !1);
              };
              function X(H, M, R, ee) {
                R = Number(R) || 0;
                const he = H.length - R;
                ee ? (ee = Number(ee), ee > he && (ee = he)) : ee = he;
                const we = M.length;
                ee > we / 2 && (ee = we / 2);
                let Oe;
                for (Oe = 0; Oe < ee; ++Oe) {
                  const Ct = parseInt(M.substr(Oe * 2, 2), 16);
                  if (Ce(Ct)) return Oe;
                  H[R + Oe] = Ct;
                }
                return Oe;
              }
              function Q(H, M, R, ee) {
                return le(ei(M, H.length - R), H, R, ee);
              }
              function O(H, M, R, ee) {
                return le(Dn(M), H, R, ee);
              }
              function K(H, M, R, ee) {
                return le(Xe(M), H, R, ee);
              }
              function ne(H, M, R, ee) {
                return le(Yt(M, H.length - R), H, R, ee);
              }
              p.prototype.write = function(M, R, ee, he) {
                if (R === void 0)
                  he = "utf8", ee = this.length, R = 0;
                else if (ee === void 0 && typeof R == "string")
                  he = R, ee = this.length, R = 0;
                else if (isFinite(R))
                  R = R >>> 0, isFinite(ee) ? (ee = ee >>> 0, he === void 0 && (he = "utf8")) : (he = ee, ee = void 0);
                else
                  throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                const we = this.length - R;
                if ((ee === void 0 || ee > we) && (ee = we), M.length > 0 && (ee < 0 || R < 0) || R > this.length)
                  throw new RangeError("Attempt to write outside buffer bounds");
                he || (he = "utf8");
                let Oe = !1;
                for (; ; )
                  switch (he) {
                    case "hex":
                      return X(this, M, R, ee);
                    case "utf8":
                    case "utf-8":
                      return Q(this, M, R, ee);
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return O(this, M, R, ee);
                    case "base64":
                      return K(this, M, R, ee);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ne(this, M, R, ee);
                    default:
                      if (Oe) throw new TypeError("Unknown encoding: " + he);
                      he = ("" + he).toLowerCase(), Oe = !0;
                  }
              }, p.prototype.toJSON = function() {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0)
                };
              };
              function pe(H, M, R) {
                return M === 0 && R === H.length ? C.fromByteArray(H) : C.fromByteArray(H.slice(M, R));
              }
              function be(H, M, R) {
                R = Math.min(H.length, R);
                const ee = [];
                let he = M;
                for (; he < R; ) {
                  const we = H[he];
                  let Oe = null, Ct = we > 239 ? 4 : we > 223 ? 3 : we > 191 ? 2 : 1;
                  if (he + Ct <= R) {
                    let Pt, _t, St, qt;
                    switch (Ct) {
                      case 1:
                        we < 128 && (Oe = we);
                        break;
                      case 2:
                        Pt = H[he + 1], (Pt & 192) === 128 && (qt = (we & 31) << 6 | Pt & 63, qt > 127 && (Oe = qt));
                        break;
                      case 3:
                        Pt = H[he + 1], _t = H[he + 2], (Pt & 192) === 128 && (_t & 192) === 128 && (qt = (we & 15) << 12 | (Pt & 63) << 6 | _t & 63, qt > 2047 && (qt < 55296 || qt > 57343) && (Oe = qt));
                        break;
                      case 4:
                        Pt = H[he + 1], _t = H[he + 2], St = H[he + 3], (Pt & 192) === 128 && (_t & 192) === 128 && (St & 192) === 128 && (qt = (we & 15) << 18 | (Pt & 63) << 12 | (_t & 63) << 6 | St & 63, qt > 65535 && qt < 1114112 && (Oe = qt));
                    }
                  }
                  Oe === null ? (Oe = 65533, Ct = 1) : Oe > 65535 && (Oe -= 65536, ee.push(Oe >>> 10 & 1023 | 55296), Oe = 56320 | Oe & 1023), ee.push(Oe), he += Ct;
                }
                return ke(ee);
              }
              const Te = 4096;
              function ke(H) {
                const M = H.length;
                if (M <= Te)
                  return String.fromCharCode.apply(String, H);
                let R = "", ee = 0;
                for (; ee < M; )
                  R += String.fromCharCode.apply(String, H.slice(ee, ee += Te));
                return R;
              }
              function Ve(H, M, R) {
                let ee = "";
                R = Math.min(H.length, R);
                for (let he = M; he < R; ++he)
                  ee += String.fromCharCode(H[he] & 127);
                return ee;
              }
              function st(H, M, R) {
                let ee = "";
                R = Math.min(H.length, R);
                for (let he = M; he < R; ++he)
                  ee += String.fromCharCode(H[he]);
                return ee;
              }
              function ut(H, M, R) {
                const ee = H.length;
                (!M || M < 0) && (M = 0), (!R || R < 0 || R > ee) && (R = ee);
                let he = "";
                for (let we = M; we < R; ++we)
                  he += fe[H[we]];
                return he;
              }
              function It(H, M, R) {
                const ee = H.slice(M, R);
                let he = "";
                for (let we = 0; we < ee.length - 1; we += 2)
                  he += String.fromCharCode(ee[we] + ee[we + 1] * 256);
                return he;
              }
              p.prototype.slice = function(M, R) {
                const ee = this.length;
                M = ~~M, R = R === void 0 ? ee : ~~R, M < 0 ? (M += ee, M < 0 && (M = 0)) : M > ee && (M = ee), R < 0 ? (R += ee, R < 0 && (R = 0)) : R > ee && (R = ee), R < M && (R = M);
                const he = this.subarray(M, R);
                return Object.setPrototypeOf(he, p.prototype), he;
              };
              function ht(H, M, R) {
                if (H % 1 !== 0 || H < 0) throw new RangeError("offset is not uint");
                if (H + M > R) throw new RangeError("Trying to access beyond buffer length");
              }
              p.prototype.readUintLE = p.prototype.readUIntLE = function(M, R, ee) {
                M = M >>> 0, R = R >>> 0, ee || ht(M, R, this.length);
                let he = this[M], we = 1, Oe = 0;
                for (; ++Oe < R && (we *= 256); )
                  he += this[M + Oe] * we;
                return he;
              }, p.prototype.readUintBE = p.prototype.readUIntBE = function(M, R, ee) {
                M = M >>> 0, R = R >>> 0, ee || ht(M, R, this.length);
                let he = this[M + --R], we = 1;
                for (; R > 0 && (we *= 256); )
                  he += this[M + --R] * we;
                return he;
              }, p.prototype.readUint8 = p.prototype.readUInt8 = function(M, R) {
                return M = M >>> 0, R || ht(M, 1, this.length), this[M];
              }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(M, R) {
                return M = M >>> 0, R || ht(M, 2, this.length), this[M] | this[M + 1] << 8;
              }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(M, R) {
                return M = M >>> 0, R || ht(M, 2, this.length), this[M] << 8 | this[M + 1];
              }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(M, R) {
                return M = M >>> 0, R || ht(M, 4, this.length), (this[M] | this[M + 1] << 8 | this[M + 2] << 16) + this[M + 3] * 16777216;
              }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(M, R) {
                return M = M >>> 0, R || ht(M, 4, this.length), this[M] * 16777216 + (this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3]);
              }, p.prototype.readBigUInt64LE = ge(function(M) {
                M = M >>> 0, Be(M, "offset");
                const R = this[M], ee = this[M + 7];
                (R === void 0 || ee === void 0) && Et(M, this.length - 8);
                const he = R + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + this[++M] * 2 ** 24, we = this[++M] + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + ee * 2 ** 24;
                return BigInt(he) + (BigInt(we) << BigInt(32));
              }), p.prototype.readBigUInt64BE = ge(function(M) {
                M = M >>> 0, Be(M, "offset");
                const R = this[M], ee = this[M + 7];
                (R === void 0 || ee === void 0) && Et(M, this.length - 8);
                const he = R * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M], we = this[++M] * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + ee;
                return (BigInt(he) << BigInt(32)) + BigInt(we);
              }), p.prototype.readIntLE = function(M, R, ee) {
                M = M >>> 0, R = R >>> 0, ee || ht(M, R, this.length);
                let he = this[M], we = 1, Oe = 0;
                for (; ++Oe < R && (we *= 256); )
                  he += this[M + Oe] * we;
                return we *= 128, he >= we && (he -= Math.pow(2, 8 * R)), he;
              }, p.prototype.readIntBE = function(M, R, ee) {
                M = M >>> 0, R = R >>> 0, ee || ht(M, R, this.length);
                let he = R, we = 1, Oe = this[M + --he];
                for (; he > 0 && (we *= 256); )
                  Oe += this[M + --he] * we;
                return we *= 128, Oe >= we && (Oe -= Math.pow(2, 8 * R)), Oe;
              }, p.prototype.readInt8 = function(M, R) {
                return M = M >>> 0, R || ht(M, 1, this.length), this[M] & 128 ? (255 - this[M] + 1) * -1 : this[M];
              }, p.prototype.readInt16LE = function(M, R) {
                M = M >>> 0, R || ht(M, 2, this.length);
                const ee = this[M] | this[M + 1] << 8;
                return ee & 32768 ? ee | 4294901760 : ee;
              }, p.prototype.readInt16BE = function(M, R) {
                M = M >>> 0, R || ht(M, 2, this.length);
                const ee = this[M + 1] | this[M] << 8;
                return ee & 32768 ? ee | 4294901760 : ee;
              }, p.prototype.readInt32LE = function(M, R) {
                return M = M >>> 0, R || ht(M, 4, this.length), this[M] | this[M + 1] << 8 | this[M + 2] << 16 | this[M + 3] << 24;
              }, p.prototype.readInt32BE = function(M, R) {
                return M = M >>> 0, R || ht(M, 4, this.length), this[M] << 24 | this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3];
              }, p.prototype.readBigInt64LE = ge(function(M) {
                M = M >>> 0, Be(M, "offset");
                const R = this[M], ee = this[M + 7];
                (R === void 0 || ee === void 0) && Et(M, this.length - 8);
                const he = this[M + 4] + this[M + 5] * 2 ** 8 + this[M + 6] * 2 ** 16 + (ee << 24);
                return (BigInt(he) << BigInt(32)) + BigInt(R + this[++M] * 256 + this[++M] * 65536 + this[++M] * 16777216);
              }), p.prototype.readBigInt64BE = ge(function(M) {
                M = M >>> 0, Be(M, "offset");
                const R = this[M], ee = this[M + 7];
                (R === void 0 || ee === void 0) && Et(M, this.length - 8);
                const he = (R << 24) + // Overflow
                this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M];
                return (BigInt(he) << BigInt(32)) + BigInt(this[++M] * 16777216 + this[++M] * 65536 + this[++M] * 256 + ee);
              }), p.prototype.readFloatLE = function(M, R) {
                return M = M >>> 0, R || ht(M, 4, this.length), w.read(this, M, !0, 23, 4);
              }, p.prototype.readFloatBE = function(M, R) {
                return M = M >>> 0, R || ht(M, 4, this.length), w.read(this, M, !1, 23, 4);
              }, p.prototype.readDoubleLE = function(M, R) {
                return M = M >>> 0, R || ht(M, 8, this.length), w.read(this, M, !0, 52, 8);
              }, p.prototype.readDoubleBE = function(M, R) {
                return M = M >>> 0, R || ht(M, 8, this.length), w.read(this, M, !1, 52, 8);
              };
              function Rt(H, M, R, ee, he, we) {
                if (!p.isBuffer(H)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (M > he || M < we) throw new RangeError('"value" argument is out of bounds');
                if (R + ee > H.length) throw new RangeError("Index out of range");
              }
              p.prototype.writeUintLE = p.prototype.writeUIntLE = function(M, R, ee, he) {
                if (M = +M, R = R >>> 0, ee = ee >>> 0, !he) {
                  const Ct = Math.pow(2, 8 * ee) - 1;
                  Rt(this, M, R, ee, Ct, 0);
                }
                let we = 1, Oe = 0;
                for (this[R] = M & 255; ++Oe < ee && (we *= 256); )
                  this[R + Oe] = M / we & 255;
                return R + ee;
              }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(M, R, ee, he) {
                if (M = +M, R = R >>> 0, ee = ee >>> 0, !he) {
                  const Ct = Math.pow(2, 8 * ee) - 1;
                  Rt(this, M, R, ee, Ct, 0);
                }
                let we = ee - 1, Oe = 1;
                for (this[R + we] = M & 255; --we >= 0 && (Oe *= 256); )
                  this[R + we] = M / Oe & 255;
                return R + ee;
              }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 1, 255, 0), this[R] = M & 255, R + 1;
              }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 2, 65535, 0), this[R] = M & 255, this[R + 1] = M >>> 8, R + 2;
              }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 2, 65535, 0), this[R] = M >>> 8, this[R + 1] = M & 255, R + 2;
              }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 4, 4294967295, 0), this[R + 3] = M >>> 24, this[R + 2] = M >>> 16, this[R + 1] = M >>> 8, this[R] = M & 255, R + 4;
              }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 4, 4294967295, 0), this[R] = M >>> 24, this[R + 1] = M >>> 16, this[R + 2] = M >>> 8, this[R + 3] = M & 255, R + 4;
              };
              function Qt(H, M, R, ee, he) {
                Ni(M, ee, he, H, R, 7);
                let we = Number(M & BigInt(4294967295));
                H[R++] = we, we = we >> 8, H[R++] = we, we = we >> 8, H[R++] = we, we = we >> 8, H[R++] = we;
                let Oe = Number(M >> BigInt(32) & BigInt(4294967295));
                return H[R++] = Oe, Oe = Oe >> 8, H[R++] = Oe, Oe = Oe >> 8, H[R++] = Oe, Oe = Oe >> 8, H[R++] = Oe, R;
              }
              function cn(H, M, R, ee, he) {
                Ni(M, ee, he, H, R, 7);
                let we = Number(M & BigInt(4294967295));
                H[R + 7] = we, we = we >> 8, H[R + 6] = we, we = we >> 8, H[R + 5] = we, we = we >> 8, H[R + 4] = we;
                let Oe = Number(M >> BigInt(32) & BigInt(4294967295));
                return H[R + 3] = Oe, Oe = Oe >> 8, H[R + 2] = Oe, Oe = Oe >> 8, H[R + 1] = Oe, Oe = Oe >> 8, H[R] = Oe, R + 8;
              }
              p.prototype.writeBigUInt64LE = ge(function(M, R = 0) {
                return Qt(this, M, R, BigInt(0), BigInt("0xffffffffffffffff"));
              }), p.prototype.writeBigUInt64BE = ge(function(M, R = 0) {
                return cn(this, M, R, BigInt(0), BigInt("0xffffffffffffffff"));
              }), p.prototype.writeIntLE = function(M, R, ee, he) {
                if (M = +M, R = R >>> 0, !he) {
                  const Pt = Math.pow(2, 8 * ee - 1);
                  Rt(this, M, R, ee, Pt - 1, -Pt);
                }
                let we = 0, Oe = 1, Ct = 0;
                for (this[R] = M & 255; ++we < ee && (Oe *= 256); )
                  M < 0 && Ct === 0 && this[R + we - 1] !== 0 && (Ct = 1), this[R + we] = (M / Oe >> 0) - Ct & 255;
                return R + ee;
              }, p.prototype.writeIntBE = function(M, R, ee, he) {
                if (M = +M, R = R >>> 0, !he) {
                  const Pt = Math.pow(2, 8 * ee - 1);
                  Rt(this, M, R, ee, Pt - 1, -Pt);
                }
                let we = ee - 1, Oe = 1, Ct = 0;
                for (this[R + we] = M & 255; --we >= 0 && (Oe *= 256); )
                  M < 0 && Ct === 0 && this[R + we + 1] !== 0 && (Ct = 1), this[R + we] = (M / Oe >> 0) - Ct & 255;
                return R + ee;
              }, p.prototype.writeInt8 = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 1, 127, -128), M < 0 && (M = 255 + M + 1), this[R] = M & 255, R + 1;
              }, p.prototype.writeInt16LE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 2, 32767, -32768), this[R] = M & 255, this[R + 1] = M >>> 8, R + 2;
              }, p.prototype.writeInt16BE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 2, 32767, -32768), this[R] = M >>> 8, this[R + 1] = M & 255, R + 2;
              }, p.prototype.writeInt32LE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 4, 2147483647, -2147483648), this[R] = M & 255, this[R + 1] = M >>> 8, this[R + 2] = M >>> 16, this[R + 3] = M >>> 24, R + 4;
              }, p.prototype.writeInt32BE = function(M, R, ee) {
                return M = +M, R = R >>> 0, ee || Rt(this, M, R, 4, 2147483647, -2147483648), M < 0 && (M = 4294967295 + M + 1), this[R] = M >>> 24, this[R + 1] = M >>> 16, this[R + 2] = M >>> 8, this[R + 3] = M & 255, R + 4;
              }, p.prototype.writeBigInt64LE = ge(function(M, R = 0) {
                return Qt(this, M, R, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
              }), p.prototype.writeBigInt64BE = ge(function(M, R = 0) {
                return cn(this, M, R, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
              });
              function Cn(H, M, R, ee, he, we) {
                if (R + ee > H.length) throw new RangeError("Index out of range");
                if (R < 0) throw new RangeError("Index out of range");
              }
              function Tn(H, M, R, ee, he) {
                return M = +M, R = R >>> 0, he || Cn(H, M, R, 4), w.write(H, M, R, ee, 23, 4), R + 4;
              }
              p.prototype.writeFloatLE = function(M, R, ee) {
                return Tn(this, M, R, !0, ee);
              }, p.prototype.writeFloatBE = function(M, R, ee) {
                return Tn(this, M, R, !1, ee);
              };
              function wn(H, M, R, ee, he) {
                return M = +M, R = R >>> 0, he || Cn(H, M, R, 8), w.write(H, M, R, ee, 52, 8), R + 8;
              }
              p.prototype.writeDoubleLE = function(M, R, ee) {
                return wn(this, M, R, !0, ee);
              }, p.prototype.writeDoubleBE = function(M, R, ee) {
                return wn(this, M, R, !1, ee);
              }, p.prototype.copy = function(M, R, ee, he) {
                if (!p.isBuffer(M)) throw new TypeError("argument should be a Buffer");
                if (ee || (ee = 0), !he && he !== 0 && (he = this.length), R >= M.length && (R = M.length), R || (R = 0), he > 0 && he < ee && (he = ee), he === ee || M.length === 0 || this.length === 0) return 0;
                if (R < 0)
                  throw new RangeError("targetStart out of bounds");
                if (ee < 0 || ee >= this.length) throw new RangeError("Index out of range");
                if (he < 0) throw new RangeError("sourceEnd out of bounds");
                he > this.length && (he = this.length), M.length - R < he - ee && (he = M.length - R + ee);
                const we = he - ee;
                return this === M && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(R, ee, he) : Uint8Array.prototype.set.call(M, this.subarray(ee, he), R), we;
              }, p.prototype.fill = function(M, R, ee, he) {
                if (typeof M == "string") {
                  if (typeof R == "string" ? (he = R, R = 0, ee = this.length) : typeof ee == "string" && (he = ee, ee = this.length), he !== void 0 && typeof he != "string")
                    throw new TypeError("encoding must be a string");
                  if (typeof he == "string" && !p.isEncoding(he))
                    throw new TypeError("Unknown encoding: " + he);
                  if (M.length === 1) {
                    const Oe = M.charCodeAt(0);
                    (he === "utf8" && Oe < 128 || he === "latin1") && (M = Oe);
                  }
                } else typeof M == "number" ? M = M & 255 : typeof M == "boolean" && (M = Number(M));
                if (R < 0 || this.length < R || this.length < ee)
                  throw new RangeError("Out of range index");
                if (ee <= R)
                  return this;
                R = R >>> 0, ee = ee === void 0 ? this.length : ee >>> 0, M || (M = 0);
                let we;
                if (typeof M == "number")
                  for (we = R; we < ee; ++we)
                    this[we] = M;
                else {
                  const Oe = p.isBuffer(M) ? M : p.from(M, he), Ct = Oe.length;
                  if (Ct === 0)
                    throw new TypeError('The value "' + M + '" is invalid for argument "value"');
                  for (we = 0; we < ee - R; ++we)
                    this[we + R] = Oe[we % Ct];
                }
                return this;
              };
              const rn = {};
              function Bn(H, M, R) {
                rn[H] = class extends R {
                  constructor() {
                    super(), Object.defineProperty(this, "message", {
                      value: M.apply(this, arguments),
                      writable: !0,
                      configurable: !0
                    }), this.name = `${this.name} [${H}]`, this.stack, delete this.name;
                  }
                  get code() {
                    return H;
                  }
                  set code(he) {
                    Object.defineProperty(this, "code", {
                      configurable: !0,
                      enumerable: !0,
                      value: he,
                      writable: !0
                    });
                  }
                  toString() {
                    return `${this.name} [${H}]: ${this.message}`;
                  }
                };
              }
              Bn("ERR_BUFFER_OUT_OF_BOUNDS", function(H) {
                return H ? `${H} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
              }, RangeError), Bn("ERR_INVALID_ARG_TYPE", function(H, M) {
                return `The "${H}" argument must be of type number. Received type ${typeof M}`;
              }, TypeError), Bn("ERR_OUT_OF_RANGE", function(H, M, R) {
                let ee = `The value of "${H}" is out of range.`, he = R;
                return Number.isInteger(R) && Math.abs(R) > 4294967296 ? he = di(String(R)) : typeof R == "bigint" && (he = String(R), (R > BigInt(2) ** BigInt(32) || R < -(BigInt(2) ** BigInt(32))) && (he = di(he)), he += "n"), ee += ` It must be ${M}. Received ${he}`, ee;
              }, RangeError);
              function di(H) {
                let M = "", R = H.length;
                const ee = H[0] === "-" ? 1 : 0;
                for (; R >= ee + 4; R -= 3)
                  M = `_${H.slice(R - 3, R)}${M}`;
                return `${H.slice(0, R)}${M}`;
              }
              function ri(H, M, R) {
                Be(M, "offset"), (H[M] === void 0 || H[M + R] === void 0) && Et(M, H.length - (R + 1));
              }
              function Ni(H, M, R, ee, he, we) {
                if (H > R || H < M) {
                  const Oe = typeof M == "bigint" ? "n" : "";
                  let Ct;
                  throw M === 0 || M === BigInt(0) ? Ct = `>= 0${Oe} and < 2${Oe} ** ${(we + 1) * 8}${Oe}` : Ct = `>= -(2${Oe} ** ${(we + 1) * 8 - 1}${Oe}) and < 2 ** ${(we + 1) * 8 - 1}${Oe}`, new rn.ERR_OUT_OF_RANGE("value", Ct, H);
                }
                ri(ee, he, we);
              }
              function Be(H, M) {
                if (typeof H != "number")
                  throw new rn.ERR_INVALID_ARG_TYPE(M, "number", H);
              }
              function Et(H, M, R) {
                throw Math.floor(H) !== H ? (Be(H, R), new rn.ERR_OUT_OF_RANGE("offset", "an integer", H)) : M < 0 ? new rn.ERR_BUFFER_OUT_OF_BOUNDS() : new rn.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${M}`, H);
              }
              const Dt = /[^+/0-9A-Za-z-_]/g;
              function $t(H) {
                if (H = H.split("=")[0], H = H.trim().replace(Dt, ""), H.length < 2) return "";
                for (; H.length % 4 !== 0; )
                  H = H + "=";
                return H;
              }
              function ei(H, M) {
                M = M || 1 / 0;
                let R;
                const ee = H.length;
                let he = null;
                const we = [];
                for (let Oe = 0; Oe < ee; ++Oe) {
                  if (R = H.charCodeAt(Oe), R > 55295 && R < 57344) {
                    if (!he) {
                      if (R > 56319) {
                        (M -= 3) > -1 && we.push(239, 191, 189);
                        continue;
                      } else if (Oe + 1 === ee) {
                        (M -= 3) > -1 && we.push(239, 191, 189);
                        continue;
                      }
                      he = R;
                      continue;
                    }
                    if (R < 56320) {
                      (M -= 3) > -1 && we.push(239, 191, 189), he = R;
                      continue;
                    }
                    R = (he - 55296 << 10 | R - 56320) + 65536;
                  } else he && (M -= 3) > -1 && we.push(239, 191, 189);
                  if (he = null, R < 128) {
                    if ((M -= 1) < 0) break;
                    we.push(R);
                  } else if (R < 2048) {
                    if ((M -= 2) < 0) break;
                    we.push(R >> 6 | 192, R & 63 | 128);
                  } else if (R < 65536) {
                    if ((M -= 3) < 0) break;
                    we.push(R >> 12 | 224, R >> 6 & 63 | 128, R & 63 | 128);
                  } else if (R < 1114112) {
                    if ((M -= 4) < 0) break;
                    we.push(R >> 18 | 240, R >> 12 & 63 | 128, R >> 6 & 63 | 128, R & 63 | 128);
                  } else
                    throw new Error("Invalid code point");
                }
                return we;
              }
              function Dn(H) {
                const M = [];
                for (let R = 0; R < H.length; ++R)
                  M.push(H.charCodeAt(R) & 255);
                return M;
              }
              function Yt(H, M) {
                let R, ee, he;
                const we = [];
                for (let Oe = 0; Oe < H.length && !((M -= 2) < 0); ++Oe)
                  R = H.charCodeAt(Oe), ee = R >> 8, he = R % 256, we.push(he), we.push(ee);
                return we;
              }
              function Xe(H) {
                return C.toByteArray($t(H));
              }
              function le(H, M, R, ee) {
                let he;
                for (he = 0; he < ee && !(he + R >= M.length || he >= H.length); ++he)
                  M[he + R] = H[he];
                return he;
              }
              function ae(H, M) {
                return H instanceof M || H != null && H.constructor != null && H.constructor.name != null && H.constructor.name === M.name;
              }
              function Ce(H) {
                return H !== H;
              }
              const fe = function() {
                const H = "0123456789abcdef", M = new Array(256);
                for (let R = 0; R < 16; ++R) {
                  const ee = R * 16;
                  for (let he = 0; he < 16; ++he)
                    M[ee + he] = H[R] + H[he];
                }
                return M;
              }();
              function ge(H) {
                return typeof BigInt > "u" ? xe : H;
              }
              function xe() {
                throw new Error("BigInt not supported");
              }
            }
          ),
          /***/
          "./node_modules/css-loader/dist/runtime/api.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/css-loader/dist/runtime/api.js ***!
              \*****************************************************/
            /***/
            (j) => {
              j.exports = function(re) {
                var v = [];
                return v.toString = function() {
                  return this.map(function(w) {
                    var E = "", y = typeof w[5] < "u";
                    return w[4] && (E += "@supports (".concat(w[4], ") {")), w[2] && (E += "@media ".concat(w[2], " {")), y && (E += "@layer".concat(w[5].length > 0 ? " ".concat(w[5]) : "", " {")), E += re(w), y && (E += "}"), w[2] && (E += "}"), w[4] && (E += "}"), E;
                  }).join("");
                }, v.i = function(w, E, y, l, d) {
                  typeof w == "string" && (w = [[null, w, void 0]]);
                  var p = {};
                  if (y)
                    for (var c = 0; c < this.length; c++) {
                      var g = this[c][0];
                      g != null && (p[g] = !0);
                    }
                  for (var A = 0; A < w.length; A++) {
                    var u = [].concat(w[A]);
                    y && p[u[0]] || (typeof d < "u" && (typeof u[5] > "u" || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = d), E && (u[2] && (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}")), u[2] = E), l && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = l) : u[4] = "".concat(l)), v.push(u));
                  }
                }, v;
              };
            }
          ),
          /***/
          "./node_modules/css-loader/dist/runtime/getUrl.js": (
            /*!********************************************************!*\
              !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
              \********************************************************/
            /***/
            (j) => {
              j.exports = function(re, v) {
                return v || (v = {}), re && (re = String(re.__esModule ? re.default : re), /^['"].*['"]$/.test(re) && (re = re.slice(1, -1)), v.hash && (re += v.hash), /["'() \t\n]|(%20)/.test(re) || v.needQuotes ? '"'.concat(re.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : re);
              };
            }
          ),
          /***/
          "./node_modules/css-loader/dist/runtime/sourceMaps.js": (
            /*!************************************************************!*\
              !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
              \************************************************************/
            /***/
            (j) => {
              j.exports = function(re) {
                var v = re[1], C = re[3];
                if (!C)
                  return v;
                if (typeof btoa == "function") {
                  var w = btoa(unescape(encodeURIComponent(JSON.stringify(C)))), E = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(w), y = "/*# ".concat(E, " */");
                  return [v].concat([y]).join(`
`);
                }
                return [v].join(`
`);
              };
            }
          ),
          /***/
          "./node_modules/debug/src/browser.js": (
            /*!*******************************************!*\
              !*** ./node_modules/debug/src/browser.js ***!
              \*******************************************/
            /***/
            (j, re, v) => {
              re.formatArgs = w, re.save = E, re.load = y, re.useColors = C, re.storage = l(), re.destroy = /* @__PURE__ */ (() => {
                let p = !1;
                return () => {
                  p || (p = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
                };
              })(), re.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
              function C() {
                return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
                typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
                typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
              }
              function w(p) {
                if (p[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + p[0] + (this.useColors ? "%c " : " ") + "+" + j.exports.humanize(this.diff), !this.useColors)
                  return;
                const c = "color: " + this.color;
                p.splice(1, 0, c, "color: inherit");
                let g = 0, A = 0;
                p[0].replace(/%[a-zA-Z%]/g, (u) => {
                  u !== "%%" && (g++, u === "%c" && (A = g));
                }), p.splice(A, 0, c);
              }
              re.log = console.debug || console.log || (() => {
              });
              function E(p) {
                try {
                  p ? re.storage.setItem("debug", p) : re.storage.removeItem("debug");
                } catch {
                }
              }
              function y() {
                let p;
                try {
                  p = re.storage.getItem("debug");
                } catch {
                }
                return !p && typeof process < "u" && "env" in process && (p = process.env.DEBUG), p;
              }
              function l() {
                try {
                  return localStorage;
                } catch {
                }
              }
              j.exports = v(
                /*! ./common */
                "./node_modules/debug/src/common.js"
              )(re);
              const {
                formatters: d
              } = j.exports;
              d.j = function(p) {
                try {
                  return JSON.stringify(p);
                } catch (c) {
                  return "[UnexpectedJSONParseError]: " + c.message;
                }
              };
            }
          ),
          /***/
          "./node_modules/debug/src/common.js": (
            /*!******************************************!*\
              !*** ./node_modules/debug/src/common.js ***!
              \******************************************/
            /***/
            (j, re, v) => {
              function C(w) {
                y.debug = y, y.default = y, y.coerce = A, y.disable = p, y.enable = d, y.enabled = c, y.humanize = v(
                  /*! ms */
                  "./node_modules/ms/index.js"
                ), y.destroy = u, Object.keys(w).forEach((f) => {
                  y[f] = w[f];
                }), y.names = [], y.skips = [], y.formatters = {};
                function E(f) {
                  let x = 0;
                  for (let T = 0; T < f.length; T++)
                    x = (x << 5) - x + f.charCodeAt(T), x |= 0;
                  return y.colors[Math.abs(x) % y.colors.length];
                }
                y.selectColor = E;
                function y(f) {
                  let x, T = null, b, D;
                  function S(...U) {
                    if (!S.enabled)
                      return;
                    const G = S, Z = Number(/* @__PURE__ */ new Date()), W = Z - (x || Z);
                    G.diff = W, G.prev = x, G.curr = Z, x = Z, U[0] = y.coerce(U[0]), typeof U[0] != "string" && U.unshift("%O");
                    let ie = 0;
                    U[0] = U[0].replace(/%([a-zA-Z%])/g, (X, Q) => {
                      if (X === "%%")
                        return "%";
                      ie++;
                      const O = y.formatters[Q];
                      if (typeof O == "function") {
                        const K = U[ie];
                        X = O.call(G, K), U.splice(ie, 1), ie--;
                      }
                      return X;
                    }), y.formatArgs.call(G, U), (G.log || y.log).apply(G, U);
                  }
                  return S.namespace = f, S.useColors = y.useColors(), S.color = y.selectColor(f), S.extend = l, S.destroy = y.destroy, Object.defineProperty(S, "enabled", {
                    enumerable: !0,
                    configurable: !1,
                    get: () => T !== null ? T : (b !== y.namespaces && (b = y.namespaces, D = y.enabled(f)), D),
                    set: (U) => {
                      T = U;
                    }
                  }), typeof y.init == "function" && y.init(S), S;
                }
                function l(f, x) {
                  const T = y(this.namespace + (typeof x > "u" ? ":" : x) + f);
                  return T.log = this.log, T;
                }
                function d(f) {
                  y.save(f), y.namespaces = f, y.names = [], y.skips = [];
                  let x;
                  const T = (typeof f == "string" ? f : "").split(/[\s,]+/), b = T.length;
                  for (x = 0; x < b; x++)
                    T[x] && (f = T[x].replace(/\*/g, ".*?"), f[0] === "-" ? y.skips.push(new RegExp("^" + f.slice(1) + "$")) : y.names.push(new RegExp("^" + f + "$")));
                }
                function p() {
                  const f = [...y.names.map(g), ...y.skips.map(g).map((x) => "-" + x)].join(",");
                  return y.enable(""), f;
                }
                function c(f) {
                  if (f[f.length - 1] === "*")
                    return !0;
                  let x, T;
                  for (x = 0, T = y.skips.length; x < T; x++)
                    if (y.skips[x].test(f))
                      return !1;
                  for (x = 0, T = y.names.length; x < T; x++)
                    if (y.names[x].test(f))
                      return !0;
                  return !1;
                }
                function g(f) {
                  return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*");
                }
                function A(f) {
                  return f instanceof Error ? f.stack || f.message : f;
                }
                function u() {
                  console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
                return y.enable(y.load()), y;
              }
              j.exports = C;
            }
          ),
          /***/
          "./node_modules/deep-assign/index.js": (
            /*!*******************************************!*\
              !*** ./node_modules/deep-assign/index.js ***!
              \*******************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! is-obj */
                "./node_modules/is-obj/index.js"
              ), w = Object.prototype.hasOwnProperty, E = Object.prototype.propertyIsEnumerable;
              function y(p) {
                if (p == null)
                  throw new TypeError("Sources cannot be null or undefined");
                return Object(p);
              }
              function l(p, c, g) {
                var A = c[g];
                if (A != null) {
                  if (w.call(p, g) && (p[g] === void 0 || p[g] === null))
                    throw new TypeError("Cannot convert undefined or null to object (" + g + ")");
                  !w.call(p, g) || !C(A) ? p[g] = A : p[g] = d(Object(p[g]), c[g]);
                }
              }
              function d(p, c) {
                if (p === c)
                  return p;
                c = Object(c);
                for (var g in c)
                  w.call(c, g) && l(p, c, g);
                if (Object.getOwnPropertySymbols)
                  for (var A = Object.getOwnPropertySymbols(c), u = 0; u < A.length; u++)
                    E.call(c, A[u]) && l(p, c, A[u]);
                return p;
              }
              j.exports = function(c) {
                c = y(c);
                for (var g = 1; g < arguments.length; g++)
                  d(c, arguments[g]);
                return c;
              };
            }
          ),
          /***/
          "./node_modules/dtype/index.js": (
            /*!*************************************!*\
              !*** ./node_modules/dtype/index.js ***!
              \*************************************/
            /***/
            (j) => {
              j.exports = function(re) {
                switch (re) {
                  case "int8":
                    return Int8Array;
                  case "int16":
                    return Int16Array;
                  case "int32":
                    return Int32Array;
                  case "uint8":
                    return Uint8Array;
                  case "uint16":
                    return Uint16Array;
                  case "uint32":
                    return Uint32Array;
                  case "float32":
                    return Float32Array;
                  case "float64":
                    return Float64Array;
                  case "array":
                    return Array;
                  case "uint8_clamped":
                    return Uint8ClampedArray;
                }
              };
            }
          ),
          /***/
          "./node_modules/global/window.js": (
            /*!***************************************!*\
              !*** ./node_modules/global/window.js ***!
              \***************************************/
            /***/
            (j, re, v) => {
              var C;
              typeof window < "u" ? C = window : typeof v.g < "u" ? C = v.g : typeof self < "u" ? C = self : C = {}, j.exports = C;
            }
          ),
          /***/
          "./node_modules/ieee754/index.js": (
            /*!***************************************!*\
              !*** ./node_modules/ieee754/index.js ***!
              \***************************************/
            /***/
            (j, re) => {
              /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
              re.read = function(v, C, w, E, y) {
                var l, d, p = y * 8 - E - 1, c = (1 << p) - 1, g = c >> 1, A = -7, u = w ? y - 1 : 0, f = w ? -1 : 1, x = v[C + u];
                for (u += f, l = x & (1 << -A) - 1, x >>= -A, A += p; A > 0; l = l * 256 + v[C + u], u += f, A -= 8)
                  ;
                for (d = l & (1 << -A) - 1, l >>= -A, A += E; A > 0; d = d * 256 + v[C + u], u += f, A -= 8)
                  ;
                if (l === 0)
                  l = 1 - g;
                else {
                  if (l === c)
                    return d ? NaN : (x ? -1 : 1) * (1 / 0);
                  d = d + Math.pow(2, E), l = l - g;
                }
                return (x ? -1 : 1) * d * Math.pow(2, l - E);
              }, re.write = function(v, C, w, E, y, l) {
                var d, p, c, g = l * 8 - y - 1, A = (1 << g) - 1, u = A >> 1, f = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = E ? 0 : l - 1, T = E ? 1 : -1, b = C < 0 || C === 0 && 1 / C < 0 ? 1 : 0;
                for (C = Math.abs(C), isNaN(C) || C === 1 / 0 ? (p = isNaN(C) ? 1 : 0, d = A) : (d = Math.floor(Math.log(C) / Math.LN2), C * (c = Math.pow(2, -d)) < 1 && (d--, c *= 2), d + u >= 1 ? C += f / c : C += f * Math.pow(2, 1 - u), C * c >= 2 && (d++, c /= 2), d + u >= A ? (p = 0, d = A) : d + u >= 1 ? (p = (C * c - 1) * Math.pow(2, y), d = d + u) : (p = C * Math.pow(2, u - 1) * Math.pow(2, y), d = 0)); y >= 8; v[w + x] = p & 255, x += T, p /= 256, y -= 8)
                  ;
                for (d = d << y | p, g += y; g > 0; v[w + x] = d & 255, x += T, d /= 256, g -= 8)
                  ;
                v[w + x - T] |= b * 128;
              };
            }
          ),
          /***/
          "./node_modules/is-buffer/index.js": (
            /*!*****************************************!*\
              !*** ./node_modules/is-buffer/index.js ***!
              \*****************************************/
            /***/
            (j) => {
              /*!
               * Determine if an object is a Buffer
               *
               * @author   Feross Aboukhadijeh <https://feross.org>
               * @license  MIT
               */
              j.exports = function(C) {
                return C != null && (re(C) || v(C) || !!C._isBuffer);
              };
              function re(C) {
                return !!C.constructor && typeof C.constructor.isBuffer == "function" && C.constructor.isBuffer(C);
              }
              function v(C) {
                return typeof C.readFloatLE == "function" && typeof C.slice == "function" && re(C.slice(0, 0));
              }
            }
          ),
          /***/
          "./node_modules/is-function/index.js": (
            /*!*******************************************!*\
              !*** ./node_modules/is-function/index.js ***!
              \*******************************************/
            /***/
            (j) => {
              j.exports = v;
              var re = Object.prototype.toString;
              function v(C) {
                if (!C)
                  return !1;
                var w = re.call(C);
                return w === "[object Function]" || typeof C == "function" && w !== "[object RegExp]" || typeof window < "u" && // IE8 and below
                (C === window.setTimeout || C === window.alert || C === window.confirm || C === window.prompt);
              }
            }
          ),
          /***/
          "./node_modules/is-obj/index.js": (
            /*!**************************************!*\
              !*** ./node_modules/is-obj/index.js ***!
              \**************************************/
            /***/
            (j) => {
              j.exports = function(re) {
                var v = typeof re;
                return re !== null && (v === "object" || v === "function");
              };
            }
          ),
          /***/
          "./node_modules/layout-bmfont-text/index.js": (
            /*!**************************************************!*\
              !*** ./node_modules/layout-bmfont-text/index.js ***!
              \**************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! word-wrapper */
                "./node_modules/word-wrapper/index.js"
              ), w = v(
                /*! xtend */
                "./node_modules/xtend/immutable.js"
              ), E = v(
                /*! as-number */
                "./node_modules/as-number/index.js"
              ), y = ["x", "e", "a", "o", "n", "s", "r", "c", "u", "m", "v", "w", "z"], l = ["m", "w"], d = ["H", "I", "N", "E", "F", "K", "L", "T", "U", "V", "W", "X", "Y", "Z"], p = 9, c = 32, g = 0, A = 1, u = 2;
              j.exports = function(te) {
                return new f(te);
              };
              function f(ie) {
                this.glyphs = [], this._measure = this.computeMetrics.bind(this), this.update(ie);
              }
              f.prototype.update = function(ie) {
                if (ie = w({
                  measure: this._measure
                }, ie), this._opt = ie, this._opt.tabSize = E(this._opt.tabSize, 4), !ie.font) throw new Error("must provide a valid bitmap font");
                var te = this.glyphs, X = ie.text || "", Q = ie.font;
                this._setupSpaceGlyphs(Q);
                var O = C.lines(X, ie), K = ie.width || 0;
                te.length = 0;
                var ne = O.reduce(function(Rt, Qt) {
                  return Math.max(Rt, Qt.width, K);
                }, 0), pe = 0, be = 0, Te = E(ie.lineHeight, Q.common.lineHeight), ke = Q.common.base, Ve = Te - ke, st = ie.letterSpacing || 0, ut = Te * O.length - Ve, It = Z(this._opt.align);
                be -= ut, this._width = ne, this._height = ut, this._descender = Te - ke, this._baseline = ke, this._xHeight = D(Q), this._capHeight = U(Q), this._lineHeight = Te, this._ascender = Te - Ve - this._xHeight;
                var ht = this;
                O.forEach(function(Rt, Qt) {
                  for (var cn = Rt.start, Cn = Rt.end, Tn = Rt.width, wn, rn = cn; rn < Cn; rn++) {
                    var Bn = X.charCodeAt(rn), di = ht.getGlyph(Q, Bn);
                    if (di) {
                      wn && (pe += G(Q, wn.id, di.id));
                      var ri = pe;
                      It === A ? ri += (ne - Tn) / 2 : It === u && (ri += ne - Tn), te.push({
                        position: [ri, be],
                        data: di,
                        index: rn,
                        line: Qt
                      }), pe += di.xadvance + st, wn = di;
                    }
                  }
                  be += Te, pe = 0;
                }), this._linesTotal = O.length;
              }, f.prototype._setupSpaceGlyphs = function(ie) {
                if (this._fallbackSpaceGlyph = null, this._fallbackTabGlyph = null, !(!ie.chars || ie.chars.length === 0)) {
                  var te = b(ie, c) || S(ie) || ie.chars[0], X = this._opt.tabSize * te.xadvance;
                  this._fallbackSpaceGlyph = te, this._fallbackTabGlyph = w(te, {
                    x: 0,
                    y: 0,
                    xadvance: X,
                    id: p,
                    xoffset: 0,
                    yoffset: 0,
                    width: 0,
                    height: 0
                  });
                }
              }, f.prototype.getGlyph = function(ie, te) {
                var X = b(ie, te);
                return X || (te === p ? this._fallbackTabGlyph : te === c ? this._fallbackSpaceGlyph : null);
              }, f.prototype.computeMetrics = function(ie, te, X, Q) {
                var O = this._opt.letterSpacing || 0, K = this._opt.font, ne = 0, pe = 0, be = 0, Te, ke;
                if (!K.chars || K.chars.length === 0)
                  return {
                    start: te,
                    end: te,
                    width: 0
                  };
                X = Math.min(ie.length, X);
                for (var Ve = te; Ve < X; Ve++) {
                  var st = ie.charCodeAt(Ve), Te = this.getGlyph(K, st);
                  if (Te) {
                    Te.xoffset;
                    var ut = ke ? G(K, ke.id, Te.id) : 0;
                    ne += ut;
                    var It = ne + Te.xadvance + O, ht = ne + Te.width;
                    if (ht >= Q || It >= Q) break;
                    ne = It, pe = ht, ke = Te;
                  }
                  be++;
                }
                return ke && (pe += ke.xoffset), {
                  start: te,
                  end: te + be,
                  width: pe
                };
              }, ["width", "height", "descender", "ascender", "xHeight", "baseline", "capHeight", "lineHeight"].forEach(x);
              function x(ie) {
                Object.defineProperty(f.prototype, ie, {
                  get: T(ie),
                  configurable: !0
                });
              }
              function T(ie) {
                return new Function(["return function " + ie + "() {", "  return this._" + ie, "}"].join(`
`))();
              }
              function b(ie, te) {
                if (!ie.chars || ie.chars.length === 0) return null;
                var X = W(ie.chars, te);
                return X >= 0 ? ie.chars[X] : null;
              }
              function D(ie) {
                for (var te = 0; te < y.length; te++) {
                  var X = y[te].charCodeAt(0), Q = W(ie.chars, X);
                  if (Q >= 0) return ie.chars[Q].height;
                }
                return 0;
              }
              function S(ie) {
                for (var te = 0; te < l.length; te++) {
                  var X = l[te].charCodeAt(0), Q = W(ie.chars, X);
                  if (Q >= 0) return ie.chars[Q];
                }
                return 0;
              }
              function U(ie) {
                for (var te = 0; te < d.length; te++) {
                  var X = d[te].charCodeAt(0), Q = W(ie.chars, X);
                  if (Q >= 0) return ie.chars[Q].height;
                }
                return 0;
              }
              function G(ie, te, X) {
                if (!ie.kernings || ie.kernings.length === 0) return 0;
                for (var Q = ie.kernings, O = 0; O < Q.length; O++) {
                  var K = Q[O];
                  if (K.first === te && K.second === X) return K.amount;
                }
                return 0;
              }
              function Z(ie) {
                return ie === "center" ? A : ie === "right" ? u : g;
              }
              function W(ie, te, X) {
                X = X || 0;
                for (var Q = X; Q < ie.length; Q++)
                  if (ie[Q].id === te)
                    return Q;
                return -1;
              }
            }
          ),
          /***/
          "./node_modules/load-bmfont/browser.js": (
            /*!*********************************************!*\
              !*** ./node_modules/load-bmfont/browser.js ***!
              \*********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! buffer */
                "./node_modules/buffer/index.js"
              ).Buffer, w = v(
                /*! xhr */
                "./node_modules/xhr/index.js"
              ), E = function() {
              }, y = v(
                /*! parse-bmfont-ascii */
                "./node_modules/parse-bmfont-ascii/index.js"
              ), l = v(
                /*! parse-bmfont-xml */
                "./node_modules/parse-bmfont-xml/lib/browser.js"
              ), d = v(
                /*! parse-bmfont-binary */
                "./node_modules/parse-bmfont-binary/index.js"
              ), p = v(
                /*! ./lib/is-binary */
                "./node_modules/load-bmfont/lib/is-binary.js"
              ), c = v(
                /*! xtend */
                "./node_modules/xtend/immutable.js"
              ), g = function() {
                return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
              }();
              j.exports = function(f, x) {
                x = typeof x == "function" ? x : E, typeof f == "string" ? f = {
                  uri: f
                } : f || (f = {});
                var T = f.binary;
                T && (f = u(f)), w(f, function(b, D, S) {
                  if (b) return x(b);
                  if (!/^2/.test(D.statusCode)) return x(new Error("http status code: " + D.statusCode));
                  if (!S) return x(new Error("no body result"));
                  var U = !1;
                  if (A(S)) {
                    var G = new Uint8Array(S);
                    S = C.from(G, "binary");
                  }
                  p(S) && (U = !0, typeof S == "string" && (S = C.from(S, "binary"))), U || (C.isBuffer(S) && (S = S.toString(f.encoding)), S = S.trim());
                  var Z;
                  try {
                    var W = D.headers["content-type"];
                    U ? Z = d(S) : /json/.test(W) || S.charAt(0) === "{" ? Z = JSON.parse(S) : /xml/.test(W) || S.charAt(0) === "<" ? Z = l(S) : Z = y(S);
                  } catch (ie) {
                    x(new Error("error parsing font " + ie.message)), x = E;
                  }
                  x(null, Z);
                });
              };
              function A(f) {
                var x = Object.prototype.toString;
                return x.call(f) === "[object ArrayBuffer]";
              }
              function u(f) {
                if (g) return c(f, {
                  responseType: "arraybuffer"
                });
                if (typeof self.XMLHttpRequest > "u") throw new Error("your browser does not support XHR loading");
                var x = new self.XMLHttpRequest();
                return x.overrideMimeType("text/plain; charset=x-user-defined"), c({
                  xhr: x
                }, f);
              }
            }
          ),
          /***/
          "./node_modules/load-bmfont/lib/is-binary.js": (
            /*!***************************************************!*\
              !*** ./node_modules/load-bmfont/lib/is-binary.js ***!
              \***************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! buffer */
                "./node_modules/buffer/index.js"
              ).Buffer, w = v(
                /*! buffer-equal */
                "./node_modules/buffer-equal/index.js"
              ), E = C.from([66, 77, 70, 3]);
              j.exports = function(y) {
                return typeof y == "string" ? y.substring(0, 3) === "BMF" : y.length > 4 && w(y.slice(0, 4), E);
              };
            }
          ),
          /***/
          "./node_modules/ms/index.js": (
            /*!**********************************!*\
              !*** ./node_modules/ms/index.js ***!
              \**********************************/
            /***/
            (j) => {
              var re = 1e3, v = re * 60, C = v * 60, w = C * 24, E = w * 7, y = w * 365.25;
              j.exports = function(g, A) {
                A = A || {};
                var u = typeof g;
                if (u === "string" && g.length > 0)
                  return l(g);
                if (u === "number" && isFinite(g))
                  return A.long ? p(g) : d(g);
                throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(g));
              };
              function l(g) {
                if (g = String(g), !(g.length > 100)) {
                  var A = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(g);
                  if (A) {
                    var u = parseFloat(A[1]), f = (A[2] || "ms").toLowerCase();
                    switch (f) {
                      case "years":
                      case "year":
                      case "yrs":
                      case "yr":
                      case "y":
                        return u * y;
                      case "weeks":
                      case "week":
                      case "w":
                        return u * E;
                      case "days":
                      case "day":
                      case "d":
                        return u * w;
                      case "hours":
                      case "hour":
                      case "hrs":
                      case "hr":
                      case "h":
                        return u * C;
                      case "minutes":
                      case "minute":
                      case "mins":
                      case "min":
                      case "m":
                        return u * v;
                      case "seconds":
                      case "second":
                      case "secs":
                      case "sec":
                      case "s":
                        return u * re;
                      case "milliseconds":
                      case "millisecond":
                      case "msecs":
                      case "msec":
                      case "ms":
                        return u;
                      default:
                        return;
                    }
                  }
                }
              }
              function d(g) {
                var A = Math.abs(g);
                return A >= w ? Math.round(g / w) + "d" : A >= C ? Math.round(g / C) + "h" : A >= v ? Math.round(g / v) + "m" : A >= re ? Math.round(g / re) + "s" : g + "ms";
              }
              function p(g) {
                var A = Math.abs(g);
                return A >= w ? c(g, A, w, "day") : A >= C ? c(g, A, C, "hour") : A >= v ? c(g, A, v, "minute") : A >= re ? c(g, A, re, "second") : g + " ms";
              }
              function c(g, A, u, f) {
                var x = A >= u * 1.5;
                return Math.round(g / u) + " " + f + (x ? "s" : "");
              }
            }
          ),
          /***/
          "./node_modules/parse-bmfont-ascii/index.js": (
            /*!**************************************************!*\
              !*** ./node_modules/parse-bmfont-ascii/index.js ***!
              \**************************************************/
            /***/
            (j) => {
              j.exports = function(E) {
                if (!E) throw new Error("no data provided");
                E = E.toString().trim();
                var y = {
                  pages: [],
                  chars: [],
                  kernings: []
                }, l = E.split(/\r\n?|\n/g);
                if (l.length === 0) throw new Error("no data in BMFont file");
                for (var d = 0; d < l.length; d++) {
                  var p = re(l[d], d);
                  if (p)
                    if (p.key === "page") {
                      if (typeof p.data.id != "number") throw new Error("malformed file at line " + d + " -- needs page id=N");
                      if (typeof p.data.file != "string") throw new Error("malformed file at line " + d + ' -- needs page file="path"');
                      y.pages[p.data.id] = p.data.file;
                    } else p.key === "chars" || p.key === "kernings" || (p.key === "char" ? y.chars.push(p.data) : p.key === "kerning" ? y.kernings.push(p.data) : y[p.key] = p.data);
                }
                return y;
              };
              function re(w, E) {
                if (w = w.replace(/\t+/g, " ").trim(), !w) return null;
                var y = w.indexOf(" ");
                if (y === -1) throw new Error("no named row at line " + E);
                var l = w.substring(0, y);
                w = w.substring(y + 1), w = w.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), w = w.split("="), w = w.map(function(A) {
                  return A.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
                });
                for (var d = [], p = 0; p < w.length; p++) {
                  var c = w[p];
                  p === 0 ? d.push({
                    key: c[0],
                    data: ""
                  }) : p === w.length - 1 ? d[d.length - 1].data = v(c[0]) : (d[d.length - 1].data = v(c[0]), d.push({
                    key: c[1],
                    data: ""
                  }));
                }
                var g = {
                  key: l,
                  data: {}
                };
                return d.forEach(function(A) {
                  g.data[A.key] = A.data;
                }), g;
              }
              function v(w) {
                return !w || w.length === 0 ? "" : w.indexOf('"') === 0 || w.indexOf("'") === 0 ? w.substring(1, w.length - 1) : w.indexOf(",") !== -1 ? C(w) : parseInt(w, 10);
              }
              function C(w) {
                return w.split(",").map(function(E) {
                  return parseInt(E, 10);
                });
              }
            }
          ),
          /***/
          "./node_modules/parse-bmfont-binary/index.js": (
            /*!***************************************************!*\
              !*** ./node_modules/parse-bmfont-binary/index.js ***!
              \***************************************************/
            /***/
            (j) => {
              var re = [66, 77, 70];
              j.exports = function(g) {
                if (g.length < 6) throw new Error("invalid buffer length for BMFont");
                var A = re.every(function(b, D) {
                  return g.readUInt8(D) === b;
                });
                if (!A) throw new Error("BMFont missing BMF byte header");
                var u = 3, f = g.readUInt8(u++);
                if (f > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
                for (var x = {
                  kernings: [],
                  chars: []
                }, T = 0; T < 5; T++) u += v(x, g, u);
                return x;
              };
              function v(c, g, A) {
                if (A > g.length - 1) return 0;
                var u = g.readUInt8(A++), f = g.readInt32LE(A);
                switch (A += 4, u) {
                  case 1:
                    c.info = C(g, A);
                    break;
                  case 2:
                    c.common = w(g, A);
                    break;
                  case 3:
                    c.pages = E(g, A, f);
                    break;
                  case 4:
                    c.chars = y(g, A, f);
                    break;
                  case 5:
                    c.kernings = l(g, A, f);
                    break;
                }
                return 5 + f;
              }
              function C(c, g) {
                var A = {};
                A.size = c.readInt16LE(g);
                var u = c.readUInt8(g + 2);
                return A.smooth = u >> 7 & 1, A.unicode = u >> 6 & 1, A.italic = u >> 5 & 1, A.bold = u >> 4 & 1, u >> 3 & 1 && (A.fixedHeight = 1), A.charset = c.readUInt8(g + 3) || "", A.stretchH = c.readUInt16LE(g + 4), A.aa = c.readUInt8(g + 6), A.padding = [c.readInt8(g + 7), c.readInt8(g + 8), c.readInt8(g + 9), c.readInt8(g + 10)], A.spacing = [c.readInt8(g + 11), c.readInt8(g + 12)], A.outline = c.readUInt8(g + 13), A.face = p(c, g + 14), A;
              }
              function w(c, g) {
                var A = {};
                return A.lineHeight = c.readUInt16LE(g), A.base = c.readUInt16LE(g + 2), A.scaleW = c.readUInt16LE(g + 4), A.scaleH = c.readUInt16LE(g + 6), A.pages = c.readUInt16LE(g + 8), c.readUInt8(g + 10), A.packed = 0, A.alphaChnl = c.readUInt8(g + 11), A.redChnl = c.readUInt8(g + 12), A.greenChnl = c.readUInt8(g + 13), A.blueChnl = c.readUInt8(g + 14), A;
              }
              function E(c, g, A) {
                for (var u = [], f = d(c, g), x = f.length + 1, T = A / x, b = 0; b < T; b++)
                  u[b] = c.slice(g, g + f.length).toString("utf8"), g += x;
                return u;
              }
              function y(c, g, A) {
                for (var u = [], f = A / 20, x = 0; x < f; x++) {
                  var T = {}, b = x * 20;
                  T.id = c.readUInt32LE(g + 0 + b), T.x = c.readUInt16LE(g + 4 + b), T.y = c.readUInt16LE(g + 6 + b), T.width = c.readUInt16LE(g + 8 + b), T.height = c.readUInt16LE(g + 10 + b), T.xoffset = c.readInt16LE(g + 12 + b), T.yoffset = c.readInt16LE(g + 14 + b), T.xadvance = c.readInt16LE(g + 16 + b), T.page = c.readUInt8(g + 18 + b), T.chnl = c.readUInt8(g + 19 + b), u[x] = T;
                }
                return u;
              }
              function l(c, g, A) {
                for (var u = [], f = A / 10, x = 0; x < f; x++) {
                  var T = {}, b = x * 10;
                  T.first = c.readUInt32LE(g + 0 + b), T.second = c.readUInt32LE(g + 4 + b), T.amount = c.readInt16LE(g + 8 + b), u[x] = T;
                }
                return u;
              }
              function d(c, g) {
                for (var A = g; A < c.length && c[A] !== 0; A++)
                  ;
                return c.slice(g, A);
              }
              function p(c, g) {
                return d(c, g).toString("utf8");
              }
            }
          ),
          /***/
          "./node_modules/parse-bmfont-xml/lib/browser.js": (
            /*!******************************************************!*\
              !*** ./node_modules/parse-bmfont-xml/lib/browser.js ***!
              \******************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./parse-attribs */
                "./node_modules/parse-bmfont-xml/lib/parse-attribs.js"
              ), w = v(
                /*! xml-parse-from-string */
                "./node_modules/xml-parse-from-string/index.js"
              ), E = {
                scaleh: "scaleH",
                scalew: "scaleW",
                stretchh: "stretchH",
                lineheight: "lineHeight",
                alphachnl: "alphaChnl",
                redchnl: "redChnl",
                greenchnl: "greenChnl",
                bluechnl: "blueChnl"
              };
              j.exports = function(c) {
                c = c.toString();
                var g = w(c), A = {
                  pages: [],
                  chars: [],
                  kernings: []
                };
                ["info", "common"].forEach(function(S) {
                  var U = g.getElementsByTagName(S)[0];
                  U && (A[S] = C(y(U)));
                });
                var u = g.getElementsByTagName("pages")[0];
                if (!u) throw new Error("malformed file -- no <pages> element");
                for (var f = u.getElementsByTagName("page"), x = 0; x < f.length; x++) {
                  var T = f[x], b = parseInt(T.getAttribute("id"), 10), D = T.getAttribute("file");
                  if (isNaN(b)) throw new Error('malformed file -- page "id" attribute is NaN');
                  if (!D) throw new Error('malformed file -- needs page "file" attribute');
                  A.pages[parseInt(b, 10)] = D;
                }
                return ["chars", "kernings"].forEach(function(S) {
                  var U = g.getElementsByTagName(S)[0];
                  if (U)
                    for (var G = S.substring(0, S.length - 1), Z = U.getElementsByTagName(G), W = 0; W < Z.length; W++) {
                      var ie = Z[W];
                      A[S].push(C(y(ie)));
                    }
                }), A;
              };
              function y(p) {
                var c = l(p);
                return c.reduce(function(g, A) {
                  var u = d(A.nodeName);
                  return g[u] = A.nodeValue, g;
                }, {});
              }
              function l(p) {
                for (var c = [], g = 0; g < p.attributes.length; g++) c.push(p.attributes[g]);
                return c;
              }
              function d(p) {
                return E[p.toLowerCase()] || p;
              }
            }
          ),
          /***/
          "./node_modules/parse-bmfont-xml/lib/parse-attribs.js": (
            /*!************************************************************!*\
              !*** ./node_modules/parse-bmfont-xml/lib/parse-attribs.js ***!
              \************************************************************/
            /***/
            (j) => {
              var re = "chasrset";
              j.exports = function(w) {
                re in w && (w.charset = w[re], delete w[re]);
                for (var E in w)
                  E === "face" || E === "charset" || (E === "padding" || E === "spacing" ? w[E] = v(w[E]) : w[E] = parseInt(w[E], 10));
                return w;
              };
              function v(C) {
                return C.split(",").map(function(w) {
                  return parseInt(w, 10);
                });
              }
            }
          ),
          /***/
          "./node_modules/parse-headers/parse-headers.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/parse-headers/parse-headers.js ***!
              \*****************************************************/
            /***/
            (j) => {
              var re = function(C) {
                return C.replace(/^\s+|\s+$/g, "");
              }, v = function(C) {
                return Object.prototype.toString.call(C) === "[object Array]";
              };
              j.exports = function(C) {
                if (!C) return {};
                for (var w = {}, E = re(C).split(`
`), y = 0; y < E.length; y++) {
                  var l = E[y], d = l.indexOf(":"), p = re(l.slice(0, d)).toLowerCase(), c = re(l.slice(d + 1));
                  typeof w[p] > "u" ? w[p] = c : v(w[p]) ? w[p].push(c) : w[p] = [w[p], c];
                }
                return w;
              };
            }
          ),
          /***/
          "./node_modules/quad-indices/index.js": (
            /*!********************************************!*\
              !*** ./node_modules/quad-indices/index.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! dtype */
                "./node_modules/dtype/index.js"
              ), w = v(
                /*! an-array */
                "./node_modules/an-array/index.js"
              ), E = v(
                /*! is-buffer */
                "./node_modules/is-buffer/index.js"
              ), y = [0, 2, 3], l = [2, 1, 3];
              j.exports = function(p, c) {
                (!p || !(w(p) || E(p))) && (c = p || {}, p = null), typeof c == "number" ? c = {
                  count: c
                } : c = c || {};
                for (var g = typeof c.type == "string" ? c.type : "uint16", A = typeof c.count == "number" ? c.count : 1, u = c.start || 0, f = c.clockwise !== !1 ? y : l, x = f[0], T = f[1], b = f[2], D = A * 6, S = p || new (C(g))(D), U = 0, G = 0; U < D; U += 6, G += 4) {
                  var Z = U + u;
                  S[Z + 0] = G + 0, S[Z + 1] = G + 1, S[Z + 2] = G + 2, S[Z + 3] = G + x, S[Z + 4] = G + T, S[Z + 5] = G + b;
                }
                return S;
              };
            }
          ),
          /***/
          "./node_modules/super-animejs/lib/anime.es.js": (
            /*!****************************************************!*\
              !*** ./node_modules/super-animejs/lib/anime.es.js ***!
              \****************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                default: () => jn
                /* harmony export */
              });
              var C = {
                update: null,
                begin: null,
                loopBegin: null,
                changeBegin: null,
                change: null,
                changeComplete: null,
                loopComplete: null,
                complete: null,
                loop: 1,
                direction: "normal",
                autoplay: !0,
                timelineOffset: 0
              }, w = {
                duration: 1e3,
                delay: 0,
                endDelay: 0,
                easing: "easeOutElastic(1, .5)",
                round: 0
              }, E = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective"], y = {
                CSS: {},
                springs: {}
              };
              function l(de, _e, Ne) {
                return Math.min(Math.max(de, _e), Ne);
              }
              function d(de, _e) {
                return de.indexOf(_e) > -1;
              }
              function p(de, _e) {
                return de.apply(null, _e);
              }
              var c = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i, g = /^rgb/, A = /^hsl/, u = {
                arr: function(de) {
                  return Array.isArray(de);
                },
                obj: function(de) {
                  return d(Object.prototype.toString.call(de), "Object");
                },
                pth: function(de) {
                  return u.obj(de) && de.hasOwnProperty("totalLength");
                },
                svg: function(de) {
                  return de instanceof SVGElement;
                },
                inp: function(de) {
                  return de instanceof HTMLInputElement;
                },
                dom: function(de) {
                  return de.nodeType || u.svg(de);
                },
                str: function(de) {
                  return typeof de == "string";
                },
                fnc: function(de) {
                  return typeof de == "function";
                },
                und: function(de) {
                  return typeof de > "u";
                },
                hex: function(de) {
                  return c.test(de);
                },
                rgb: function(de) {
                  return g.test(de);
                },
                hsl: function(de) {
                  return A.test(de);
                },
                col: function(de) {
                  return u.hex(de) || u.rgb(de) || u.hsl(de);
                },
                key: function(de) {
                  return !C.hasOwnProperty(de) && !w.hasOwnProperty(de) && de !== "targets" && de !== "keyframes";
                }
              }, f = /\(([^)]+)\)/;
              function x(de) {
                var _e = f.exec(de);
                return _e ? _e[1].split(",").map(function(Ne) {
                  return parseFloat(Ne);
                }) : [];
              }
              function T(de, _e) {
                var Ne = x(de), Ye = l(u.und(Ne[0]) ? 1 : Ne[0], 0.1, 100), Ke = l(u.und(Ne[1]) ? 100 : Ne[1], 0.1, 100), rt = l(u.und(Ne[2]) ? 10 : Ne[2], 0.1, 100), bt = l(u.und(Ne[3]) ? 0 : Ne[3], 0.1, 100), ln = Math.sqrt(Ke / Ye), jt = rt / (2 * Math.sqrt(Ke * Ye)), at = jt < 1 ? ln * Math.sqrt(1 - jt * jt) : 0, mn = 1, _n = jt < 1 ? (jt * ln + -bt) / at : -bt + ln;
                function Rn(Wn) {
                  var Nn = _e ? _e * Wn / 1e3 : Wn;
                  return jt < 1 ? Nn = Math.exp(-Nn * jt * ln) * (mn * Math.cos(at * Nn) + _n * Math.sin(at * Nn)) : Nn = (mn + _n * Nn) * Math.exp(-Nn * ln), Wn === 0 || Wn === 1 ? Wn : 1 - Nn;
                }
                function Bi() {
                  var Wn = y.springs[de];
                  if (Wn)
                    return Wn;
                  for (var Nn = 1 / 6, li = 0, Gi = 0; ; )
                    if (li += Nn, Rn(li) === 1) {
                      if (Gi++, Gi >= 16)
                        break;
                    } else
                      Gi = 0;
                  var rr = li * Nn * 1e3;
                  return y.springs[de] = rr, rr;
                }
                return _e ? Rn : Bi;
              }
              function b(de, _e) {
                de === void 0 && (de = 1), _e === void 0 && (_e = 0.5);
                var Ne = l(de, 1, 10), Ye = l(_e, 0.1, 2);
                return function(Ke) {
                  return Ke === 0 || Ke === 1 ? Ke : -Ne * Math.pow(2, 10 * (Ke - 1)) * Math.sin((Ke - 1 - Ye / (Math.PI * 2) * Math.asin(1 / Ne)) * (Math.PI * 2) / Ye);
                };
              }
              function D(de) {
                return de === void 0 && (de = 10), function(_e) {
                  return Math.round(_e * de) * (1 / de);
                };
              }
              var S = function() {
                var de = 11, _e = 1 / (de - 1);
                function Ne(mn, _n) {
                  return 1 - 3 * _n + 3 * mn;
                }
                function Ye(mn, _n) {
                  return 3 * _n - 6 * mn;
                }
                function Ke(mn) {
                  return 3 * mn;
                }
                function rt(mn, _n, Rn) {
                  return ((Ne(_n, Rn) * mn + Ye(_n, Rn)) * mn + Ke(_n)) * mn;
                }
                function bt(mn, _n, Rn) {
                  return 3 * Ne(_n, Rn) * mn * mn + 2 * Ye(_n, Rn) * mn + Ke(_n);
                }
                function ln(mn, _n, Rn, Bi, Wn) {
                  var Nn, li, Gi = 0;
                  do
                    li = _n + (Rn - _n) / 2, Nn = rt(li, Bi, Wn) - mn, Nn > 0 ? Rn = li : _n = li;
                  while (Math.abs(Nn) > 1e-7 && ++Gi < 10);
                  return li;
                }
                function jt(mn, _n, Rn, Bi) {
                  for (var Wn = 0; Wn < 4; ++Wn) {
                    var Nn = bt(_n, Rn, Bi);
                    if (Nn === 0)
                      return _n;
                    var li = rt(_n, Rn, Bi) - mn;
                    _n -= li / Nn;
                  }
                  return _n;
                }
                function at(mn, _n, Rn, Bi) {
                  if (!(0 <= mn && mn <= 1 && 0 <= Rn && Rn <= 1))
                    return;
                  var Wn = new Float32Array(de);
                  if (mn !== _n || Rn !== Bi)
                    for (var Nn = 0; Nn < de; ++Nn)
                      Wn[Nn] = rt(Nn * _e, mn, Rn);
                  function li(Gi) {
                    for (var rr = 0, Wt = 1, Kn = de - 1; Wt !== Kn && Wn[Wt] <= Gi; ++Wt)
                      rr += _e;
                    --Wt;
                    var qi = (Gi - Wn[Wt]) / (Wn[Wt + 1] - Wn[Wt]), fi = rr + qi * _e, F = bt(fi, mn, Rn);
                    return F >= 1e-3 ? jt(Gi, fi, mn, Rn) : F === 0 ? fi : ln(Gi, rr, rr + _e, mn, Rn);
                  }
                  return function(Gi) {
                    return mn === _n && Rn === Bi || Gi === 0 || Gi === 1 ? Gi : rt(li(Gi), _n, Bi);
                  };
                }
                return at;
              }(), U = function() {
                var de = ["Quad", "Cubic", "Quart", "Quint", "Sine", "Expo", "Circ", "Back", "Elastic"], _e = {
                  In: [
                    [0.55, 0.085, 0.68, 0.53],
                    /* inQuad */
                    [0.55, 0.055, 0.675, 0.19],
                    /* inCubic */
                    [0.895, 0.03, 0.685, 0.22],
                    /* inQuart */
                    [0.755, 0.05, 0.855, 0.06],
                    /* inQuint */
                    [0.47, 0, 0.745, 0.715],
                    /* inSine */
                    [0.95, 0.05, 0.795, 0.035],
                    /* inExpo */
                    [0.6, 0.04, 0.98, 0.335],
                    /* inCirc */
                    [0.6, -0.28, 0.735, 0.045],
                    /* inBack */
                    b
                    /* inElastic */
                  ],
                  Out: [
                    [0.25, 0.46, 0.45, 0.94],
                    /* outQuad */
                    [0.215, 0.61, 0.355, 1],
                    /* outCubic */
                    [0.165, 0.84, 0.44, 1],
                    /* outQuart */
                    [0.23, 1, 0.32, 1],
                    /* outQuint */
                    [0.39, 0.575, 0.565, 1],
                    /* outSine */
                    [0.19, 1, 0.22, 1],
                    /* outExpo */
                    [0.075, 0.82, 0.165, 1],
                    /* outCirc */
                    [0.175, 0.885, 0.32, 1.275],
                    /* outBack */
                    function(bt, ln) {
                      return function(jt) {
                        return 1 - b(bt, ln)(1 - jt);
                      };
                    }
                    /* outElastic */
                  ],
                  InOut: [
                    [0.455, 0.03, 0.515, 0.955],
                    /* inOutQuad */
                    [0.645, 0.045, 0.355, 1],
                    /* inOutCubic */
                    [0.77, 0, 0.175, 1],
                    /* inOutQuart */
                    [0.86, 0, 0.07, 1],
                    /* inOutQuint */
                    [0.445, 0.05, 0.55, 0.95],
                    /* inOutSine */
                    [1, 0, 0, 1],
                    /* inOutExpo */
                    [0.785, 0.135, 0.15, 0.86],
                    /* inOutCirc */
                    [0.68, -0.55, 0.265, 1.55],
                    /* inOutBack */
                    function(bt, ln) {
                      return function(jt) {
                        return jt < 0.5 ? b(bt, ln)(jt * 2) / 2 : 1 - b(bt, ln)(jt * -2 + 2) / 2;
                      };
                    }
                    /* inOutElastic */
                  ]
                }, Ne = {
                  linear: [0.25, 0.25, 0.75, 0.75]
                };
                for (var Ye in _e)
                  for (var Ke = 0, rt = _e[Ye].length; Ke < rt; Ke++)
                    Ne["ease" + Ye + de[Ke]] = _e[Ye][Ke];
                return Ne;
              }();
              function G(de, _e) {
                if (u.fnc(de))
                  return de;
                var Ne = de.split("(")[0], Ye = U[Ne], Ke = x(de);
                switch (Ne) {
                  case "spring":
                    return T(de, _e);
                  case "cubicBezier":
                    return p(S, Ke);
                  case "steps":
                    return p(D, Ke);
                  default:
                    return u.fnc(Ye) ? p(Ye, Ke) : p(S, Ye);
                }
              }
              function Z(de) {
                try {
                  var _e = document.querySelectorAll(de);
                  return _e;
                } catch {
                  return;
                }
              }
              var W = [];
              function ie(de, _e) {
                for (var Ne = W, Ye = de.length, Ke = arguments.length >= 2 ? arguments[1] : void 0, rt = 0; rt < Ye; rt++)
                  if (rt in de) {
                    var bt = de[rt];
                    _e.call(Ke, bt, rt, de) && Ne.push(bt);
                  }
                return W = de, W.length = 0, Ne;
              }
              function te(de, _e) {
                _e || (_e = []);
                for (var Ne = 0, Ye = de.length; Ne < Ye; Ne++) {
                  var Ke = de[Ne];
                  Array.isArray(Ke) ? te(Ke, _e) : _e.push(Ke);
                }
                return _e;
              }
              function X(de) {
                return u.arr(de) ? de : (u.str(de) && (de = Z(de) || de), de instanceof NodeList || de instanceof HTMLCollection ? [].slice.call(de) : [de]);
              }
              function Q(de, _e) {
                return de.some(function(Ne) {
                  return Ne === _e;
                });
              }
              function O(de) {
                var _e = {};
                for (var Ne in de)
                  _e[Ne] = de[Ne];
                return _e;
              }
              function K(de, _e) {
                var Ne = O(de);
                for (var Ye in de)
                  Ne[Ye] = _e.hasOwnProperty(Ye) ? _e[Ye] : de[Ye];
                return Ne;
              }
              function ne(de, _e) {
                var Ne = O(de);
                for (var Ye in _e)
                  Ne[Ye] = u.und(de[Ye]) ? _e[Ye] : de[Ye];
                return Ne;
              }
              var pe = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g;
              function be(de) {
                var _e = pe.exec(de);
                return _e ? "rgba(" + _e[1] + ",1)" : de;
              }
              var Te = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, ke = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
              function Ve(de) {
                var _e = de.replace(Te, function(bt, ln, jt, at) {
                  return ln + ln + jt + jt + at + at;
                }), Ne = ke.exec(_e), Ye = parseInt(Ne[1], 16), Ke = parseInt(Ne[2], 16), rt = parseInt(Ne[3], 16);
                return "rgba(" + Ye + "," + Ke + "," + rt + ",1)";
              }
              var st = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g, ut = /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g;
              function It(de) {
                var _e = st.exec(de) || ut.exec(de), Ne = parseInt(_e[1], 10) / 360, Ye = parseInt(_e[2], 10) / 100, Ke = parseInt(_e[3], 10) / 100, rt = _e[4] || 1;
                function bt(Rn, Bi, Wn) {
                  return Wn < 0 && (Wn += 1), Wn > 1 && (Wn -= 1), Wn < 0.16666666666666666 ? Rn + (Bi - Rn) * 6 * Wn : Wn < 0.5 ? Bi : Wn < 0.6666666666666666 ? Rn + (Bi - Rn) * (0.6666666666666666 - Wn) * 6 : Rn;
                }
                var ln, jt, at;
                if (Ye == 0)
                  ln = jt = at = Ke;
                else {
                  var mn = Ke < 0.5 ? Ke * (1 + Ye) : Ke + Ye - Ke * Ye, _n = 2 * Ke - mn;
                  ln = bt(_n, mn, Ne + 0.3333333333333333), jt = bt(_n, mn, Ne), at = bt(_n, mn, Ne - 0.3333333333333333);
                }
                return "rgba(" + ln * 255 + "," + jt * 255 + "," + at * 255 + "," + rt + ")";
              }
              function ht(de) {
                if (u.rgb(de))
                  return be(de);
                if (u.hex(de))
                  return Ve(de);
                if (u.hsl(de))
                  return It(de);
              }
              var Rt = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/;
              function Qt(de) {
                var _e = Rt.exec(de);
                if (_e)
                  return _e[2];
              }
              function cn(de) {
                if (d(de, "translate") || de === "perspective")
                  return "px";
                if (d(de, "rotate") || d(de, "skew"))
                  return "deg";
              }
              function Cn(de, _e) {
                return u.fnc(de) ? de(_e.target, _e.id, _e.total) : de;
              }
              function Tn(de, _e) {
                return de.getAttribute(_e);
              }
              function wn(de, _e, Ne) {
                var Ye = Qt(_e);
                if (Q([Ne, "deg", "rad", "turn"], Ye))
                  return _e;
                var Ke = y.CSS[_e + Ne];
                if (!u.und(Ke))
                  return Ke;
                var rt = 100, bt = document.createElement(de.tagName), ln = de.parentNode && de.parentNode !== document ? de.parentNode : document.body;
                ln.appendChild(bt), bt.style.position = "absolute", bt.style.width = rt + Ne;
                var jt = rt / bt.offsetWidth;
                ln.removeChild(bt);
                var at = jt * parseFloat(_e);
                return y.CSS[_e + Ne] = at, at;
              }
              function rn(de, _e, Ne) {
                if (_e in de.style) {
                  var Ye = _e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), Ke = de.style[_e] || getComputedStyle(de).getPropertyValue(Ye) || "0";
                  return Ne ? wn(de, Ke, Ne) : Ke;
                }
              }
              function Bn(de, _e) {
                if (u.dom(de) && !u.inp(de) && (Tn(de, _e) || u.svg(de) && de[_e]))
                  return "attribute";
                if (u.dom(de) && Q(E, _e))
                  return "transform";
                if (u.dom(de) && _e !== "transform" && rn(de, _e))
                  return "css";
                if (de[_e] != null)
                  return "object";
              }
              var di = /(\w+)\(([^)]*)\)/g;
              function ri(de) {
                if (u.dom(de)) {
                  for (var _e = de.style.transform || "", Ne = /* @__PURE__ */ new Map(), Ye; Ye = di.exec(_e); )
                    Ne.set(Ye[1], Ye[2]);
                  return Ne;
                }
              }
              function Ni(de, _e, Ne, Ye) {
                var Ke = d(_e, "scale") ? 1 : 0 + cn(_e), rt = ri(de).get(_e) || Ke;
                return Ne && (Ne.transforms.list.set(_e, rt), Ne.transforms.last = _e), Ye ? wn(de, rt, Ye) : rt;
              }
              function Be(de, _e, Ne, Ye) {
                switch (Bn(de, _e)) {
                  case "transform":
                    return Ni(de, _e, Ye, Ne);
                  case "css":
                    return rn(de, _e, Ne);
                  case "attribute":
                    return Tn(de, _e);
                  default:
                    return de[_e] || 0;
                }
              }
              var Et = /^(\*=|\+=|-=)/;
              function Dt(de, _e) {
                var Ne = Et.exec(de);
                if (!Ne)
                  return de;
                var Ye = Qt(de) || 0, Ke = parseFloat(_e), rt = parseFloat(de.replace(Ne[0], ""));
                switch (Ne[0][0]) {
                  case "+":
                    return Ke + rt + Ye;
                  case "-":
                    return Ke - rt + Ye;
                  case "*":
                    return Ke * rt + Ye;
                }
              }
              var $t = /\s/g;
              function ei(de, _e) {
                if (u.col(de))
                  return ht(de);
                var Ne = Qt(de), Ye = Ne ? de.substr(0, de.length - Ne.length) : de;
                return _e && !$t.test(de) ? Ye + _e : Ye;
              }
              function Dn(de, _e) {
                return Math.sqrt(Math.pow(_e.x - de.x, 2) + Math.pow(_e.y - de.y, 2));
              }
              function Yt(de) {
                return Math.PI * 2 * Tn(de, "r");
              }
              function Xe(de) {
                return Tn(de, "width") * 2 + Tn(de, "height") * 2;
              }
              function le(de) {
                return Dn({
                  x: Tn(de, "x1"),
                  y: Tn(de, "y1")
                }, {
                  x: Tn(de, "x2"),
                  y: Tn(de, "y2")
                });
              }
              function ae(de) {
                for (var _e = de.points, Ne = 0, Ye, Ke = 0; Ke < _e.numberOfItems; Ke++) {
                  var rt = _e.getItem(Ke);
                  Ke > 0 && (Ne += Dn(Ye, rt)), Ye = rt;
                }
                return Ne;
              }
              function Ce(de) {
                var _e = de.points;
                return ae(de) + Dn(_e.getItem(_e.numberOfItems - 1), _e.getItem(0));
              }
              function fe(de) {
                if (de.getTotalLength)
                  return de.getTotalLength();
                switch (de.tagName.toLowerCase()) {
                  case "circle":
                    return Yt(de);
                  case "rect":
                    return Xe(de);
                  case "line":
                    return le(de);
                  case "polyline":
                    return ae(de);
                  case "polygon":
                    return Ce(de);
                }
              }
              function ge(de) {
                var _e = fe(de);
                return de.setAttribute("stroke-dasharray", _e), _e;
              }
              function xe(de) {
                for (var _e = de.parentNode; u.svg(_e) && (_e = _e.parentNode, !!u.svg(_e.parentNode)); )
                  ;
                return _e;
              }
              function H(de, _e) {
                var Ne = _e || {}, Ye = Ne.el || xe(de), Ke = Ye.getBoundingClientRect(), rt = Tn(Ye, "viewBox"), bt = Ke.width, ln = Ke.height, jt = Ne.viewBox || (rt ? rt.split(" ") : [0, 0, bt, ln]);
                return {
                  el: Ye,
                  viewBox: jt,
                  x: jt[0] / 1,
                  y: jt[1] / 1,
                  w: bt / jt[2],
                  h: ln / jt[3]
                };
              }
              function M(de, _e) {
                var Ne = u.str(de) ? Z(de)[0] : de, Ye = _e || 100;
                return function(Ke) {
                  return {
                    property: Ke,
                    el: Ne,
                    svg: H(Ne),
                    totalLength: fe(Ne) * (Ye / 100)
                  };
                };
              }
              function R(de, _e) {
                function Ne(ln) {
                  ln === void 0 && (ln = 0);
                  var jt = _e + ln >= 1 ? _e + ln : 0;
                  return de.el.getPointAtLength(jt);
                }
                var Ye = H(de.el, de.svg), Ke = Ne(), rt = Ne(-1), bt = Ne(1);
                switch (de.property) {
                  case "x":
                    return (Ke.x - Ye.x) * Ye.w;
                  case "y":
                    return (Ke.y - Ye.y) * Ye.h;
                  case "angle":
                    return Math.atan2(bt.y - rt.y, bt.x - rt.x) * 180 / Math.PI;
                }
              }
              var ee = /-?\d*\.?\d+/g;
              function he(de, _e) {
                var Ne = ei(u.pth(de) ? de.totalLength : de, _e) + "";
                return {
                  original: Ne,
                  numbers: Ne.match(ee) ? Ne.match(ee).map(Number) : [0],
                  strings: u.str(de) || _e ? Ne.split(ee) : []
                };
              }
              function we(de) {
                var _e = de ? te(u.arr(de) ? de.map(X) : X(de)) : [];
                return ie(_e, function(Ne, Ye, Ke) {
                  return Ke.indexOf(Ne) === Ye;
                });
              }
              function Oe(de) {
                var _e = we(de);
                return _e.map(function(Ne, Ye) {
                  return {
                    target: Ne,
                    id: Ye,
                    total: _e.length,
                    transforms: {
                      list: ri(Ne)
                    }
                  };
                });
              }
              var Ct = /^spring/;
              function Pt(de, _e) {
                var Ne = O(_e);
                if (Ct.test(Ne.easing) && (Ne.duration = T(Ne.easing)), u.arr(de)) {
                  var Ye = de.length, Ke = Ye === 2 && !u.obj(de[0]);
                  Ke ? de = {
                    value: de
                  } : u.fnc(_e.duration) || (Ne.duration = _e.duration / Ye);
                }
                var rt = u.arr(de) ? de : [de];
                return rt.map(function(bt, ln) {
                  var jt = u.obj(bt) && !u.pth(bt) ? bt : {
                    value: bt
                  };
                  return u.und(jt.delay) && (jt.delay = ln ? 0 : _e.delay), u.und(jt.endDelay) && (jt.endDelay = ln === rt.length - 1 ? _e.endDelay : 0), jt;
                }).map(function(bt) {
                  return ne(bt, Ne);
                });
              }
              function _t(de) {
                for (var _e = ie(te(de.map(function(rt) {
                  return Object.keys(rt);
                })), function(rt) {
                  return u.key(rt);
                }).reduce(function(rt, bt) {
                  return rt.indexOf(bt) < 0 && rt.push(bt), rt;
                }, []), Ne = {}, Ye = function(rt) {
                  var bt = _e[rt];
                  Ne[bt] = de.map(function(ln) {
                    var jt = {};
                    for (var at in ln)
                      u.key(at) ? at == bt && (jt.value = ln[at]) : jt[at] = ln[at];
                    return jt;
                  });
                }, Ke = 0; Ke < _e.length; Ke++) Ye(Ke);
                return Ne;
              }
              function St(de, _e) {
                var Ne = [], Ye = _e.keyframes;
                Ye && (_e = ne(_t(Ye), _e));
                for (var Ke in _e)
                  u.key(Ke) && Ne.push({
                    name: Ke,
                    tweens: Pt(_e[Ke], de)
                  });
                return Ne;
              }
              function qt(de, _e) {
                var Ne = {};
                for (var Ye in de) {
                  var Ke = Cn(de[Ye], _e);
                  u.arr(Ke) && (Ke = Ke.map(function(rt) {
                    return Cn(rt, _e);
                  }), Ke.length === 1 && (Ke = Ke[0])), Ne[Ye] = Ke;
                }
                return Ne.duration = parseFloat(Ne.duration), Ne.delay = parseFloat(Ne.delay), Ne;
              }
              function ki(de, _e) {
                var Ne;
                return de.tweens.map(function(Ye) {
                  var Ke = qt(Ye, _e), rt = Ke.value, bt = u.arr(rt) ? rt[1] : rt, ln = Qt(bt), jt = Be(_e.target, de.name, ln, _e), at = Ne ? Ne.to.original : jt, mn = u.arr(rt) ? rt[0] : at, _n = Qt(mn) || Qt(jt), Rn = ln || _n;
                  return u.und(bt) && (bt = at), Ke.from = he(mn, Rn), Ke.to = he(Dt(bt, mn), Rn), Ke.start = Ne ? Ne.end : 0, Ke.end = Ke.start + Ke.delay + Ke.duration + Ke.endDelay, Ke.easing = G(Ke.easing, Ke.duration), Ke.isPath = u.pth(rt), Ke.isColor = u.col(Ke.from.original), Ke.isColor && (Ke.round = 1), Ne = Ke, Ke;
                });
              }
              var vn = {
                css: function(de, _e, Ne) {
                  return de.style[_e] = Ne;
                },
                attribute: function(de, _e, Ne) {
                  return de.setAttribute(_e, Ne);
                },
                object: function(de, _e, Ne) {
                  return de[_e] = Ne;
                },
                transform: function(de, _e, Ne, Ye, Ke) {
                  if (Ye.list.set(_e, Ne), _e === Ye.last || Ke) {
                    var rt = "";
                    Ye.list.forEach(function(bt, ln) {
                      rt += ln + "(" + bt + ") ";
                    }), de.style.transform = rt;
                  }
                }
              };
              function Oi(de, _e) {
                for (var Ne = Oe(de), Ye = 0, Ke = Ne.length; Ye < Ke; Ye++) {
                  var rt = Ne[Ye];
                  for (var bt in _e) {
                    var ln = Cn(_e[bt], rt), jt = rt.target, at = Qt(ln), mn = Be(jt, bt, at, rt), _n = at || Qt(mn), Rn = Dt(ei(ln, _n), mn), Bi = Bn(jt, bt);
                    vn[Bi](jt, bt, Rn, rt.transforms, !0);
                  }
                }
              }
              function ui(de, _e) {
                var Ne = Bn(de.target, _e.name);
                if (Ne) {
                  var Ye = ki(_e, de), Ke = Ye[Ye.length - 1];
                  return {
                    type: Ne,
                    property: _e.name,
                    animatable: de,
                    tweens: Ye,
                    duration: Ke.end,
                    delay: Ye[0].delay,
                    endDelay: Ke.endDelay
                  };
                }
              }
              function Ei(de, _e) {
                return ie(te(de.map(function(Ne) {
                  return _e.map(function(Ye) {
                    return ui(Ne, Ye);
                  });
                })), function(Ne) {
                  return !u.und(Ne);
                });
              }
              function fr(de, _e) {
                var Ne = de.length, Ye = function(rt) {
                  return rt.timelineOffset ? rt.timelineOffset : 0;
                }, Ke = {};
                return Ke.duration = Ne ? Math.max.apply(Math, de.map(function(rt) {
                  return Ye(rt) + rt.duration;
                })) : _e.duration, Ke.delay = Ne ? Math.min.apply(Math, de.map(function(rt) {
                  return Ye(rt) + rt.delay;
                })) : _e.delay, Ke.endDelay = Ne ? Ke.duration - Math.max.apply(Math, de.map(function(rt) {
                  return Ye(rt) + rt.duration - rt.endDelay;
                })) : _e.endDelay, Ke;
              }
              var Ii = 0;
              function Sr(de) {
                var _e = K(C, de), Ne = K(w, de), Ye = St(Ne, de), Ke = Oe(de.targets), rt = Ei(Ke, Ye), bt = fr(rt, Ne), ln = Ii;
                return Ii++, ne(_e, {
                  id: ln,
                  children: [],
                  animatables: Ke,
                  animations: rt,
                  duration: bt.duration,
                  delay: bt.delay,
                  endDelay: bt.endDelay
                });
              }
              var ji = [], Cr = [], Y, Fe = /* @__PURE__ */ function() {
                function de() {
                  Y = requestAnimationFrame(_e);
                }
                function _e(Ne) {
                  var Ye = ji.length;
                  if (Ye) {
                    for (var Ke = 0; Ke < Ye; ) {
                      var rt = ji[Ke];
                      if (!rt.paused)
                        rt.tick(Ne);
                      else {
                        var bt = ji.indexOf(rt);
                        bt > -1 && (ji.splice(bt, 1), Ye = ji.length);
                      }
                      Ke++;
                    }
                    de();
                  } else
                    Y = cancelAnimationFrame(Y);
                }
                return de;
              }();
              function tt() {
                if (document.hidden) {
                  for (var de = 0, _e = ji.length; de < _e; de++)
                    activeInstance[de].pause();
                  Cr = ji.slice(0), ji = [];
                } else
                  for (var Ne = 0, Ye = Cr.length; Ne < Ye; Ne++)
                    Cr[Ne].play();
              }
              document.addEventListener("visibilitychange", tt);
              function lt(de) {
                de === void 0 && (de = {});
                var _e = 0, Ne = 0, Ye = 0, Ke, rt = 0, bt = null;
                function ln() {
                  return window.Promise && new Promise(function(Wt) {
                    return bt = Wt;
                  });
                }
                var jt = ln(), at = Sr(de);
                function mn() {
                  at.reversed = !at.reversed;
                  for (var Wt = 0, Kn = Ke.length; Wt < Kn; Wt++)
                    Ke[Wt].reversed = at.reversed;
                }
                function _n(Wt) {
                  return at.reversed ? at.duration - Wt : Wt;
                }
                function Rn() {
                  _e = 0, Ne = _n(at.currentTime) * (1 / lt.speed);
                }
                function Bi(Wt, Kn) {
                  Kn && Kn.seek(Wt - Kn.timelineOffset);
                }
                function Wn(Wt) {
                  if (at.reversePlayback)
                    for (var qi = rt; qi--; )
                      Bi(Wt, Ke[qi]);
                  else
                    for (var Kn = 0; Kn < rt; Kn++)
                      Bi(Wt, Ke[Kn]);
                }
                function Nn(Wt) {
                  for (var Kn = 0, qi = at.animations, fi = qi.length; Kn < fi; ) {
                    var F = qi[Kn], V = F.animatable, q = F.tweens, oe = q.length - 1, me = q[oe];
                    oe && (me = ie(q, function(Wi) {
                      return Wt < Wi.end;
                    })[0] || me);
                    for (var De = l(Wt - me.start - me.delay, 0, me.duration) / me.duration, Ge = isNaN(De) ? 1 : me.easing(De), ft = me.to.strings, ct = me.round, je = [], nt = me.to.numbers.length, xt = void 0, Jt = 0; Jt < nt; Jt++) {
                      var dn = void 0, Mn = me.to.numbers[Jt], Vn = me.from.numbers[Jt] || 0;
                      me.isPath ? dn = R(me.value, Ge * Mn) : dn = Vn + Ge * (Mn - Vn), ct && (me.isColor && Jt > 2 || (dn = Math.round(dn * ct) / ct)), je.push(dn);
                    }
                    var On = ft.length;
                    if (!On)
                      xt = je[0];
                    else {
                      xt = ft[0];
                      for (var In = 0; In < On; In++) {
                        ft[In];
                        var Ai = ft[In + 1], Ri = je[In];
                        isNaN(Ri) || (Ai ? xt += Ri + Ai : xt += Ri + " ");
                      }
                    }
                    vn[F.type](V.target, F.property, xt, V.transforms), F.currentValue = xt, Kn++;
                  }
                }
                function li(Wt) {
                  at[Wt] && !at.passThrough && at[Wt](at);
                }
                function Gi() {
                  at.remaining && at.remaining !== !0 && at.remaining--;
                }
                function rr(Wt) {
                  var Kn = at.duration, qi = at.delay, fi = Kn - at.endDelay, F = _n(Wt);
                  at.progress = l(F / Kn * 100, 0, 100), at.reversePlayback = F < at.currentTime, Ke && Wn(F), !at.began && at.currentTime > 0 && (at.began = !0, li("begin"), li("loopBegin")), F <= qi && at.currentTime !== 0 && Nn(0), (F >= fi && at.currentTime !== Kn || !Kn) && Nn(Kn), F > qi && F < fi ? (at.changeBegan || (at.changeBegan = !0, at.changeCompleted = !1, li("changeBegin")), li("change"), Nn(F)) : at.changeBegan && (at.changeCompleted = !0, at.changeBegan = !1, li("changeComplete")), at.currentTime = l(F, 0, Kn), at.began && li("update"), Wt >= Kn && (Ne = 0, Gi(), at.remaining ? (_e = Ye, li("loopComplete"), li("loopBegin"), at.direction === "alternate" && mn()) : (at.paused = !0, at.completed || (at.completed = !0, li("loopComplete"), li("complete"), "Promise" in window && (bt(), jt = ln()))));
                }
                return at.reset = function() {
                  var Wt = at.direction;
                  at.passThrough = !1, at.currentTime = 0, at.progress = 0, at.paused = !0, at.began = !1, at.changeBegan = !1, at.completed = !1, at.changeCompleted = !1, at.reversePlayback = !1, at.reversed = Wt === "reverse", at.remaining = at.loop, Ke = at.children, rt = Ke.length;
                  for (var Kn = rt; Kn--; )
                    at.children[Kn].reset();
                  (at.reversed && at.loop !== !0 || Wt === "alternate" && at.loop === 1) && at.remaining++, Nn(0);
                }, at.set = function(Wt, Kn) {
                  return Oi(Wt, Kn), at;
                }, at.tick = function(Wt) {
                  Ye = Wt, _e || (_e = Ye), rr((Ye + (Ne - _e)) * lt.speed);
                }, at.seek = function(Wt) {
                  rr(_n(Wt));
                }, at.pause = function() {
                  at.paused = !0, Rn();
                }, at.play = function() {
                  at.paused && (at.paused = !1, ji.push(at), Rn(), Y || Fe());
                }, at.reverse = function() {
                  mn(), Rn();
                }, at.restart = function() {
                  at.reset(), at.play();
                }, at.finished = jt, at.reset(), at.autoplay && at.play(), at;
              }
              function Ut(de, _e) {
                for (var Ne = _e.length; Ne--; )
                  Q(de, _e[Ne].animatable.target) && _e.splice(Ne, 1);
              }
              function hn(de) {
                for (var _e = we(de), Ne = ji.length; Ne--; ) {
                  var Ye = ji[Ne], Ke = Ye.animations, rt = Ye.children;
                  Ut(_e, Ke);
                  for (var bt = rt.length; bt--; ) {
                    var ln = rt[bt], jt = ln.animations;
                    Ut(_e, jt), !jt.length && !ln.children.length && rt.splice(bt, 1);
                  }
                  !Ke.length && !rt.length && Ye.pause();
                }
              }
              function zt(de, _e) {
                _e === void 0 && (_e = {});
                var Ne = _e.direction || "normal", Ye = _e.easing ? G(_e.easing) : null, Ke = _e.grid, rt = _e.axis, bt = _e.from || 0, ln = bt === "first", jt = bt === "center", at = bt === "last", mn = u.arr(de), _n = parseFloat(mn ? de[0] : de), Rn = mn ? parseFloat(de[1]) : 0, Bi = Qt(mn ? de[1] : de) || 0, Wn = _e.start || 0 + (mn ? _n : 0), Nn = [], li = 0;
                return function(Gi, rr, Wt) {
                  if (ln && (bt = 0), jt && (bt = (Wt - 1) / 2), at && (bt = Wt - 1), !Nn.length) {
                    for (var Kn = 0; Kn < Wt; Kn++) {
                      if (!Ke)
                        Nn.push(Math.abs(bt - Kn));
                      else {
                        var qi = jt ? (Ke[0] - 1) / 2 : bt % Ke[0], fi = jt ? (Ke[1] - 1) / 2 : Math.floor(bt / Ke[0]), F = Kn % Ke[0], V = Math.floor(Kn / Ke[0]), q = qi - F, oe = fi - V, me = Math.sqrt(q * q + oe * oe);
                        rt === "x" && (me = -q), rt === "y" && (me = -oe), Nn.push(me);
                      }
                      li = Math.max.apply(Math, Nn);
                    }
                    Ye && (Nn = Nn.map(function(Ge) {
                      return Ye(Ge / li) * li;
                    })), Ne === "reverse" && (Nn = Nn.map(function(Ge) {
                      return rt ? Ge < 0 ? Ge * -1 : -Ge : Math.abs(li - Ge);
                    }));
                  }
                  var De = mn ? (Rn - _n) / li : _n;
                  return Wn + De * (Math.round(Nn[rr] * 100) / 100) + Bi;
                };
              }
              function ai(de) {
                de === void 0 && (de = {});
                var _e = lt(de);
                return _e.duration = 0, _e.add = function(Ne, Ye) {
                  var Ke = ji.indexOf(_e), rt = _e.children;
                  Ke > -1 && ji.splice(Ke, 1);
                  function bt(Rn) {
                    Rn.passThrough = !0;
                  }
                  for (var ln = 0; ln < rt.length; ln++)
                    bt(rt[ln]);
                  var jt = ne(Ne, K(w, de));
                  jt.targets = jt.targets || de.targets;
                  var at = _e.duration;
                  jt.autoplay = !1, jt.direction = _e.direction, jt.timelineOffset = u.und(Ye) ? at : Dt(Ye, at), bt(_e), _e.seek(jt.timelineOffset);
                  var mn = lt(jt);
                  bt(mn), rt.push(mn);
                  var _n = fr(rt, de);
                  return _e.delay = _n.delay, _e.endDelay = _n.endDelay, _e.duration = _n.duration, _e.seek(0), _e.reset(), _e.autoplay && _e.play(), _e;
                }, _e;
              }
              lt.version = "3.0.0", lt.speed = 1, lt.running = ji, lt.remove = hn, lt.get = Be, lt.set = Oi, lt.convertPx = wn, lt.path = M, lt.setDashoffset = ge, lt.stagger = zt, lt.timeline = ai, lt.easing = G, lt.penner = U, lt.random = function(de, _e) {
                return Math.floor(Math.random() * (_e - de + 1)) + de;
              };
              const jn = lt;
            }
          ),
          /***/
          "./node_modules/three-bmfont-text/index.js": (
            /*!*************************************************!*\
              !*** ./node_modules/three-bmfont-text/index.js ***!
              \*************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! layout-bmfont-text */
                "./node_modules/layout-bmfont-text/index.js"
              ), w = v(
                /*! quad-indices */
                "./node_modules/quad-indices/index.js"
              ), E = v(
                /*! ./lib/vertices */
                "./node_modules/three-bmfont-text/lib/vertices.js"
              ), y = v(
                /*! ./lib/utils */
                "./node_modules/three-bmfont-text/lib/utils.js"
              );
              j.exports = function(p) {
                return new l(p);
              };
              class l extends THREE.BufferGeometry {
                constructor(p) {
                  super(), typeof p == "string" && (p = {
                    text: p
                  }), this._opt = Object.assign({}, p), p && this.update(p);
                }
                update(p) {
                  if (typeof p == "string" && (p = {
                    text: p
                  }), p = Object.assign({}, this._opt, p), !p.font)
                    throw new TypeError("must specify a { font } in options");
                  this.layout = C(p);
                  var c = p.flipY !== !1, g = p.font, A = g.common.scaleW, u = g.common.scaleH, f = this.layout.glyphs.filter(function(S) {
                    var U = S.data;
                    return U.width * U.height > 0;
                  });
                  this.visibleGlyphs = f;
                  var x = E.positions(f), T = E.uvs(f, A, u, c), b = w([], {
                    clockwise: !0,
                    type: "uint16",
                    count: f.length
                  });
                  if (this.setIndex(b), this.setAttribute("position", new THREE.BufferAttribute(x, 2)), this.setAttribute("uv", new THREE.BufferAttribute(T, 2)), !p.multipage && "page" in this.attributes)
                    this.removeAttribute("page");
                  else if (p.multipage) {
                    var D = E.pages(f);
                    this.setAttribute("page", new THREE.BufferAttribute(D, 1));
                  }
                  this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere();
                }
                computeBoundingSphere() {
                  this.boundingSphere === null && (this.boundingSphere = new THREE.Sphere());
                  var p = this.attributes.position.array, c = this.attributes.position.itemSize;
                  if (!p || !c || p.length < 2) {
                    this.boundingSphere.radius = 0, this.boundingSphere.center.set(0, 0, 0);
                    return;
                  }
                  y.computeSphere(p, this.boundingSphere), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');
                }
                computeBoundingBox() {
                  this.boundingBox === null && (this.boundingBox = new THREE.Box3());
                  var p = this.boundingBox, c = this.attributes.position.array, g = this.attributes.position.itemSize;
                  if (!c || !g || c.length < 2) {
                    p.makeEmpty();
                    return;
                  }
                  y.computeBox(c, p);
                }
              }
            }
          ),
          /***/
          "./node_modules/three-bmfont-text/lib/utils.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/three-bmfont-text/lib/utils.js ***!
              \*****************************************************/
            /***/
            (j) => {
              var re = 2, v = {
                min: [0, 0],
                max: [0, 0]
              };
              function C(w) {
                var E = w.length / re;
                v.min[0] = w[0], v.min[1] = w[1], v.max[0] = w[0], v.max[1] = w[1];
                for (var y = 0; y < E; y++) {
                  var l = w[y * re + 0], d = w[y * re + 1];
                  v.min[0] = Math.min(l, v.min[0]), v.min[1] = Math.min(d, v.min[1]), v.max[0] = Math.max(l, v.max[0]), v.max[1] = Math.max(d, v.max[1]);
                }
              }
              j.exports.computeBox = function(w, E) {
                C(w), E.min.set(v.min[0], v.min[1], 0), E.max.set(v.max[0], v.max[1], 0);
              }, j.exports.computeSphere = function(w, E) {
                C(w);
                var y = v.min[0], l = v.min[1], d = v.max[0], p = v.max[1], c = d - y, g = p - l, A = Math.sqrt(c * c + g * g);
                E.center.set(y + c / 2, l + g / 2, 0), E.radius = A / 2;
              };
            }
          ),
          /***/
          "./node_modules/three-bmfont-text/lib/vertices.js": (
            /*!********************************************************!*\
              !*** ./node_modules/three-bmfont-text/lib/vertices.js ***!
              \********************************************************/
            /***/
            (j) => {
              j.exports.pages = function(v) {
                var C = new Float32Array(v.length * 4 * 1), w = 0;
                return v.forEach(function(E) {
                  var y = E.data.page || 0;
                  C[w++] = y, C[w++] = y, C[w++] = y, C[w++] = y;
                }), C;
              }, j.exports.uvs = function(v, C, w, E) {
                var y = new Float32Array(v.length * 4 * 2), l = 0;
                return v.forEach(function(d) {
                  var p = d.data, c = p.x + p.width, g = p.y + p.height, A = p.x / C, u = p.y / w, f = c / C, x = g / w;
                  E && (u = (w - p.y) / w, x = (w - g) / w), y[l++] = A, y[l++] = u, y[l++] = A, y[l++] = x, y[l++] = f, y[l++] = x, y[l++] = f, y[l++] = u;
                }), y;
              }, j.exports.positions = function(v) {
                var C = new Float32Array(v.length * 4 * 2), w = 0;
                return v.forEach(function(E) {
                  var y = E.data, l = E.position[0] + y.xoffset, d = E.position[1] + y.yoffset, p = y.width, c = y.height;
                  C[w++] = l, C[w++] = d, C[w++] = l, C[w++] = d + c, C[w++] = l + p, C[w++] = d + c, C[w++] = l + p, C[w++] = d;
                }), C;
              };
            }
          ),
          /***/
          "./node_modules/webvr-polyfill/build/webvr-polyfill.js": (
            /*!*************************************************************!*\
              !*** ./node_modules/webvr-polyfill/build/webvr-polyfill.js ***!
              \*************************************************************/
            /***/
            function(j, re, v) {
              /**
               * @license
               * webvr-polyfill
               * Copyright (c) 2015-2017 Google
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               * http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */
              /**
               * @license
               * cardboard-vr-display
               * Copyright (c) 2015-2017 Google
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               * http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */
              /**
               * @license
               * webvr-polyfill-dpdb 
               * Copyright (c) 2017 Google
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               * http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */
              /**
               * @license
               * wglu-preserve-state
               * Copyright (c) 2016, Brandon Jones.
               *
               * Permission is hereby granted, free of charge, to any person obtaining a copy
               * of this software and associated documentation files (the "Software"), to deal
               * in the Software without restriction, including without limitation the rights
               * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
               * copies of the Software, and to permit persons to whom the Software is
               * furnished to do so, subject to the following conditions:
               *
               * The above copyright notice and this permission notice shall be included in
               * all copies or substantial portions of the Software.
               *
               * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
               * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
               * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
               * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
               * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
               * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
               * THE SOFTWARE.
               */
              /**
               * @license
               * nosleep.js
               * Copyright (c) 2017, Rich Tibbett
               *
               * Permission is hereby granted, free of charge, to any person obtaining a copy
               * of this software and associated documentation files (the "Software"), to deal
               * in the Software without restriction, including without limitation the rights
               * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
               * copies of the Software, and to permit persons to whom the Software is
               * furnished to do so, subject to the following conditions:
               *
               * The above copyright notice and this permission notice shall be included in
               * all copies or substantial portions of the Software.
               *
               * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
               * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
               * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
               * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
               * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
               * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
               * THE SOFTWARE.
               */
              (function(C, w) {
                j.exports = w();
              })(this, function() {
                var C = typeof window < "u" ? window : typeof v.g < "u" ? v.g : typeof self < "u" ? self : {};
                function w(b) {
                  return b && b.__esModule && Object.prototype.hasOwnProperty.call(b, "default") ? b.default : b;
                }
                function E(b, D) {
                  return D = {
                    exports: {}
                  }, b(D, D.exports), D.exports;
                }
                var y = function() {
                  return /Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent);
                }, l = function(D, S) {
                  for (var U = 0, G = D.length; U < G; U++)
                    S[U] = D[U];
                }, d = function(D, S) {
                  for (var U in S)
                    S.hasOwnProperty(U) && (D[U] = S[U]);
                  return D;
                }, p = E(function(b, D) {
                  /**
                   * @license
                   * cardboard-vr-display
                   * Copyright (c) 2015-2017 Google
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   * http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */
                  /**
                   * @license
                   * gl-preserve-state
                   * Copyright (c) 2016, Brandon Jones.
                   *
                   * Permission is hereby granted, free of charge, to any person obtaining a copy
                   * of this software and associated documentation files (the "Software"), to deal
                   * in the Software without restriction, including without limitation the rights
                   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                   * copies of the Software, and to permit persons to whom the Software is
                   * furnished to do so, subject to the following conditions:
                   *
                   * The above copyright notice and this permission notice shall be included in
                   * all copies or substantial portions of the Software.
                   *
                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                   * THE SOFTWARE.
                   */
                  /**
                   * @license
                   * webvr-polyfill-dpdb
                   * Copyright (c) 2015-2017 Google
                   * Licensed under the Apache License, Version 2.0 (the "License");
                   * you may not use this file except in compliance with the License.
                   * You may obtain a copy of the License at
                   *
                   * http://www.apache.org/licenses/LICENSE-2.0
                   *
                   * Unless required by applicable law or agreed to in writing, software
                   * distributed under the License is distributed on an "AS IS" BASIS,
                   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                   * See the License for the specific language governing permissions and
                   * limitations under the License.
                   */
                  /**
                   * @license
                   * nosleep.js
                   * Copyright (c) 2017, Rich Tibbett
                   *
                   * Permission is hereby granted, free of charge, to any person obtaining a copy
                   * of this software and associated documentation files (the "Software"), to deal
                   * in the Software without restriction, including without limitation the rights
                   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                   * copies of the Software, and to permit persons to whom the Software is
                   * furnished to do so, subject to the following conditions:
                   *
                   * The above copyright notice and this permission notice shall be included in
                   * all copies or substantial portions of the Software.
                   *
                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                   * THE SOFTWARE.
                   */
                  (function(S, U) {
                    b.exports = U();
                  })(C, function() {
                    var S = function(F, V) {
                      if (!(F instanceof V))
                        throw new TypeError("Cannot call a class as a function");
                    }, U = /* @__PURE__ */ function() {
                      function F(V, q) {
                        for (var oe = 0; oe < q.length; oe++) {
                          var me = q[oe];
                          me.enumerable = me.enumerable || !1, me.configurable = !0, "value" in me && (me.writable = !0), Object.defineProperty(V, me.key, me);
                        }
                      }
                      return function(V, q, oe) {
                        return q && F(V.prototype, q), oe && F(V, oe), V;
                      };
                    }(), G = /* @__PURE__ */ function() {
                      function F(V, q) {
                        var oe = [], me = !0, De = !1, Ge = void 0;
                        try {
                          for (var ft = V[Symbol.iterator](), ct; !(me = (ct = ft.next()).done) && (oe.push(ct.value), !(q && oe.length === q)); me = !0)
                            ;
                        } catch (je) {
                          De = !0, Ge = je;
                        } finally {
                          try {
                            !me && ft.return && ft.return();
                          } finally {
                            if (De) throw Ge;
                          }
                        }
                        return oe;
                      }
                      return function(V, q) {
                        if (Array.isArray(V))
                          return V;
                        if (Symbol.iterator in Object(V))
                          return F(V, q);
                        throw new TypeError("Invalid attempt to destructure non-iterable instance");
                      };
                    }(), Z = 1e-3, W = 1, ie = function(V, q) {
                      return "data:" + V + "," + encodeURIComponent(q);
                    }, te = function(V, q, oe) {
                      return V + (q - V) * oe;
                    }, X = function() {
                      var F = /iPad|iPhone|iPod/.test(navigator.platform);
                      return function() {
                        return F;
                      };
                    }(), Q = function() {
                      var F = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
                      return function() {
                        return F;
                      };
                    }(), O = function() {
                      var F = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                      return function() {
                        return F;
                      };
                    }(), K = function() {
                      var F = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
                      return function() {
                        return F;
                      };
                    }(), ne = function() {
                      var F = navigator.userAgent.match(/.*Chrome\/([0-9]+)/), V = F ? parseInt(F[1], 10) : null;
                      return function() {
                        return V;
                      };
                    }(), pe = function() {
                      var F = !1;
                      return F = X() && O() && navigator.userAgent.indexOf("13_4") !== -1, function() {
                        return F;
                      };
                    }(), be = function() {
                      var F = !1;
                      if (ne() === 65) {
                        var V = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
                        if (V) {
                          var q = V[1].split("."), oe = G(q, 4);
                          oe[0], oe[1];
                          var me = oe[2], De = oe[3];
                          F = parseInt(me, 10) === 3325 && parseInt(De, 10) < 148;
                        }
                      }
                      return function() {
                        return F;
                      };
                    }(), Te = function() {
                      var F = navigator.userAgent.indexOf("R7 Build") !== -1;
                      return function() {
                        return F;
                      };
                    }(), ke = function() {
                      var V = window.orientation == 90 || window.orientation == -90;
                      return Te() ? !V : V;
                    }, Ve = function(V) {
                      return !(isNaN(V) || V <= Z || V > W);
                    }, st = function() {
                      return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
                    }, ut = function() {
                      return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
                    }, It = function(V) {
                      if (Q())
                        return !1;
                      if (V.requestFullscreen)
                        V.requestFullscreen();
                      else if (V.webkitRequestFullscreen)
                        V.webkitRequestFullscreen();
                      else if (V.mozRequestFullScreen)
                        V.mozRequestFullScreen();
                      else if (V.msRequestFullscreen)
                        V.msRequestFullscreen();
                      else
                        return !1;
                      return !0;
                    }, ht = function() {
                      if (document.exitFullscreen)
                        document.exitFullscreen();
                      else if (document.webkitExitFullscreen)
                        document.webkitExitFullscreen();
                      else if (document.mozCancelFullScreen)
                        document.mozCancelFullScreen();
                      else if (document.msExitFullscreen)
                        document.msExitFullscreen();
                      else
                        return !1;
                      return !0;
                    }, Rt = function() {
                      return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
                    }, Qt = function(V, q, oe, me) {
                      var De = V.createShader(V.VERTEX_SHADER);
                      V.shaderSource(De, q), V.compileShader(De);
                      var Ge = V.createShader(V.FRAGMENT_SHADER);
                      V.shaderSource(Ge, oe), V.compileShader(Ge);
                      var ft = V.createProgram();
                      V.attachShader(ft, De), V.attachShader(ft, Ge);
                      for (var ct in me)
                        V.bindAttribLocation(ft, me[ct], ct);
                      return V.linkProgram(ft), V.deleteShader(De), V.deleteShader(Ge), ft;
                    }, cn = function(V, q) {
                      for (var oe = {}, me = V.getProgramParameter(q, V.ACTIVE_UNIFORMS), De = "", Ge = 0; Ge < me; Ge++) {
                        var ft = V.getActiveUniform(q, Ge);
                        De = ft.name.replace("[0]", ""), oe[De] = V.getUniformLocation(q, De);
                      }
                      return oe;
                    }, Cn = function(V, q, oe, me, De, Ge, ft) {
                      var ct = 1 / (q - oe), je = 1 / (me - De), nt = 1 / (Ge - ft);
                      return V[0] = -2 * ct, V[1] = 0, V[2] = 0, V[3] = 0, V[4] = 0, V[5] = -2 * je, V[6] = 0, V[7] = 0, V[8] = 0, V[9] = 0, V[10] = 2 * nt, V[11] = 0, V[12] = (q + oe) * ct, V[13] = (De + me) * je, V[14] = (ft + Ge) * nt, V[15] = 1, V;
                    }, Tn = function() {
                      var V = !1;
                      return function(q) {
                        (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(q) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(q.substr(0, 4))) && (V = !0);
                      }(navigator.userAgent || navigator.vendor || window.opera), V;
                    }, wn = function(V, q) {
                      for (var oe in q)
                        q.hasOwnProperty(oe) && (V[oe] = q[oe]);
                      return V;
                    }, rn = function(V) {
                      if (X()) {
                        var q = V.style.width, oe = V.style.height;
                        V.style.width = parseInt(q) + 1 + "px", V.style.height = parseInt(oe) + "px", setTimeout(function() {
                          V.style.width = q, V.style.height = oe;
                        }, 100);
                      }
                      window.canvas = V;
                    }, Bn = function() {
                      var F = Math.PI / 180, V = Math.PI * 0.25;
                      function q(je, nt, xt, Jt) {
                        var dn = Math.tan(nt ? nt.upDegrees * F : V), Mn = Math.tan(nt ? nt.downDegrees * F : V), Vn = Math.tan(nt ? nt.leftDegrees * F : V), On = Math.tan(nt ? nt.rightDegrees * F : V), In = 2 / (Vn + On), Ai = 2 / (dn + Mn);
                        return je[0] = In, je[1] = 0, je[2] = 0, je[3] = 0, je[4] = 0, je[5] = Ai, je[6] = 0, je[7] = 0, je[8] = -((Vn - On) * In * 0.5), je[9] = (dn - Mn) * Ai * 0.5, je[10] = Jt / (xt - Jt), je[11] = -1, je[12] = 0, je[13] = 0, je[14] = Jt * xt / (xt - Jt), je[15] = 0, je;
                      }
                      function oe(je, nt, xt) {
                        var Jt = nt[0], dn = nt[1], Mn = nt[2], Vn = nt[3], On = Jt + Jt, In = dn + dn, Ai = Mn + Mn, Ri = Jt * On, Wi = Jt * In, Qi = Jt * Ai, sr = dn * In, or = dn * Ai, ar = Mn * Ai, cr = Vn * On, Ji = Vn * In, xr = Vn * Ai;
                        return je[0] = 1 - (sr + ar), je[1] = Wi + xr, je[2] = Qi - Ji, je[3] = 0, je[4] = Wi - xr, je[5] = 1 - (Ri + ar), je[6] = or + cr, je[7] = 0, je[8] = Qi + Ji, je[9] = or - cr, je[10] = 1 - (Ri + sr), je[11] = 0, je[12] = xt[0], je[13] = xt[1], je[14] = xt[2], je[15] = 1, je;
                      }
                      function me(je, nt, xt) {
                        var Jt = xt[0], dn = xt[1], Mn = xt[2], Vn, On, In, Ai, Ri, Wi, Qi, sr, or, ar, cr, Ji;
                        return nt === je ? (je[12] = nt[0] * Jt + nt[4] * dn + nt[8] * Mn + nt[12], je[13] = nt[1] * Jt + nt[5] * dn + nt[9] * Mn + nt[13], je[14] = nt[2] * Jt + nt[6] * dn + nt[10] * Mn + nt[14], je[15] = nt[3] * Jt + nt[7] * dn + nt[11] * Mn + nt[15]) : (Vn = nt[0], On = nt[1], In = nt[2], Ai = nt[3], Ri = nt[4], Wi = nt[5], Qi = nt[6], sr = nt[7], or = nt[8], ar = nt[9], cr = nt[10], Ji = nt[11], je[0] = Vn, je[1] = On, je[2] = In, je[3] = Ai, je[4] = Ri, je[5] = Wi, je[6] = Qi, je[7] = sr, je[8] = or, je[9] = ar, je[10] = cr, je[11] = Ji, je[12] = Vn * Jt + Ri * dn + or * Mn + nt[12], je[13] = On * Jt + Wi * dn + ar * Mn + nt[13], je[14] = In * Jt + Qi * dn + cr * Mn + nt[14], je[15] = Ai * Jt + sr * dn + Ji * Mn + nt[15]), je;
                      }
                      function De(je, nt) {
                        var xt = nt[0], Jt = nt[1], dn = nt[2], Mn = nt[3], Vn = nt[4], On = nt[5], In = nt[6], Ai = nt[7], Ri = nt[8], Wi = nt[9], Qi = nt[10], sr = nt[11], or = nt[12], ar = nt[13], cr = nt[14], Ji = nt[15], xr = xt * On - Jt * Vn, Yr = xt * In - dn * Vn, rs = xt * Ai - Mn * Vn, us = Jt * In - dn * On, Ms = Jt * Ai - Mn * On, Ss = dn * Ai - Mn * In, Ts = Ri * ar - Wi * or, vs = Ri * cr - Qi * or, Es = Ri * Ji - sr * or, Rr = Wi * cr - Qi * ar, ys = Wi * Ji - sr * ar, Tr = Qi * Ji - sr * cr, mi = xr * Tr - Yr * ys + rs * Rr + us * Es - Ms * vs + Ss * Ts;
                        return mi ? (mi = 1 / mi, je[0] = (On * Tr - In * ys + Ai * Rr) * mi, je[1] = (dn * ys - Jt * Tr - Mn * Rr) * mi, je[2] = (ar * Ss - cr * Ms + Ji * us) * mi, je[3] = (Qi * Ms - Wi * Ss - sr * us) * mi, je[4] = (In * Es - Vn * Tr - Ai * vs) * mi, je[5] = (xt * Tr - dn * Es + Mn * vs) * mi, je[6] = (cr * rs - or * Ss - Ji * Yr) * mi, je[7] = (Ri * Ss - Qi * rs + sr * Yr) * mi, je[8] = (Vn * ys - On * Es + Ai * Ts) * mi, je[9] = (Jt * Es - xt * ys - Mn * Ts) * mi, je[10] = (or * Ms - ar * rs + Ji * xr) * mi, je[11] = (Wi * rs - Ri * Ms - sr * xr) * mi, je[12] = (On * vs - Vn * Rr - In * Ts) * mi, je[13] = (xt * Rr - Jt * vs + dn * Ts) * mi, je[14] = (ar * Yr - or * us - cr * xr) * mi, je[15] = (Ri * us - Wi * Yr + Qi * xr) * mi, je) : null;
                      }
                      var Ge = new Float32Array([0, 0, 0, 1]), ft = new Float32Array([0, 0, 0]);
                      function ct(je, nt, xt, Jt, dn, Mn) {
                        q(je, Jt || null, Mn.depthNear, Mn.depthFar);
                        var Vn = xt.orientation || Ge, On = xt.position || ft;
                        oe(nt, Vn, On), dn && me(nt, nt, dn), De(nt, nt);
                      }
                      return function(je, nt, xt) {
                        return !je || !nt ? !1 : (je.pose = nt, je.timestamp = nt.timestamp, ct(je.leftProjectionMatrix, je.leftViewMatrix, nt, xt._getFieldOfView("left"), xt._getEyeOffset("left"), xt), ct(je.rightProjectionMatrix, je.rightViewMatrix, nt, xt._getFieldOfView("right"), xt._getEyeOffset("right"), xt), !0);
                      };
                    }(), di = function() {
                      var V = window.self !== window.top, q = ri(document.referrer), oe = ri(window.location.href);
                      return V && q !== oe;
                    }, ri = function(V) {
                      var q, oe = V.indexOf("://");
                      oe !== -1 ? q = oe + 3 : q = 0;
                      var me = V.indexOf("/", q);
                      return me === -1 && (me = V.length), V.substring(0, me);
                    }, Ni = function(V) {
                      if (V.w > 1)
                        return console.warn("getQuaternionAngle: w > 1"), 0;
                      var q = 2 * Math.acos(V.w);
                      return q;
                    }, Be = /* @__PURE__ */ function() {
                      var F = {};
                      return function(V, q) {
                        F[V] === void 0 && (console.warn("webvr-polyfill: " + q), F[V] = !0);
                      };
                    }(), Et = function(V, q) {
                      var oe = q ? "Please use " + q + " instead." : "";
                      Be(V, V + " has been deprecated. This may not work on native WebVR displays. " + oe);
                    };
                    function Dt(F, V, q) {
                      if (!V) {
                        q(F);
                        return;
                      }
                      for (var oe = [], me = null, De = 0; De < V.length; ++De) {
                        var Ge = V[De];
                        switch (Ge) {
                          case F.TEXTURE_BINDING_2D:
                          case F.TEXTURE_BINDING_CUBE_MAP:
                            var ft = V[++De];
                            if (ft < F.TEXTURE0 || ft > F.TEXTURE31) {
                              console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit"), oe.push(null, null);
                              break;
                            }
                            me || (me = F.getParameter(F.ACTIVE_TEXTURE)), F.activeTexture(ft), oe.push(F.getParameter(Ge), null);
                            break;
                          case F.ACTIVE_TEXTURE:
                            me = F.getParameter(F.ACTIVE_TEXTURE), oe.push(null);
                            break;
                          default:
                            oe.push(F.getParameter(Ge));
                            break;
                        }
                      }
                      q(F);
                      for (var De = 0; De < V.length; ++De) {
                        var Ge = V[De], ct = oe[De];
                        switch (Ge) {
                          case F.ACTIVE_TEXTURE:
                            break;
                          case F.ARRAY_BUFFER_BINDING:
                            F.bindBuffer(F.ARRAY_BUFFER, ct);
                            break;
                          case F.COLOR_CLEAR_VALUE:
                            F.clearColor(ct[0], ct[1], ct[2], ct[3]);
                            break;
                          case F.COLOR_WRITEMASK:
                            F.colorMask(ct[0], ct[1], ct[2], ct[3]);
                            break;
                          case F.CURRENT_PROGRAM:
                            F.useProgram(ct);
                            break;
                          case F.ELEMENT_ARRAY_BUFFER_BINDING:
                            F.bindBuffer(F.ELEMENT_ARRAY_BUFFER, ct);
                            break;
                          case F.FRAMEBUFFER_BINDING:
                            F.bindFramebuffer(F.FRAMEBUFFER, ct);
                            break;
                          case F.RENDERBUFFER_BINDING:
                            F.bindRenderbuffer(F.RENDERBUFFER, ct);
                            break;
                          case F.TEXTURE_BINDING_2D:
                            var ft = V[++De];
                            if (ft < F.TEXTURE0 || ft > F.TEXTURE31) break;
                            F.activeTexture(ft), F.bindTexture(F.TEXTURE_2D, ct);
                            break;
                          case F.TEXTURE_BINDING_CUBE_MAP:
                            var ft = V[++De];
                            if (ft < F.TEXTURE0 || ft > F.TEXTURE31) break;
                            F.activeTexture(ft), F.bindTexture(F.TEXTURE_CUBE_MAP, ct);
                            break;
                          case F.VIEWPORT:
                            F.viewport(ct[0], ct[1], ct[2], ct[3]);
                            break;
                          case F.BLEND:
                          case F.CULL_FACE:
                          case F.DEPTH_TEST:
                          case F.SCISSOR_TEST:
                          case F.STENCIL_TEST:
                            ct ? F.enable(Ge) : F.disable(Ge);
                            break;
                          default:
                            console.log("No GL restore behavior for 0x" + Ge.toString(16));
                            break;
                        }
                        me && F.activeTexture(me);
                      }
                    }
                    var $t = Dt, ei = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join(`
`), Dn = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join(`
`);
                    function Yt(F, V, q, oe) {
                      this.gl = F, this.cardboardUI = V, this.bufferScale = q, this.dirtySubmitFrameBindings = oe, this.ctxAttribs = F.getContextAttributes(), this.instanceExt = F.getExtension("ANGLE_instanced_arrays"), this.meshWidth = 20, this.meshHeight = 20, this.bufferWidth = F.drawingBufferWidth, this.bufferHeight = F.drawingBufferHeight, this.realBindFramebuffer = F.bindFramebuffer, this.realEnable = F.enable, this.realDisable = F.disable, this.realColorMask = F.colorMask, this.realClearColor = F.clearColor, this.realViewport = F.viewport, X() || (this.realCanvasWidth = Object.getOwnPropertyDescriptor(F.canvas.__proto__, "width"), this.realCanvasHeight = Object.getOwnPropertyDescriptor(F.canvas.__proto__, "height")), this.isPatched = !1, this.lastBoundFramebuffer = null, this.cullFace = !1, this.depthTest = !1, this.blend = !1, this.scissorTest = !1, this.stencilTest = !1, this.viewport = [0, 0, 0, 0], this.colorMask = [!0, !0, !0, !0], this.clearColor = [0, 0, 0, 0], this.attribs = {
                        position: 0,
                        texCoord: 1
                      }, this.program = Qt(F, ei, Dn, this.attribs), this.uniforms = cn(F, this.program), this.viewportOffsetScale = new Float32Array(8), this.setTextureBounds(), this.vertexBuffer = F.createBuffer(), this.indexBuffer = F.createBuffer(), this.indexCount = 0, this.renderTarget = F.createTexture(), this.framebuffer = F.createFramebuffer(), this.depthStencilBuffer = null, this.depthBuffer = null, this.stencilBuffer = null, this.ctxAttribs.depth && this.ctxAttribs.stencil ? this.depthStencilBuffer = F.createRenderbuffer() : this.ctxAttribs.depth ? this.depthBuffer = F.createRenderbuffer() : this.ctxAttribs.stencil && (this.stencilBuffer = F.createRenderbuffer()), this.patch(), this.onResize();
                    }
                    Yt.prototype.destroy = function() {
                      var F = this.gl;
                      this.unpatch(), F.deleteProgram(this.program), F.deleteBuffer(this.vertexBuffer), F.deleteBuffer(this.indexBuffer), F.deleteTexture(this.renderTarget), F.deleteFramebuffer(this.framebuffer), this.depthStencilBuffer && F.deleteRenderbuffer(this.depthStencilBuffer), this.depthBuffer && F.deleteRenderbuffer(this.depthBuffer), this.stencilBuffer && F.deleteRenderbuffer(this.stencilBuffer), this.cardboardUI && this.cardboardUI.destroy();
                    }, Yt.prototype.onResize = function() {
                      var F = this.gl, V = this, q = [F.RENDERBUFFER_BINDING, F.TEXTURE_BINDING_2D, F.TEXTURE0];
                      $t(F, q, function(oe) {
                        V.realBindFramebuffer.call(oe, oe.FRAMEBUFFER, null), V.scissorTest && V.realDisable.call(oe, oe.SCISSOR_TEST), V.realColorMask.call(oe, !0, !0, !0, !0), V.realViewport.call(oe, 0, 0, oe.drawingBufferWidth, oe.drawingBufferHeight), V.realClearColor.call(oe, 0, 0, 0, 1), oe.clear(oe.COLOR_BUFFER_BIT), V.realBindFramebuffer.call(oe, oe.FRAMEBUFFER, V.framebuffer), oe.bindTexture(oe.TEXTURE_2D, V.renderTarget), oe.texImage2D(oe.TEXTURE_2D, 0, V.ctxAttribs.alpha ? oe.RGBA : oe.RGB, V.bufferWidth, V.bufferHeight, 0, V.ctxAttribs.alpha ? oe.RGBA : oe.RGB, oe.UNSIGNED_BYTE, null), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MAG_FILTER, oe.LINEAR), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MIN_FILTER, oe.LINEAR), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_WRAP_S, oe.CLAMP_TO_EDGE), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_WRAP_T, oe.CLAMP_TO_EDGE), oe.framebufferTexture2D(oe.FRAMEBUFFER, oe.COLOR_ATTACHMENT0, oe.TEXTURE_2D, V.renderTarget, 0), V.ctxAttribs.depth && V.ctxAttribs.stencil ? (oe.bindRenderbuffer(oe.RENDERBUFFER, V.depthStencilBuffer), oe.renderbufferStorage(oe.RENDERBUFFER, oe.DEPTH_STENCIL, V.bufferWidth, V.bufferHeight), oe.framebufferRenderbuffer(oe.FRAMEBUFFER, oe.DEPTH_STENCIL_ATTACHMENT, oe.RENDERBUFFER, V.depthStencilBuffer)) : V.ctxAttribs.depth ? (oe.bindRenderbuffer(oe.RENDERBUFFER, V.depthBuffer), oe.renderbufferStorage(oe.RENDERBUFFER, oe.DEPTH_COMPONENT16, V.bufferWidth, V.bufferHeight), oe.framebufferRenderbuffer(oe.FRAMEBUFFER, oe.DEPTH_ATTACHMENT, oe.RENDERBUFFER, V.depthBuffer)) : V.ctxAttribs.stencil && (oe.bindRenderbuffer(oe.RENDERBUFFER, V.stencilBuffer), oe.renderbufferStorage(oe.RENDERBUFFER, oe.STENCIL_INDEX8, V.bufferWidth, V.bufferHeight), oe.framebufferRenderbuffer(oe.FRAMEBUFFER, oe.STENCIL_ATTACHMENT, oe.RENDERBUFFER, V.stencilBuffer)), !oe.checkFramebufferStatus(oe.FRAMEBUFFER) === oe.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!"), V.realBindFramebuffer.call(oe, oe.FRAMEBUFFER, V.lastBoundFramebuffer), V.scissorTest && V.realEnable.call(oe, oe.SCISSOR_TEST), V.realColorMask.apply(oe, V.colorMask), V.realViewport.apply(oe, V.viewport), V.realClearColor.apply(oe, V.clearColor);
                      }), this.cardboardUI && this.cardboardUI.onResize();
                    }, Yt.prototype.patch = function() {
                      if (!this.isPatched) {
                        var F = this, V = this.gl.canvas, q = this.gl;
                        X() || (V.width = st() * this.bufferScale, V.height = ut() * this.bufferScale, Object.defineProperty(V, "width", {
                          configurable: !0,
                          enumerable: !0,
                          get: function() {
                            return F.bufferWidth;
                          },
                          set: function(me) {
                            F.bufferWidth = me, F.realCanvasWidth.set.call(V, me), F.onResize();
                          }
                        }), Object.defineProperty(V, "height", {
                          configurable: !0,
                          enumerable: !0,
                          get: function() {
                            return F.bufferHeight;
                          },
                          set: function(me) {
                            F.bufferHeight = me, F.realCanvasHeight.set.call(V, me), F.onResize();
                          }
                        })), this.lastBoundFramebuffer = q.getParameter(q.FRAMEBUFFER_BINDING), this.lastBoundFramebuffer == null && (this.lastBoundFramebuffer = this.framebuffer, this.gl.bindFramebuffer(q.FRAMEBUFFER, this.framebuffer)), this.gl.bindFramebuffer = function(oe, me) {
                          F.lastBoundFramebuffer = me || F.framebuffer, F.realBindFramebuffer.call(q, oe, F.lastBoundFramebuffer);
                        }, this.cullFace = q.getParameter(q.CULL_FACE), this.depthTest = q.getParameter(q.DEPTH_TEST), this.blend = q.getParameter(q.BLEND), this.scissorTest = q.getParameter(q.SCISSOR_TEST), this.stencilTest = q.getParameter(q.STENCIL_TEST), q.enable = function(oe) {
                          switch (oe) {
                            case q.CULL_FACE:
                              F.cullFace = !0;
                              break;
                            case q.DEPTH_TEST:
                              F.depthTest = !0;
                              break;
                            case q.BLEND:
                              F.blend = !0;
                              break;
                            case q.SCISSOR_TEST:
                              F.scissorTest = !0;
                              break;
                            case q.STENCIL_TEST:
                              F.stencilTest = !0;
                              break;
                          }
                          F.realEnable.call(q, oe);
                        }, q.disable = function(oe) {
                          switch (oe) {
                            case q.CULL_FACE:
                              F.cullFace = !1;
                              break;
                            case q.DEPTH_TEST:
                              F.depthTest = !1;
                              break;
                            case q.BLEND:
                              F.blend = !1;
                              break;
                            case q.SCISSOR_TEST:
                              F.scissorTest = !1;
                              break;
                            case q.STENCIL_TEST:
                              F.stencilTest = !1;
                              break;
                          }
                          F.realDisable.call(q, oe);
                        }, this.colorMask = q.getParameter(q.COLOR_WRITEMASK), q.colorMask = function(oe, me, De, Ge) {
                          F.colorMask[0] = oe, F.colorMask[1] = me, F.colorMask[2] = De, F.colorMask[3] = Ge, F.realColorMask.call(q, oe, me, De, Ge);
                        }, this.clearColor = q.getParameter(q.COLOR_CLEAR_VALUE), q.clearColor = function(oe, me, De, Ge) {
                          F.clearColor[0] = oe, F.clearColor[1] = me, F.clearColor[2] = De, F.clearColor[3] = Ge, F.realClearColor.call(q, oe, me, De, Ge);
                        }, this.viewport = q.getParameter(q.VIEWPORT), q.viewport = function(oe, me, De, Ge) {
                          F.viewport[0] = oe, F.viewport[1] = me, F.viewport[2] = De, F.viewport[3] = Ge, F.realViewport.call(q, oe, me, De, Ge);
                        }, this.isPatched = !0, rn(V);
                      }
                    }, Yt.prototype.unpatch = function() {
                      if (this.isPatched) {
                        var F = this.gl, V = this.gl.canvas;
                        X() || (Object.defineProperty(V, "width", this.realCanvasWidth), Object.defineProperty(V, "height", this.realCanvasHeight)), V.width = this.bufferWidth, V.height = this.bufferHeight, F.bindFramebuffer = this.realBindFramebuffer, F.enable = this.realEnable, F.disable = this.realDisable, F.colorMask = this.realColorMask, F.clearColor = this.realClearColor, F.viewport = this.realViewport, this.lastBoundFramebuffer == this.framebuffer && F.bindFramebuffer(F.FRAMEBUFFER, null), this.isPatched = !1, setTimeout(function() {
                          rn(V);
                        }, 1);
                      }
                    }, Yt.prototype.setTextureBounds = function(F, V) {
                      F || (F = [0, 0, 0.5, 1]), V || (V = [0.5, 0, 0.5, 1]), this.viewportOffsetScale[0] = F[0], this.viewportOffsetScale[1] = F[1], this.viewportOffsetScale[2] = F[2], this.viewportOffsetScale[3] = F[3], this.viewportOffsetScale[4] = V[0], this.viewportOffsetScale[5] = V[1], this.viewportOffsetScale[6] = V[2], this.viewportOffsetScale[7] = V[3];
                    }, Yt.prototype.submitFrame = function() {
                      var F = this.gl, V = this, q = [];
                      if (this.dirtySubmitFrameBindings || q.push(F.CURRENT_PROGRAM, F.ARRAY_BUFFER_BINDING, F.ELEMENT_ARRAY_BUFFER_BINDING, F.TEXTURE_BINDING_2D, F.TEXTURE0), $t(F, q, function(me) {
                        V.realBindFramebuffer.call(me, me.FRAMEBUFFER, null);
                        var De = 0, Ge = 0;
                        V.instanceExt && (De = me.getVertexAttrib(V.attribs.position, V.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE), Ge = me.getVertexAttrib(V.attribs.texCoord, V.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)), V.cullFace && V.realDisable.call(me, me.CULL_FACE), V.depthTest && V.realDisable.call(me, me.DEPTH_TEST), V.blend && V.realDisable.call(me, me.BLEND), V.scissorTest && V.realDisable.call(me, me.SCISSOR_TEST), V.stencilTest && V.realDisable.call(me, me.STENCIL_TEST), V.realColorMask.call(me, !0, !0, !0, !0), V.realViewport.call(me, 0, 0, me.drawingBufferWidth, me.drawingBufferHeight), (V.ctxAttribs.alpha || X()) && (V.realClearColor.call(me, 0, 0, 0, 1), me.clear(me.COLOR_BUFFER_BIT)), me.useProgram(V.program), me.bindBuffer(me.ELEMENT_ARRAY_BUFFER, V.indexBuffer), me.bindBuffer(me.ARRAY_BUFFER, V.vertexBuffer), me.enableVertexAttribArray(V.attribs.position), me.enableVertexAttribArray(V.attribs.texCoord), me.vertexAttribPointer(V.attribs.position, 2, me.FLOAT, !1, 20, 0), me.vertexAttribPointer(V.attribs.texCoord, 3, me.FLOAT, !1, 20, 8), V.instanceExt && (De != 0 && V.instanceExt.vertexAttribDivisorANGLE(V.attribs.position, 0), Ge != 0 && V.instanceExt.vertexAttribDivisorANGLE(V.attribs.texCoord, 0)), me.activeTexture(me.TEXTURE0), me.uniform1i(V.uniforms.diffuse, 0), me.bindTexture(me.TEXTURE_2D, V.renderTarget), me.uniform4fv(V.uniforms.viewportOffsetScale, V.viewportOffsetScale), me.drawElements(me.TRIANGLES, V.indexCount, me.UNSIGNED_SHORT, 0), V.cardboardUI && V.cardboardUI.renderNoState(), V.realBindFramebuffer.call(V.gl, me.FRAMEBUFFER, V.framebuffer), V.ctxAttribs.preserveDrawingBuffer || (V.realClearColor.call(me, 0, 0, 0, 0), me.clear(me.COLOR_BUFFER_BIT)), V.dirtySubmitFrameBindings || V.realBindFramebuffer.call(me, me.FRAMEBUFFER, V.lastBoundFramebuffer), V.cullFace && V.realEnable.call(me, me.CULL_FACE), V.depthTest && V.realEnable.call(me, me.DEPTH_TEST), V.blend && V.realEnable.call(me, me.BLEND), V.scissorTest && V.realEnable.call(me, me.SCISSOR_TEST), V.stencilTest && V.realEnable.call(me, me.STENCIL_TEST), V.realColorMask.apply(me, V.colorMask), V.realViewport.apply(me, V.viewport), (V.ctxAttribs.alpha || !V.ctxAttribs.preserveDrawingBuffer) && V.realClearColor.apply(me, V.clearColor), V.instanceExt && (De != 0 && V.instanceExt.vertexAttribDivisorANGLE(V.attribs.position, De), Ge != 0 && V.instanceExt.vertexAttribDivisorANGLE(V.attribs.texCoord, Ge));
                      }), X()) {
                        var oe = F.canvas;
                        (oe.width != V.bufferWidth || oe.height != V.bufferHeight) && (V.bufferWidth = oe.width, V.bufferHeight = oe.height, V.onResize());
                      }
                    }, Yt.prototype.updateDeviceInfo = function(F) {
                      var V = this.gl, q = this, oe = [V.ARRAY_BUFFER_BINDING, V.ELEMENT_ARRAY_BUFFER_BINDING];
                      $t(V, oe, function(me) {
                        var De = q.computeMeshVertices_(q.meshWidth, q.meshHeight, F);
                        if (me.bindBuffer(me.ARRAY_BUFFER, q.vertexBuffer), me.bufferData(me.ARRAY_BUFFER, De, me.STATIC_DRAW), !q.indexCount) {
                          var Ge = q.computeMeshIndices_(q.meshWidth, q.meshHeight);
                          me.bindBuffer(me.ELEMENT_ARRAY_BUFFER, q.indexBuffer), me.bufferData(me.ELEMENT_ARRAY_BUFFER, Ge, me.STATIC_DRAW), q.indexCount = Ge.length;
                        }
                      });
                    }, Yt.prototype.computeMeshVertices_ = function(F, V, q) {
                      for (var oe = new Float32Array(2 * F * V * 5), me = q.getLeftEyeVisibleTanAngles(), De = q.getLeftEyeNoLensTanAngles(), Ge = q.getLeftEyeVisibleScreenRect(De), ft = 0, ct = 0; ct < 2; ct++) {
                        for (var je = 0; je < V; je++)
                          for (var nt = 0; nt < F; nt++, ft++) {
                            var xt = nt / (F - 1), Jt = je / (V - 1), dn = xt, Mn = Jt, Vn = te(me[0], me[2], xt), On = te(me[3], me[1], Jt), In = Math.sqrt(Vn * Vn + On * On), Ai = q.distortion.distortInverse(In), Ri = Vn * Ai / In, Wi = On * Ai / In;
                            xt = (Ri - De[0]) / (De[2] - De[0]), Jt = (Wi - De[3]) / (De[1] - De[3]), xt = (Ge.x + xt * Ge.width - 0.5) * 2, Jt = (Ge.y + Jt * Ge.height - 0.5) * 2, oe[ft * 5 + 0] = xt, oe[ft * 5 + 1] = Jt, oe[ft * 5 + 2] = dn, oe[ft * 5 + 3] = Mn, oe[ft * 5 + 4] = ct;
                          }
                        var Qi = me[2] - me[0];
                        me[0] = -(Qi + me[0]), me[2] = Qi - me[2], Qi = De[2] - De[0], De[0] = -(Qi + De[0]), De[2] = Qi - De[2], Ge.x = 1 - (Ge.x + Ge.width);
                      }
                      return oe;
                    }, Yt.prototype.computeMeshIndices_ = function(F, V) {
                      for (var q = new Uint16Array(2 * (F - 1) * (V - 1) * 6), oe = F / 2, me = V / 2, De = 0, Ge = 0, ft = 0; ft < 2; ft++)
                        for (var ct = 0; ct < V; ct++)
                          for (var je = 0; je < F; je++, De++)
                            je == 0 || ct == 0 || (je <= oe == ct <= me ? (q[Ge++] = De, q[Ge++] = De - F - 1, q[Ge++] = De - F, q[Ge++] = De - F - 1, q[Ge++] = De, q[Ge++] = De - 1) : (q[Ge++] = De - 1, q[Ge++] = De - F, q[Ge++] = De, q[Ge++] = De - F, q[Ge++] = De - 1, q[Ge++] = De - F - 1));
                      return q;
                    }, Yt.prototype.getOwnPropertyDescriptor_ = function(F, V) {
                      var q = Object.getOwnPropertyDescriptor(F, V);
                      return (q.get === void 0 || q.set === void 0) && (q.configurable = !0, q.enumerable = !0, q.get = function() {
                        return this.getAttribute(V);
                      }, q.set = function(oe) {
                        this.setAttribute(V, oe);
                      }), q;
                    };
                    var Xe = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join(`
`), le = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join(`
`), ae = Math.PI / 180, Ce = 60, fe = 12, ge = 20, xe = 1, H = 0.75, M = 0.3125, R = 4, ee = 28, he = 1.5;
                    function we(F) {
                      this.gl = F, this.attribs = {
                        position: 0
                      }, this.program = Qt(F, Xe, le, this.attribs), this.uniforms = cn(F, this.program), this.vertexBuffer = F.createBuffer(), this.gearOffset = 0, this.gearVertexCount = 0, this.arrowOffset = 0, this.arrowVertexCount = 0, this.projMat = new Float32Array(16), this.listener = null, this.onResize();
                    }
                    we.prototype.destroy = function() {
                      var F = this.gl;
                      this.listener && F.canvas.removeEventListener("click", this.listener, !1), F.deleteProgram(this.program), F.deleteBuffer(this.vertexBuffer);
                    }, we.prototype.listen = function(F, V) {
                      var q = this.gl.canvas;
                      this.listener = function(oe) {
                        var me = q.clientWidth / 2, De = ee * he;
                        oe.clientX > me - De && oe.clientX < me + De && oe.clientY > q.clientHeight - De ? F(oe) : oe.clientX < De && oe.clientY < De && V(oe);
                      }, q.addEventListener("click", this.listener, !1);
                    }, we.prototype.onResize = function() {
                      var F = this.gl, V = this, q = [F.ARRAY_BUFFER_BINDING];
                      $t(F, q, function(oe) {
                        var me = [], De = oe.drawingBufferWidth / 2, Ge = Math.max(screen.width, screen.height) * window.devicePixelRatio, ft = oe.drawingBufferWidth / Ge, ct = ft * window.devicePixelRatio, je = R * ct / 2, nt = ee * he * ct, xt = ee * ct / 2, Jt = (ee * he - ee) * ct;
                        me.push(De - je, nt), me.push(De - je, oe.drawingBufferHeight), me.push(De + je, nt), me.push(De + je, oe.drawingBufferHeight), V.gearOffset = me.length / 2;
                        function dn(Ai, Ri) {
                          var Wi = (90 - Ai) * ae, Qi = Math.cos(Wi), sr = Math.sin(Wi);
                          me.push(M * Qi * xt + De, M * sr * xt + xt), me.push(Ri * Qi * xt + De, Ri * sr * xt + xt);
                        }
                        for (var Mn = 0; Mn <= 6; Mn++) {
                          var Vn = Mn * Ce;
                          dn(Vn, xe), dn(Vn + fe, xe), dn(Vn + ge, H), dn(Vn + (Ce - ge), H), dn(Vn + (Ce - fe), xe);
                        }
                        V.gearVertexCount = me.length / 2 - V.gearOffset, V.arrowOffset = me.length / 2;
                        function On(Ai, Ri) {
                          me.push(Jt + Ai, oe.drawingBufferHeight - Jt - Ri);
                        }
                        var In = je / Math.sin(45 * ae);
                        On(0, xt), On(xt, 0), On(xt + In, In), On(In, xt + In), On(In, xt - In), On(0, xt), On(xt, xt * 2), On(xt + In, xt * 2 - In), On(In, xt - In), On(0, xt), On(In, xt - je), On(ee * ct, xt - je), On(In, xt + je), On(ee * ct, xt + je), V.arrowVertexCount = me.length / 2 - V.arrowOffset, oe.bindBuffer(oe.ARRAY_BUFFER, V.vertexBuffer), oe.bufferData(oe.ARRAY_BUFFER, new Float32Array(me), oe.STATIC_DRAW);
                      });
                    }, we.prototype.render = function() {
                      var F = this.gl, V = this, q = [F.CULL_FACE, F.DEPTH_TEST, F.BLEND, F.SCISSOR_TEST, F.STENCIL_TEST, F.COLOR_WRITEMASK, F.VIEWPORT, F.CURRENT_PROGRAM, F.ARRAY_BUFFER_BINDING];
                      $t(F, q, function(oe) {
                        oe.disable(oe.CULL_FACE), oe.disable(oe.DEPTH_TEST), oe.disable(oe.BLEND), oe.disable(oe.SCISSOR_TEST), oe.disable(oe.STENCIL_TEST), oe.colorMask(!0, !0, !0, !0), oe.viewport(0, 0, oe.drawingBufferWidth, oe.drawingBufferHeight), V.renderNoState();
                      });
                    }, we.prototype.renderNoState = function() {
                      var F = this.gl;
                      F.useProgram(this.program), F.bindBuffer(F.ARRAY_BUFFER, this.vertexBuffer), F.enableVertexAttribArray(this.attribs.position), F.vertexAttribPointer(this.attribs.position, 2, F.FLOAT, !1, 8, 0), F.uniform4f(this.uniforms.color, 1, 1, 1, 1), Cn(this.projMat, 0, F.drawingBufferWidth, 0, F.drawingBufferHeight, 0.1, 1024), F.uniformMatrix4fv(this.uniforms.projectionMat, !1, this.projMat), F.drawArrays(F.TRIANGLE_STRIP, 0, 4), F.drawArrays(F.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount), F.drawArrays(F.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
                    };
                    function Oe(F) {
                      this.coefficients = F;
                    }
                    Oe.prototype.distortInverse = function(F) {
                      for (var V = 0, q = 1, oe = F - this.distort(V); Math.abs(q - V) > 1e-4; ) {
                        var me = F - this.distort(q), De = q - me * ((q - V) / (me - oe));
                        V = q, q = De, oe = me;
                      }
                      return q;
                    }, Oe.prototype.distort = function(F) {
                      for (var V = F * F, q = 0, oe = 0; oe < this.coefficients.length; oe++)
                        q = V * (q + this.coefficients[oe]);
                      return (q + 1) * F;
                    };
                    var Ct = Math.PI / 180, Pt = 180 / Math.PI, _t = function(V, q, oe) {
                      this.x = V || 0, this.y = q || 0, this.z = oe || 0;
                    };
                    _t.prototype = {
                      constructor: _t,
                      set: function(V, q, oe) {
                        return this.x = V, this.y = q, this.z = oe, this;
                      },
                      copy: function(V) {
                        return this.x = V.x, this.y = V.y, this.z = V.z, this;
                      },
                      length: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                      },
                      normalize: function() {
                        var V = this.length();
                        if (V !== 0) {
                          var q = 1 / V;
                          this.multiplyScalar(q);
                        } else
                          this.x = 0, this.y = 0, this.z = 0;
                        return this;
                      },
                      multiplyScalar: function(V) {
                        this.x *= V, this.y *= V, this.z *= V;
                      },
                      applyQuaternion: function(V) {
                        var q = this.x, oe = this.y, me = this.z, De = V.x, Ge = V.y, ft = V.z, ct = V.w, je = ct * q + Ge * me - ft * oe, nt = ct * oe + ft * q - De * me, xt = ct * me + De * oe - Ge * q, Jt = -De * q - Ge * oe - ft * me;
                        return this.x = je * ct + Jt * -De + nt * -ft - xt * -Ge, this.y = nt * ct + Jt * -Ge + xt * -De - je * -ft, this.z = xt * ct + Jt * -ft + je * -Ge - nt * -De, this;
                      },
                      dot: function(V) {
                        return this.x * V.x + this.y * V.y + this.z * V.z;
                      },
                      crossVectors: function(V, q) {
                        var oe = V.x, me = V.y, De = V.z, Ge = q.x, ft = q.y, ct = q.z;
                        return this.x = me * ct - De * ft, this.y = De * Ge - oe * ct, this.z = oe * ft - me * Ge, this;
                      }
                    };
                    var St = function(V, q, oe, me) {
                      this.x = V || 0, this.y = q || 0, this.z = oe || 0, this.w = me !== void 0 ? me : 1;
                    };
                    St.prototype = {
                      constructor: St,
                      set: function(V, q, oe, me) {
                        return this.x = V, this.y = q, this.z = oe, this.w = me, this;
                      },
                      copy: function(V) {
                        return this.x = V.x, this.y = V.y, this.z = V.z, this.w = V.w, this;
                      },
                      setFromEulerXYZ: function(V, q, oe) {
                        var me = Math.cos(V / 2), De = Math.cos(q / 2), Ge = Math.cos(oe / 2), ft = Math.sin(V / 2), ct = Math.sin(q / 2), je = Math.sin(oe / 2);
                        return this.x = ft * De * Ge + me * ct * je, this.y = me * ct * Ge - ft * De * je, this.z = me * De * je + ft * ct * Ge, this.w = me * De * Ge - ft * ct * je, this;
                      },
                      setFromEulerYXZ: function(V, q, oe) {
                        var me = Math.cos(V / 2), De = Math.cos(q / 2), Ge = Math.cos(oe / 2), ft = Math.sin(V / 2), ct = Math.sin(q / 2), je = Math.sin(oe / 2);
                        return this.x = ft * De * Ge + me * ct * je, this.y = me * ct * Ge - ft * De * je, this.z = me * De * je - ft * ct * Ge, this.w = me * De * Ge + ft * ct * je, this;
                      },
                      setFromAxisAngle: function(V, q) {
                        var oe = q / 2, me = Math.sin(oe);
                        return this.x = V.x * me, this.y = V.y * me, this.z = V.z * me, this.w = Math.cos(oe), this;
                      },
                      multiply: function(V) {
                        return this.multiplyQuaternions(this, V);
                      },
                      multiplyQuaternions: function(V, q) {
                        var oe = V.x, me = V.y, De = V.z, Ge = V.w, ft = q.x, ct = q.y, je = q.z, nt = q.w;
                        return this.x = oe * nt + Ge * ft + me * je - De * ct, this.y = me * nt + Ge * ct + De * ft - oe * je, this.z = De * nt + Ge * je + oe * ct - me * ft, this.w = Ge * nt - oe * ft - me * ct - De * je, this;
                      },
                      inverse: function() {
                        return this.x *= -1, this.y *= -1, this.z *= -1, this.normalize(), this;
                      },
                      normalize: function() {
                        var V = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                        return V === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (V = 1 / V, this.x = this.x * V, this.y = this.y * V, this.z = this.z * V, this.w = this.w * V), this;
                      },
                      slerp: function(V, q) {
                        if (q === 0) return this;
                        if (q === 1) return this.copy(V);
                        var oe = this.x, me = this.y, De = this.z, Ge = this.w, ft = Ge * V.w + oe * V.x + me * V.y + De * V.z;
                        if (ft < 0 ? (this.w = -V.w, this.x = -V.x, this.y = -V.y, this.z = -V.z, ft = -ft) : this.copy(V), ft >= 1)
                          return this.w = Ge, this.x = oe, this.y = me, this.z = De, this;
                        var ct = Math.acos(ft), je = Math.sqrt(1 - ft * ft);
                        if (Math.abs(je) < 1e-3)
                          return this.w = 0.5 * (Ge + this.w), this.x = 0.5 * (oe + this.x), this.y = 0.5 * (me + this.y), this.z = 0.5 * (De + this.z), this;
                        var nt = Math.sin((1 - q) * ct) / je, xt = Math.sin(q * ct) / je;
                        return this.w = Ge * nt + this.w * xt, this.x = oe * nt + this.x * xt, this.y = me * nt + this.y * xt, this.z = De * nt + this.z * xt, this;
                      },
                      setFromUnitVectors: /* @__PURE__ */ function() {
                        var F, V, q = 1e-6;
                        return function(oe, me) {
                          return F === void 0 && (F = new _t()), V = oe.dot(me) + 1, V < q ? (V = 0, Math.abs(oe.x) > Math.abs(oe.z) ? F.set(-oe.y, oe.x, 0) : F.set(0, -oe.z, oe.y)) : F.crossVectors(oe, me), this.x = F.x, this.y = F.y, this.z = F.z, this.w = V, this.normalize(), this;
                        };
                      }()
                    };
                    function qt(F) {
                      this.width = F.width || st(), this.height = F.height || ut(), this.widthMeters = F.widthMeters, this.heightMeters = F.heightMeters, this.bevelMeters = F.bevelMeters;
                    }
                    var ki = new qt({
                      widthMeters: 0.11,
                      heightMeters: 0.062,
                      bevelMeters: 4e-3
                    }), vn = new qt({
                      widthMeters: 0.1038,
                      heightMeters: 0.0584,
                      bevelMeters: 4e-3
                    }), Oi = {
                      CardboardV1: new Ei({
                        id: "CardboardV1",
                        label: "Cardboard I/O 2014",
                        fov: 40,
                        interLensDistance: 0.06,
                        baselineLensDistance: 0.035,
                        screenLensDistance: 0.042,
                        distortionCoefficients: [0.441, 0.156],
                        inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
                      }),
                      CardboardV2: new Ei({
                        id: "CardboardV2",
                        label: "Cardboard I/O 2015",
                        fov: 60,
                        interLensDistance: 0.064,
                        baselineLensDistance: 0.035,
                        screenLensDistance: 0.039,
                        distortionCoefficients: [0.34, 0.55],
                        inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
                      })
                    };
                    function ui(F, V) {
                      this.viewer = Oi.CardboardV2, this.updateDeviceParams(F), this.distortion = new Oe(this.viewer.distortionCoefficients);
                      for (var q = 0; q < V.length; q++) {
                        var oe = V[q];
                        Oi[oe.id] = new Ei(oe);
                      }
                    }
                    ui.prototype.updateDeviceParams = function(F) {
                      this.device = this.determineDevice_(F) || this.device;
                    }, ui.prototype.getDevice = function() {
                      return this.device;
                    }, ui.prototype.setViewer = function(F) {
                      this.viewer = F, this.distortion = new Oe(this.viewer.distortionCoefficients);
                    }, ui.prototype.determineDevice_ = function(F) {
                      if (!F)
                        return X() ? (console.warn("Using fallback iOS device measurements."), vn) : (console.warn("Using fallback Android device measurements."), ki);
                      var V = 0.0254, q = V / F.xdpi, oe = V / F.ydpi, me = st(), De = ut();
                      return new qt({
                        widthMeters: q * me,
                        heightMeters: oe * De,
                        bevelMeters: F.bevelMm * 1e-3
                      });
                    }, ui.prototype.getDistortedFieldOfViewLeftEye = function() {
                      var F = this.viewer, V = this.device, q = this.distortion, oe = F.screenLensDistance, me = (V.widthMeters - F.interLensDistance) / 2, De = F.interLensDistance / 2, Ge = F.baselineLensDistance - V.bevelMeters, ft = V.heightMeters - Ge, ct = Pt * Math.atan(q.distort(me / oe)), je = Pt * Math.atan(q.distort(De / oe)), nt = Pt * Math.atan(q.distort(Ge / oe)), xt = Pt * Math.atan(q.distort(ft / oe));
                      return {
                        leftDegrees: Math.min(ct, F.fov),
                        rightDegrees: Math.min(je, F.fov),
                        downDegrees: Math.min(nt, F.fov),
                        upDegrees: Math.min(xt, F.fov)
                      };
                    }, ui.prototype.getLeftEyeVisibleTanAngles = function() {
                      var F = this.viewer, V = this.device, q = this.distortion, oe = Math.tan(-Ct * F.fov), me = Math.tan(Ct * F.fov), De = Math.tan(Ct * F.fov), Ge = Math.tan(-Ct * F.fov), ft = V.widthMeters / 4, ct = V.heightMeters / 2, je = F.baselineLensDistance - V.bevelMeters - ct, nt = F.interLensDistance / 2 - ft, xt = -je, Jt = F.screenLensDistance, dn = q.distort((nt - ft) / Jt), Mn = q.distort((xt + ct) / Jt), Vn = q.distort((nt + ft) / Jt), On = q.distort((xt - ct) / Jt), In = new Float32Array(4);
                      return In[0] = Math.max(oe, dn), In[1] = Math.min(me, Mn), In[2] = Math.min(De, Vn), In[3] = Math.max(Ge, On), In;
                    }, ui.prototype.getLeftEyeNoLensTanAngles = function() {
                      var F = this.viewer, V = this.device, q = this.distortion, oe = new Float32Array(4), me = q.distortInverse(Math.tan(-Ct * F.fov)), De = q.distortInverse(Math.tan(Ct * F.fov)), Ge = q.distortInverse(Math.tan(Ct * F.fov)), ft = q.distortInverse(Math.tan(-Ct * F.fov)), ct = V.widthMeters / 4, je = V.heightMeters / 2, nt = F.baselineLensDistance - V.bevelMeters - je, xt = F.interLensDistance / 2 - ct, Jt = -nt, dn = F.screenLensDistance, Mn = (xt - ct) / dn, Vn = (Jt + je) / dn, On = (xt + ct) / dn, In = (Jt - je) / dn;
                      return oe[0] = Math.max(me, Mn), oe[1] = Math.min(De, Vn), oe[2] = Math.min(Ge, On), oe[3] = Math.max(ft, In), oe;
                    }, ui.prototype.getLeftEyeVisibleScreenRect = function(F) {
                      var V = this.viewer, q = this.device, oe = V.screenLensDistance, me = (q.widthMeters - V.interLensDistance) / 2, De = V.baselineLensDistance - q.bevelMeters, Ge = (F[0] * oe + me) / q.widthMeters, ft = (F[1] * oe + De) / q.heightMeters, ct = (F[2] * oe + me) / q.widthMeters, je = (F[3] * oe + De) / q.heightMeters;
                      return {
                        x: Ge,
                        y: je,
                        width: ct - Ge,
                        height: ft - je
                      };
                    }, ui.prototype.getFieldOfViewLeftEye = function(F) {
                      return F ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
                    }, ui.prototype.getFieldOfViewRightEye = function(F) {
                      var V = this.getFieldOfViewLeftEye(F);
                      return {
                        leftDegrees: V.rightDegrees,
                        rightDegrees: V.leftDegrees,
                        upDegrees: V.upDegrees,
                        downDegrees: V.downDegrees
                      };
                    }, ui.prototype.getUndistortedFieldOfViewLeftEye = function() {
                      var F = this.getUndistortedParams_();
                      return {
                        leftDegrees: Pt * Math.atan(F.outerDist),
                        rightDegrees: Pt * Math.atan(F.innerDist),
                        downDegrees: Pt * Math.atan(F.bottomDist),
                        upDegrees: Pt * Math.atan(F.topDist)
                      };
                    }, ui.prototype.getUndistortedViewportLeftEye = function() {
                      var F = this.getUndistortedParams_(), V = this.viewer, q = this.device, oe = V.screenLensDistance, me = q.widthMeters / oe, De = q.heightMeters / oe, Ge = q.width / me, ft = q.height / De, ct = Math.round((F.eyePosX - F.outerDist) * Ge), je = Math.round((F.eyePosY - F.bottomDist) * ft);
                      return {
                        x: ct,
                        y: je,
                        width: Math.round((F.eyePosX + F.innerDist) * Ge) - ct,
                        height: Math.round((F.eyePosY + F.topDist) * ft) - je
                      };
                    }, ui.prototype.getUndistortedParams_ = function() {
                      var F = this.viewer, V = this.device, q = this.distortion, oe = F.screenLensDistance, me = F.interLensDistance / 2 / oe, De = V.widthMeters / oe, Ge = V.heightMeters / oe, ft = De / 2 - me, ct = (F.baselineLensDistance - V.bevelMeters) / oe, je = F.fov, nt = q.distortInverse(Math.tan(Ct * je)), xt = Math.min(ft, nt), Jt = Math.min(me, nt), dn = Math.min(ct, nt), Mn = Math.min(Ge - ct, nt);
                      return {
                        outerDist: xt,
                        innerDist: Jt,
                        topDist: Mn,
                        bottomDist: dn,
                        eyePosX: ft,
                        eyePosY: ct
                      };
                    };
                    function Ei(F) {
                      this.id = F.id, this.label = F.label, this.fov = F.fov, this.interLensDistance = F.interLensDistance, this.baselineLensDistance = F.baselineLensDistance, this.screenLensDistance = F.screenLensDistance, this.distortionCoefficients = F.distortionCoefficients, this.inverseCoefficients = F.inverseCoefficients;
                    }
                    ui.Viewers = Oi;
                    var fr = 1, Ii = "2019-11-09T17:36:14Z", Sr = [{
                      type: "android",
                      rules: [{
                        mdmh: "asus/*/Nexus 7/*"
                      }, {
                        ua: "Nexus 7"
                      }],
                      dpi: [320.8, 323],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "asus/*/ASUS_X00PD/*"
                      }, {
                        ua: "ASUS_X00PD"
                      }],
                      dpi: 245,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "asus/*/ASUS_X008D/*"
                      }, {
                        ua: "ASUS_X008D"
                      }],
                      dpi: 282,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "asus/*/ASUS_Z00AD/*"
                      }, {
                        ua: "ASUS_Z00AD"
                      }],
                      dpi: [403, 404.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Google/*/Pixel 2 XL/*"
                      }, {
                        ua: "Pixel 2 XL"
                      }],
                      dpi: 537.9,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Google/*/Pixel 3 XL/*"
                      }, {
                        ua: "Pixel 3 XL"
                      }],
                      dpi: [558.5, 553.8],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Google/*/Pixel XL/*"
                      }, {
                        ua: "Pixel XL"
                      }],
                      dpi: [537.9, 533],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Google/*/Pixel 3/*"
                      }, {
                        ua: "Pixel 3"
                      }],
                      dpi: 442.4,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Google/*/Pixel 2/*"
                      }, {
                        ua: "Pixel 2"
                      }],
                      dpi: 441,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Google/*/Pixel/*"
                      }, {
                        ua: "Pixel"
                      }],
                      dpi: [432.6, 436.7],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "HTC/*/HTC6435LVW/*"
                      }, {
                        ua: "HTC6435LVW"
                      }],
                      dpi: [449.7, 443.3],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "HTC/*/HTC One XL/*"
                      }, {
                        ua: "HTC One XL"
                      }],
                      dpi: [315.3, 314.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "htc/*/Nexus 9/*"
                      }, {
                        ua: "Nexus 9"
                      }],
                      dpi: 289,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "HTC/*/HTC One M9/*"
                      }, {
                        ua: "HTC One M9"
                      }],
                      dpi: [442.5, 443.3],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "HTC/*/HTC One_M8/*"
                      }, {
                        ua: "HTC One_M8"
                      }],
                      dpi: [449.7, 447.4],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "HTC/*/HTC One/*"
                      }, {
                        ua: "HTC One"
                      }],
                      dpi: 472.8,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Huawei/*/Nexus 6P/*"
                      }, {
                        ua: "Nexus 6P"
                      }],
                      dpi: [515.1, 518],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Huawei/*/BLN-L24/*"
                      }, {
                        ua: "HONORBLN-L24"
                      }],
                      dpi: 480,
                      bw: 4,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Huawei/*/BKL-L09/*"
                      }, {
                        ua: "BKL-L09"
                      }],
                      dpi: 403,
                      bw: 3.47,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LENOVO/*/Lenovo PB2-690Y/*"
                      }, {
                        ua: "Lenovo PB2-690Y"
                      }],
                      dpi: [457.2, 454.713],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/Nexus 5X/*"
                      }, {
                        ua: "Nexus 5X"
                      }],
                      dpi: [422, 419.9],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/LGMS345/*"
                      }, {
                        ua: "LGMS345"
                      }],
                      dpi: [221.7, 219.1],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/LG-D800/*"
                      }, {
                        ua: "LG-D800"
                      }],
                      dpi: [422, 424.1],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/LG-D850/*"
                      }, {
                        ua: "LG-D850"
                      }],
                      dpi: [537.9, 541.9],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/VS985 4G/*"
                      }, {
                        ua: "VS985 4G"
                      }],
                      dpi: [537.9, 535.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/Nexus 5/*"
                      }, {
                        ua: "Nexus 5 B"
                      }],
                      dpi: [442.4, 444.8],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/Nexus 4/*"
                      }, {
                        ua: "Nexus 4"
                      }],
                      dpi: [319.8, 318.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/LG-P769/*"
                      }, {
                        ua: "LG-P769"
                      }],
                      dpi: [240.6, 247.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/LGMS323/*"
                      }, {
                        ua: "LGMS323"
                      }],
                      dpi: [206.6, 204.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "LGE/*/LGLS996/*"
                      }, {
                        ua: "LGLS996"
                      }],
                      dpi: [403.4, 401.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Micromax/*/4560MMX/*"
                      }, {
                        ua: "4560MMX"
                      }],
                      dpi: [240, 219.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Micromax/*/A250/*"
                      }, {
                        ua: "Micromax A250"
                      }],
                      dpi: [480, 446.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Micromax/*/Micromax AQ4501/*"
                      }, {
                        ua: "Micromax AQ4501"
                      }],
                      dpi: 240,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/G5/*"
                      }, {
                        ua: "Moto G (5) Plus"
                      }],
                      dpi: [403.4, 403],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/DROID RAZR/*"
                      }, {
                        ua: "DROID RAZR"
                      }],
                      dpi: [368.1, 256.7],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT830C/*"
                      }, {
                        ua: "XT830C"
                      }],
                      dpi: [254, 255.9],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1021/*"
                      }, {
                        ua: "XT1021"
                      }],
                      dpi: [254, 256.7],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1023/*"
                      }, {
                        ua: "XT1023"
                      }],
                      dpi: [254, 256.7],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1028/*"
                      }, {
                        ua: "XT1028"
                      }],
                      dpi: [326.6, 327.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1034/*"
                      }, {
                        ua: "XT1034"
                      }],
                      dpi: [326.6, 328.4],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1053/*"
                      }, {
                        ua: "XT1053"
                      }],
                      dpi: [315.3, 316.1],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1562/*"
                      }, {
                        ua: "XT1562"
                      }],
                      dpi: [403.4, 402.7],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/Nexus 6/*"
                      }, {
                        ua: "Nexus 6 B"
                      }],
                      dpi: [494.3, 489.7],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1063/*"
                      }, {
                        ua: "XT1063"
                      }],
                      dpi: [295, 296.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1064/*"
                      }, {
                        ua: "XT1064"
                      }],
                      dpi: [295, 295.6],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1092/*"
                      }, {
                        ua: "XT1092"
                      }],
                      dpi: [422, 424.1],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/XT1095/*"
                      }, {
                        ua: "XT1095"
                      }],
                      dpi: [422, 423.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "motorola/*/G4/*"
                      }, {
                        ua: "Moto G (4)"
                      }],
                      dpi: 401,
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/A0001/*"
                      }, {
                        ua: "A0001"
                      }],
                      dpi: [403.4, 401],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONE E1001/*"
                      }, {
                        ua: "ONE E1001"
                      }],
                      dpi: [442.4, 441.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONE E1003/*"
                      }, {
                        ua: "ONE E1003"
                      }],
                      dpi: [442.4, 441.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONE E1005/*"
                      }, {
                        ua: "ONE E1005"
                      }],
                      dpi: [442.4, 441.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONE A2001/*"
                      }, {
                        ua: "ONE A2001"
                      }],
                      dpi: [391.9, 405.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONE A2003/*"
                      }, {
                        ua: "ONE A2003"
                      }],
                      dpi: [391.9, 405.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONE A2005/*"
                      }, {
                        ua: "ONE A2005"
                      }],
                      dpi: [391.9, 405.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A3000/*"
                      }, {
                        ua: "ONEPLUS A3000"
                      }],
                      dpi: 401,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A3003/*"
                      }, {
                        ua: "ONEPLUS A3003"
                      }],
                      dpi: 401,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A3010/*"
                      }, {
                        ua: "ONEPLUS A3010"
                      }],
                      dpi: 401,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A5000/*"
                      }, {
                        ua: "ONEPLUS A5000 "
                      }],
                      dpi: [403.411, 399.737],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONE A5010/*"
                      }, {
                        ua: "ONEPLUS A5010"
                      }],
                      dpi: [403, 400],
                      bw: 2,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A6000/*"
                      }, {
                        ua: "ONEPLUS A6000"
                      }],
                      dpi: 401,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A6003/*"
                      }, {
                        ua: "ONEPLUS A6003"
                      }],
                      dpi: 401,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A6010/*"
                      }, {
                        ua: "ONEPLUS A6010"
                      }],
                      dpi: 401,
                      bw: 2,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OnePlus/*/ONEPLUS A6013/*"
                      }, {
                        ua: "ONEPLUS A6013"
                      }],
                      dpi: 401,
                      bw: 2,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "OPPO/*/X909/*"
                      }, {
                        ua: "X909"
                      }],
                      dpi: [442.4, 444.1],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-I9082/*"
                      }, {
                        ua: "GT-I9082"
                      }],
                      dpi: [184.7, 185.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G360P/*"
                      }, {
                        ua: "SM-G360P"
                      }],
                      dpi: [196.7, 205.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/Nexus S/*"
                      }, {
                        ua: "Nexus S"
                      }],
                      dpi: [234.5, 229.8],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-I9300/*"
                      }, {
                        ua: "GT-I9300"
                      }],
                      dpi: [304.8, 303.9],
                      bw: 5,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-T230NU/*"
                      }, {
                        ua: "SM-T230NU"
                      }],
                      dpi: 216,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SGH-T399/*"
                      }, {
                        ua: "SGH-T399"
                      }],
                      dpi: [217.7, 231.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SGH-M919/*"
                      }, {
                        ua: "SGH-M919"
                      }],
                      dpi: [440.8, 437.7],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-N9005/*"
                      }, {
                        ua: "SM-N9005"
                      }],
                      dpi: [386.4, 387],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SAMSUNG-SM-N900A/*"
                      }, {
                        ua: "SAMSUNG-SM-N900A"
                      }],
                      dpi: [386.4, 387.7],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-I9500/*"
                      }, {
                        ua: "GT-I9500"
                      }],
                      dpi: [442.5, 443.3],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-I9505/*"
                      }, {
                        ua: "GT-I9505"
                      }],
                      dpi: 439.4,
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G900F/*"
                      }, {
                        ua: "SM-G900F"
                      }],
                      dpi: [415.6, 431.6],
                      bw: 5,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G900M/*"
                      }, {
                        ua: "SM-G900M"
                      }],
                      dpi: [415.6, 431.6],
                      bw: 5,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G800F/*"
                      }, {
                        ua: "SM-G800F"
                      }],
                      dpi: 326.8,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G906S/*"
                      }, {
                        ua: "SM-G906S"
                      }],
                      dpi: [562.7, 572.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-I9300/*"
                      }, {
                        ua: "GT-I9300"
                      }],
                      dpi: [306.7, 304.8],
                      bw: 5,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-T535/*"
                      }, {
                        ua: "SM-T535"
                      }],
                      dpi: [142.6, 136.4],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-N920C/*"
                      }, {
                        ua: "SM-N920C"
                      }],
                      dpi: [515.1, 518.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-N920P/*"
                      }, {
                        ua: "SM-N920P"
                      }],
                      dpi: [386.3655, 390.144],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-N920W8/*"
                      }, {
                        ua: "SM-N920W8"
                      }],
                      dpi: [515.1, 518.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-I9300I/*"
                      }, {
                        ua: "GT-I9300I"
                      }],
                      dpi: [304.8, 305.8],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-I9195/*"
                      }, {
                        ua: "GT-I9195"
                      }],
                      dpi: [249.4, 256.7],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SPH-L520/*"
                      }, {
                        ua: "SPH-L520"
                      }],
                      dpi: [249.4, 255.9],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SAMSUNG-SGH-I717/*"
                      }, {
                        ua: "SAMSUNG-SGH-I717"
                      }],
                      dpi: 285.8,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SPH-D710/*"
                      }, {
                        ua: "SPH-D710"
                      }],
                      dpi: [217.7, 204.2],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/GT-N7100/*"
                      }, {
                        ua: "GT-N7100"
                      }],
                      dpi: 265.1,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SCH-I605/*"
                      }, {
                        ua: "SCH-I605"
                      }],
                      dpi: 265.1,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/Galaxy Nexus/*"
                      }, {
                        ua: "Galaxy Nexus"
                      }],
                      dpi: [315.3, 314.2],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-N910H/*"
                      }, {
                        ua: "SM-N910H"
                      }],
                      dpi: [515.1, 518],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-N910C/*"
                      }, {
                        ua: "SM-N910C"
                      }],
                      dpi: [515.2, 520.2],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G130M/*"
                      }, {
                        ua: "SM-G130M"
                      }],
                      dpi: [165.9, 164.8],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G928I/*"
                      }, {
                        ua: "SM-G928I"
                      }],
                      dpi: [515.1, 518.4],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G920F/*"
                      }, {
                        ua: "SM-G920F"
                      }],
                      dpi: 580.6,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G920P/*"
                      }, {
                        ua: "SM-G920P"
                      }],
                      dpi: [522.5, 577],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G925F/*"
                      }, {
                        ua: "SM-G925F"
                      }],
                      dpi: 580.6,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G925V/*"
                      }, {
                        ua: "SM-G925V"
                      }],
                      dpi: [522.5, 576.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G930F/*"
                      }, {
                        ua: "SM-G930F"
                      }],
                      dpi: 576.6,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G935F/*"
                      }, {
                        ua: "SM-G935F"
                      }],
                      dpi: 533,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G950F/*"
                      }, {
                        ua: "SM-G950F"
                      }],
                      dpi: [562.707, 565.293],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G955U/*"
                      }, {
                        ua: "SM-G955U"
                      }],
                      dpi: [522.514, 525.762],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G955F/*"
                      }, {
                        ua: "SM-G955F"
                      }],
                      dpi: [522.514, 525.762],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G960F/*"
                      }, {
                        ua: "SM-G960F"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G9600/*"
                      }, {
                        ua: "SM-G9600"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G960T/*"
                      }, {
                        ua: "SM-G960T"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G960N/*"
                      }, {
                        ua: "SM-G960N"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G960U/*"
                      }, {
                        ua: "SM-G960U"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G9608/*"
                      }, {
                        ua: "SM-G9608"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G960FD/*"
                      }, {
                        ua: "SM-G960FD"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G960W/*"
                      }, {
                        ua: "SM-G960W"
                      }],
                      dpi: [569.575, 571.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G965F/*"
                      }, {
                        ua: "SM-G965F"
                      }],
                      dpi: 529,
                      bw: 2,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Sony/*/C6903/*"
                      }, {
                        ua: "C6903"
                      }],
                      dpi: [442.5, 443.3],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Sony/*/D6653/*"
                      }, {
                        ua: "D6653"
                      }],
                      dpi: [428.6, 427.6],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Sony/*/E6653/*"
                      }, {
                        ua: "E6653"
                      }],
                      dpi: [428.6, 425.7],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Sony/*/E6853/*"
                      }, {
                        ua: "E6853"
                      }],
                      dpi: [403.4, 401.9],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Sony/*/SGP321/*"
                      }, {
                        ua: "SGP321"
                      }],
                      dpi: [224.7, 224.1],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*"
                      }, {
                        ua: "ALCATEL ONE TOUCH Fierce"
                      }],
                      dpi: [240, 247.5],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "THL/*/thl 5000/*"
                      }, {
                        ua: "thl 5000"
                      }],
                      dpi: [480, 443.3],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Fly/*/IQ4412/*"
                      }, {
                        ua: "IQ4412"
                      }],
                      dpi: 307.9,
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "ZTE/*/ZTE Blade L2/*"
                      }, {
                        ua: "ZTE Blade L2"
                      }],
                      dpi: 240,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "BENEVE/*/VR518/*"
                      }, {
                        ua: "VR518"
                      }],
                      dpi: 480,
                      bw: 3,
                      ac: 500
                    }, {
                      type: "ios",
                      rules: [{
                        res: [640, 960]
                      }],
                      dpi: [325.1, 328.4],
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "ios",
                      rules: [{
                        res: [640, 1136]
                      }],
                      dpi: [317.1, 320.2],
                      bw: 3,
                      ac: 1e3
                    }, {
                      type: "ios",
                      rules: [{
                        res: [750, 1334]
                      }],
                      dpi: 326.4,
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "ios",
                      rules: [{
                        res: [1242, 2208]
                      }],
                      dpi: [453.6, 458.4],
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "ios",
                      rules: [{
                        res: [1125, 2001]
                      }],
                      dpi: [410.9, 415.4],
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "ios",
                      rules: [{
                        res: [1125, 2436]
                      }],
                      dpi: 458,
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Huawei/*/EML-L29/*"
                      }, {
                        ua: "EML-L29"
                      }],
                      dpi: 428,
                      bw: 3.45,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "Nokia/*/Nokia 7.1/*"
                      }, {
                        ua: "Nokia 7.1"
                      }],
                      dpi: [432, 431.9],
                      bw: 3,
                      ac: 500
                    }, {
                      type: "ios",
                      rules: [{
                        res: [1242, 2688]
                      }],
                      dpi: 458,
                      bw: 4,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G570M/*"
                      }, {
                        ua: "SM-G570M"
                      }],
                      dpi: 320,
                      bw: 3.684,
                      ac: 1e3
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G970F/*"
                      }, {
                        ua: "SM-G970F"
                      }],
                      dpi: 438,
                      bw: 2.281,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G973F/*"
                      }, {
                        ua: "SM-G973F"
                      }],
                      dpi: 550,
                      bw: 2.002,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G975F/*"
                      }, {
                        ua: "SM-G975F"
                      }],
                      dpi: 522,
                      bw: 2.054,
                      ac: 500
                    }, {
                      type: "android",
                      rules: [{
                        mdmh: "samsung/*/SM-G977F/*"
                      }, {
                        ua: "SM-G977F"
                      }],
                      dpi: 505,
                      bw: 2.334,
                      ac: 500
                    }, {
                      type: "ios",
                      rules: [{
                        res: [828, 1792]
                      }],
                      dpi: 326,
                      bw: 5,
                      ac: 500
                    }], ji = {
                      format: fr,
                      last_updated: Ii,
                      devices: Sr
                    };
                    function Cr(F, V) {
                      if (this.dpdb = ji, this.recalculateDeviceParams_(), F) {
                        this.onDeviceParamsUpdated = V;
                        var q = new XMLHttpRequest(), oe = this;
                        q.open("GET", F, !0), q.addEventListener("load", function() {
                          oe.loading = !1, q.status >= 200 && q.status <= 299 ? (oe.dpdb = JSON.parse(q.response), oe.recalculateDeviceParams_()) : console.error("Error loading online DPDB!");
                        }), q.send();
                      }
                    }
                    Cr.prototype.getDeviceParams = function() {
                      return this.deviceParams;
                    }, Cr.prototype.recalculateDeviceParams_ = function() {
                      var F = this.calcDeviceParams_();
                      F ? (this.deviceParams = F, this.onDeviceParamsUpdated && this.onDeviceParamsUpdated(this.deviceParams)) : console.error("Failed to recalculate device parameters.");
                    }, Cr.prototype.calcDeviceParams_ = function() {
                      var F = this.dpdb;
                      if (!F)
                        return console.error("DPDB not available."), null;
                      if (F.format != 1)
                        return console.error("DPDB has unexpected format version."), null;
                      if (!F.devices || !F.devices.length)
                        return console.error("DPDB does not have a devices section."), null;
                      var V = navigator.userAgent || navigator.vendor || window.opera, q = st(), oe = ut();
                      if (!F.devices)
                        return console.error("DPDB has no devices section."), null;
                      for (var me = 0; me < F.devices.length; me++) {
                        var De = F.devices[me];
                        if (!De.rules) {
                          console.warn("Device[" + me + "] has no rules section.");
                          continue;
                        }
                        if (De.type != "ios" && De.type != "android") {
                          console.warn("Device[" + me + "] has invalid type.");
                          continue;
                        }
                        if (X() == (De.type == "ios")) {
                          for (var Ge = !1, ft = 0; ft < De.rules.length; ft++) {
                            var ct = De.rules[ft];
                            if (this.ruleMatches_(ct, V, q, oe)) {
                              Ge = !0;
                              break;
                            }
                          }
                          if (Ge) {
                            var je = De.dpi[0] || De.dpi, nt = De.dpi[1] || De.dpi;
                            return new Y({
                              xdpi: je,
                              ydpi: nt,
                              bevelMm: De.bw
                            });
                          }
                        }
                      }
                      return console.warn("No DPDB device match."), null;
                    }, Cr.prototype.ruleMatches_ = function(F, V, q, oe) {
                      if (!F.ua && !F.res || (F.ua && F.ua.substring(0, 2) === "SM" && (F.ua = F.ua.substring(0, 7)), F.ua && V.indexOf(F.ua) < 0)) return !1;
                      if (F.res) {
                        if (!F.res[0] || !F.res[1]) return !1;
                        var me = F.res[0], De = F.res[1];
                        if (Math.min(q, oe) != Math.min(me, De) || Math.max(q, oe) != Math.max(me, De))
                          return !1;
                      }
                      return !0;
                    };
                    function Y(F) {
                      this.xdpi = F.xdpi, this.ydpi = F.ydpi, this.bevelMm = F.bevelMm;
                    }
                    function Fe(F, V) {
                      this.set(F, V);
                    }
                    Fe.prototype.set = function(F, V) {
                      this.sample = F, this.timestampS = V;
                    }, Fe.prototype.copy = function(F) {
                      this.set(F.sample, F.timestampS);
                    };
                    function tt(F, V) {
                      this.kFilter = F, this.isDebug = V, this.currentAccelMeasurement = new Fe(), this.currentGyroMeasurement = new Fe(), this.previousGyroMeasurement = new Fe(), X() ? this.filterQ = new St(-1, 0, 0, 1) : this.filterQ = new St(1, 0, 0, 1), this.previousFilterQ = new St(), this.previousFilterQ.copy(this.filterQ), this.accelQ = new St(), this.isOrientationInitialized = !1, this.estimatedGravity = new _t(), this.measuredGravity = new _t(), this.gyroIntegralQ = new St();
                    }
                    tt.prototype.addAccelMeasurement = function(F, V) {
                      this.currentAccelMeasurement.set(F, V);
                    }, tt.prototype.addGyroMeasurement = function(F, V) {
                      this.currentGyroMeasurement.set(F, V);
                      var q = V - this.previousGyroMeasurement.timestampS;
                      Ve(q) && this.run_(), this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
                    }, tt.prototype.run_ = function() {
                      if (!this.isOrientationInitialized) {
                        this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample), this.previousFilterQ.copy(this.accelQ), this.isOrientationInitialized = !0;
                        return;
                      }
                      var F = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS, V = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, F);
                      this.gyroIntegralQ.multiply(V), this.filterQ.copy(this.previousFilterQ), this.filterQ.multiply(V);
                      var q = new St();
                      q.copy(this.filterQ), q.inverse(), this.estimatedGravity.set(0, 0, -1), this.estimatedGravity.applyQuaternion(q), this.estimatedGravity.normalize(), this.measuredGravity.copy(this.currentAccelMeasurement.sample), this.measuredGravity.normalize();
                      var oe = new St();
                      oe.setFromUnitVectors(this.estimatedGravity, this.measuredGravity), oe.inverse(), this.isDebug && console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", Pt * Ni(oe), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
                      var me = new St();
                      me.copy(this.filterQ), me.multiply(oe), this.filterQ.slerp(me, 1 - this.kFilter), this.previousFilterQ.copy(this.filterQ);
                    }, tt.prototype.getOrientation = function() {
                      return this.filterQ;
                    }, tt.prototype.accelToQuaternion_ = function(F) {
                      var V = new _t();
                      V.copy(F), V.normalize();
                      var q = new St();
                      return q.setFromUnitVectors(new _t(0, 0, -1), V), q.inverse(), q;
                    }, tt.prototype.gyroToQuaternionDelta_ = function(F, V) {
                      var q = new St(), oe = new _t();
                      return oe.copy(F), oe.normalize(), q.setFromAxisAngle(oe, F.length() * V), q;
                    };
                    function lt(F, V) {
                      this.predictionTimeS = F, this.isDebug = V, this.previousQ = new St(), this.previousTimestampS = null, this.deltaQ = new St(), this.outQ = new St();
                    }
                    lt.prototype.getPrediction = function(F, V, q) {
                      if (!this.previousTimestampS)
                        return this.previousQ.copy(F), this.previousTimestampS = q, F;
                      var oe = new _t();
                      oe.copy(V), oe.normalize();
                      var me = V.length();
                      if (me < Ct * 20)
                        return this.isDebug && console.log("Moving slowly, at %s deg/s: no prediction", (Pt * me).toFixed(1)), this.outQ.copy(F), this.previousQ.copy(F), this.outQ;
                      var De = me * this.predictionTimeS;
                      return this.deltaQ.setFromAxisAngle(oe, De), this.outQ.copy(this.previousQ), this.outQ.multiply(this.deltaQ), this.previousQ.copy(F), this.previousTimestampS = q, this.outQ;
                    };
                    function Ut(F, V, q, oe) {
                      this.yawOnly = q, this.accelerometer = new _t(), this.gyroscope = new _t(), this.filter = new tt(F, oe), this.posePredictor = new lt(V, oe), this.isFirefoxAndroid = K(), this.isIOS = X();
                      var me = ne();
                      this.isDeviceMotionInRadians = !this.isIOS && me && me < 66, this.isWithoutDeviceMotion = be() || pe(), this.filterToWorldQ = new St(), X() ? this.filterToWorldQ.setFromAxisAngle(new _t(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new _t(1, 0, 0), -Math.PI / 2), this.inverseWorldToScreenQ = new St(), this.worldToScreenQ = new St(), this.originalPoseAdjustQ = new St(), this.originalPoseAdjustQ.setFromAxisAngle(new _t(0, 0, 1), -window.orientation * Math.PI / 180), this.setScreenTransform_(), ke() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ), this.resetQ = new St(), this.orientationOut_ = new Float32Array(4), this.start();
                    }
                    Ut.prototype.getPosition = function() {
                      return null;
                    }, Ut.prototype.getOrientation = function() {
                      var F = void 0;
                      if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
                        this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
                          var me = new St().setFromAxisAngle(new _t(0, 0, -1), 0), De = new St();
                          return window.orientation === -90 ? De.setFromAxisAngle(new _t(0, 1, 0), Math.PI / -2) : De.setFromAxisAngle(new _t(0, 1, 0), Math.PI / 2), me.multiply(De);
                        }(), this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
                          var me = new St();
                          return me.setFromAxisAngle(new _t(1, 0, 0), -Math.PI / 2), me;
                        }(), F = this._deviceOrientationQ;
                        var q = new St();
                        return q.copy(F), q.multiply(this.deviceOrientationFilterToWorldQ), q.multiply(this.resetQ), q.multiply(this.worldToScreenQ), q.multiplyQuaternions(this.deviceOrientationFixQ, q), this.yawOnly && (q.x = 0, q.z = 0, q.normalize()), this.orientationOut_[0] = q.x, this.orientationOut_[1] = q.y, this.orientationOut_[2] = q.z, this.orientationOut_[3] = q.w, this.orientationOut_;
                      } else {
                        var V = this.filter.getOrientation();
                        F = this.posePredictor.getPrediction(V, this.gyroscope, this.previousTimestampS);
                      }
                      var q = new St();
                      return q.copy(this.filterToWorldQ), q.multiply(this.resetQ), q.multiply(F), q.multiply(this.worldToScreenQ), this.yawOnly && (q.x = 0, q.z = 0, q.normalize()), this.orientationOut_[0] = q.x, this.orientationOut_[1] = q.y, this.orientationOut_[2] = q.z, this.orientationOut_[3] = q.w, this.orientationOut_;
                    }, Ut.prototype.resetPose = function() {
                      this.resetQ.copy(this.filter.getOrientation()), this.resetQ.x = 0, this.resetQ.y = 0, this.resetQ.z *= -1, this.resetQ.normalize(), ke() && this.resetQ.multiply(this.inverseWorldToScreenQ), this.resetQ.multiply(this.originalPoseAdjustQ);
                    }, Ut.prototype.onDeviceOrientation_ = function(F) {
                      this._deviceOrientationQ = this._deviceOrientationQ || new St();
                      var V = F.alpha, q = F.beta, oe = F.gamma;
                      V = (V || 0) * Math.PI / 180, q = (q || 0) * Math.PI / 180, oe = (oe || 0) * Math.PI / 180, this._deviceOrientationQ.setFromEulerYXZ(q, V, -oe);
                    }, Ut.prototype.onDeviceMotion_ = function(F) {
                      this.updateDeviceMotion_(F);
                    }, Ut.prototype.updateDeviceMotion_ = function(F) {
                      var V = F.accelerationIncludingGravity, q = F.rotationRate, oe = F.timeStamp / 1e3, me = oe - this.previousTimestampS;
                      if (me < 0) {
                        Be("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion"), this.previousTimestampS = oe;
                        return;
                      } else if (me <= Z || me > W) {
                        Be("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range."), this.previousTimestampS = oe;
                        return;
                      }
                      this.accelerometer.set(-V.x, -V.y, -V.z), q && (Te() ? this.gyroscope.set(-q.beta, q.alpha, q.gamma) : this.gyroscope.set(q.alpha, q.beta, q.gamma), this.isDeviceMotionInRadians || this.gyroscope.multiplyScalar(Math.PI / 180), this.filter.addGyroMeasurement(this.gyroscope, oe)), this.filter.addAccelMeasurement(this.accelerometer, oe), this.previousTimestampS = oe;
                    }, Ut.prototype.onOrientationChange_ = function(F) {
                      this.setScreenTransform_();
                    }, Ut.prototype.onMessage_ = function(F) {
                      var V = F.data;
                      if (!(!V || !V.type)) {
                        var q = V.type.toLowerCase();
                        q === "devicemotion" && this.updateDeviceMotion_(V.deviceMotionEvent);
                      }
                    }, Ut.prototype.setScreenTransform_ = function() {
                      switch (this.worldToScreenQ.set(0, 0, 0, 1), window.orientation) {
                        case 0:
                          break;
                        case 90:
                          this.worldToScreenQ.setFromAxisAngle(new _t(0, 0, 1), -Math.PI / 2);
                          break;
                        case -90:
                          this.worldToScreenQ.setFromAxisAngle(new _t(0, 0, 1), Math.PI / 2);
                          break;
                      }
                      this.inverseWorldToScreenQ.copy(this.worldToScreenQ), this.inverseWorldToScreenQ.inverse();
                    }, Ut.prototype.start = function() {
                      this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this), this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this), this.onMessageCallback_ = this.onMessage_.bind(this), this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this), X() && di() && window.addEventListener("message", this.onMessageCallback_), window.addEventListener("orientationchange", this.onOrientationChangeCallback_), this.isWithoutDeviceMotion ? window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_) : window.addEventListener("devicemotion", this.onDeviceMotionCallback_);
                    }, Ut.prototype.stop = function() {
                      window.removeEventListener("devicemotion", this.onDeviceMotionCallback_), window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_), window.removeEventListener("orientationchange", this.onOrientationChangeCallback_), window.removeEventListener("message", this.onMessageCallback_);
                    };
                    var hn = 60, zt = new _t(1, 0, 0), ai = new _t(0, 0, 1), jn = new St();
                    jn.setFromAxisAngle(zt, -Math.PI / 2), jn.multiply(new St().setFromAxisAngle(ai, Math.PI / 2));
                    var de = function() {
                      function F(V) {
                        S(this, F), this.config = V, this.sensor = null, this.fusionSensor = null, this._out = new Float32Array(4), this.api = null, this.errors = [], this._sensorQ = new St(), this._outQ = new St(), this._onSensorRead = this._onSensorRead.bind(this), this._onSensorError = this._onSensorError.bind(this), this.init();
                      }
                      return U(F, [{
                        key: "init",
                        value: function() {
                          var q = null;
                          try {
                            q = new RelativeOrientationSensor({
                              frequency: hn,
                              referenceFrame: "screen"
                            }), q.addEventListener("error", this._onSensorError);
                          } catch (oe) {
                            this.errors.push(oe), oe.name === "SecurityError" ? (console.error("Cannot construct sensors due to the Feature Policy"), console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.'), this.useDeviceMotion()) : oe.name === "ReferenceError" ? this.useDeviceMotion() : console.error(oe);
                          }
                          q && (this.api = "sensor", this.sensor = q, this.sensor.addEventListener("reading", this._onSensorRead), this.sensor.start());
                        }
                      }, {
                        key: "useDeviceMotion",
                        value: function() {
                          this.api = "devicemotion", this.fusionSensor = new Ut(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG), this.sensor && (this.sensor.removeEventListener("reading", this._onSensorRead), this.sensor.removeEventListener("error", this._onSensorError), this.sensor = null);
                        }
                      }, {
                        key: "getOrientation",
                        value: function() {
                          if (this.fusionSensor)
                            return this.fusionSensor.getOrientation();
                          if (!this.sensor || !this.sensor.quaternion)
                            return this._out[0] = this._out[1] = this._out[2] = 0, this._out[3] = 1, this._out;
                          var q = this.sensor.quaternion;
                          this._sensorQ.set(q[0], q[1], q[2], q[3]);
                          var oe = this._outQ;
                          return oe.copy(jn), oe.multiply(this._sensorQ), this.config.YAW_ONLY && (oe.x = oe.z = 0, oe.normalize()), this._out[0] = oe.x, this._out[1] = oe.y, this._out[2] = oe.z, this._out[3] = oe.w, this._out;
                        }
                      }, {
                        key: "_onSensorError",
                        value: function(q) {
                          this.errors.push(q.error), q.error.name === "NotAllowedError" ? console.error("Permission to access sensor was denied") : q.error.name === "NotReadableError" ? console.error("Sensor could not be read") : console.error(q.error), this.useDeviceMotion();
                        }
                      }, {
                        key: "_onSensorRead",
                        value: function() {
                        }
                      }]), F;
                    }(), _e = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
                    function Ne() {
                      this.loadIcon_();
                      var F = document.createElement("div"), Ge = F.style;
                      Ge.position = "fixed", Ge.top = 0, Ge.right = 0, Ge.bottom = 0, Ge.left = 0, Ge.backgroundColor = "gray", Ge.fontFamily = "sans-serif", Ge.zIndex = 1e6;
                      var V = document.createElement("img");
                      V.src = this.icon;
                      var Ge = V.style;
                      Ge.marginLeft = "25%", Ge.marginTop = "25%", Ge.width = "50%", F.appendChild(V);
                      var q = document.createElement("div"), Ge = q.style;
                      Ge.textAlign = "center", Ge.fontSize = "16px", Ge.lineHeight = "24px", Ge.margin = "24px 25%", Ge.width = "50%", q.innerHTML = "Place your phone into your Cardboard viewer.", F.appendChild(q);
                      var oe = document.createElement("div"), Ge = oe.style;
                      Ge.backgroundColor = "#CFD8DC", Ge.position = "fixed", Ge.bottom = 0, Ge.width = "100%", Ge.height = "48px", Ge.padding = "14px 24px", Ge.boxSizing = "border-box", Ge.color = "#656A6B", F.appendChild(oe);
                      var me = document.createElement("div");
                      me.style.float = "left", me.innerHTML = "No Cardboard viewer?";
                      var De = document.createElement("a");
                      De.href = "https://www.google.com/get/cardboard/get-cardboard/", De.innerHTML = "get one", De.target = "_blank";
                      var Ge = De.style;
                      Ge.float = "right", Ge.fontWeight = 600, Ge.textTransform = "uppercase", Ge.borderLeft = "1px solid gray", Ge.paddingLeft = "24px", Ge.textDecoration = "none", Ge.color = "#656A6B", oe.appendChild(me), oe.appendChild(De), this.overlay = F, this.text = q, this.hide();
                    }
                    Ne.prototype.show = function(F) {
                      !F && !this.overlay.parentElement ? document.body.appendChild(this.overlay) : F && (this.overlay.parentElement && this.overlay.parentElement != F && this.overlay.parentElement.removeChild(this.overlay), F.appendChild(this.overlay)), this.overlay.style.display = "block";
                      var V = this.overlay.querySelector("img"), q = V.style;
                      ke() ? (q.width = "20%", q.marginLeft = "40%", q.marginTop = "3%") : (q.width = "50%", q.marginLeft = "25%", q.marginTop = "25%");
                    }, Ne.prototype.hide = function() {
                      this.overlay.style.display = "none";
                    }, Ne.prototype.showTemporarily = function(F, V) {
                      this.show(V), this.timer = setTimeout(this.hide.bind(this), F);
                    }, Ne.prototype.disableShowTemporarily = function() {
                      clearTimeout(this.timer);
                    }, Ne.prototype.update = function() {
                      this.disableShowTemporarily(), !ke() && Tn() ? this.show() : this.hide();
                    }, Ne.prototype.loadIcon_ = function() {
                      this.icon = ie("image/svg+xml", _e);
                    };
                    var Ye = "CardboardV1", Ke = "WEBVR_CARDBOARD_VIEWER", rt = "webvr-polyfill-viewer-selector";
                    function bt(F) {
                      try {
                        this.selectedKey = localStorage.getItem(Ke);
                      } catch (V) {
                        console.error("Failed to load viewer profile: %s", V);
                      }
                      this.selectedKey || (this.selectedKey = F || Ye), this.dialog = this.createDialog_(ui.Viewers), this.root = null, this.onChangeCallbacks_ = [];
                    }
                    bt.prototype.show = function(F) {
                      this.root = F, F.appendChild(this.dialog);
                      var V = this.dialog.querySelector("#" + this.selectedKey);
                      V.checked = !0, this.dialog.style.display = "block";
                    }, bt.prototype.hide = function() {
                      this.root && this.root.contains(this.dialog) && this.root.removeChild(this.dialog), this.dialog.style.display = "none";
                    }, bt.prototype.getCurrentViewer = function() {
                      return ui.Viewers[this.selectedKey];
                    }, bt.prototype.getSelectedKey_ = function() {
                      var F = this.dialog.querySelector("input[name=field]:checked");
                      return F ? F.id : null;
                    }, bt.prototype.onChange = function(F) {
                      this.onChangeCallbacks_.push(F);
                    }, bt.prototype.fireOnChange_ = function(F) {
                      for (var V = 0; V < this.onChangeCallbacks_.length; V++)
                        this.onChangeCallbacks_[V](F);
                    }, bt.prototype.onSave_ = function() {
                      if (this.selectedKey = this.getSelectedKey_(), !this.selectedKey || !ui.Viewers[this.selectedKey]) {
                        console.error("ViewerSelector.onSave_: this should never happen!");
                        return;
                      }
                      this.fireOnChange_(ui.Viewers[this.selectedKey]);
                      try {
                        localStorage.setItem(Ke, this.selectedKey);
                      } catch (F) {
                        console.error("Failed to save viewer profile: %s", F);
                      }
                      this.hide();
                    }, bt.prototype.createDialog_ = function(F) {
                      var V = document.createElement("div");
                      V.classList.add(rt), V.style.display = "none";
                      var q = document.createElement("div"), De = q.style;
                      De.position = "fixed", De.left = 0, De.top = 0, De.width = "100%", De.height = "100%", De.background = "rgba(0, 0, 0, 0.3)", q.addEventListener("click", this.hide.bind(this));
                      var oe = 280, me = document.createElement("div"), De = me.style;
                      De.boxSizing = "border-box", De.position = "fixed", De.top = "24px", De.left = "50%", De.marginLeft = -oe / 2 + "px", De.width = oe + "px", De.padding = "24px", De.overflow = "hidden", De.background = "#fafafa", De.fontFamily = "'Roboto', sans-serif", De.boxShadow = "0px 5px 20px #666", me.appendChild(this.createH1_("Select your viewer"));
                      for (var Ge in F)
                        me.appendChild(this.createChoice_(Ge, F[Ge].label));
                      return me.appendChild(this.createButton_("Save", this.onSave_.bind(this))), V.appendChild(q), V.appendChild(me), V;
                    }, bt.prototype.createH1_ = function(F) {
                      var V = document.createElement("h1"), q = V.style;
                      return q.color = "black", q.fontSize = "20px", q.fontWeight = "bold", q.marginTop = 0, q.marginBottom = "24px", V.innerHTML = F, V;
                    }, bt.prototype.createChoice_ = function(F, V) {
                      var q = document.createElement("div");
                      q.style.marginTop = "8px", q.style.color = "black";
                      var oe = document.createElement("input");
                      oe.style.fontSize = "30px", oe.setAttribute("id", F), oe.setAttribute("type", "radio"), oe.setAttribute("value", F), oe.setAttribute("name", "field");
                      var me = document.createElement("label");
                      return me.style.marginLeft = "4px", me.setAttribute("for", F), me.innerHTML = V, q.appendChild(oe), q.appendChild(me), q;
                    }, bt.prototype.createButton_ = function(F, V) {
                      var q = document.createElement("button");
                      q.innerHTML = F;
                      var oe = q.style;
                      return oe.float = "right", oe.textTransform = "uppercase", oe.color = "#1094f7", oe.fontSize = "14px", oe.letterSpacing = 0, oe.border = 0, oe.background = "none", oe.marginTop = "16px", q.addEventListener("click", V), q;
                    };
                    var ln = typeof window < "u" ? window : typeof C < "u" ? C : typeof self < "u" ? self : {};
                    function jt(F) {
                      return F && F.__esModule && Object.prototype.hasOwnProperty.call(F, "default") ? F.default : F;
                    }
                    function at(F, V) {
                      return V = {
                        exports: {}
                      }, F(V, V.exports), V.exports;
                    }
                    var mn = at(function(F, V) {
                      (function(oe, me) {
                        F.exports = me();
                      })(ln, function() {
                        return function(q) {
                          var oe = {};
                          function me(De) {
                            if (oe[De])
                              return oe[De].exports;
                            var Ge = oe[De] = {
                              i: De,
                              l: !1,
                              exports: {}
                            };
                            return q[De].call(Ge.exports, Ge, Ge.exports, me), Ge.l = !0, Ge.exports;
                          }
                          return me.m = q, me.c = oe, me.d = function(De, Ge, ft) {
                            me.o(De, Ge) || Object.defineProperty(De, Ge, {
                              configurable: !1,
                              enumerable: !0,
                              get: ft
                            });
                          }, me.n = function(De) {
                            var Ge = De && De.__esModule ? function() {
                              return De.default;
                            } : function() {
                              return De;
                            };
                            return me.d(Ge, "a", Ge), Ge;
                          }, me.o = function(De, Ge) {
                            return Object.prototype.hasOwnProperty.call(De, Ge);
                          }, me.p = "", me(me.s = 0);
                        }([function(q, oe, me) {
                          var De = /* @__PURE__ */ function() {
                            function nt(xt, Jt) {
                              for (var dn = 0; dn < Jt.length; dn++) {
                                var Mn = Jt[dn];
                                Mn.enumerable = Mn.enumerable || !1, Mn.configurable = !0, "value" in Mn && (Mn.writable = !0), Object.defineProperty(xt, Mn.key, Mn);
                              }
                            }
                            return function(xt, Jt, dn) {
                              return Jt && nt(xt.prototype, Jt), dn && nt(xt, dn), xt;
                            };
                          }();
                          function Ge(nt, xt) {
                            if (!(nt instanceof xt))
                              throw new TypeError("Cannot call a class as a function");
                          }
                          var ft = me(1), ct = typeof navigator < "u" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream, je = function() {
                            function nt() {
                              Ge(this, nt), ct ? this.noSleepTimer = null : (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("playsinline", ""), this.noSleepVideo.setAttribute("src", ft), this.noSleepVideo.addEventListener("timeupdate", function(xt) {
                                this.noSleepVideo.currentTime > 0.5 && (this.noSleepVideo.currentTime = Math.random());
                              }.bind(this)));
                            }
                            return De(nt, [{
                              key: "enable",
                              value: function() {
                                ct ? (this.disable(), this.noSleepTimer = window.setInterval(function() {
                                  window.location.href = "/", window.setTimeout(window.stop, 0);
                                }, 15e3)) : this.noSleepVideo.play();
                              }
                            }, {
                              key: "disable",
                              value: function() {
                                ct ? this.noSleepTimer && (window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : this.noSleepVideo.pause();
                              }
                            }]), nt;
                          }();
                          q.exports = je;
                        }, function(q, oe, me) {
                          q.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=";
                        }]);
                      });
                    }), _n = jt(mn), Rn = 1e3, Bi = [0, 0, 0.5, 1], Wn = [0.5, 0, 0.5, 1], Nn = window.requestAnimationFrame, li = window.cancelAnimationFrame;
                    function Gi() {
                      this.leftProjectionMatrix = new Float32Array(16), this.leftViewMatrix = new Float32Array(16), this.rightProjectionMatrix = new Float32Array(16), this.rightViewMatrix = new Float32Array(16), this.pose = null;
                    }
                    function rr(F) {
                      Object.defineProperties(this, {
                        hasPosition: {
                          writable: !1,
                          enumerable: !0,
                          value: F.hasPosition
                        },
                        hasExternalDisplay: {
                          writable: !1,
                          enumerable: !0,
                          value: F.hasExternalDisplay
                        },
                        canPresent: {
                          writable: !1,
                          enumerable: !0,
                          value: F.canPresent
                        },
                        maxLayers: {
                          writable: !1,
                          enumerable: !0,
                          value: F.maxLayers
                        },
                        hasOrientation: {
                          enumerable: !0,
                          get: function() {
                            return Et("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData"), F.hasOrientation;
                          }
                        }
                      });
                    }
                    function Wt(F) {
                      F = F || {};
                      var V = "wakelock" in F ? F.wakelock : !0;
                      this.isPolyfilled = !0, this.displayId = Rn++, this.displayName = "", this.depthNear = 0.01, this.depthFar = 1e4, this.isPresenting = !1, Object.defineProperty(this, "isConnected", {
                        get: function() {
                          return Et("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay"), !1;
                        }
                      }), this.capabilities = new rr({
                        hasPosition: !1,
                        hasOrientation: !1,
                        hasExternalDisplay: !1,
                        canPresent: !1,
                        maxLayers: 1
                      }), this.stageParameters = null, this.waitingForPresent_ = !1, this.layer_ = null, this.originalParent_ = null, this.fullscreenElement_ = null, this.fullscreenWrapper_ = null, this.fullscreenElementCachedStyle_ = null, this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null, V && Tn() && (this.wakelock_ = new _n());
                    }
                    Wt.prototype.getFrameData = function(F) {
                      return Bn(F, this._getPose(), this);
                    }, Wt.prototype.getPose = function() {
                      return Et("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData"), this._getPose();
                    }, Wt.prototype.resetPose = function() {
                      return Et("VRDisplay.prototype.resetPose"), this._resetPose();
                    }, Wt.prototype.getImmediatePose = function() {
                      return Et("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData"), this._getPose();
                    }, Wt.prototype.requestAnimationFrame = function(F) {
                      return Nn(F);
                    }, Wt.prototype.cancelAnimationFrame = function(F) {
                      return li(F);
                    }, Wt.prototype.wrapForFullscreen = function(F) {
                      if (X())
                        return F;
                      if (!this.fullscreenWrapper_) {
                        this.fullscreenWrapper_ = document.createElement("div");
                        var V = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
                        this.fullscreenWrapper_.setAttribute("style", V.join("; ") + ";"), this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
                      }
                      if (this.fullscreenElement_ == F)
                        return this.fullscreenWrapper_;
                      if (this.fullscreenElement_ && (this.originalParent_ ? this.originalParent_.appendChild(this.fullscreenElement_) : this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_)), this.fullscreenElement_ = F, this.originalParent_ = F.parentElement, this.originalParent_ || document.body.appendChild(F), !this.fullscreenWrapper_.parentElement) {
                        var q = this.fullscreenElement_.parentElement;
                        q.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_), q.removeChild(this.fullscreenElement_);
                      }
                      this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild), this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
                      var oe = this;
                      function me() {
                        if (oe.fullscreenElement_) {
                          var De = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
                          oe.fullscreenElement_.setAttribute("style", De.join("; ") + ";");
                        }
                      }
                      return me(), this.fullscreenWrapper_;
                    }, Wt.prototype.removeFullscreenWrapper = function() {
                      if (this.fullscreenElement_) {
                        var F = this.fullscreenElement_;
                        this.fullscreenElementCachedStyle_ ? F.setAttribute("style", this.fullscreenElementCachedStyle_) : F.removeAttribute("style"), this.fullscreenElement_ = null, this.fullscreenElementCachedStyle_ = null;
                        var V = this.fullscreenWrapper_.parentElement;
                        return this.fullscreenWrapper_.removeChild(F), this.originalParent_ === V ? V.insertBefore(F, this.fullscreenWrapper_) : this.originalParent_ && this.originalParent_.appendChild(F), V.removeChild(this.fullscreenWrapper_), F;
                      }
                    }, Wt.prototype.requestPresent = function(F) {
                      var V = this.isPresenting, q = this;
                      return F instanceof Array || (Et("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument"), F = [F]), new Promise(function(oe, me) {
                        if (!q.capabilities.canPresent) {
                          me(new Error("VRDisplay is not capable of presenting."));
                          return;
                        }
                        if (F.length == 0 || F.length > q.capabilities.maxLayers) {
                          me(new Error("Invalid number of layers."));
                          return;
                        }
                        var De = F[0];
                        if (!De.source) {
                          oe();
                          return;
                        }
                        var Ge = De.leftBounds || Bi, ft = De.rightBounds || Wn;
                        if (V) {
                          var ct = q.layer_;
                          ct.source !== De.source && (ct.source = De.source);
                          for (var je = 0; je < 4; je++)
                            ct.leftBounds[je] = Ge[je], ct.rightBounds[je] = ft[je];
                          q.wrapForFullscreen(q.layer_.source), q.updatePresent_(), oe();
                          return;
                        }
                        if (q.layer_ = {
                          predistorted: De.predistorted,
                          source: De.source,
                          leftBounds: Ge.slice(0),
                          rightBounds: ft.slice(0)
                        }, q.waitingForPresent_ = !1, q.layer_ && q.layer_.source) {
                          var nt = q.wrapForFullscreen(q.layer_.source), xt = function() {
                            var Mn = Rt();
                            q.isPresenting = nt === Mn, q.isPresenting ? (screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape-primary").catch(function(Vn) {
                              console.error("screen.orientation.lock() failed due to", Vn.message);
                            }), q.waitingForPresent_ = !1, q.beginPresent_(), oe()) : (screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), q.removeFullscreenWrapper(), q.disableWakeLock(), q.endPresent_(), q.removeFullscreenListeners_()), q.fireVRDisplayPresentChange_();
                          }, Jt = function() {
                            q.waitingForPresent_ && (q.removeFullscreenWrapper(), q.removeFullscreenListeners_(), q.disableWakeLock(), q.waitingForPresent_ = !1, q.isPresenting = !1, me(new Error("Unable to present.")));
                          };
                          q.addFullscreenListeners_(nt, xt, Jt), It(nt) ? (q.enableWakeLock(), q.waitingForPresent_ = !0) : (X() || Q()) && (q.enableWakeLock(), q.isPresenting = !0, q.beginPresent_(), q.fireVRDisplayPresentChange_(), oe());
                        }
                        !q.waitingForPresent_ && !X() && (ht(), me(new Error("Unable to present.")));
                      });
                    }, Wt.prototype.exitPresent = function() {
                      var F = this.isPresenting, V = this;
                      return this.isPresenting = !1, this.layer_ = null, this.disableWakeLock(), new Promise(function(q, oe) {
                        F ? (!ht() && X() && (V.endPresent_(), V.fireVRDisplayPresentChange_()), Q() && (V.removeFullscreenWrapper(), V.removeFullscreenListeners_(), V.endPresent_(), V.fireVRDisplayPresentChange_()), q()) : oe(new Error("Was not presenting to VRDisplay."));
                      });
                    }, Wt.prototype.getLayers = function() {
                      return this.layer_ ? [this.layer_] : [];
                    }, Wt.prototype.fireVRDisplayPresentChange_ = function() {
                      var F = new CustomEvent("vrdisplaypresentchange", {
                        detail: {
                          display: this
                        }
                      });
                      window.dispatchEvent(F);
                    }, Wt.prototype.fireVRDisplayConnect_ = function() {
                      var F = new CustomEvent("vrdisplayconnect", {
                        detail: {
                          display: this
                        }
                      });
                      window.dispatchEvent(F);
                    }, Wt.prototype.addFullscreenListeners_ = function(F, V, q) {
                      this.removeFullscreenListeners_(), this.fullscreenEventTarget_ = F, this.fullscreenChangeHandler_ = V, this.fullscreenErrorHandler_ = q, V && (document.fullscreenEnabled ? F.addEventListener("fullscreenchange", V, !1) : document.webkitFullscreenEnabled ? F.addEventListener("webkitfullscreenchange", V, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenchange", V, !1) : document.msFullscreenEnabled && F.addEventListener("msfullscreenchange", V, !1)), q && (document.fullscreenEnabled ? F.addEventListener("fullscreenerror", q, !1) : document.webkitFullscreenEnabled ? F.addEventListener("webkitfullscreenerror", q, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenerror", q, !1) : document.msFullscreenEnabled && F.addEventListener("msfullscreenerror", q, !1));
                    }, Wt.prototype.removeFullscreenListeners_ = function() {
                      if (this.fullscreenEventTarget_) {
                        var F = this.fullscreenEventTarget_;
                        if (this.fullscreenChangeHandler_) {
                          var V = this.fullscreenChangeHandler_;
                          F.removeEventListener("fullscreenchange", V, !1), F.removeEventListener("webkitfullscreenchange", V, !1), document.removeEventListener("mozfullscreenchange", V, !1), F.removeEventListener("msfullscreenchange", V, !1);
                        }
                        if (this.fullscreenErrorHandler_) {
                          var q = this.fullscreenErrorHandler_;
                          F.removeEventListener("fullscreenerror", q, !1), F.removeEventListener("webkitfullscreenerror", q, !1), document.removeEventListener("mozfullscreenerror", q, !1), F.removeEventListener("msfullscreenerror", q, !1);
                        }
                        this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null;
                      }
                    }, Wt.prototype.enableWakeLock = function() {
                      this.wakelock_ && this.wakelock_.enable();
                    }, Wt.prototype.disableWakeLock = function() {
                      this.wakelock_ && this.wakelock_.disable();
                    }, Wt.prototype.beginPresent_ = function() {
                    }, Wt.prototype.endPresent_ = function() {
                    }, Wt.prototype.submitFrame = function(F) {
                    }, Wt.prototype.getEyeParameters = function(F) {
                      return null;
                    };
                    var Kn = {
                      ADDITIONAL_VIEWERS: [],
                      DEFAULT_VIEWER: "",
                      MOBILE_WAKE_LOCK: !0,
                      DEBUG: !1,
                      DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
                      K_FILTER: 0.98,
                      PREDICTION_TIME_S: 0.04,
                      CARDBOARD_UI_DISABLED: !1,
                      ROTATE_INSTRUCTIONS_DISABLED: !1,
                      YAW_ONLY: !1,
                      BUFFER_SCALE: 0.5,
                      DIRTY_SUBMIT_FRAME_BINDINGS: !1
                    }, qi = {
                      LEFT: "left",
                      RIGHT: "right"
                    };
                    function fi(F) {
                      var V = wn({}, Kn);
                      F = wn(V, F || {}), Wt.call(this, {
                        wakelock: F.MOBILE_WAKE_LOCK
                      }), this.config = F, this.displayName = "Cardboard VRDisplay", this.capabilities = new rr({
                        hasPosition: !1,
                        hasOrientation: !0,
                        hasExternalDisplay: !1,
                        canPresent: !0,
                        maxLayers: 1
                      }), this.stageParameters = null, this.bufferScale_ = this.config.BUFFER_SCALE, this.poseSensor_ = new de(this.config), this.distorter_ = null, this.cardboardUI_ = null, this.dpdb_ = new Cr(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this)), this.deviceInfo_ = new ui(this.dpdb_.getDeviceParams(), F.ADDITIONAL_VIEWERS), this.viewerSelector_ = new bt(F.DEFAULT_VIEWER), this.viewerSelector_.onChange(this.onViewerChanged_.bind(this)), this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer()), this.config.ROTATE_INSTRUCTIONS_DISABLED || (this.rotateInstructions_ = new Ne()), X() && window.addEventListener("resize", this.onResize_.bind(this));
                    }
                    return fi.prototype = Object.create(Wt.prototype), fi.prototype._getPose = function() {
                      return {
                        position: null,
                        orientation: this.poseSensor_.getOrientation(),
                        linearVelocity: null,
                        linearAcceleration: null,
                        angularVelocity: null,
                        angularAcceleration: null
                      };
                    }, fi.prototype._resetPose = function() {
                      this.poseSensor_.resetPose && this.poseSensor_.resetPose();
                    }, fi.prototype._getFieldOfView = function(F) {
                      var V;
                      if (F == qi.LEFT)
                        V = this.deviceInfo_.getFieldOfViewLeftEye();
                      else if (F == qi.RIGHT)
                        V = this.deviceInfo_.getFieldOfViewRightEye();
                      else
                        return console.error("Invalid eye provided: %s", F), null;
                      return V;
                    }, fi.prototype._getEyeOffset = function(F) {
                      var V;
                      if (F == qi.LEFT)
                        V = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
                      else if (F == qi.RIGHT)
                        V = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
                      else
                        return console.error("Invalid eye provided: %s", F), null;
                      return V;
                    }, fi.prototype.getEyeParameters = function(F) {
                      var V = this._getEyeOffset(F), q = this._getFieldOfView(F), oe = {
                        offset: V,
                        renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
                        renderHeight: this.deviceInfo_.device.height * this.bufferScale_
                      };
                      return Object.defineProperty(oe, "fieldOfView", {
                        enumerable: !0,
                        get: function() {
                          return Et("VRFieldOfView", "VRFrameData's projection matrices"), q;
                        }
                      }), oe;
                    }, fi.prototype.onDeviceParamsUpdated_ = function(F) {
                      this.config.DEBUG && console.log("DPDB reported that device params were updated."), this.deviceInfo_.updateDeviceParams(F), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_);
                    }, fi.prototype.updateBounds_ = function() {
                      this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds) && this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
                    }, fi.prototype.beginPresent_ = function() {
                      var F = this.layer_.source.getContext("webgl");
                      F || (F = this.layer_.source.getContext("experimental-webgl")), F || (F = this.layer_.source.getContext("webgl2")), F && (this.layer_.predistorted ? this.config.CARDBOARD_UI_DISABLED || (F.canvas.width = st() * this.bufferScale_, F.canvas.height = ut() * this.bufferScale_, this.cardboardUI_ = new we(F)) : (this.config.CARDBOARD_UI_DISABLED || (this.cardboardUI_ = new we(F)), this.distorter_ = new Yt(F, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS), this.distorter_.updateDeviceInfo(this.deviceInfo_)), this.cardboardUI_ && this.cardboardUI_.listen(function(V) {
                        this.viewerSelector_.show(this.layer_.source.parentElement), V.stopPropagation(), V.preventDefault();
                      }.bind(this), function(V) {
                        this.exitPresent(), V.stopPropagation(), V.preventDefault();
                      }.bind(this)), this.rotateInstructions_ && (ke() && Tn() ? this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement) : this.rotateInstructions_.update()), this.orientationHandler = this.onOrientationChange_.bind(this), window.addEventListener("orientationchange", this.orientationHandler), this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this), window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler), this.fireVRDisplayDeviceParamsChange_());
                    }, fi.prototype.endPresent_ = function() {
                      this.distorter_ && (this.distorter_.destroy(), this.distorter_ = null), this.cardboardUI_ && (this.cardboardUI_.destroy(), this.cardboardUI_ = null), this.rotateInstructions_ && this.rotateInstructions_.hide(), this.viewerSelector_.hide(), window.removeEventListener("orientationchange", this.orientationHandler), window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
                    }, fi.prototype.updatePresent_ = function() {
                      this.endPresent_(), this.beginPresent_();
                    }, fi.prototype.submitFrame = function(F) {
                      if (this.distorter_)
                        this.updateBounds_(), this.distorter_.submitFrame();
                      else if (this.cardboardUI_ && this.layer_) {
                        var V = this.layer_.source.getContext("webgl");
                        V || (V = this.layer_.source.getContext("experimental-webgl")), V || (V = this.layer_.source.getContext("webgl2"));
                        var q = V.canvas;
                        (q.width != this.lastWidth || q.height != this.lastHeight) && this.cardboardUI_.onResize(), this.lastWidth = q.width, this.lastHeight = q.height, this.cardboardUI_.render();
                      }
                    }, fi.prototype.onOrientationChange_ = function(F) {
                      this.viewerSelector_.hide(), this.rotateInstructions_ && this.rotateInstructions_.update(), this.onResize_();
                    }, fi.prototype.onResize_ = function(F) {
                      if (this.layer_) {
                        var V = this.layer_.source.getContext("webgl");
                        V || (V = this.layer_.source.getContext("experimental-webgl")), V || (V = this.layer_.source.getContext("webgl2"));
                        var q = ["position: absolute", "top: 0", "left: 0", "width: 100vw", "height: 100vh", "border: 0", "margin: 0", "padding: 0px", "box-sizing: content-box"];
                        V.canvas.setAttribute("style", q.join("; ") + ";"), rn(V.canvas);
                      }
                    }, fi.prototype.onViewerChanged_ = function(F) {
                      this.deviceInfo_.setViewer(F), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_), this.fireVRDisplayDeviceParamsChange_();
                    }, fi.prototype.fireVRDisplayDeviceParamsChange_ = function() {
                      var F = new CustomEvent("vrdisplaydeviceparamschange", {
                        detail: {
                          vrdisplay: this,
                          deviceInfo: this.deviceInfo_
                        }
                      });
                      window.dispatchEvent(F);
                    }, fi.VRFrameData = Gi, fi.VRDisplay = Wt, fi;
                  });
                }), c = w(p), g = "0.10.12", A = {
                  ADDITIONAL_VIEWERS: [],
                  DEFAULT_VIEWER: "",
                  PROVIDE_MOBILE_VRDISPLAY: !0,
                  MOBILE_WAKE_LOCK: !0,
                  DEBUG: !1,
                  DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
                  K_FILTER: 0.98,
                  PREDICTION_TIME_S: 0.04,
                  CARDBOARD_UI_DISABLED: !1,
                  ROTATE_INSTRUCTIONS_DISABLED: !1,
                  YAW_ONLY: !1,
                  BUFFER_SCALE: 0.5,
                  DIRTY_SUBMIT_FRAME_BINDINGS: !1
                };
                function u(b) {
                  this.config = d(d({}, A), b), this.polyfillDisplays = [], this.enabled = !1, this.hasNative = "getVRDisplays" in navigator, this.native = {}, this.native.getVRDisplays = navigator.getVRDisplays, this.native.VRFrameData = window.VRFrameData, this.native.VRDisplay = window.VRDisplay, (!this.hasNative || this.config.PROVIDE_MOBILE_VRDISPLAY && y()) && (this.enable(), this.getVRDisplays().then(function(D) {
                    D && D[0] && D[0].fireVRDisplayConnect_ && D[0].fireVRDisplayConnect_();
                  }));
                }
                u.prototype.getPolyfillDisplays = function() {
                  if (this._polyfillDisplaysPopulated)
                    return this.polyfillDisplays;
                  if (y()) {
                    var b = new c({
                      ADDITIONAL_VIEWERS: this.config.ADDITIONAL_VIEWERS,
                      DEFAULT_VIEWER: this.config.DEFAULT_VIEWER,
                      MOBILE_WAKE_LOCK: this.config.MOBILE_WAKE_LOCK,
                      DEBUG: this.config.DEBUG,
                      DPDB_URL: this.config.DPDB_URL,
                      CARDBOARD_UI_DISABLED: this.config.CARDBOARD_UI_DISABLED,
                      K_FILTER: this.config.K_FILTER,
                      PREDICTION_TIME_S: this.config.PREDICTION_TIME_S,
                      ROTATE_INSTRUCTIONS_DISABLED: this.config.ROTATE_INSTRUCTIONS_DISABLED,
                      YAW_ONLY: this.config.YAW_ONLY,
                      BUFFER_SCALE: this.config.BUFFER_SCALE,
                      DIRTY_SUBMIT_FRAME_BINDINGS: this.config.DIRTY_SUBMIT_FRAME_BINDINGS
                    });
                    this.polyfillDisplays.push(b);
                  }
                  return this._polyfillDisplaysPopulated = !0, this.polyfillDisplays;
                }, u.prototype.enable = function() {
                  if (this.enabled = !0, this.hasNative && this.native.VRFrameData) {
                    var b = this.native.VRFrameData, D = new this.native.VRFrameData(), S = this.native.VRDisplay.prototype.getFrameData;
                    window.VRDisplay.prototype.getFrameData = function(U) {
                      if (U instanceof b) {
                        S.call(this, U);
                        return;
                      }
                      S.call(this, D), U.pose = D.pose, l(D.leftProjectionMatrix, U.leftProjectionMatrix), l(D.rightProjectionMatrix, U.rightProjectionMatrix), l(D.leftViewMatrix, U.leftViewMatrix), l(D.rightViewMatrix, U.rightViewMatrix);
                    };
                  }
                  navigator.getVRDisplays = this.getVRDisplays.bind(this), window.VRDisplay = c.VRDisplay, window.VRFrameData = c.VRFrameData;
                }, u.prototype.getVRDisplays = function() {
                  var b = this;
                  return this.config, this.hasNative ? this.native.getVRDisplays.call(navigator).then(function(D) {
                    return D.length > 0 ? D : b.getPolyfillDisplays();
                  }) : Promise.resolve(this.getPolyfillDisplays());
                }, u.version = g, u.VRFrameData = c.VRFrameData, u.VRDisplay = c.VRDisplay;
                var f = Object.freeze({
                  default: u
                }), x = f && u || f;
                typeof C < "u" && C.window && (C.document || (C.document = C.window.document), C.navigator || (C.navigator = C.window.navigator));
                var T = x;
                return T;
              });
            }
          ),
          /***/
          "./node_modules/word-wrapper/index.js": (
            /*!********************************************!*\
              !*** ./node_modules/word-wrapper/index.js ***!
              \********************************************/
            /***/
            (j) => {
              var re = /\n/, v = `
`, C = /\s/;
              j.exports = function(p, c) {
                var g = j.exports.lines(p, c);
                return g.map(function(A) {
                  return p.substring(A.start, A.end);
                }).join(`
`);
              }, j.exports.lines = function(c, g) {
                if (g = g || {}, g.width === 0 && g.mode !== "nowrap") return [];
                c = c || "";
                var A = typeof g.width == "number" ? g.width : Number.MAX_VALUE, u = Math.max(0, g.start || 0), f = typeof g.end == "number" ? g.end : c.length, x = g.mode, T = g.measure || d;
                return x === "pre" ? y(T, c, u, f, A) : l(T, c, u, f, A, x);
              };
              function w(p, c, g, A) {
                var u = p.indexOf(c, g);
                return u === -1 || u > A ? A : u;
              }
              function E(p) {
                return C.test(p);
              }
              function y(p, c, g, A, u) {
                for (var f = [], x = g, T = g; T < A && T < c.length; T++) {
                  var b = c.charAt(T), D = re.test(b);
                  if (D || T === A - 1) {
                    var S = D ? T : T + 1, U = p(c, x, S, u);
                    f.push(U), x = T + 1;
                  }
                }
                return f;
              }
              function l(p, c, g, A, u, f) {
                var x = [], T = u;
                for (f === "nowrap" && (T = Number.MAX_VALUE); g < A && g < c.length; ) {
                  for (var b = w(c, v, g, A); g < b && E(c.charAt(g)); )
                    g++;
                  var D = p(c, g, b, T), S = g + (D.end - D.start), U = S + v.length;
                  if (S < b) {
                    for (; S > g && !E(c.charAt(S)); )
                      S--;
                    if (S === g)
                      U > g + v.length && U--, S = U;
                    else
                      for (U = S; S > g && E(c.charAt(S - v.length)); )
                        S--;
                  }
                  if (S >= g) {
                    var G = p(c, g, S, T);
                    x.push(G);
                  }
                  g = U;
                }
                return x;
              }
              function d(p, c, g, A) {
                var u = Math.min(A, g - c);
                return {
                  start: c,
                  end: c + u
                };
              }
            }
          ),
          /***/
          "./node_modules/xhr/index.js": (
            /*!***********************************!*\
              !*** ./node_modules/xhr/index.js ***!
              \***********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! global/window */
                "./node_modules/global/window.js"
              ), w = v(
                /*! is-function */
                "./node_modules/is-function/index.js"
              ), E = v(
                /*! parse-headers */
                "./node_modules/parse-headers/parse-headers.js"
              ), y = v(
                /*! xtend */
                "./node_modules/xtend/immutable.js"
              );
              j.exports = c, j.exports.default = c, c.XMLHttpRequest = C.XMLHttpRequest || u, c.XDomainRequest = "withCredentials" in new c.XMLHttpRequest() ? c.XMLHttpRequest : C.XDomainRequest, l(["get", "put", "post", "patch", "head", "delete"], function(f) {
                c[f === "delete" ? "del" : f] = function(x, T, b) {
                  return T = p(x, T, b), T.method = f.toUpperCase(), g(T);
                };
              });
              function l(f, x) {
                for (var T = 0; T < f.length; T++)
                  x(f[T]);
              }
              function d(f) {
                for (var x in f)
                  if (f.hasOwnProperty(x)) return !1;
                return !0;
              }
              function p(f, x, T) {
                var b = f;
                return w(x) ? (T = x, typeof f == "string" && (b = {
                  uri: f
                })) : b = y(x, {
                  uri: f
                }), b.callback = T, b;
              }
              function c(f, x, T) {
                return x = p(f, x, T), g(x);
              }
              function g(f) {
                if (typeof f.callback > "u")
                  throw new Error("callback argument missing");
                var x = !1, T = function(Te, ke, Ve) {
                  x || (x = !0, f.callback(Te, ke, Ve));
                };
                function b() {
                  G.readyState === 4 && setTimeout(U, 0);
                }
                function D() {
                  var be = void 0;
                  if (G.response ? be = G.response : be = G.responseText || A(G), K)
                    try {
                      be = JSON.parse(be);
                    } catch {
                    }
                  return be;
                }
                function S(be) {
                  return clearTimeout(ne), be instanceof Error || (be = new Error("" + (be || "Unknown XMLHttpRequest Error"))), be.statusCode = 0, T(be, pe);
                }
                function U() {
                  if (!W) {
                    var be;
                    clearTimeout(ne), f.useXDR && G.status === void 0 ? be = 200 : be = G.status === 1223 ? 204 : G.status;
                    var Te = pe, ke = null;
                    return be !== 0 ? (Te = {
                      body: D(),
                      statusCode: be,
                      method: te,
                      headers: {},
                      url: ie,
                      rawRequest: G
                    }, G.getAllResponseHeaders && (Te.headers = E(G.getAllResponseHeaders()))) : ke = new Error("Internal XMLHttpRequest Error"), T(ke, Te, Te.body);
                  }
                }
                var G = f.xhr || null;
                G || (f.cors || f.useXDR ? G = new c.XDomainRequest() : G = new c.XMLHttpRequest());
                var Z, W, ie = G.url = f.uri || f.url, te = G.method = f.method || "GET", X = f.body || f.data, Q = G.headers = f.headers || {}, O = !!f.sync, K = !1, ne, pe = {
                  body: void 0,
                  headers: {},
                  statusCode: 0,
                  method: te,
                  url: ie,
                  rawRequest: G
                };
                if ("json" in f && f.json !== !1 && (K = !0, Q.accept || Q.Accept || (Q.Accept = "application/json"), te !== "GET" && te !== "HEAD" && (Q["content-type"] || Q["Content-Type"] || (Q["Content-Type"] = "application/json"), X = JSON.stringify(f.json === !0 ? X : f.json))), G.onreadystatechange = b, G.onload = U, G.onerror = S, G.onprogress = function() {
                }, G.onabort = function() {
                  W = !0;
                }, G.ontimeout = S, G.open(te, ie, !O, f.username, f.password), O || (G.withCredentials = !!f.withCredentials), !O && f.timeout > 0 && (ne = setTimeout(function() {
                  if (!W) {
                    W = !0, G.abort("timeout");
                    var be = new Error("XMLHttpRequest timeout");
                    be.code = "ETIMEDOUT", S(be);
                  }
                }, f.timeout)), G.setRequestHeader)
                  for (Z in Q)
                    Q.hasOwnProperty(Z) && G.setRequestHeader(Z, Q[Z]);
                else if (f.headers && !d(f.headers))
                  throw new Error("Headers cannot be set on an XDomainRequest object");
                return "responseType" in f && (G.responseType = f.responseType), "beforeSend" in f && typeof f.beforeSend == "function" && f.beforeSend(G), G.send(X || null), G;
              }
              function A(f) {
                try {
                  if (f.responseType === "document")
                    return f.responseXML;
                  var x = f.responseXML && f.responseXML.documentElement.nodeName === "parsererror";
                  if (f.responseType === "" && !x)
                    return f.responseXML;
                } catch {
                }
                return null;
              }
              function u() {
              }
            }
          ),
          /***/
          "./node_modules/xml-parse-from-string/index.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/xml-parse-from-string/index.js ***!
              \*****************************************************/
            /***/
            (j) => {
              j.exports = function() {
                return typeof self.DOMParser < "u" ? function(v) {
                  var C = new self.DOMParser();
                  return C.parseFromString(v, "application/xml");
                } : typeof self.ActiveXObject < "u" && new self.ActiveXObject("Microsoft.XMLDOM") ? function(v) {
                  var C = new self.ActiveXObject("Microsoft.XMLDOM");
                  return C.async = "false", C.loadXML(v), C;
                } : function(v) {
                  var C = document.createElement("div");
                  return C.innerHTML = v, C;
                };
              }();
            }
          ),
          /***/
          "./node_modules/xtend/immutable.js": (
            /*!*****************************************!*\
              !*** ./node_modules/xtend/immutable.js ***!
              \*****************************************/
            /***/
            (j) => {
              j.exports = v;
              var re = Object.prototype.hasOwnProperty;
              function v() {
                for (var C = {}, w = 0; w < arguments.length; w++) {
                  var E = arguments[w];
                  for (var y in E)
                    re.call(E, y) && (C[y] = E[y]);
                }
                return C;
              }
            }
          ),
          /***/
          "./src/components/anchored.js": (
            /*!************************************!*\
              !*** ./src/components/anchored.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), E = w.debug("components:anchored:warn");
              j.exports.Component = C("anchored", {
                schema: {
                  persistent: {
                    default: !1
                  }
                },
                init: function() {
                  var l = this.el.sceneEl, d = l.getAttribute("webxr"), p = d.optionalFeatures;
                  p.indexOf("anchors") === -1 && (p.push("anchors"), this.el.sceneEl.setAttribute("webxr", d)), this.auxQuaternion = new THREE.Quaternion(), this.onEnterVR = this.onEnterVR.bind(this), this.el.sceneEl.addEventListener("enter-vr", this.onEnterVR);
                },
                onEnterVR: function() {
                  this.anchor = void 0, this.requestPersistentAnchorPending = this.data.persistent, this.requestAnchorPending = !this.data.persistent;
                },
                tick: function() {
                  var l = this.el.sceneEl, d = l.renderer.xr, p, c, g, A = this.el.object3D;
                  !l.is("ar-mode") && !l.is("vr-mode") || (!this.anchor && this.requestPersistentAnchorPending && this.restorePersistentAnchor(), !this.anchor && this.requestAnchorPending && this.createAnchor(), this.anchor && (p = l.frame, c = d.getReferenceSpace(), g = p.getPose(this.anchor.anchorSpace, c), A.matrix.elements = g.transform.matrix, A.matrix.decompose(A.position, A.rotation, A.scale)));
                },
                createAnchor: async function(d, p) {
                  var c = this.el.sceneEl, g = c.renderer.xr, A, u, f, x, T = this.el.object3D;
                  if (d = d || T.position, p = p || this.auxQuaternion.setFromEuler(T.rotation), !y(c)) {
                    E("This browser doesn't support the WebXR anchors module");
                    return;
                  }
                  this.anchor && this.deleteAnchor(), A = c.frame, u = g.getReferenceSpace(), f = new XRRigidTransform({
                    x: d.x,
                    y: d.y,
                    z: d.z
                  }, {
                    x: p.x,
                    y: p.y,
                    z: p.z,
                    w: p.w
                  }), this.requestAnchorPending = !1, x = await A.createAnchor(f, u), this.data.persistent && (this.el.id ? (this.persistentHandle = await x.requestPersistentHandle(), localStorage.setItem(this.el.id, this.persistentHandle)) : E("The anchor won't be persisted because the entity has no assigned id.")), c.object3D.attach(this.el.object3D), this.anchor = x;
                },
                restorePersistentAnchor: async function() {
                  var d = this.el.sceneEl.renderer.xr, p = d.getSession(), c = p.persistentAnchors, g;
                  if (this.requestPersistentAnchorPending = !1, !this.el.id) {
                    E("The entity associated to the persistent anchor cannot be retrieved because it doesn't have an assigned id."), this.requestAnchorPending = !0;
                    return;
                  }
                  if (c) {
                    g = localStorage.getItem(this.el.id);
                    for (var A = 0; A < c.length; ++A)
                      if (g === c[A]) {
                        this.anchor = await p.restorePersistentAnchor(c[A]), this.anchor && (this.persistentHandle = c[A]);
                        break;
                      }
                    this.anchor || (this.requestAnchorPending = !0);
                  } else
                    this.requestPersistentAnchorPending = !0;
                },
                deleteAnchor: function() {
                  var l, d, p = this.anchor;
                  p && (l = this.el.sceneEl.renderer.xr, d = l.getSession(), p.delete(), this.el.sceneEl.object3D.add(this.el.object3D), this.persistentHandle && d.deletePersistentAnchor(this.persistentHandle), this.anchor = void 0);
                }
              });
              function y(l) {
                var d = l.renderer.xr, p = d.getSession();
                return p && p.restorePersistentAnchor;
              }
            }
          ),
          /***/
          "./src/components/animation.js": (
            /*!*************************************!*\
              !*** ./src/components/animation.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! super-animejs */
                "./node_modules/super-animejs/lib/anime.es.js"
              ).default, w = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).components, E = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, y = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), l = v(
                /*! ../utils */
                "./src/utils/index.js"
              ), d = new y.Color(), p = new y.Color(), c = l.entity.getComponentProperty, g = l.entity.setComponentProperty, A = {}, u = "color", f = "position", x = "rotation", T = "scale", b = "components", D = "object3D";
              j.exports.Component = E("animation", {
                schema: {
                  autoplay: {
                    default: !0
                  },
                  delay: {
                    default: 0
                  },
                  dir: {
                    default: ""
                  },
                  dur: {
                    default: 1e3
                  },
                  easing: {
                    default: "easeInQuad"
                  },
                  elasticity: {
                    default: 400
                  },
                  enabled: {
                    default: !0
                  },
                  from: {
                    default: ""
                  },
                  loop: {
                    default: 0,
                    parse: function(Q) {
                      return Q === !0 || Q === "true" ? !0 : Q === !1 || Q === "false" ? !1 : parseInt(Q, 10);
                    }
                  },
                  property: {
                    default: ""
                  },
                  startEvents: {
                    type: "array"
                  },
                  pauseEvents: {
                    type: "array"
                  },
                  resumeEvents: {
                    type: "array"
                  },
                  round: {
                    default: !1
                  },
                  to: {
                    default: ""
                  },
                  type: {
                    default: ""
                  },
                  isRawProperty: {
                    default: !1
                  }
                },
                multiple: !0,
                init: function() {
                  var Q = this;
                  this.eventDetail = {
                    name: this.attrName
                  }, this.time = 0, this.animation = null, this.animationIsPlaying = !1, this.onStartEvent = this.onStartEvent.bind(this), this.beginAnimation = this.beginAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.resumeAnimation = this.resumeAnimation.bind(this), this.fromColor = {}, this.toColor = {}, this.targets = {}, this.targetsArray = [], this.updateConfigForDefault = this.updateConfigForDefault.bind(this), this.updateConfigForRawColor = this.updateConfigForRawColor.bind(this), this.config = {
                    complete: function() {
                      Q.animationIsPlaying = !1, Q.el.emit("animationcomplete", Q.eventDetail, !1), Q.id && Q.el.emit("animationcomplete__" + Q.id, Q.eventDetail, !1);
                    }
                  };
                },
                update: function(Q) {
                  var O = this.config, K = this.data;
                  this.animationIsPlaying = !1, this.data.enabled && K.property && (O.autoplay = !1, O.direction = K.dir, O.duration = K.dur, O.easing = K.easing, O.elasticity = K.elasticity, O.loop = K.loop, O.round = K.round, this.createAndStartAnimation());
                },
                tick: function(Q, O) {
                  this.animationIsPlaying && (this.time += O, this.animation.tick(this.time));
                },
                remove: function() {
                  this.pauseAnimation(), this.removeEventListeners();
                },
                pause: function() {
                  this.paused = !0, this.pausedWasPlaying = this.animationIsPlaying, this.pauseAnimation(), this.removeEventListeners();
                },
                /**
                 * `play` handler only for resuming scene.
                 */
                play: function() {
                  this.paused && (this.paused = !1, this.addEventListeners(), this.pausedWasPlaying && (this.resumeAnimation(), this.pausedWasPlaying = !1));
                },
                /**
                 * Start animation from scratch.
                 */
                createAndStartAnimation: function() {
                  var Q = this.data;
                  if (this.updateConfig(), this.animationIsPlaying = !1, this.animation = C(this.config), this.animation.began = !0, this.removeEventListeners(), this.addEventListeners(), !(!Q.autoplay || Q.startEvents && Q.startEvents.length)) {
                    if (Q.delay) {
                      setTimeout(this.beginAnimation, Q.delay);
                      return;
                    }
                    this.beginAnimation();
                  }
                },
                /**
                 * This is before animation start (including from startEvents).
                 * Set to initial state (config.from, time = 0, seekTime = 0).
                 */
                beginAnimation: function() {
                  this.updateConfig(), this.animation.began = !0, this.time = 0, this.animationIsPlaying = !0, this.stopRelatedAnimations(), this.el.emit("animationbegin", this.eventDetail, !1);
                },
                pauseAnimation: function() {
                  this.animationIsPlaying = !1;
                },
                resumeAnimation: function() {
                  this.animationIsPlaying = !0;
                },
                /**
                 * startEvents callback.
                 */
                onStartEvent: function() {
                  if (this.data.enabled) {
                    if (this.updateConfig(), this.animation && this.animation.pause(), this.animation = C(this.config), this.data.delay) {
                      setTimeout(this.beginAnimation, this.data.delay);
                      return;
                    }
                    this.beginAnimation();
                  }
                },
                /**
                 * rawProperty: true and type: color;
                 */
                updateConfigForRawColor: function() {
                  var Q = this.config, O = this.data, K = this.el, ne, pe, be;
                  if (!this.waitComponentInitRawProperty(this.updateConfigForRawColor)) {
                    ne = O.from === "" ? W(K, O.property) : O.from, be = O.to, this.setColorConfig(ne, be), ne = this.fromColor, be = this.toColor, this.targetsArray.length = 0, this.targetsArray.push(ne), Q.targets = this.targetsArray;
                    for (pe in be)
                      Q[pe] = be[pe];
                    Q.update = /* @__PURE__ */ function() {
                      var Te = {};
                      return function(ke) {
                        var Ve;
                        Ve = ke.animatables[0].target, !(Ve.r === Te.r && Ve.g === Te.g && Ve.b === Te.b) && ie(K, O.property, Ve, O.type);
                      };
                    }();
                  }
                },
                /**
                 * Stuff property into generic `property` key.
                 */
                updateConfigForDefault: function() {
                  var Q = this.config, O = this.data, K = this.el, ne, pe, be, Te;
                  this.waitComponentInitRawProperty(this.updateConfigForDefault) || (O.from === "" ? ne = X(O) ? W(K, O.property) : c(K, O.property) : ne = O.from, Te = O.to, be = !isNaN(ne || Te), be ? (ne = parseFloat(ne), Te = parseFloat(Te)) : (ne = ne && ne.toString(), Te = Te && Te.toString()), pe = O.to === "true" || O.to === "false" || O.to === !0 || O.to === !1, pe && (ne = O.from === "true" || O.from === !0 ? 1 : 0, Te = O.to === "true" || O.to === !0 ? 1 : 0), this.targets.aframeProperty = ne, Q.targets = this.targets, Q.aframeProperty = Te, Q.update = /* @__PURE__ */ function() {
                    var ke;
                    return function(Ve) {
                      var st;
                      st = Ve.animatables[0].target.aframeProperty, st !== ke && (ke = st, pe && (st = st >= 1), X(O) ? ie(K, O.property, st, O.type) : g(K, O.property, st));
                    };
                  }());
                },
                /**
                 * Extend x/y/z/w onto the config.
                 * Update vector by modifying object3D.
                 */
                updateConfigForVector: function() {
                  var Q = this.config, O = this.data, K = this.el, ne, pe, be;
                  pe = O.from !== "" ? l.coordinates.parse(O.from) : c(K, O.property), be = l.coordinates.parse(O.to), O.property === x && (U(pe), U(be)), this.targetsArray.length = 0, this.targetsArray.push(pe), Q.targets = this.targetsArray;
                  for (ne in be)
                    Q[ne] = be[ne];
                  if (O.property === f || O.property === x || O.property === T) {
                    Q.update = /* @__PURE__ */ function() {
                      var Te = {};
                      return function(ke) {
                        var Ve = ke.animatables[0].target;
                        Ve.x === Te.x && Ve.y === Te.y && Ve.z === Te.z || (Te.x = Ve.x, Te.y = Ve.y, Te.z = Ve.z, K.object3D[O.property].set(Ve.x, Ve.y, Ve.z));
                      };
                    }();
                    return;
                  }
                  Q.update = /* @__PURE__ */ function() {
                    var Te = {};
                    return function(ke) {
                      var Ve = ke.animatables[0].target;
                      Ve.x === Te.x && Ve.y === Te.y && Ve.z === Te.z || (Te.x = Ve.x, Te.y = Ve.y, Te.z = Ve.z, g(K, O.property, Ve));
                    };
                  }();
                },
                /**
                 * Update the config before each run.
                 */
                updateConfig: function() {
                  var Q;
                  Q = S(this.el, this.data.property), X(this.data) && this.data.type === u ? this.updateConfigForRawColor() : Q === "vec2" || Q === "vec3" || Q === "vec4" ? this.updateConfigForVector() : this.updateConfigForDefault();
                },
                /**
                 * Wait for component to initialize.
                 */
                waitComponentInitRawProperty: function(Q) {
                  var O, K = this.data, ne = this.el, pe = this;
                  return K.from !== "" || !K.property.startsWith(b) || (O = te(K.property)[1], ne.components[O]) ? !1 : (ne.addEventListener("componentinitialized", function be(Te) {
                    Te.detail.name === O && (Q(), pe.animation = C(pe.config), ne.removeEventListener("componentinitialized", be));
                  }), !0);
                },
                /**
                 * Make sure two animations on the same property don't fight each other.
                 * e.g., animation__mouseenter="property: material.opacity"
                 *       animation__mouseleave="property: material.opacity"
                 */
                stopRelatedAnimations: function() {
                  var Q, O;
                  for (O in this.el.components)
                    Q = this.el.components[O], O !== this.attrName && Q.name === "animation" && Q.animationIsPlaying && Q.data.property === this.data.property && (Q.animationIsPlaying = !1);
                },
                addEventListeners: function() {
                  var Q = this.data, O = this.el;
                  G(O, Q.startEvents, this.onStartEvent), G(O, Q.pauseEvents, this.pauseAnimation), G(O, Q.resumeEvents, this.resumeAnimation);
                },
                removeEventListeners: function() {
                  var Q = this.data, O = this.el;
                  Z(O, Q.startEvents, this.onStartEvent), Z(O, Q.pauseEvents, this.pauseAnimation), Z(O, Q.resumeEvents, this.resumeAnimation);
                },
                setColorConfig: function(Q, O) {
                  d.set(Q), p.set(O), Q = this.fromColor, O = this.toColor, Q.r = d.r, Q.g = d.g, Q.b = d.b, O.r = p.r, O.g = p.g, O.b = p.b;
                }
              });
              function S(Q, O) {
                var K, ne, pe, be;
                return pe = O.split("."), ne = pe[0], be = pe[1], K = Q.components[ne] || w[ne], !K || be && !K.schema[be] ? null : be ? K.schema[be].type : K.schema.type;
              }
              function U(Q) {
                Q.x = y.MathUtils.degToRad(Q.x), Q.y = y.MathUtils.degToRad(Q.y), Q.z = y.MathUtils.degToRad(Q.z);
              }
              function G(Q, O, K) {
                var ne;
                for (ne = 0; ne < O.length; ne++)
                  Q.addEventListener(O[ne], K);
              }
              function Z(Q, O, K) {
                var ne;
                for (ne = 0; ne < O.length; ne++)
                  Q.removeEventListener(O[ne], K);
              }
              function W(Q, O) {
                var K, ne, pe;
                for (ne = te(O), pe = Q, K = 0; K < ne.length; K++)
                  pe = pe[ne[K]];
                if (pe === void 0)
                  throw console.log(Q), new Error("[animation] property (" + O + ") could not be found");
                return pe;
              }
              function ie(Q, O, K, ne) {
                var pe, be, Te, ke;
                for (O.startsWith("object3D.rotation") && (K = y.MathUtils.degToRad(K)), be = te(O), ke = Q, pe = 0; pe < be.length - 1; pe++)
                  ke = ke[be[pe]];
                if (Te = be[be.length - 1], ne === u) {
                  "r" in ke[Te] ? (ke[Te].r = K.r, ke[Te].g = K.g, ke[Te].b = K.b) : (ke[Te].x = K.r, ke[Te].y = K.g, ke[Te].z = K.b);
                  return;
                }
                ke[Te] = K;
              }
              function te(Q) {
                return Q in A || (A[Q] = Q.split(".")), A[Q];
              }
              function X(Q) {
                return Q.isRawProperty || Q.property.startsWith(b) || Q.property.startsWith(D);
              }
            }
          ),
          /***/
          "./src/components/camera.js": (
            /*!**********************************!*\
              !*** ./src/components/camera.js ***!
              \**********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              j.exports.Component = C("camera", {
                schema: {
                  active: {
                    default: !0
                  },
                  far: {
                    default: 1e4
                  },
                  fov: {
                    default: 80,
                    min: 0
                  },
                  near: {
                    default: 5e-3,
                    min: 0
                  },
                  spectator: {
                    default: !1
                  },
                  zoom: {
                    default: 1,
                    min: 0
                  }
                },
                /**
                 * Initialize three.js camera and add it to the entity.
                 * Add reference from scene to this entity as the camera.
                 */
                init: function() {
                  var E, y = this.el;
                  E = this.camera = new w.PerspectiveCamera(), y.setObject3D("camera", E);
                },
                /**
                 * Update three.js camera.
                 */
                update: function(E) {
                  var y = this.data, l = this.camera;
                  l.aspect = y.aspect || window.innerWidth / window.innerHeight, l.far = y.far, l.fov = y.fov, l.near = y.near, l.zoom = y.zoom, l.updateProjectionMatrix(), this.updateActiveCamera(E), this.updateSpectatorCamera(E);
                },
                updateActiveCamera: function(E) {
                  var y = this.data, l = this.el, d = this.system;
                  E && E.active === y.active || y.spectator || (y.active && d.activeCameraEl !== l ? d.setActiveCamera(l) : !y.active && d.activeCameraEl === l && d.disableActiveCamera());
                },
                updateSpectatorCamera: function(E) {
                  var y = this.data, l = this.el, d = this.system;
                  E && E.spectator === y.spectator || (y.spectator && d.spectatorCameraEl !== l ? d.setSpectatorCamera(l) : !y.spectator && d.spectatorCameraEl === l && d.disableSpectatorCamera());
                },
                /**
                 * Remove camera on remove (callback).
                 */
                remove: function() {
                  this.el.removeObject3D("camera");
                }
              });
            }
          ),
          /***/
          "./src/components/cursor.js": (
            /*!**********************************!*\
              !*** ./src/components/cursor.js ***!
              \**********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), E = {
                CLICK: "click",
                FUSING: "fusing",
                MOUSEENTER: "mouseenter",
                MOUSEDOWN: "mousedown",
                MOUSELEAVE: "mouseleave",
                MOUSEUP: "mouseup"
              }, y = {
                FUSING: "cursor-fusing",
                HOVERING: "cursor-hovering",
                HOVERED: "cursor-hovered"
              }, l = {
                DOWN: ["mousedown", "touchstart"],
                UP: ["mouseup", "touchend"]
              }, d = {
                DOWN: ["selectstart"],
                UP: ["selectend"]
              }, p = "a-mouse-cursor-hover";
              j.exports.Component = C("cursor", {
                dependencies: ["raycaster"],
                schema: {
                  downEvents: {
                    default: []
                  },
                  fuse: {
                    default: w.device.isMobile()
                  },
                  fuseTimeout: {
                    default: 1500,
                    min: 0
                  },
                  mouseCursorStylesEnabled: {
                    default: !0
                  },
                  upEvents: {
                    default: []
                  },
                  rayOrigin: {
                    default: "entity",
                    oneOf: ["mouse", "entity", "xrselect"]
                  }
                },
                after: ["tracked-controls"],
                multiple: !0,
                init: function() {
                  var c = this;
                  this.fuseTimeout = void 0, this.cursorDownEl = null, this.intersectedEl = null, this.canvasBounds = document.body.getBoundingClientRect(), this.isCursorDown = !1, this.activeXRInput = null, this.updateCanvasBounds = w.debounce(function() {
                    c.canvasBounds = c.el.sceneEl.canvas.getBoundingClientRect();
                  }, 500), this.eventDetail = {}, this.intersectedEventDetail = {
                    cursorEl: this.el
                  }, this.onCursorDown = this.onCursorDown.bind(this), this.onCursorUp = this.onCursorUp.bind(this), this.onIntersection = this.onIntersection.bind(this), this.onIntersectionCleared = this.onIntersectionCleared.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onEnterVR = this.onEnterVR.bind(this);
                },
                update: function(c) {
                  this.data.rayOrigin !== c.rayOrigin && this.updateMouseEventListeners();
                },
                tick: function() {
                  var c = this.el.sceneEl.frame, g = this.activeXRInput;
                  this.data.rayOrigin === "xrselect" && c && g && this.onMouseMove({
                    frame: c,
                    inputSource: g,
                    type: "fakeselectevent"
                  });
                },
                play: function() {
                  this.addEventListeners();
                },
                pause: function() {
                  this.removeEventListeners();
                },
                remove: function() {
                  var c = this.el;
                  c.removeState(y.HOVERING), c.removeState(y.FUSING), clearTimeout(this.fuseTimeout), this.intersectedEl && this.intersectedEl.removeState(y.HOVERED), this.removeEventListeners();
                },
                addEventListeners: function() {
                  var c, g = this.data, A = this.el, u = this;
                  function f() {
                    c = A.sceneEl.canvas, !(g.downEvents.length || g.upEvents.length) && (l.DOWN.forEach(function(x) {
                      c.addEventListener(x, u.onCursorDown, {
                        passive: !1
                      });
                    }), l.UP.forEach(function(x) {
                      c.addEventListener(x, u.onCursorUp, {
                        passive: !1
                      });
                    }));
                  }
                  c = A.sceneEl.canvas, c ? f() : A.sceneEl.addEventListener("render-target-loaded", f), g.downEvents.forEach(function(x) {
                    A.addEventListener(x, u.onCursorDown);
                  }), g.upEvents.forEach(function(x) {
                    A.addEventListener(x, u.onCursorUp);
                  }), A.addEventListener("raycaster-intersection", this.onIntersection), A.addEventListener("raycaster-closest-entity-changed", this.onIntersection), A.addEventListener("raycaster-intersection-cleared", this.onIntersectionCleared), A.sceneEl.addEventListener("rendererresize", this.updateCanvasBounds), A.sceneEl.addEventListener("enter-vr", this.onEnterVR), window.addEventListener("resize", this.updateCanvasBounds), window.addEventListener("scroll", this.updateCanvasBounds), this.updateMouseEventListeners();
                },
                removeEventListeners: function() {
                  var c, g = this.data, A = this.el, u = this;
                  c = A.sceneEl.canvas, c && !g.downEvents.length && !g.upEvents.length && (l.DOWN.forEach(function(f) {
                    c.removeEventListener(f, u.onCursorDown);
                  }), l.UP.forEach(function(f) {
                    c.removeEventListener(f, u.onCursorUp);
                  })), g.downEvents.forEach(function(f) {
                    A.removeEventListener(f, u.onCursorDown);
                  }), g.upEvents.forEach(function(f) {
                    A.removeEventListener(f, u.onCursorUp);
                  }), A.removeEventListener("raycaster-intersection", this.onIntersection), A.removeEventListener("raycaster-intersection-cleared", this.onIntersectionCleared), c.removeEventListener("mousemove", this.onMouseMove), c.removeEventListener("touchstart", this.onMouseMove), c.removeEventListener("touchmove", this.onMouseMove), A.sceneEl.removeEventListener("rendererresize", this.updateCanvasBounds), A.sceneEl.removeEventListener("enter-vr", this.onEnterVR), window.removeEventListener("resize", this.updateCanvasBounds), window.removeEventListener("scroll", this.updateCanvasBounds);
                },
                updateMouseEventListeners: function() {
                  var c, g = this.el;
                  c = g.sceneEl.canvas, c.removeEventListener("mousemove", this.onMouseMove), c.removeEventListener("touchmove", this.onMouseMove), g.setAttribute("raycaster", "useWorldCoordinates", !1), this.data.rayOrigin === "mouse" && (c.addEventListener("mousemove", this.onMouseMove), c.addEventListener("touchmove", this.onMouseMove, {
                    passive: !1
                  }), g.setAttribute("raycaster", "useWorldCoordinates", !0), this.updateCanvasBounds());
                },
                onMouseMove: function() {
                  var c = new THREE.Vector3(), g = new THREE.Vector2(), A = new THREE.Vector3(), u = {
                    origin: A,
                    direction: c
                  };
                  return function(f) {
                    var x = this.canvasBounds, T = this.el.sceneEl.camera, b, D, S, U, G, Z, W, ie;
                    T.parent.updateMatrixWorld(), f.type === "touchmove" || f.type === "touchstart" ? D = f.touches.item(0) : D = f, b = D.clientX - x.left, S = D.clientY - x.top, g.x = b / x.width * 2 - 1, g.y = -(S / x.height) * 2 + 1, this.data.rayOrigin === "xrselect" && (f.type === "selectstart" || f.type === "fakeselectevent") ? (U = f.frame, G = f.inputSource, Z = this.el.renderer.xr.getReferenceSpace(), W = U.getPose(G.targetRaySpace, Z), ie = W.transform, c.set(0, 0, -1), c.applyQuaternion(ie.orientation), A.copy(ie.position)) : f.type === "fakeselectout" ? (c.set(0, 1, 0), A.set(0, 9999, 0)) : T && T.isPerspectiveCamera ? (A.setFromMatrixPosition(T.matrixWorld), c.set(g.x, g.y, 0.5).unproject(T).sub(A).normalize()) : T && T.isOrthographicCamera ? (A.set(g.x, g.y, (T.near + T.far) / (T.near - T.far)).unproject(T), c.set(0, 0, -1).transformDirection(T.matrixWorld)) : console.error("AFRAME.Raycaster: Unsupported camera type: " + T.type), this.el.setAttribute("raycaster", u), f.type === "touchmove" && f.preventDefault();
                  };
                }(),
                /**
                 * Trigger mousedown and keep track of the mousedowned entity.
                 */
                onCursorDown: function(c) {
                  this.isCursorDown = !0, this.data.rayOrigin === "mouse" && c.type === "touchstart" && (this.onMouseMove(c), this.el.components.raycaster.checkIntersections(), c.preventDefault()), this.data.rayOrigin === "xrselect" && c.type === "selectstart" && (this.activeXRInput = c.inputSource, this.onMouseMove(c), this.el.components.raycaster.checkIntersections(), this.el.components.raycaster.intersectedEls.length && this.el.sceneEl.components["ar-hit-test"] !== void 0 && this.el.sceneEl.getAttribute("ar-hit-test").enabled && (this.el.sceneEl.setAttribute("ar-hit-test", "enabled", !1), this.reenableARHitTest = !0)), this.twoWayEmit(E.MOUSEDOWN, c), this.cursorDownEl = this.intersectedEl;
                },
                /**
                 * Trigger mouseup if:
                 * - Not fusing (mobile has no mouse).
                 * - Currently intersecting an entity.
                 * - Currently-intersected entity is the same as the one when mousedown was triggered,
                 *   in case user mousedowned one entity, dragged to another, and mouseupped.
                 */
                onCursorUp: function(c) {
                  if (this.isCursorDown) {
                    this.isCursorDown = !1;
                    var g = this.data;
                    this.twoWayEmit(E.MOUSEUP, c), this.reenableARHitTest === !0 && (this.el.sceneEl.setAttribute("ar-hit-test", "enabled", !0), this.reenableARHitTest = void 0), this.cursorDownEl && this.cursorDownEl !== this.intersectedEl && (this.intersectedEventDetail.intersection = null, this.cursorDownEl.emit(E.MOUSEUP, this.intersectedEventDetail)), (!g.fuse || g.rayOrigin === "mouse" || g.rayOrigin === "xrselect") && this.intersectedEl && this.cursorDownEl === this.intersectedEl && this.twoWayEmit(E.CLICK, c), g.rayOrigin === "xrselect" && this.activeXRInput === c.inputSource && this.onMouseMove({
                      type: "fakeselectout"
                    }), this.activeXRInput = null, this.cursorDownEl = null, c.type === "touchend" && c.preventDefault();
                  }
                },
                /**
                 * Handle intersection.
                 */
                onIntersection: function(c) {
                  var g, A = this.el, u, f, x;
                  u = c.detail.els[0] === A ? 1 : 0, x = c.detail.intersections[u], f = c.detail.els[u], f && this.intersectedEl !== f && (this.intersectedEl && (g = this.el.components.raycaster.getIntersection(this.intersectedEl), g && g.distance <= x.distance) || (this.clearCurrentIntersection(!0), this.setIntersection(f, x)));
                },
                /**
                 * Handle intersection cleared.
                 */
                onIntersectionCleared: function(c) {
                  var g = c.detail.clearedEls;
                  g.indexOf(this.intersectedEl) !== -1 && this.clearCurrentIntersection();
                },
                onEnterVR: function() {
                  this.clearCurrentIntersection(!0);
                  var c = this.el.sceneEl.xrSession, g = this;
                  c && this.data.rayOrigin !== "mouse" && (d.DOWN.forEach(function(A) {
                    c.addEventListener(A, g.onCursorDown);
                  }), d.UP.forEach(function(A) {
                    c.addEventListener(A, g.onCursorUp);
                  }));
                },
                setIntersection: function(c, g) {
                  var A = this.el, u = this.data, f = this;
                  this.intersectedEl !== c && (this.intersectedEl = c, A.addState(y.HOVERING), c.addState(y.HOVERED), this.twoWayEmit(E.MOUSEENTER), this.data.mouseCursorStylesEnabled && this.data.rayOrigin === "mouse" && this.el.sceneEl.canvas.classList.add(p), !(u.fuseTimeout === 0 || !u.fuse || u.rayOrigin === "xrselect" || u.rayOrigin === "mouse") && (A.addState(y.FUSING), this.twoWayEmit(E.FUSING), this.fuseTimeout = setTimeout(function() {
                    A.removeState(y.FUSING), f.twoWayEmit(E.CLICK);
                  }, u.fuseTimeout)));
                },
                clearCurrentIntersection: function(c) {
                  var g, A, u, f = this.el;
                  this.intersectedEl && (this.intersectedEl.removeState(y.HOVERED), f.removeState(y.HOVERING), f.removeState(y.FUSING), this.twoWayEmit(E.MOUSELEAVE), this.data.mouseCursorStylesEnabled && this.data.rayOrigin === "mouse" && this.el.sceneEl.canvas.classList.remove(p), this.intersectedEl = null, clearTimeout(this.fuseTimeout), c !== !0 && (u = this.el.components.raycaster.intersections, u.length !== 0 && (g = u[0].object.el === f ? 1 : 0, A = u[g], A && this.setIntersection(A.object.el, A))));
                },
                /**
                 * Helper to emit on both the cursor and the intersected entity (if exists).
                 */
                twoWayEmit: function(c, g) {
                  var A = this.el, u = this.intersectedEl, f;
                  function x(T, b) {
                    g instanceof MouseEvent ? T.mouseEvent = g : typeof TouchEvent < "u" && g instanceof TouchEvent && (T.touchEvent = g);
                  }
                  f = this.el.components.raycaster.getIntersection(u), this.eventDetail.intersectedEl = u, this.eventDetail.intersection = f, x(this.eventDetail), A.emit(c, this.eventDetail), u && (this.intersectedEventDetail.intersection = f, x(this.intersectedEventDetail), u.emit(c, this.intersectedEventDetail));
                }
              });
            }
          ),
          /***/
          "./src/components/generic-tracked-controller-controls.js": (
            /*!***************************************************************!*\
              !*** ./src/components/generic-tracked-controller-controls.js ***!
              \***************************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), E = w.checkControllerPresentAndSetup, y = w.emitIfAxesChanged, l = w.onButtonEvent, d = "generic", p = {
                axes: {
                  touchpad: [0, 1],
                  thumbstick: [2, 3]
                },
                buttons: ["trigger", "squeeze", "touchpad", "thumbstick"]
              };
              j.exports.Component = C("generic-tracked-controller-controls", {
                schema: {
                  hand: {
                    default: ""
                  },
                  // This informs the degenerate arm model.
                  defaultModel: {
                    default: !0
                  },
                  defaultModelColor: {
                    default: "gray"
                  },
                  orientationOffset: {
                    type: "vec3"
                  },
                  disabled: {
                    default: !1
                  }
                },
                after: ["tracked-controls"],
                /**
                 * Button IDs:
                 * 0 - trackpad
                 * 1 - trigger
                 */
                mapping: p,
                bindMethods: function() {
                  this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                init: function() {
                  var c = this;
                  this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(g) {
                    l(g.detail.id, "down", c);
                  }, this.onButtonUp = function(g) {
                    l(g.detail.id, "up", c);
                  }, this.onButtonTouchStart = function(g) {
                    l(g.detail.id, "touchstart", c);
                  }, this.onButtonTouchEnd = function(g) {
                    l(g.detail.id, "touchend", c);
                  }, this.controllerPresent = !1, this.wasControllerConnected = !1, this.lastControllerCheck = 0, this.bindMethods(), this.el.addEventListener("controllerconnected", function(g) {
                    g.detail.name !== c.name && (c.wasControllerConnected = !0, c.removeEventListeners(), c.removeControllersUpdateListener());
                  });
                },
                addEventListeners: function() {
                  var c = this.el;
                  c.addEventListener("buttonchanged", this.onButtonChanged), c.addEventListener("buttondown", this.onButtonDown), c.addEventListener("buttonup", this.onButtonUp), c.addEventListener("touchstart", this.onButtonTouchStart), c.addEventListener("touchend", this.onButtonTouchEnd), c.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var c = this.el;
                  c.removeEventListener("buttonchanged", this.onButtonChanged), c.removeEventListener("buttondown", this.onButtonDown), c.removeEventListener("buttonup", this.onButtonUp), c.removeEventListener("touchstart", this.onButtonTouchStart), c.removeEventListener("touchend", this.onButtonTouchEnd), c.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
                },
                checkIfControllerPresent: function() {
                  var c = this.data, g = c.hand ? c.hand : void 0;
                  E(this, d, {
                    hand: g,
                    iterateControllerProfiles: !0
                  });
                },
                play: function() {
                  this.wasControllerConnected || (this.checkIfControllerPresent(), this.addControllersUpdateListener());
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                injectTrackedControls: function() {
                  var c = this.el, g = this.data;
                  if (this.el.components["tracked-controls"]) {
                    this.removeEventListeners();
                    return;
                  }
                  c.setAttribute("tracked-controls", {
                    hand: g.hand,
                    idPrefix: d,
                    orientationOffset: g.orientationOffset,
                    iterateControllerProfiles: !0
                  }), this.data.defaultModel && this.initDefaultModel();
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.wasControllerConnected && this.checkIfControllerPresent();
                },
                onButtonChanged: function(c) {
                  var g = this.mapping.buttons[c.detail.id];
                  g && this.el.emit(g + "changed", c.detail.state);
                },
                onAxisMoved: function(c) {
                  y(this, this.mapping.axes, c);
                },
                initDefaultModel: function() {
                  var c = this.modelEl = document.createElement("a-entity");
                  c.setAttribute("geometry", {
                    primitive: "sphere",
                    radius: 0.03
                  }), c.setAttribute("material", {
                    color: this.data.color
                  }), this.el.appendChild(c), this.el.emit("controllermodelready", {
                    name: "generic-tracked-controller-controls",
                    model: this.modelEl,
                    rayOrigin: {
                      origin: {
                        x: 0,
                        y: 0,
                        z: -0.01
                      },
                      direction: {
                        x: 0,
                        y: 0,
                        z: -1
                      }
                    }
                  });
                }
              });
            }
          ),
          /***/
          "./src/components/geometry.js": (
            /*!************************************!*\
              !*** ./src/components/geometry.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).geometries, w = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).geometryNames, E = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, y = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), l = new y.BufferGeometry();
              j.exports.Component = E("geometry", {
                schema: {
                  buffer: {
                    default: !0
                  },
                  primitive: {
                    default: "box",
                    oneOf: w,
                    schemaChange: !0
                  },
                  skipCache: {
                    default: !1
                  }
                },
                init: function() {
                  this.geometry = null;
                },
                /**
                 * Talk to geometry system to get or create geometry.
                 */
                update: function(d) {
                  var p = this.data, c = this.el, g, A = this.system;
                  this.geometry && (A.unuseGeometry(d), this.geometry = null), this.geometry = A.getOrCreateGeometry(p), g = c.getObject3D("mesh"), g ? g.geometry = this.geometry : (g = new y.Mesh(), g.geometry = this.geometry, this.el.getAttribute("material") || (g.material = new y.MeshStandardMaterial({
                    color: Math.random() * 16777215,
                    metalness: 0,
                    roughness: 0.5
                  })), c.setObject3D("mesh", g));
                },
                /**
                 * Tell geometry system that entity is no longer using the geometry.
                 * Unset the geometry on the mesh
                 */
                remove: function() {
                  this.system.unuseGeometry(this.data), this.el.getObject3D("mesh").geometry = l, this.geometry = null;
                },
                /**
                 * Update geometry component schema based on geometry type.
                 */
                updateSchema: function(d) {
                  var p = this.oldData && this.oldData.primitive, c = d.primitive, g = C[c] && C[c].schema;
                  if (!g)
                    throw new Error("Unknown geometry schema `" + c + "`");
                  p && p === c || this.extendSchema(g);
                }
              });
            }
          ),
          /***/
          "./src/components/gltf-model.js": (
            /*!**************************************!*\
              !*** ./src/components/gltf-model.js ***!
              \**************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), y = E.debug("components:gltf-model:warn");
              j.exports.Component = C("gltf-model", {
                schema: {
                  type: "model"
                },
                init: function() {
                  var l = this, d = this.system.getDRACOLoader(), p = this.system.getMeshoptDecoder(), c = this.system.getKTX2Loader();
                  this.model = null, this.loader = new w.GLTFLoader(), d && this.loader.setDRACOLoader(d), p ? this.ready = p.then(function(g) {
                    l.loader.setMeshoptDecoder(g);
                  }) : this.ready = Promise.resolve(), c && this.loader.setKTX2Loader(c);
                },
                update: function() {
                  var l = this, d = this.el, p = this.data;
                  p && (this.remove(), this.ready.then(function() {
                    l.loader.load(p, function(g) {
                      l.model = g.scene || g.scenes[0], l.model.animations = g.animations, d.setObject3D("mesh", l.model), d.emit("model-loaded", {
                        format: "gltf",
                        model: l.model
                      });
                    }, void 0, function(g) {
                      var A = g && g.message ? g.message : "Failed to load glTF model";
                      y(A), d.emit("model-error", {
                        format: "gltf",
                        src: p
                      });
                    });
                  }));
                },
                remove: function() {
                  this.model && this.el.removeObject3D("mesh");
                }
              });
            }
          ),
          /***/
          "./src/components/grabbable.js": (
            /*!*************************************!*\
              !*** ./src/components/grabbable.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              C("grabbable", {
                init: function() {
                  this.el.setAttribute("obb-collider", "centerModel: true");
                }
              });
            }
          ),
          /***/
          "./src/components/hand-controls.js": (
            /*!*****************************************!*\
              !*** ./src/components/hand-controls.js ***!
              \*****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, E = {
                toonLeft: w + "controllers/hands/leftHand.glb",
                toonRight: w + "controllers/hands/rightHand.glb",
                lowPolyLeft: w + "controllers/hands/leftHandLow.glb",
                lowPolyRight: w + "controllers/hands/rightHandLow.glb",
                highPolyLeft: w + "controllers/hands/leftHandHigh.glb",
                highPolyRight: w + "controllers/hands/rightHandHigh.glb"
              }, y = {
                open: "Open",
                // point: grip active, trackpad surface active, trigger inactive.
                point: "Point",
                // pointThumb: grip active, trigger inactive, trackpad surface inactive.
                pointThumb: "Point + Thumb",
                // fist: grip active, trigger active, trackpad surface active.
                fist: "Fist",
                // hold: trigger active, grip inactive.
                hold: "Hold",
                // thumbUp: grip active, trigger active, trackpad surface inactive.
                thumbUp: "Thumb Up"
              }, l = {};
              l[y.fist] = "grip", l[y.thumbUp] = "pistol", l[y.point] = "pointing", j.exports.Component = C("hand-controls", {
                schema: {
                  color: {
                    default: "white",
                    type: "color"
                  },
                  hand: {
                    default: "left"
                  },
                  handModelStyle: {
                    default: "lowPoly",
                    oneOf: ["lowPoly", "highPoly", "toon"]
                  }
                },
                after: ["tracked-controls"],
                init: function() {
                  var c = this, g = this.el;
                  this.pressedButtons = {}, this.touchedButtons = {}, this.loader = new THREE.GLTFLoader(), this.loader.setCrossOrigin("anonymous"), this.onGripDown = function() {
                    c.handleButton("grip", "down");
                  }, this.onGripUp = function() {
                    c.handleButton("grip", "up");
                  }, this.onTrackpadDown = function() {
                    c.handleButton("trackpad", "down");
                  }, this.onTrackpadUp = function() {
                    c.handleButton("trackpad", "up");
                  }, this.onTrackpadTouchStart = function() {
                    c.handleButton("trackpad", "touchstart");
                  }, this.onTrackpadTouchEnd = function() {
                    c.handleButton("trackpad", "touchend");
                  }, this.onTriggerDown = function() {
                    c.handleButton("trigger", "down");
                  }, this.onTriggerUp = function() {
                    c.handleButton("trigger", "up");
                  }, this.onTriggerTouchStart = function() {
                    c.handleButton("trigger", "touchstart");
                  }, this.onTriggerTouchEnd = function() {
                    c.handleButton("trigger", "touchend");
                  }, this.onGripTouchStart = function() {
                    c.handleButton("grip", "touchstart");
                  }, this.onGripTouchEnd = function() {
                    c.handleButton("grip", "touchend");
                  }, this.onThumbstickDown = function() {
                    c.handleButton("thumbstick", "down");
                  }, this.onThumbstickUp = function() {
                    c.handleButton("thumbstick", "up");
                  }, this.onAorXTouchStart = function() {
                    c.handleButton("AorX", "touchstart");
                  }, this.onAorXTouchEnd = function() {
                    c.handleButton("AorX", "touchend");
                  }, this.onBorYTouchStart = function() {
                    c.handleButton("BorY", "touchstart");
                  }, this.onBorYTouchEnd = function() {
                    c.handleButton("BorY", "touchend");
                  }, this.onSurfaceTouchStart = function() {
                    c.handleButton("surface", "touchstart");
                  }, this.onSurfaceTouchEnd = function() {
                    c.handleButton("surface", "touchend");
                  }, this.onControllerConnected = this.onControllerConnected.bind(this), this.onControllerDisconnected = this.onControllerDisconnected.bind(this), g.addEventListener("controllerconnected", this.onControllerConnected), g.addEventListener("controllerdisconnected", this.onControllerDisconnected), g.object3D.visible = !1;
                },
                play: function() {
                  this.addEventListeners();
                },
                pause: function() {
                  this.removeEventListeners();
                },
                tick: function(c, g) {
                  var A = this.el.getObject3D("mesh");
                  !A || !A.mixer || A.mixer.update(g / 1e3);
                },
                onControllerConnected: function() {
                  this.el.object3D.visible = !0;
                },
                onControllerDisconnected: function() {
                  this.el.object3D.visible = !1;
                },
                addEventListeners: function() {
                  var c = this.el;
                  c.addEventListener("gripdown", this.onGripDown), c.addEventListener("gripup", this.onGripUp), c.addEventListener("trackpaddown", this.onTrackpadDown), c.addEventListener("trackpadup", this.onTrackpadUp), c.addEventListener("trackpadtouchstart", this.onTrackpadTouchStart), c.addEventListener("trackpadtouchend", this.onTrackpadTouchEnd), c.addEventListener("triggerdown", this.onTriggerDown), c.addEventListener("triggerup", this.onTriggerUp), c.addEventListener("triggertouchstart", this.onTriggerTouchStart), c.addEventListener("triggertouchend", this.onTriggerTouchEnd), c.addEventListener("griptouchstart", this.onGripTouchStart), c.addEventListener("griptouchend", this.onGripTouchEnd), c.addEventListener("thumbstickdown", this.onThumbstickDown), c.addEventListener("thumbstickup", this.onThumbstickUp), c.addEventListener("abuttontouchstart", this.onAorXTouchStart), c.addEventListener("abuttontouchend", this.onAorXTouchEnd), c.addEventListener("bbuttontouchstart", this.onBorYTouchStart), c.addEventListener("bbuttontouchend", this.onBorYTouchEnd), c.addEventListener("xbuttontouchstart", this.onAorXTouchStart), c.addEventListener("xbuttontouchend", this.onAorXTouchEnd), c.addEventListener("ybuttontouchstart", this.onBorYTouchStart), c.addEventListener("ybuttontouchend", this.onBorYTouchEnd), c.addEventListener("surfacetouchstart", this.onSurfaceTouchStart), c.addEventListener("surfacetouchend", this.onSurfaceTouchEnd);
                },
                removeEventListeners: function() {
                  var c = this.el;
                  c.removeEventListener("gripdown", this.onGripDown), c.removeEventListener("gripup", this.onGripUp), c.removeEventListener("trackpaddown", this.onTrackpadDown), c.removeEventListener("trackpadup", this.onTrackpadUp), c.removeEventListener("trackpadtouchstart", this.onTrackpadTouchStart), c.removeEventListener("trackpadtouchend", this.onTrackpadTouchEnd), c.removeEventListener("triggerdown", this.onTriggerDown), c.removeEventListener("triggerup", this.onTriggerUp), c.removeEventListener("triggertouchstart", this.onTriggerTouchStart), c.removeEventListener("triggertouchend", this.onTriggerTouchEnd), c.removeEventListener("griptouchstart", this.onGripTouchStart), c.removeEventListener("griptouchend", this.onGripTouchEnd), c.removeEventListener("thumbstickdown", this.onThumbstickDown), c.removeEventListener("thumbstickup", this.onThumbstickUp), c.removeEventListener("abuttontouchstart", this.onAorXTouchStart), c.removeEventListener("abuttontouchend", this.onAorXTouchEnd), c.removeEventListener("bbuttontouchstart", this.onBorYTouchStart), c.removeEventListener("bbuttontouchend", this.onBorYTouchEnd), c.removeEventListener("xbuttontouchstart", this.onAorXTouchStart), c.removeEventListener("xbuttontouchend", this.onAorXTouchEnd), c.removeEventListener("ybuttontouchstart", this.onBorYTouchStart), c.removeEventListener("ybuttontouchend", this.onBorYTouchEnd), c.removeEventListener("surfacetouchstart", this.onSurfaceTouchStart), c.removeEventListener("surfacetouchend", this.onSurfaceTouchEnd);
                },
                /**
                 * Update handler. More like the `init` handler since the only property is the hand, and
                 * that won't be changing much.
                 */
                update: function(c) {
                  var g, A = this.el, u = this.data.hand, f = this.data.handModelStyle, x = this.data.color, T = this;
                  if (g = {
                    hand: u,
                    model: !1
                  }, u !== c) {
                    var b = E[f + u.charAt(0).toUpperCase() + u.slice(1)];
                    this.loader.load(b, function(D) {
                      var S = D.scene.children[0], U = u === "left" ? Math.PI / 2 : -Math.PI / 2, G = A.sceneEl.hasWebXR ? -Math.PI / 2 : 0;
                      S.mixer = new THREE.AnimationMixer(S), T.clips = D.animations, A.setObject3D("mesh", S), S.traverse(function(Z) {
                        Z.isMesh && (Z.material.color = new THREE.Color(x));
                      }), S.position.set(0, 0, 0), S.rotation.set(G, 0, U), A.setAttribute("magicleap-controls", g), A.setAttribute("vive-controls", g), A.setAttribute("oculus-touch-controls", g), A.setAttribute("pico-controls", g), A.setAttribute("windows-motion-controls", g), A.setAttribute("hp-mixed-reality-controls", g);
                    });
                  }
                },
                remove: function() {
                  this.el.removeObject3D("mesh");
                },
                /**
                 * Play model animation, based on which button was pressed and which kind of event.
                 *
                 * 1. Process buttons.
                 * 2. Determine gesture (this.determineGesture()).
                 * 3. Animation gesture (this.animationGesture()).
                 * 4. Emit gesture events (this.emitGestureEvents()).
                 *
                 * @param {string} button - Name of the button.
                 * @param {string} evt - Type of event for the button (i.e., down/up/touchstart/touchend).
                 */
                handleButton: function(c, g) {
                  var A, u = g === "down", f = g === "touchstart";
                  if (g.indexOf("touch") === 0) {
                    if (f === this.touchedButtons[c])
                      return;
                    this.touchedButtons[c] = f;
                  } else {
                    if (u === this.pressedButtons[c])
                      return;
                    this.pressedButtons[c] = u;
                  }
                  A = this.gesture, this.gesture = this.determineGesture(), this.gesture !== A && (this.animateGesture(this.gesture, A), this.emitGestureEvents(this.gesture, A));
                },
                /**
                 * Determine which pose hand should be in considering active and touched buttons.
                 */
                determineGesture: function() {
                  var c, g = this.pressedButtons.grip, A = this.pressedButtons.surface || this.touchedButtons.surface, u = this.pressedButtons.trackpad || this.touchedButtons.trackpad, f = this.pressedButtons.trigger || this.touchedButtons.trigger, x = this.touchedButtons.AorX || this.touchedButtons.BorY, T = p(this.el.components["tracked-controls"]);
                  return T ? g || f ? c = y.fist : u && (c = y.point) : g ? A || x || u ? c = f ? y.fist : y.point : c = f ? y.thumbUp : y.pointThumb : f && (c = y.hold), c;
                },
                /**
                 * Play corresponding clip to a gesture
                 */
                getClip: function(c) {
                  var g, A;
                  for (A = 0; A < this.clips.length; A++)
                    if (g = this.clips[A], g.name === c)
                      return g;
                },
                /**
                 * Play gesture animation.
                 *
                 * @param {string} gesture - Which pose to animate to. If absent, then animate to open.
                 * @param {string} lastGesture - Previous gesture, to reverse back to open if needed.
                 */
                animateGesture: function(c, g) {
                  if (c) {
                    this.playAnimation(c || y.open, g, !1);
                    return;
                  }
                  this.playAnimation(g, g, !0);
                },
                /**
                 * Emit `hand-controls`-specific events.
                 */
                emitGestureEvents: function(c, g) {
                  var A = this.el, u;
                  g !== c && (u = d(g, !1), u && A.emit(u), u = d(c, !0), u && A.emit(u));
                },
                /**
                * Play hand animation based on button state.
                *
                * @param {string} gesture - Name of the animation as specified by the model.
                * @param {string} lastGesture - Previous pose.
                * @param {boolean} reverse - Whether animation should play in reverse.
                */
                playAnimation: function(c, g, A) {
                  var u, f, x = this.el.getObject3D("mesh"), T;
                  if (x) {
                    if (u = this.getClip(c), T = x.mixer.clipAction(u), A) {
                      T.paused = !1, T.timeScale = -1;
                      return;
                    }
                    if (T.clampWhenFinished = !0, T.loop = THREE.LoopOnce, T.repetitions = 0, T.timeScale = 1, T.time = 0, T.weight = 1, !g) {
                      x.mixer.stopAllAction(), T.play();
                      return;
                    }
                    u = this.getClip(g), T.reset(), T.play(), f = x.mixer.clipAction(u), f.crossFadeTo(T, 0.15, !0);
                  }
                }
              });
              function d(c, g) {
                var A;
                if (c) {
                  if (A = l[c], A === "grip")
                    return A + (g ? "close" : "open");
                  if (A === "point")
                    return A + (g ? "up" : "down");
                  if (A === "pointing" || A === "pistol")
                    return A + (g ? "start" : "end");
                }
              }
              function p(c) {
                var g = c && c.controller, A = g && (g.id && g.id.indexOf("OpenVR ") === 0 || g.profiles && g.profiles[0] && g.profiles[0] === "htc-vive");
                return A;
              }
            }
          ),
          /***/
          "./src/components/hand-tracking-controls.js": (
            /*!**************************************************!*\
              !*** ./src/components/hand-tracking-controls.js ***!
              \**************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../core/a-entity */
                "./src/core/a-entity.js"
              ).AEntity, E = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), y = E.checkControllerPresentAndSetup, l = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, d = l + "controllers/oculus-hands/v4/left.glb", p = l + "controllers/oculus-hands/v4/right.glb", c = ["wrist", "thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip", "index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip", "middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip", "ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip", "pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"], g = 0, A = 4, u = 9, f = 0.015, x = 0.1;
              j.exports.Component = C("hand-tracking-controls", {
                schema: {
                  hand: {
                    default: "right",
                    oneOf: ["left", "right"]
                  },
                  modelStyle: {
                    default: "mesh",
                    oneOf: ["dots", "mesh"]
                  },
                  modelColor: {
                    default: "white"
                  },
                  modelOpacity: {
                    default: 1
                  }
                },
                after: ["tracked-controls"],
                bindMethods: function() {
                  this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this);
                },
                addEventListeners: function() {
                  this.el.addEventListener("model-loaded", this.onModelLoaded);
                  for (var T = 0; T < this.jointEls.length; ++T)
                    this.jointEls[T].object3D.visible = !0;
                },
                removeEventListeners: function() {
                  this.el.removeEventListener("model-loaded", this.onModelLoaded);
                  for (var T = 0; T < this.jointEls.length; ++T)
                    this.jointEls[T].object3D.visible = !1;
                },
                init: function() {
                  var T = this.el.sceneEl, b = T.getAttribute("webxr"), D = b.optionalFeatures;
                  D.indexOf("hand-tracking") === -1 && (D.push("hand-tracking"), T.setAttribute("webxr", b)), this.wristObject3D = new THREE.Object3D(), this.el.sceneEl.object3D.add(this.wristObject3D), this.onModelLoaded = this.onModelLoaded.bind(this), this.onChildAttached = this.onChildAttached.bind(this), this.jointEls = [], this.controllerPresent = !1, this.isPinched = !1, this.pinchEventDetail = {
                    position: new THREE.Vector3(),
                    wristRotation: new THREE.Quaternion()
                  }, this.indexTipPosition = new THREE.Vector3(), this.hasPoses = !1, this.jointPoses = new Float32Array(16 * c.length), this.jointRadii = new Float32Array(c.length), this.bindMethods(), this.updateReferenceSpace = this.updateReferenceSpace.bind(this), this.el.sceneEl.addEventListener("enter-vr", this.updateReferenceSpace), this.el.sceneEl.addEventListener("exit-vr", this.updateReferenceSpace), this.el.addEventListener("child-attached", this.onChildAttached), this.el.object3D.visible = !1, this.wristObject3D.visible = !1;
                },
                onChildAttached: function(T) {
                  this.addChildEntity(T.detail.el);
                },
                update: function() {
                  this.updateModelMaterial();
                },
                updateModelMaterial: function() {
                  var T = this.jointEls, b = this.skinnedMesh, D = this.data.modelOpacity !== 1;
                  b && (this.skinnedMesh.material.color.set(this.data.modelColor), this.skinnedMesh.material.transparent = D, this.skinnedMesh.material.opacity = this.data.modelOpacity);
                  for (var S = 0; S < T.length; S++)
                    T[S].setAttribute("material", {
                      color: this.data.modelColor,
                      transparent: D,
                      opacity: this.data.modelOpacity
                    });
                },
                updateReferenceSpace: function() {
                  var T = this, b = this.el.sceneEl.xrSession;
                  if (this.referenceSpace = void 0, !!b) {
                    var D = T.el.sceneEl.systems.webxr.sessionReferenceSpaceType;
                    b.requestReferenceSpace(D).then(function(S) {
                      T.referenceSpace = S;
                    }).catch(function(S) {
                      throw T.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(D, "tracked-controls-webxr uses reference space " + D), S;
                    });
                  }
                },
                checkIfControllerPresent: function() {
                  var T = this.data, b = T.hand ? T.hand : void 0;
                  y(this, "", {
                    hand: b,
                    iterateControllerProfiles: !0,
                    handTracking: !0
                  });
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                tick: function() {
                  var T = this.el.sceneEl, b = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller, D = T.frame, S = this.el.components["tracked-controls-webxr"], U = this.referenceSpace;
                  !b || !D || !U || !S || (this.hasPoses = !1, b.hand && (this.el.object3D.position.set(0, 0, 0), this.el.object3D.rotation.set(0, 0, 0), this.hasPoses = D.fillPoses(b.hand.values(), U, this.jointPoses) && D.fillJointRadii(b.hand.values(), this.jointRadii), this.updateHandModel(), this.detectGesture(), this.updateWristObject()));
                },
                updateWristObject: function() {
                  var T = new THREE.Matrix4();
                  return function() {
                    var b = this.wristObject3D;
                    !b || !this.hasPoses || (T.fromArray(this.jointPoses, g * 16), b.position.setFromMatrixPosition(T), b.quaternion.setFromRotationMatrix(T));
                  };
                }(),
                updateHandModel: function() {
                  this.data.modelStyle === "dots" && this.updateHandDotsModel(), this.data.modelStyle === "mesh" && this.updateHandMeshModel();
                },
                getBone: function(T) {
                  for (var b = this.bones, D = 0; D < b.length; D++)
                    if (b[D].name === T)
                      return b[D];
                  return null;
                },
                updateHandMeshModel: function() {
                  var T = new THREE.Matrix4();
                  return function() {
                    var b = 0, D = this.jointPoses, S = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller;
                    if (!(!S || !this.mesh) && (this.mesh.visible = !1, !!this.hasPoses))
                      for (var U of S.hand.values()) {
                        var G = this.getBone(U.jointName);
                        G != null && (this.mesh.visible = !0, T.fromArray(D, b * 16), G.position.setFromMatrixPosition(T), G.quaternion.setFromRotationMatrix(T)), b++;
                      }
                  };
                }(),
                updateHandDotsModel: function() {
                  for (var T = this.jointPoses, b = this.jointRadii, D = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller, S, U, G = 0; G < D.hand.size; G++)
                    S = this.jointEls[G], U = S.object3D, S.object3D.visible = this.hasPoses, this.hasPoses && (U.matrix.fromArray(T, G * 16), U.matrix.decompose(U.position, U.rotation, U.scale), S.setAttribute("scale", {
                      x: b[G],
                      y: b[G],
                      z: b[G]
                    }));
                },
                detectGesture: function() {
                  this.detectPinch();
                },
                detectPinch: function() {
                  var T = new THREE.Vector3(), b = new THREE.Matrix4();
                  return function() {
                    var D = this.indexTipPosition, S = this.pinchEventDetail;
                    if (this.hasPoses) {
                      T.setFromMatrixPosition(b.fromArray(this.jointPoses, A * 16)), D.setFromMatrixPosition(b.fromArray(this.jointPoses, u * 16)), S.wristRotation.setFromRotationMatrix(b.fromArray(this.jointPoses, g * 16));
                      var U = D.distanceTo(T);
                      U < f && this.isPinched === !1 && (this.isPinched = !0, this.pinchDistance = U, S.position.copy(D).add(T).multiplyScalar(0.5), this.el.emit("pinchstarted", S)), U > this.pinchDistance + this.pinchDistance * x && this.isPinched === !0 && (this.isPinched = !1, S.position.copy(D).add(T).multiplyScalar(0.5), this.el.emit("pinchended", S)), this.isPinched && (S.position.copy(D).add(T).multiplyScalar(0.5), this.el.emit("pinchmoved", S));
                    }
                  };
                }(),
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                injectTrackedControls: function() {
                  var T = this.el, b = this.data;
                  if (T.setAttribute("tracked-controls", {
                    id: "",
                    hand: b.hand,
                    iterateControllerProfiles: !0,
                    handTrackingEnabled: !0
                  }), this.mesh) {
                    this.mesh !== T.getObject3D("mesh") && T.setObject3D("mesh", this.mesh);
                    return;
                  }
                  this.initDefaultModel();
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  var T = this.el, b;
                  this.checkIfControllerPresent(), b = T.components["tracked-controls"] && T.components["tracked-controls"].controller, this.mesh && b && b.hand && b.hand instanceof XRHand && T.setObject3D("mesh", this.mesh);
                },
                initDefaultModel: function() {
                  var T = this.data;
                  T.modelStyle === "dots" && this.initDotsModel(), T.modelStyle === "mesh" && this.initMeshHandModel(), this.el.object3D.visible = !0, this.wristObject3D.visible = !0;
                },
                initDotsModel: function() {
                  if (this.jointEls.length === 0) {
                    for (var T = 0; T < c.length; ++T) {
                      var b = this.jointEl = document.createElement("a-entity");
                      b.setAttribute("geometry", {
                        primitive: "sphere",
                        radius: 1
                      }), b.object3D.visible = !1, this.el.appendChild(b), this.jointEls.push(b);
                    }
                    this.updateModelMaterial();
                  }
                },
                initMeshHandModel: function() {
                  var T = this.data.hand === "left" ? d : p;
                  this.el.setAttribute("gltf-model", T);
                },
                onModelLoaded: function() {
                  var T = this.mesh = this.el.getObject3D("mesh").children[0], b = this.skinnedMesh = T.getObjectByProperty("type", "SkinnedMesh");
                  this.skinnedMesh && (this.bones = b.skeleton.bones, this.el.removeObject3D("mesh"), T.position.set(0, 0, 0), T.rotation.set(0, 0, 0), b.frustumCulled = !1, b.material = new THREE.MeshStandardMaterial(), this.updateModelMaterial(), this.setupChildrenEntities(), this.el.setObject3D("mesh", T));
                },
                setupChildrenEntities: function() {
                  for (var T = this.el.children, b = 0; b < T.length; ++b)
                    T[b] instanceof w && this.addChildEntity(T[b]);
                },
                addChildEntity: function(T) {
                  T instanceof w && this.wristObject3D.add(T.object3D);
                }
              });
            }
          ),
          /***/
          "./src/components/hand-tracking-grab-controls.js": (
            /*!*******************************************************!*\
              !*** ./src/components/hand-tracking-grab-controls.js ***!
              \*******************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("hand-tracking-grab-controls", {
                schema: {
                  hand: {
                    default: "right",
                    oneOf: ["left", "right"]
                  },
                  color: {
                    type: "color",
                    default: "white"
                  },
                  hoverColor: {
                    type: "color",
                    default: "#538df1"
                  },
                  hoverEnabled: {
                    default: !1
                  }
                },
                init: function() {
                  var E = this.el, y = this.data, l;
                  y.hand === "right" ? l = "components.hand-tracking-controls.bones.3" : l = "components.hand-tracking-controls.bones.21", E.setAttribute("hand-tracking-controls", {
                    hand: y.hand
                  }), E.setAttribute("obb-collider", {
                    trackedObject3D: l,
                    size: 0.04
                  }), this.auxMatrix = new w.Matrix4(), this.auxQuaternion = new w.Quaternion(), this.auxQuaternion2 = new w.Quaternion(), this.auxVector = new w.Vector3(), this.auxVector2 = new w.Vector3(), this.grabbingObjectPosition = new w.Vector3(), this.grabbedObjectPosition = new w.Vector3(), this.grabbedObjectPositionDelta = new w.Vector3(), this.grabDeltaPosition = new w.Vector3(), this.grabInitialRotation = new w.Quaternion(), this.onCollisionStarted = this.onCollisionStarted.bind(this), this.el.addEventListener("obbcollisionstarted", this.onCollisionStarted), this.onCollisionEnded = this.onCollisionEnded.bind(this), this.el.addEventListener("obbcollisionended", this.onCollisionEnded), this.onPinchStarted = this.onPinchStarted.bind(this), this.el.addEventListener("pinchstarted", this.onPinchStarted), this.onPinchEnded = this.onPinchEnded.bind(this), this.el.addEventListener("pinchended", this.onPinchEnded), this.onPinchMoved = this.onPinchMoved.bind(this), this.el.addEventListener("pinchmoved", this.onPinchMoved);
                },
                transferEntityOwnership: function() {
                  for (var E, y = this.el.sceneEl.querySelectorAll("[hand-tracking-grab-controls]"), l = 0; l < y.length; ++l)
                    E = y[l].components["hand-tracking-grab-controls"], E !== this && this.grabbedEl && this.grabbedEl === E.grabbedEl && E.releaseGrabbedEntity();
                  return !1;
                },
                onCollisionStarted: function(E) {
                  var y = E.detail.withEl;
                  this.collidedEl || y.getAttribute("grabbable") && (this.collidedEl = y, this.grabbingObject3D = E.detail.trackedObject3D, this.data.hoverEnabled && this.el.setAttribute("hand-tracking-controls", "modelColor", this.data.hoverColor));
                },
                onCollisionEnded: function() {
                  this.collidedEl = void 0, !this.grabbedEl && (this.grabbingObject3D = void 0, this.data.hoverEnabled && this.el.setAttribute("hand-tracking-controls", "modelColor", this.data.color));
                },
                onPinchStarted: function(E) {
                  this.collidedEl && (this.pinchPosition = E.detail.position, this.wristRotation = E.detail.wristRotation, this.grabbedEl = this.collidedEl, this.transferEntityOwnership(), this.grab());
                },
                onPinchEnded: function() {
                  this.releaseGrabbedEntity();
                },
                onPinchMoved: function(E) {
                  this.wristRotation = E.detail.wristRotation;
                },
                releaseGrabbedEntity: function() {
                  var E = this.grabbedEl;
                  E && (E.object3D.updateMatrixWorld = this.originalUpdateMatrixWorld, E.object3D.matrixAutoUpdate = !0, E.object3D.matrixWorldAutoUpdate = !0, E.object3D.matrixWorld.decompose(this.auxVector, this.auxQuaternion, this.auxVector2), E.object3D.position.copy(this.auxVector), E.object3D.quaternion.copy(this.auxQuaternion), this.el.emit("grabended", {
                    grabbedEl: E
                  }), this.grabbedEl = void 0);
                },
                grab: function() {
                  var E = this.grabbedEl, y;
                  y = E.object3D.getWorldPosition(this.grabbedObjectPosition), this.grabDeltaPosition.copy(y).sub(this.pinchPosition), this.grabInitialRotation.copy(this.auxQuaternion.copy(this.wristRotation).invert()), this.originalUpdateMatrixWorld = E.object3D.updateMatrixWorld, E.object3D.updateMatrixWorld = function() {
                  }, E.object3D.updateMatrixWorldChildren = function(l) {
                    for (var d = this.children, p = 0, c = d.length; p < c; p++) {
                      var g = d[p];
                      (g.matrixWorldAutoUpdate === !0 || l === !0) && g.updateMatrixWorld(!0);
                    }
                  }, E.object3D.matrixAutoUpdate = !1, E.object3D.matrixWorldAutoUpdate = !1, this.el.emit("grabstarted", {
                    grabbedEl: E
                  });
                },
                tock: function() {
                  var E = this.auxMatrix, y = this.auxQuaternion, l = this.auxQuaternion2, d, p = this.grabbedEl;
                  p && (d = p.object3D, d.getWorldQuaternion(l), d.matrixWorld.identity(), E.identity(), E.makeTranslation(this.pinchPosition), d.matrixWorld.multiply(E), E.identity(), E.makeRotationFromQuaternion(y.copy(this.wristRotation).multiply(this.grabInitialRotation)), d.matrixWorld.multiply(E), E.identity(), E.makeTranslation(this.grabDeltaPosition), d.matrixWorld.multiply(E), E.identity(), E.makeRotationFromQuaternion(l), d.matrixWorld.multiply(E), E.makeScale(p.object3D.scale.x, p.object3D.scale.y, p.object3D.scale.z), d.matrixWorld.multiply(E), d.updateMatrixWorldChildren());
                }
              });
            }
          ),
          /***/
          "./src/components/hide-on-enter-ar.js": (
            /*!********************************************!*\
              !*** ./src/components/hide-on-enter-ar.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("hide-on-enter-ar", {
                init: function() {
                  var w = this;
                  this.el.sceneEl.addEventListener("enter-vr", function() {
                    w.el.sceneEl.is("ar-mode") && (w.el.object3D.visible = !1);
                  }), this.el.sceneEl.addEventListener("exit-vr", function() {
                    w.el.object3D.visible = !0;
                  });
                }
              });
            }
          ),
          /***/
          "./src/components/hide-on-enter-vr.js": (
            /*!********************************************!*\
              !*** ./src/components/hide-on-enter-vr.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("hide-on-enter-vr", {
                init: function() {
                  var w = this;
                  this.el.sceneEl.addEventListener("enter-vr", function() {
                    w.el.sceneEl.is("vr-mode") && (w.el.object3D.visible = !1);
                  }), this.el.sceneEl.addEventListener("exit-vr", function() {
                    w.el.object3D.visible = !0;
                  });
                }
              });
            }
          ),
          /***/
          "./src/components/hp-mixed-reality-controls.js": (
            /*!*****************************************************!*\
              !*** ./src/components/hp-mixed-reality-controls.js ***!
              \*****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), y = E.checkControllerPresentAndSetup, l = E.emitIfAxesChanged, d = E.onButtonEvent, p = "hp-mixed-reality", c = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, g = c + "controllers/hp/mixed-reality/", A = {
                x: 0,
                y: 0,
                z: 0.06
              }, u = {
                _x: Math.PI / 4,
                _y: 0,
                _z: 0,
                _order: "XYZ"
              }, f = {
                left: {
                  axes: {
                    touchpad: [2, 3]
                  },
                  buttons: ["trigger", "grip", "none", "thumbstick", "xbutton", "ybutton"]
                },
                right: {
                  axes: {
                    touchpad: [2, 3]
                  },
                  buttons: ["trigger", "grip", "none", "thumbstick", "abutton", "bbutton"]
                }
              };
              j.exports.Component = C("hp-mixed-reality-controls", {
                schema: {
                  hand: {
                    default: "none"
                  },
                  model: {
                    default: !0
                  },
                  orientationOffset: {
                    type: "vec3"
                  }
                },
                mapping: f,
                init: function() {
                  var x = this;
                  this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(T) {
                    d(T.detail.id, "down", x, x.data.hand);
                  }, this.onButtonUp = function(T) {
                    d(T.detail.id, "up", x, x.data.hand);
                  }, this.onButtonTouchEnd = function(T) {
                    d(T.detail.id, "touchend", x, x.data.hand);
                  }, this.onButtonTouchStart = function(T) {
                    d(T.detail.id, "touchstart", x, x.data.hand);
                  }, this.previousButtonValues = {}, this.bindMethods();
                },
                update: function() {
                  var x = this.data;
                  this.controllerIndex = x.hand === "right" ? 0 : x.hand === "left" ? 1 : 2;
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                bindMethods: function() {
                  this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                addEventListeners: function() {
                  var x = this.el;
                  x.addEventListener("buttonchanged", this.onButtonChanged), x.addEventListener("buttondown", this.onButtonDown), x.addEventListener("buttonup", this.onButtonUp), x.addEventListener("touchstart", this.onButtonTouchStart), x.addEventListener("touchend", this.onButtonTouchEnd), x.addEventListener("axismove", this.onAxisMoved), x.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var x = this.el;
                  x.removeEventListener("buttonchanged", this.onButtonChanged), x.removeEventListener("buttondown", this.onButtonDown), x.removeEventListener("buttonup", this.onButtonUp), x.removeEventListener("touchstart", this.onButtonTouchStart), x.removeEventListener("touchend", this.onButtonTouchEnd), x.removeEventListener("axismove", this.onAxisMoved), x.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
                },
                checkIfControllerPresent: function() {
                  var x = this.data;
                  y(this, p, {
                    index: this.controllerIndex,
                    hand: x.hand
                  });
                },
                injectTrackedControls: function() {
                  var x = this.el, T = this.data;
                  x.setAttribute("tracked-controls", {
                    // TODO: verify expected behavior between reserved prefixes.
                    idPrefix: p,
                    hand: T.hand,
                    controller: this.controllerIndex,
                    orientationOffset: T.orientationOffset
                  }), this.data.model && this.el.setAttribute("gltf-model", g + this.data.hand + ".glb");
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                onButtonChanged: function(x) {
                  var T = this.mapping[this.data.hand].buttons[x.detail.id], b;
                  T && (T === "trigger" && (b = x.detail.state.value, console.log("analog value of trigger press: " + b)), this.el.emit(T + "changed", x.detail.state));
                },
                onModelLoaded: function(x) {
                  var T = x.detail.model;
                  this.data.model && (T.position.copy(A), T.rotation.copy(u), this.el.emit("controllermodelready", {
                    name: "hp-mixed-reality-controls",
                    model: this.data.model,
                    rayOrigin: new w.Vector3(0, 0, 0)
                  }));
                },
                onAxisMoved: function(x) {
                  l(this, this.mapping.axes, x);
                }
              });
            }
          ),
          /***/
          "./src/components/index.js": (
            /*!*********************************!*\
              !*** ./src/components/index.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              v(
                /*! ./animation */
                "./src/components/animation.js"
              ), v(
                /*! ./anchored */
                "./src/components/anchored.js"
              ), v(
                /*! ./camera */
                "./src/components/camera.js"
              ), v(
                /*! ./cursor */
                "./src/components/cursor.js"
              ), v(
                /*! ./geometry */
                "./src/components/geometry.js"
              ), v(
                /*! ./generic-tracked-controller-controls */
                "./src/components/generic-tracked-controller-controls.js"
              ), v(
                /*! ./gltf-model */
                "./src/components/gltf-model.js"
              ), v(
                /*! ./grabbable */
                "./src/components/grabbable.js"
              ), v(
                /*! ./hand-tracking-controls */
                "./src/components/hand-tracking-controls.js"
              ), v(
                /*! ./hand-tracking-grab-controls */
                "./src/components/hand-tracking-grab-controls.js"
              ), v(
                /*! ./hand-controls */
                "./src/components/hand-controls.js"
              ), v(
                /*! ./hide-on-enter-ar */
                "./src/components/hide-on-enter-ar.js"
              ), v(
                /*! ./hide-on-enter-vr */
                "./src/components/hide-on-enter-vr.js"
              ), v(
                /*! ./hp-mixed-reality-controls */
                "./src/components/hp-mixed-reality-controls.js"
              ), v(
                /*! ./layer */
                "./src/components/layer.js"
              ), v(
                /*! ./laser-controls */
                "./src/components/laser-controls.js"
              ), v(
                /*! ./light */
                "./src/components/light.js"
              ), v(
                /*! ./line */
                "./src/components/line.js"
              ), v(
                /*! ./link */
                "./src/components/link.js"
              ), v(
                /*! ./look-controls */
                "./src/components/look-controls.js"
              ), v(
                /*! ./magicleap-controls */
                "./src/components/magicleap-controls.js"
              ), v(
                /*! ./material */
                "./src/components/material.js"
              ), v(
                /*! ./obb-collider */
                "./src/components/obb-collider.js"
              ), v(
                /*! ./obj-model */
                "./src/components/obj-model.js"
              ), v(
                /*! ./oculus-go-controls */
                "./src/components/oculus-go-controls.js"
              ), v(
                /*! ./oculus-touch-controls */
                "./src/components/oculus-touch-controls.js"
              ), v(
                /*! ./pico-controls */
                "./src/components/pico-controls.js"
              ), v(
                /*! ./position */
                "./src/components/position.js"
              ), v(
                /*! ./raycaster */
                "./src/components/raycaster.js"
              ), v(
                /*! ./rotation */
                "./src/components/rotation.js"
              ), v(
                /*! ./scale */
                "./src/components/scale.js"
              ), v(
                /*! ./shadow */
                "./src/components/shadow.js"
              ), v(
                /*! ./sound */
                "./src/components/sound.js"
              ), v(
                /*! ./text */
                "./src/components/text.js"
              ), v(
                /*! ./tracked-controls */
                "./src/components/tracked-controls.js"
              ), v(
                /*! ./tracked-controls-webvr */
                "./src/components/tracked-controls-webvr.js"
              ), v(
                /*! ./tracked-controls-webxr */
                "./src/components/tracked-controls-webxr.js"
              ), v(
                /*! ./visible */
                "./src/components/visible.js"
              ), v(
                /*! ./valve-index-controls */
                "./src/components/valve-index-controls.js"
              ), v(
                /*! ./vive-controls */
                "./src/components/vive-controls.js"
              ), v(
                /*! ./vive-focus-controls */
                "./src/components/vive-focus-controls.js"
              ), v(
                /*! ./wasd-controls */
                "./src/components/wasd-controls.js"
              ), v(
                /*! ./windows-motion-controls */
                "./src/components/windows-motion-controls.js"
              ), v(
                /*! ./scene/ar-hit-test */
                "./src/components/scene/ar-hit-test.js"
              ), v(
                /*! ./scene/background */
                "./src/components/scene/background.js"
              ), v(
                /*! ./scene/debug */
                "./src/components/scene/debug.js"
              ), v(
                /*! ./scene/device-orientation-permission-ui */
                "./src/components/scene/device-orientation-permission-ui.js"
              ), v(
                /*! ./scene/embedded */
                "./src/components/scene/embedded.js"
              ), v(
                /*! ./scene/inspector */
                "./src/components/scene/inspector.js"
              ), v(
                /*! ./scene/fog */
                "./src/components/scene/fog.js"
              ), v(
                /*! ./scene/keyboard-shortcuts */
                "./src/components/scene/keyboard-shortcuts.js"
              ), v(
                /*! ./scene/pool */
                "./src/components/scene/pool.js"
              ), v(
                /*! ./scene/real-world-meshing */
                "./src/components/scene/real-world-meshing.js"
              ), v(
                /*! ./scene/reflection */
                "./src/components/scene/reflection.js"
              ), v(
                /*! ./scene/screenshot */
                "./src/components/scene/screenshot.js"
              ), v(
                /*! ./scene/stats */
                "./src/components/scene/stats.js"
              ), v(
                /*! ./scene/xr-mode-ui */
                "./src/components/scene/xr-mode-ui.js"
              );
            }
          ),
          /***/
          "./src/components/laser-controls.js": (
            /*!******************************************!*\
              !*** ./src/components/laser-controls.js ***!
              \******************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              );
              C("laser-controls", {
                schema: {
                  hand: {
                    default: "right"
                  },
                  model: {
                    default: !0
                  },
                  defaultModelColor: {
                    type: "color",
                    default: "grey"
                  }
                },
                init: function() {
                  var E = this.config, y = this.data, l = this.el, d = this, p = {
                    hand: y.hand,
                    model: y.model
                  };
                  l.setAttribute("hp-mixed-reality-controls", p), l.setAttribute("magicleap-controls", p), l.setAttribute("oculus-go-controls", p), l.setAttribute("oculus-touch-controls", p), l.setAttribute("pico-controls", p), l.setAttribute("valve-index-controls", p), l.setAttribute("vive-controls", p), l.setAttribute("vive-focus-controls", p), l.setAttribute("windows-motion-controls", p), l.setAttribute("generic-tracked-controller-controls", {
                    hand: p.hand
                  }), l.addEventListener("controllerconnected", c), l.addEventListener("controllerdisconnected", g), l.addEventListener("controllermodelready", function(A) {
                    c(A), d.modelReady = !0;
                  });
                  function c(A) {
                    var u = E[A.detail.name];
                    if (u) {
                      var f = w.extend({
                        showLine: !0
                      }, u.raycaster || {});
                      A.detail.rayOrigin && (f.origin = A.detail.rayOrigin.origin, f.direction = A.detail.rayOrigin.direction, f.showLine = !0), A.detail.rayOrigin || !d.modelReady ? l.setAttribute("raycaster", f) : l.setAttribute("raycaster", "showLine", !0), l.setAttribute("cursor", w.extend({
                        fuse: !1
                      }, u.cursor));
                    }
                  }
                  function g(A) {
                    var u = E[A.detail.name];
                    u && l.setAttribute("raycaster", "showLine", !1);
                  }
                },
                config: {
                  "generic-tracked-controller-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    }
                  },
                  "hp-mixed-reality-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    },
                    raycaster: {
                      origin: {
                        x: 0,
                        y: 0,
                        z: 0
                      }
                    }
                  },
                  "magicleap-controls": {
                    cursor: {
                      downEvents: ["trackpaddown", "triggerdown"],
                      upEvents: ["trackpadup", "triggerup"]
                    }
                  },
                  "oculus-go-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    },
                    raycaster: {
                      origin: {
                        x: 0,
                        y: 5e-4,
                        z: 0
                      }
                    }
                  },
                  "oculus-touch-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    },
                    raycaster: {
                      origin: {
                        x: 0,
                        y: 0,
                        z: 0
                      }
                    }
                  },
                  "pico-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    }
                  },
                  "valve-index-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    }
                  },
                  "vive-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    }
                  },
                  "vive-focus-controls": {
                    cursor: {
                      downEvents: ["trackpaddown", "triggerdown"],
                      upEvents: ["trackpadup", "triggerup"]
                    }
                  },
                  "windows-motion-controls": {
                    cursor: {
                      downEvents: ["triggerdown"],
                      upEvents: ["triggerup"]
                    },
                    raycaster: {
                      showLine: !1
                    }
                  }
                }
              });
            }
          ),
          /***/
          "./src/components/layer.js": (
            /*!*********************************!*\
              !*** ./src/components/layer.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), E = w.debug("components:layer:warn");
              j.exports.Component = C("layer", {
                schema: {
                  type: {
                    default: "quad",
                    oneOf: ["quad", "monocubemap", "stereocubemap"]
                  },
                  src: {
                    type: "map"
                  },
                  rotateCubemap: {
                    default: !1
                  },
                  width: {
                    default: 0
                  },
                  height: {
                    default: 0
                  }
                },
                init: function() {
                  var l = this.el.sceneEl.renderer.getContext();
                  this.quaternion = new THREE.Quaternion(), this.position = new THREE.Vector3(), this.bindMethods(), this.needsRedraw = !1, this.frameBuffer = l.createFramebuffer();
                  var d = this.el.sceneEl.getAttribute("webxr"), p = d.requiredFeatures;
                  p.indexOf("layers") === -1 && (p.push("layers"), this.el.sceneEl.setAttribute("webxr", d)), this.el.sceneEl.addEventListener("enter-vr", this.onEnterVR), this.el.sceneEl.addEventListener("exit-vr", this.onExitVR);
                },
                bindMethods: function() {
                  this.onRequestedReferenceSpace = this.onRequestedReferenceSpace.bind(this), this.onEnterVR = this.onEnterVR.bind(this), this.onExitVR = this.onExitVR.bind(this);
                },
                update: function(l) {
                  this.data.src !== l.src && this.updateSrc();
                },
                updateSrc: function() {
                  var l = this.data.type;
                  if (this.texture = void 0, l === "quad") {
                    this.loadQuadImage();
                    return;
                  }
                  if (l === "monocubemap" || l === "stereocubemap") {
                    this.loadCubeMapImages();
                    return;
                  }
                },
                loadCubeMapImages: function() {
                  var l, d = this.xrGLFactory, p = this.el.sceneEl.frame, c = this.data.src, g = this.data.type;
                  this.visibilityChanged = !1, this.layer && (g !== "monocubemap" && g !== "stereocubemap" || (c.complete ? this.pendingCubeMapUpdate = !1 : this.pendingCubeMapUpdate = !0, this.loadingScreen ? this.loadingScreen = !1 : this.loadingScreen = !0, g === "monocubemap" ? (l = d.getSubImage(this.layer, p), this.loadCubeMapImage(l.colorTexture, c, 0)) : (l = d.getSubImage(this.layer, p, "left"), this.loadCubeMapImage(l.colorTexture, c, 0), l = d.getSubImage(this.layer, p, "right"), this.loadCubeMapImage(l.colorTexture, c, 6))));
                },
                loadQuadImage: function() {
                  var l = this.data.src, d = this;
                  this.el.sceneEl.systems.material.loadTexture(l, {
                    src: l
                  }, function(c) {
                    d.el.sceneEl.renderer.initTexture(c), d.texture = c, l.tagName === "VIDEO" && setTimeout(function() {
                      d.textureIsVideo = !0;
                    }, 1e3), d.layer && (d.layer.height = d.data.height / 2 || d.texture.image.height / 1e3, d.layer.width = d.data.width / 2 || d.texture.image.width / 1e3, d.needsRedraw = !0), d.updateQuadPanel();
                  });
                },
                preGenerateCubeMapTextures: function(l, d) {
                  this.data.type === "monocubemap" ? this.generateCubeMapTextures(l, 0, d) : (this.generateCubeMapTextures(l, 0, d), this.generateCubeMapTextures(l, 6, d));
                },
                generateCubeMapTextures: function(l, d, p) {
                  for (var c = this.data, g = this.cubeFaceSize, A = Math.min(l.width, l.height), u = [], f, x, T = 0; T < 6; T++) {
                    var b = document.createElement("CANVAS");
                    b.width = b.height = g;
                    var D = b.getContext("2d");
                    c.rotateCubemap && (T === 2 || T === 3) && (D.save(), D.translate(g, g), D.rotate(Math.PI)), D.drawImage(
                      l,
                      (T + d) * A,
                      // top left x coord in source
                      0,
                      // top left y coord in source
                      A,
                      // x pixel count from source
                      A,
                      // y pixel count from source
                      0,
                      // dest x offset in the canvas
                      0,
                      // dest y offset in the canvas
                      g,
                      // x pixel count in dest
                      g
                      // y pixel count in dest
                    ), D.restore(), p && p(), u.push(b);
                  }
                  return c.rotateCubemap && (f = u[0], x = u[1], u[0] = x, u[1] = f, f = u[4], x = u[5], u[4] = x, u[5] = f), p && p(), u;
                },
                loadCubeMapImage: function(l, d, p) {
                  var c = this.el.sceneEl.renderer.getContext(), g;
                  c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, !1), c.bindTexture(c.TEXTURE_CUBE_MAP, l), !d.complete || this.loadingScreen ? g = this.loadingScreenImages : g = this.generateCubeMapTextures(d, p);
                  var A = 0;
                  g.forEach(function(u, f) {
                    c.texSubImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, 0, 0, c.RGBA, c.UNSIGNED_BYTE, u), A = c.getError();
                  }), A !== 0 && console.log("renderingError, WebGL Error Code: " + A), c.bindTexture(c.TEXTURE_CUBE_MAP, null);
                },
                tick: function() {
                  this.el.sceneEl.xrSession && (!this.layer && (this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) && this.initLayer(), this.updateTransform(), this.data.src.complete && (this.pendingCubeMapUpdate || this.loadingScreen || this.visibilityChanged) && this.loadCubeMapImages(), !(!this.needsRedraw && !this.layer.needsRedraw && !this.textureIsVideo) && (this.data.type === "quad" && this.draw(), this.needsRedraw = !1));
                },
                initLayer: function() {
                  var l = this, d = this.data.type;
                  if (this.el.sceneEl.xrSession.onvisibilitychange = function(p) {
                    l.visibilityChanged = p.session.visibilityState !== "hidden";
                  }, d === "quad") {
                    this.initQuadLayer();
                    return;
                  }
                  if (d === "monocubemap" || d === "stereocubemap") {
                    this.initCubeMapLayer();
                    return;
                  }
                },
                initQuadLayer: function() {
                  var l = this.el.sceneEl, d = l.renderer.getContext(), p = this.xrGLFactory = new XRWebGLBinding(l.xrSession, d);
                  this.texture && (this.layer = p.createQuadLayer({
                    space: this.referenceSpace,
                    viewPixelHeight: 2048,
                    viewPixelWidth: 2048,
                    height: this.data.height / 2 || this.texture.image.height / 1e3,
                    width: this.data.width / 2 || this.texture.image.width / 1e3
                  }), this.initLoadingScreenImages(), l.renderer.xr.addLayer(this.layer));
                },
                initCubeMapLayer: function() {
                  var l = this.data.src, d = this.el.sceneEl, p = d.renderer.getContext(), c = p.getParameter(p.MAX_CUBE_MAP_TEXTURE_SIZE), g = this.cubeFaceSize = Math.min(c, Math.min(l.width, l.height)), A = this.xrGLFactory = new XRWebGLBinding(d.xrSession, p);
                  this.layer = A.createCubeLayer({
                    space: this.referenceSpace,
                    viewPixelWidth: g,
                    viewPixelHeight: g,
                    layout: this.data.type === "monocubemap" ? "mono" : "stereo",
                    isStatic: !1
                  }), this.initLoadingScreenImages(), this.loadCubeMapImages(), d.renderer.xr.addLayer(this.layer);
                },
                initLoadingScreenImages: function() {
                  for (var l = this.cubeFaceSize, d = this.loadingScreenImages = [], p = 0; p < 6; p++) {
                    var c = document.createElement("CANVAS");
                    c.width = c.height = l;
                    var g = c.getContext("2d");
                    c.width = c.height = l, g.fillStyle = "black", g.fillRect(0, 0, l, l), p !== 2 && p !== 3 && (g.translate(l, 0), g.scale(-1, 1), g.fillStyle = "white", g.font = "30px Arial", g.fillText("Loading", l / 2, l / 2)), d.push(c);
                  }
                },
                destroyLayer: function() {
                  this.layer && (this.el.sceneEl.renderer.xr.removeLayer(this.layer), this.layer.destroy(), this.layer = void 0);
                },
                toggleCompositorLayer: function() {
                  this.enableCompositorLayer(!this.layerEnabled);
                },
                enableCompositorLayer: function(l) {
                  this.layerEnabled = l, this.quadPanelEl.object3D.visible = !this.layerEnabled;
                },
                updateQuadPanel: function() {
                  var l = this.quadPanelEl;
                  this.quadPanelEl || (l = this.quadPanelEl = document.createElement("a-entity"), this.el.appendChild(l)), l.setAttribute("material", {
                    shader: "flat",
                    src: this.data.src,
                    transparent: !0
                  }), l.setAttribute("geometry", {
                    primitive: "plane",
                    height: this.data.height || this.texture.image.height / 1e3,
                    width: this.data.width || this.texture.image.height / 1e3
                  });
                },
                draw: function() {
                  var l = this.el.sceneEl, d = this.el.sceneEl.renderer.getContext(), p = this.xrGLFactory.getSubImage(this.layer, l.frame), c = l.renderer.properties.get(this.texture).__webglTexture, g = d.getParameter(d.FRAMEBUFFER_BINDING);
                  d.viewport(p.viewport.x, p.viewport.y, p.viewport.width, p.viewport.height), d.bindFramebuffer(d.FRAMEBUFFER, this.frameBuffer), d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, p.colorTexture, 0), y(d, c, p, this.data.src), d.bindFramebuffer(d.FRAMEBUFFER, g);
                },
                updateTransform: function() {
                  var l = this.el, d = this.position, p = this.quaternion;
                  l.object3D.updateMatrixWorld(), d.setFromMatrixPosition(l.object3D.matrixWorld), p.setFromRotationMatrix(l.object3D.matrixWorld), this.layerEnabled || d.set(0, 0, 1e8), this.layer.transform = new XRRigidTransform(d, p);
                },
                onEnterVR: function() {
                  var l = this.el.sceneEl, d = l.xrSession;
                  if (!l.hasWebXR || !XRWebGLBinding || !d) {
                    E("The layer component requires WebXR and the layers API enabled");
                    return;
                  }
                  d.requestReferenceSpace("local-floor").then(this.onRequestedReferenceSpace), this.layerEnabled = !0, this.quadPanelEl && (this.quadPanelEl.object3D.visible = !1), this.data.src.play && this.data.src.play();
                },
                onExitVR: function() {
                  this.quadPanelEl && (this.quadPanelEl.object3D.visible = !0), this.destroyLayer();
                },
                onRequestedReferenceSpace: function(l) {
                  this.referenceSpace = l;
                }
              });
              function y(l, d, p, c) {
                var g = l.createFramebuffer(), A = p.viewport.x, u = p.viewport.y, f = p.viewport.x + p.viewport.width, x = p.viewport.y + p.viewport.height;
                c.tagName === "VIDEO" && (l.bindTexture(l.TEXTURE_2D, d), l.texSubImage2D(l.TEXTURE_2D, 0, 0, 0, c.width, c.height, l.RGB, l.UNSIGNED_BYTE, c)), l.bindFramebuffer(l.READ_FRAMEBUFFER, g), l.framebufferTexture2D(l.READ_FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_2D, d, 0), l.readBuffer(l.COLOR_ATTACHMENT0), l.blitFramebuffer(0, 0, c.width, c.height, A, u, f, x, l.COLOR_BUFFER_BIT, l.NEAREST), l.bindFramebuffer(l.READ_FRAMEBUFFER, null), l.deleteFramebuffer(g);
              }
            }
          ),
          /***/
          "./src/components/light.js": (
            /*!*********************************!*\
              !*** ./src/components/light.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils */
                "./src/utils/index.js"
              ), w = C.diff, E = v(
                /*! ../utils/debug */
                "./src/utils/debug.js"
              ), y = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, l = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), d = v(
                /*! ../utils/math */
                "./src/utils/math.js"
              ), p = l.MathUtils.degToRad, c = E("components:light:warn"), g = new l.CubeTextureLoader(), A = {};
              j.exports.Component = y("light", {
                schema: {
                  angle: {
                    default: 60,
                    if: {
                      type: ["spot"]
                    }
                  },
                  color: {
                    type: "color",
                    if: {
                      type: ["ambient", "directional", "hemisphere", "point", "spot"]
                    }
                  },
                  envMap: {
                    default: "",
                    if: {
                      type: ["probe"]
                    }
                  },
                  groundColor: {
                    type: "color",
                    if: {
                      type: ["hemisphere"]
                    }
                  },
                  decay: {
                    default: 1,
                    if: {
                      type: ["point", "spot"]
                    }
                  },
                  distance: {
                    default: 0,
                    min: 0,
                    if: {
                      type: ["point", "spot"]
                    }
                  },
                  intensity: {
                    default: 1,
                    min: 0,
                    if: {
                      type: ["ambient", "directional", "hemisphere", "point", "spot", "probe"]
                    }
                  },
                  penumbra: {
                    default: 0,
                    min: 0,
                    max: 1,
                    if: {
                      type: ["spot"]
                    }
                  },
                  type: {
                    default: "directional",
                    oneOf: ["ambient", "directional", "hemisphere", "point", "spot", "probe"],
                    schemaChange: !0
                  },
                  target: {
                    type: "selector",
                    if: {
                      type: ["spot", "directional"]
                    }
                  },
                  // Shadows.
                  castShadow: {
                    default: !1,
                    if: {
                      type: ["point", "spot", "directional"]
                    }
                  },
                  shadowBias: {
                    default: 0,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraFar: {
                    default: 500,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraFov: {
                    default: 90,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraNear: {
                    default: 0.5,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraTop: {
                    default: 5,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraRight: {
                    default: 5,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraBottom: {
                    default: -5,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraLeft: {
                    default: -5,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraVisible: {
                    default: !1,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowCameraAutomatic: {
                    default: "",
                    if: {
                      type: ["directional"]
                    }
                  },
                  shadowMapHeight: {
                    default: 512,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowMapWidth: {
                    default: 512,
                    if: {
                      castShadow: !0
                    }
                  },
                  shadowRadius: {
                    default: 1,
                    if: {
                      castShadow: !0
                    }
                  }
                },
                /**
                 * Notifies scene a light has been added to remove default lighting.
                 */
                init: function() {
                  var u = this.el;
                  this.light = null, this.defaultTarget = null, this.system.registerLight(u);
                },
                /**
                 * (Re)create or update light.
                 */
                update: function(u) {
                  var f = this.data, x = w(f, u), T = this.light, b = this;
                  if (T && !("type" in x)) {
                    var D = !1;
                    Object.keys(x).forEach(function(S) {
                      var U = f[S];
                      switch (S) {
                        case "color": {
                          T.color.set(U);
                          break;
                        }
                        case "groundColor": {
                          T.groundColor.set(U);
                          break;
                        }
                        case "angle": {
                          T.angle = p(U);
                          break;
                        }
                        case "target": {
                          U === null ? (f.type === "spot" || f.type === "directional") && (T.target = b.defaultTarget) : U.hasLoaded ? b.onSetTarget(U, T) : U.addEventListener("loaded", b.onSetTarget.bind(b, U, T));
                          break;
                        }
                        case "envMap":
                          b.updateProbeMap(f, T);
                          break;
                        case "castShadow":
                        case "shadowBias":
                        case "shadowCameraFar":
                        case "shadowCameraFov":
                        case "shadowCameraNear":
                        case "shadowCameraTop":
                        case "shadowCameraRight":
                        case "shadowCameraBottom":
                        case "shadowCameraLeft":
                        case "shadowCameraVisible":
                        case "shadowMapHeight":
                        case "shadowMapWidth":
                        case "shadowRadius":
                          D || (b.updateShadow(), D = !0);
                          break;
                        case "shadowCameraAutomatic":
                          f.shadowCameraAutomatic ? b.shadowCameraAutomaticEls = Array.from(document.querySelectorAll(f.shadowCameraAutomatic)) : b.shadowCameraAutomaticEls = [];
                          break;
                        default:
                          T[S] = U;
                      }
                    });
                    return;
                  }
                  this.setLight(this.data), this.updateShadow();
                },
                tick: function() {
                  var u = new l.Box3(), f = new l.Vector3(), x = new l.Vector3(), T = new l.Matrix4(), b = new l.Sphere(), D = new l.Vector3();
                  return function() {
                    if (this.data.type === "directional" && this.light.shadow && this.light.shadow.camera instanceof l.OrthographicCamera && this.shadowCameraAutomaticEls.length) {
                      var S = this.light.shadow.camera;
                      S.getWorldDirection(f), S.getWorldPosition(x), T.copy(S.matrixWorld), T.invert(), S.near = 1, S.left = 1e5, S.right = -1e5, S.top = -1e5, S.bottom = 1e5, this.shadowCameraAutomaticEls.forEach(function(U) {
                        u.setFromObject(U.object3D), u.getBoundingSphere(b);
                        var G = d.distanceOfPointFromPlane(x, f, b.center), Z = d.nearestPointInPlane(x, f, b.center, D), W = Z.applyMatrix4(T);
                        S.near = Math.min(-G - b.radius - 1, S.near), S.left = Math.min(-b.radius + W.x, S.left), S.right = Math.max(b.radius + W.x, S.right), S.top = Math.max(b.radius + W.y, S.top), S.bottom = Math.min(-b.radius + W.y, S.bottom);
                      }), S.updateProjectionMatrix();
                    }
                  };
                }(),
                setLight: function(u) {
                  var f = this.el, x = this.getLight(u);
                  x && (this.light && f.removeObject3D("light"), this.light = x, this.light.el = f, f.setObject3D("light", this.light), (u.type === "spot" || u.type === "directional" || u.type === "hemisphere") && f.getObject3D("light").translateY(-1), u.type === "spot" && (f.setObject3D("light-target", this.defaultTarget), f.getObject3D("light-target").position.set(0, 0, -1)), u.shadowCameraAutomatic ? this.shadowCameraAutomaticEls = Array.from(document.querySelectorAll(u.shadowCameraAutomatic)) : this.shadowCameraAutomaticEls = []);
                },
                /**
                 * Updates shadow-related properties on the current light.
                 */
                updateShadow: function() {
                  var u = this.el, f = this.data, x = this.light;
                  x.castShadow = f.castShadow;
                  var T = u.getObject3D("cameraHelper");
                  if (f.shadowCameraVisible && !T ? u.setObject3D("cameraHelper", new l.CameraHelper(x.shadow.camera)) : !f.shadowCameraVisible && T && u.removeObject3D("cameraHelper"), !f.castShadow)
                    return x;
                  x.shadow.bias = f.shadowBias, x.shadow.radius = f.shadowRadius, x.shadow.mapSize.height = f.shadowMapHeight, x.shadow.mapSize.width = f.shadowMapWidth, x.shadow.camera.near = f.shadowCameraNear, x.shadow.camera.far = f.shadowCameraFar, x.shadow.camera instanceof l.OrthographicCamera ? (x.shadow.camera.top = f.shadowCameraTop, x.shadow.camera.right = f.shadowCameraRight, x.shadow.camera.bottom = f.shadowCameraBottom, x.shadow.camera.left = f.shadowCameraLeft) : x.shadow.camera.fov = f.shadowCameraFov, x.shadow.camera.updateProjectionMatrix(), T && T.update();
                },
                /**
                 * Creates a new three.js light object given data object defining the light.
                 *
                 * @param {object} data
                 */
                getLight: function(u) {
                  var f = u.angle, x = new l.Color(u.color);
                  x = x.getHex();
                  var T = u.decay, b = u.distance, D = new l.Color(u.groundColor);
                  D = D.getHex();
                  var S = u.intensity, U = u.type, G = u.target, Z = null;
                  switch (U.toLowerCase()) {
                    case "ambient":
                      return new l.AmbientLight(x, S);
                    case "directional":
                      return Z = new l.DirectionalLight(x, S), this.defaultTarget = Z.target, G && (G.hasLoaded ? this.onSetTarget(G, Z) : G.addEventListener("loaded", this.onSetTarget.bind(this, G, Z))), Z;
                    case "hemisphere":
                      return new l.HemisphereLight(x, D, S);
                    case "point":
                      return new l.PointLight(x, S, b, T);
                    case "spot":
                      return Z = new l.SpotLight(x, S, b, p(f), u.penumbra, T), this.defaultTarget = Z.target, G && (G.hasLoaded ? this.onSetTarget(G, Z) : G.addEventListener("loaded", this.onSetTarget.bind(this, G, Z))), Z;
                    case "probe":
                      return Z = new l.LightProbe(), this.updateProbeMap(u, Z), Z;
                    default:
                      c("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.", U);
                  }
                },
                /**
                 * Generate the spherical harmonics for the LightProbe from a cube map
                 */
                updateProbeMap: function(u, f) {
                  u.envMap || f.copy(new l.LightProbe()), A[u.envMap] instanceof window.Promise && A[u.envMap].then(function(x) {
                    f.copy(x);
                  }), A[u.envMap] instanceof l.LightProbe && f.copy(A[u.envMap]), A[u.envMap] = new window.Promise(function(x) {
                    C.srcLoader.validateCubemapSrc(u.envMap, function(b) {
                      g.load(b, function(D) {
                        var S = l.LightProbeGenerator.fromCubeTexture(D);
                        A[u.envMap] = S, f.copy(S);
                      });
                    });
                  });
                },
                onSetTarget: function(u, f) {
                  f.target = u.object3D;
                },
                /**
                 * Remove light on remove (callback).
                 */
                remove: function() {
                  var u = this.el;
                  u.removeObject3D("light"), u.getObject3D("cameraHelper") && u.removeObject3D("cameraHelper");
                }
              });
            }
          ),
          /***/
          "./src/components/line.js": (
            /*!********************************!*\
              !*** ./src/components/line.js ***!
              \********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("line", {
                schema: {
                  start: {
                    type: "vec3",
                    default: {
                      x: 0,
                      y: 0,
                      z: 0
                    }
                  },
                  end: {
                    type: "vec3",
                    default: {
                      x: 0,
                      y: 0,
                      z: 0
                    }
                  },
                  color: {
                    type: "color",
                    default: "#74BEC1"
                  },
                  opacity: {
                    type: "number",
                    default: 1
                  },
                  visible: {
                    default: !0
                  }
                },
                multiple: !0,
                init: function() {
                  var E = this.data, y, l;
                  l = this.material = new THREE.LineBasicMaterial({
                    color: E.color,
                    opacity: E.opacity,
                    transparent: E.opacity < 1,
                    visible: E.visible
                  }), y = this.geometry = new THREE.BufferGeometry(), y.setAttribute("position", new THREE.BufferAttribute(new Float32Array(6), 3)), this.line = new THREE.Line(y, l), this.el.setObject3D(this.attrName, this.line);
                },
                update: function(E) {
                  var y = this.data, l = this.geometry, d = !1, p = this.material, c = l.attributes.position.array;
                  w(y.start, E.start) || (c[0] = y.start.x, c[1] = y.start.y, c[2] = y.start.z, d = !0), w(y.end, E.end) || (c[3] = y.end.x, c[4] = y.end.y, c[5] = y.end.z, d = !0), d && (l.attributes.position.needsUpdate = !0, l.computeBoundingSphere()), p.color.setStyle(y.color), p.opacity = y.opacity, p.transparent = y.opacity < 1, p.visible = y.visible;
                },
                remove: function() {
                  this.el.removeObject3D(this.attrName, this.line);
                }
              });
              function w(E, y) {
                return !E || !y ? !1 : E.x === y.x && E.y === y.y && E.z === y.z;
              }
            }
          ),
          /***/
          "./src/components/link.js": (
            /*!********************************!*\
              !*** ./src/components/link.js ***!
              \********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ).registerShader, E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              j.exports.Component = C("link", {
                schema: {
                  backgroundColor: {
                    default: "red",
                    type: "color"
                  },
                  borderColor: {
                    default: "white",
                    type: "color"
                  },
                  highlighted: {
                    default: !1
                  },
                  highlightedColor: {
                    default: "#24CAFF",
                    type: "color"
                  },
                  href: {
                    default: ""
                  },
                  image: {
                    type: "asset"
                  },
                  on: {
                    default: "click"
                  },
                  peekMode: {
                    default: !1
                  },
                  title: {
                    default: ""
                  },
                  titleColor: {
                    default: "white",
                    type: "color"
                  },
                  visualAspectEnabled: {
                    default: !1
                  }
                },
                init: function() {
                  this.navigate = this.navigate.bind(this), this.previousQuaternion = void 0, this.quaternionClone = new E.Quaternion(), this.hiddenEls = [];
                },
                update: function(y) {
                  var l = this.data, d = this.el, p, c;
                  l.visualAspectEnabled && (this.initVisualAspect(), p = l.highlighted ? l.highlightedColor : l.backgroundColor, c = l.highlighted ? l.highlightedColor : l.borderColor, d.setAttribute("material", "backgroundColor", p), d.setAttribute("material", "strokeColor", c), l.on !== y.on && this.updateEventListener(), y.peekMode !== void 0 && l.peekMode !== y.peekMode && this.updatePeekMode(), !(!l.image || y.image === l.image) && d.setAttribute("material", "pano", typeof l.image == "string" ? l.image : l.image.src));
                },
                /*
                 * Toggle all elements and full 360 preview of the linked page.
                 */
                updatePeekMode: function() {
                  var y = this.el, l = this.sphereEl;
                  this.data.peekMode ? (this.hideAll(), y.getObject3D("mesh").visible = !1, l.setAttribute("visible", !0)) : (this.showAll(), y.getObject3D("mesh").visible = !0, l.setAttribute("visible", !1));
                },
                play: function() {
                  this.updateEventListener();
                },
                pause: function() {
                  this.removeEventListener();
                },
                updateEventListener: function() {
                  var y = this.el;
                  y.isPlaying && (this.removeEventListener(), y.addEventListener(this.data.on, this.navigate));
                },
                removeEventListener: function() {
                  var y = this.data.on;
                  y && this.el.removeEventListener(y, this.navigate);
                },
                initVisualAspect: function() {
                  var y = this.el, l, d, p;
                  !this.data.visualAspectEnabled || this.visualAspectInitialized || (p = this.textEl = this.textEl || document.createElement("a-entity"), d = this.sphereEl = this.sphereEl || document.createElement("a-entity"), l = this.semiSphereEl = this.semiSphereEl || document.createElement("a-entity"), y.setAttribute("geometry", {
                    primitive: "circle",
                    radius: 1,
                    segments: 64
                  }), y.setAttribute("material", {
                    shader: "portal",
                    pano: this.data.image,
                    side: "double"
                  }), p.setAttribute("text", {
                    color: this.data.titleColor,
                    align: "center",
                    font: "kelsonsans",
                    value: this.data.title || this.data.href,
                    width: 4
                  }), p.setAttribute("position", "0 1.5 0"), y.appendChild(p), l.setAttribute("geometry", {
                    primitive: "sphere",
                    radius: 1,
                    phiStart: 0,
                    segmentsWidth: 64,
                    segmentsHeight: 64,
                    phiLength: 180,
                    thetaStart: 0,
                    thetaLength: 360
                  }), l.setAttribute("material", {
                    shader: "portal",
                    borderEnabled: 0,
                    pano: this.data.image,
                    side: "back"
                  }), l.setAttribute("rotation", "0 180 0"), l.setAttribute("position", "0 0 0"), l.setAttribute("visible", !1), y.appendChild(l), d.setAttribute("geometry", {
                    primitive: "sphere",
                    radius: 10,
                    segmentsWidth: 64,
                    segmentsHeight: 64
                  }), d.setAttribute("material", {
                    shader: "portal",
                    borderEnabled: 0,
                    pano: this.data.image,
                    side: "back"
                  }), d.setAttribute("visible", !1), y.appendChild(d), this.visualAspectInitialized = !0);
                },
                navigate: function() {
                  window.location = this.data.href;
                },
                /**
                 * 1. Swap plane that represents portal with sphere with a hole when the camera is close
                 * so user can peek inside portal. Sphere is rendered on opposite side of portal
                 * from where user enters.
                 * 2. Place the url/title above or inside portal depending on distance to camera.
                 * 3. Face portal to camera when far away from user.
                 */
                tick: function() {
                  var y = new E.Vector3(), l = new E.Vector3(), d = new E.Quaternion(), p = new E.Vector3();
                  return function() {
                    var c = this.el, g = c.object3D, A = c.sceneEl.camera, u, f, x = this.textEl;
                    if (this.data.visualAspectEnabled)
                      if (g.updateMatrixWorld(), A.parent.updateMatrixWorld(), A.updateMatrixWorld(), g.matrix.decompose(l, d, p), l.setFromMatrixPosition(g.matrixWorld), y.setFromMatrixPosition(A.matrixWorld), f = l.distanceTo(y), f > 20)
                        this.previousQuaternion || (this.quaternionClone.copy(d), this.previousQuaternion = this.quaternionClone), g.lookAt(y);
                      else {
                        if (u = this.calculateCameraPortalOrientation(), f < 0.5) {
                          if (this.semiSphereEl.getAttribute("visible") === !0)
                            return;
                          x.setAttribute("text", "width", 1.5), u <= 0 ? (x.setAttribute("position", "0 0 0.75"), x.setAttribute("rotation", "0 180 0"), this.semiSphereEl.setAttribute("rotation", "0 0 0")) : (x.setAttribute("position", "0 0 -0.75"), x.setAttribute("rotation", "0 0 0"), this.semiSphereEl.setAttribute("rotation", "0 180 0")), c.getObject3D("mesh").visible = !1, this.semiSphereEl.setAttribute("visible", !0), this.peekCameraPortalOrientation = u;
                        } else
                          u <= 0 ? x.setAttribute("rotation", "0 180 0") : x.setAttribute("rotation", "0 0 0"), x.setAttribute("text", "width", 5), x.setAttribute("position", "0 1.5 0"), c.getObject3D("mesh").visible = !0, this.semiSphereEl.setAttribute("visible", !1), this.peekCameraPortalOrientation = void 0;
                        this.previousQuaternion && (g.quaternion.copy(this.previousQuaternion), this.previousQuaternion = void 0);
                      }
                  };
                }(),
                hideAll: function() {
                  var y = this.el, l = this.hiddenEls, d = this;
                  l.length > 0 || y.sceneEl.object3D.traverse(function(p) {
                    p && p.el && p.el.hasAttribute("link-controls") || !p.el || p === y.sceneEl.object3D || p.el === y || p.el === d.sphereEl || p.el === y.sceneEl.cameraEl || p.el.getAttribute("visible") === !1 || p.el === d.textEl || p.el === d.semiSphereEl || (p.el.setAttribute("visible", !1), l.push(p.el));
                  });
                },
                showAll: function() {
                  this.hiddenEls.forEach(function(y) {
                    y.setAttribute("visible", !0);
                  }), this.hiddenEls = [];
                },
                /**
                 * Calculate whether the camera faces the front or back face of the portal.
                 * @returns {number} > 0 if camera faces front of portal, < 0 if it faces back of portal.
                 */
                calculateCameraPortalOrientation: function() {
                  var y = new E.Matrix4(), l = new E.Vector3(), d = new E.Vector3(0, 0, 1), p = new E.Vector3(0, 0, 0);
                  return function() {
                    var c = this.el, g = c.sceneEl.camera;
                    return l.set(0, 0, 0), d.set(0, 0, 1), p.set(0, 0, 0), c.object3D.matrixWorld.extractRotation(y), d.applyMatrix4(y), c.object3D.updateMatrixWorld(), c.object3D.localToWorld(p), g.parent.parent.updateMatrixWorld(), g.parent.updateMatrixWorld(), g.updateMatrixWorld(), g.localToWorld(l), l.sub(p).normalize(), d.normalize(), Math.sign(d.dot(l));
                  };
                }(),
                remove: function() {
                  this.removeEventListener();
                }
              }), w("portal", {
                schema: {
                  borderEnabled: {
                    default: 1,
                    type: "int",
                    is: "uniform"
                  },
                  backgroundColor: {
                    default: "red",
                    type: "color",
                    is: "uniform"
                  },
                  pano: {
                    type: "map",
                    is: "uniform"
                  },
                  strokeColor: {
                    default: "white",
                    type: "color",
                    is: "uniform"
                  }
                },
                vertexShader: ["vec3 portalPosition;", "varying vec3 vWorldPosition;", "varying float vDistanceToCenter;", "varying float vDistance;", "void main() {", "vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);", "portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;", "vDistance = length(portalPosition - cameraPosition);", "vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;", "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join(`
`),
                fragmentShader: ["#define RECIPROCAL_PI2 0.15915494", "uniform sampler2D pano;", "uniform vec3 strokeColor;", "uniform vec3 backgroundColor;", "uniform float borderEnabled;", "varying float vDistanceToCenter;", "varying float vDistance;", "varying vec3 vWorldPosition;", "void main() {", "vec3 direction = normalize(vWorldPosition - cameraPosition);", "vec2 sampleUV;", "float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);", "sampleUV.y = clamp(direction.y * 0.5  + 0.5, 0.0, 1.0);", "sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;", "if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {", "gl_FragColor = vec4(strokeColor, 1.0);", "} else {", "gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / 15.0), 2.0), 0.0, 1.0));", "}", "}"].join(`
`)
              });
            }
          ),
          /***/
          "./src/components/look-controls.js": (
            /*!*****************************************!*\
              !*** ./src/components/look-controls.js ***!
              \*****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), y = Math.PI / 2;
              j.exports.Component = C("look-controls", {
                dependencies: ["position", "rotation"],
                schema: {
                  enabled: {
                    default: !0
                  },
                  magicWindowTrackingEnabled: {
                    default: !0
                  },
                  pointerLockEnabled: {
                    default: !1
                  },
                  reverseMouseDrag: {
                    default: !1
                  },
                  reverseTouchDrag: {
                    default: !1
                  },
                  touchEnabled: {
                    default: !0
                  },
                  mouseEnabled: {
                    default: !0
                  }
                },
                init: function() {
                  this.deltaYaw = 0, this.previousHMDPosition = new w.Vector3(), this.hmdQuaternion = new w.Quaternion(), this.magicWindowAbsoluteEuler = new w.Euler(), this.magicWindowDeltaEuler = new w.Euler(), this.position = new w.Vector3(), this.magicWindowObject = new w.Object3D(), this.rotation = {}, this.deltaRotation = {}, this.savedPose = null, this.pointerLocked = !1, this.setupMouseControls(), this.bindMethods(), this.previousMouseEvent = {}, this.setupMagicWindowControls(), this.savedPose = {
                    position: new w.Vector3(),
                    rotation: new w.Euler()
                  }, (this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) && this.onEnterVR();
                },
                setupMagicWindowControls: function() {
                  var l, d = this.data;
                  (E.device.isMobile() || E.device.isMobileDeviceRequestingDesktopSite()) && (l = this.magicWindowControls = new w.DeviceOrientationControls(this.magicWindowObject), typeof DeviceOrientationEvent < "u" && DeviceOrientationEvent.requestPermission && (l.enabled = !1, this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted ? l.enabled = d.magicWindowTrackingEnabled : this.el.sceneEl.addEventListener("deviceorientationpermissiongranted", function() {
                    l.enabled = d.magicWindowTrackingEnabled;
                  })));
                },
                update: function(l) {
                  var d = this.data;
                  d.enabled !== l.enabled && this.updateGrabCursor(d.enabled), l && !d.magicWindowTrackingEnabled && l.magicWindowTrackingEnabled && (this.magicWindowAbsoluteEuler.set(0, 0, 0), this.magicWindowDeltaEuler.set(0, 0, 0)), this.magicWindowControls && (this.magicWindowControls.enabled = d.magicWindowTrackingEnabled), l && !d.pointerLockEnabled !== l.pointerLockEnabled && (this.removeEventListeners(), this.addEventListeners(), this.pointerLocked && this.exitPointerLock());
                },
                tick: function(l) {
                  var d = this.data;
                  d.enabled && this.updateOrientation();
                },
                play: function() {
                  this.addEventListeners();
                },
                pause: function() {
                  this.removeEventListeners(), this.pointerLocked && this.exitPointerLock();
                },
                remove: function() {
                  this.removeEventListeners(), this.pointerLocked && this.exitPointerLock();
                },
                bindMethods: function() {
                  this.onMouseDown = this.onMouseDown.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onMouseUp = this.onMouseUp.bind(this), this.onTouchStart = this.onTouchStart.bind(this), this.onTouchMove = this.onTouchMove.bind(this), this.onTouchEnd = this.onTouchEnd.bind(this), this.onEnterVR = this.onEnterVR.bind(this), this.onExitVR = this.onExitVR.bind(this), this.onPointerLockChange = this.onPointerLockChange.bind(this), this.onPointerLockError = this.onPointerLockError.bind(this);
                },
                /**
                 * Set up states and Object3Ds needed to store rotation data.
                 */
                setupMouseControls: function() {
                  this.mouseDown = !1, this.pitchObject = new w.Object3D(), this.yawObject = new w.Object3D(), this.yawObject.position.y = 10, this.yawObject.add(this.pitchObject);
                },
                /**
                 * Add mouse and touch event listeners to canvas.
                 */
                addEventListeners: function() {
                  var l = this.el.sceneEl, d = l.canvas;
                  if (!d) {
                    l.addEventListener("render-target-loaded", this.addEventListeners.bind(this));
                    return;
                  }
                  d.addEventListener("mousedown", this.onMouseDown, !1), window.addEventListener("mousemove", this.onMouseMove, !1), window.addEventListener("mouseup", this.onMouseUp, !1), d.addEventListener("touchstart", this.onTouchStart, {
                    passive: !0
                  }), window.addEventListener("touchmove", this.onTouchMove, {
                    passive: !0
                  }), window.addEventListener("touchend", this.onTouchEnd, {
                    passive: !0
                  }), l.addEventListener("enter-vr", this.onEnterVR), l.addEventListener("exit-vr", this.onExitVR), this.data.pointerLockEnabled && (document.addEventListener("pointerlockchange", this.onPointerLockChange, !1), document.addEventListener("mozpointerlockchange", this.onPointerLockChange, !1), document.addEventListener("pointerlockerror", this.onPointerLockError, !1));
                },
                /**
                 * Remove mouse and touch event listeners from canvas.
                 */
                removeEventListeners: function() {
                  var l = this.el.sceneEl, d = l && l.canvas;
                  d && (d.removeEventListener("mousedown", this.onMouseDown), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), d.removeEventListener("touchstart", this.onTouchStart), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd), l.removeEventListener("enter-vr", this.onEnterVR), l.removeEventListener("exit-vr", this.onExitVR), document.removeEventListener("pointerlockchange", this.onPointerLockChange, !1), document.removeEventListener("mozpointerlockchange", this.onPointerLockChange, !1), document.removeEventListener("pointerlockerror", this.onPointerLockError, !1));
                },
                /**
                 * Update orientation for mobile, mouse drag, and headset.
                 * Mouse-drag only enabled if HMD is not active.
                 */
                updateOrientation: function() {
                  var l = this.el.object3D, d = this.pitchObject, p = this.yawObject, c = this.el.sceneEl;
                  (c.is("vr-mode") || c.is("ar-mode")) && c.checkHeadsetConnected() || (this.updateMagicWindowOrientation(), l.rotation.x = this.magicWindowDeltaEuler.x + d.rotation.x, l.rotation.y = this.magicWindowDeltaEuler.y + p.rotation.y, l.rotation.z = this.magicWindowDeltaEuler.z);
                },
                updateMagicWindowOrientation: function() {
                  var l = this.magicWindowAbsoluteEuler, d = this.magicWindowDeltaEuler;
                  this.magicWindowControls && this.magicWindowControls.enabled && (this.magicWindowControls.update(), l.setFromQuaternion(this.magicWindowObject.quaternion, "YXZ"), !this.previousMagicWindowYaw && l.y !== 0 && (this.previousMagicWindowYaw = l.y), this.previousMagicWindowYaw && (d.x = l.x, d.y += l.y - this.previousMagicWindowYaw, d.z = l.z, this.previousMagicWindowYaw = l.y));
                },
                /**
                 * Translate mouse drag into rotation.
                 *
                 * Dragging up and down rotates the camera around the X-axis (yaw).
                 * Dragging left and right rotates the camera around the Y-axis (pitch).
                 */
                onMouseMove: function(l) {
                  var d, p, c, g = this.pitchObject, A = this.previousMouseEvent, u = this.yawObject;
                  !this.data.enabled || !this.mouseDown && !this.pointerLocked || (this.pointerLocked ? (p = l.movementX || l.mozMovementX || 0, c = l.movementY || l.mozMovementY || 0) : (p = l.screenX - A.screenX, c = l.screenY - A.screenY), this.previousMouseEvent.screenX = l.screenX, this.previousMouseEvent.screenY = l.screenY, d = this.data.reverseMouseDrag ? 1 : -1, u.rotation.y += p * 2e-3 * d, g.rotation.x += c * 2e-3 * d, g.rotation.x = Math.max(-y, Math.min(y, g.rotation.x)));
                },
                /**
                 * Register mouse down to detect mouse drag.
                 */
                onMouseDown: function(l) {
                  var d = this.el.sceneEl;
                  if (!(!this.data.enabled || !this.data.mouseEnabled || (d.is("vr-mode") || d.is("ar-mode")) && d.checkHeadsetConnected()) && l.button === 0) {
                    var p = d && d.canvas;
                    this.mouseDown = !0, this.previousMouseEvent.screenX = l.screenX, this.previousMouseEvent.screenY = l.screenY, this.showGrabbingCursor(), this.data.pointerLockEnabled && !this.pointerLocked && (p.requestPointerLock ? p.requestPointerLock() : p.mozRequestPointerLock && p.mozRequestPointerLock());
                  }
                },
                /**
                 * Shows grabbing cursor on scene
                 */
                showGrabbingCursor: function() {
                  this.el.sceneEl.canvas.style.cursor = "grabbing";
                },
                /**
                 * Hides grabbing cursor on scene
                 */
                hideGrabbingCursor: function() {
                  this.el.sceneEl.canvas.style.cursor = "";
                },
                /**
                 * Register mouse up to detect release of mouse drag.
                 */
                onMouseUp: function() {
                  this.mouseDown = !1, this.hideGrabbingCursor();
                },
                /**
                 * Register touch down to detect touch drag.
                 */
                onTouchStart: function(l) {
                  l.touches.length !== 1 || !this.data.touchEnabled || this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode") || (this.touchStart = {
                    x: l.touches[0].pageX,
                    y: l.touches[0].pageY
                  }, this.touchStarted = !0);
                },
                /**
                 * Translate touch move to Y-axis rotation.
                 */
                onTouchMove: function(l) {
                  var d, p = this.el.sceneEl.canvas, c, g = this.yawObject;
                  !this.touchStarted || !this.data.touchEnabled || (c = 2 * Math.PI * (l.touches[0].pageX - this.touchStart.x) / p.clientWidth, d = this.data.reverseTouchDrag ? 1 : -1, g.rotation.y -= c * 0.5 * d, this.touchStart = {
                    x: l.touches[0].pageX,
                    y: l.touches[0].pageY
                  });
                },
                /**
                 * Register touch end to detect release of touch drag.
                 */
                onTouchEnd: function() {
                  this.touchStarted = !1;
                },
                /**
                 * Save pose.
                 */
                onEnterVR: function() {
                  var l = this.el.sceneEl;
                  l.checkHeadsetConnected() && (this.saveCameraPose(), this.el.object3D.position.set(0, 0, 0), this.el.object3D.rotation.set(0, 0, 0), l.hasWebXR && (this.el.object3D.matrixAutoUpdate = !1, this.el.object3D.updateMatrix()));
                },
                /**
                 * Restore the pose.
                 */
                onExitVR: function() {
                  this.el.sceneEl.checkHeadsetConnected() && (this.restoreCameraPose(), this.previousHMDPosition.set(0, 0, 0), this.el.object3D.matrixAutoUpdate = !0);
                },
                /**
                 * Update Pointer Lock state.
                 */
                onPointerLockChange: function() {
                  this.pointerLocked = !!(document.pointerLockElement || document.mozPointerLockElement);
                },
                /**
                 * Recover from Pointer Lock error.
                 */
                onPointerLockError: function() {
                  this.pointerLocked = !1;
                },
                // Exits pointer-locked mode.
                exitPointerLock: function() {
                  document.exitPointerLock(), this.pointerLocked = !1;
                },
                /**
                 * Toggle the feature of showing/hiding the grab cursor.
                 */
                updateGrabCursor: function(l) {
                  var d = this.el.sceneEl;
                  function p() {
                    d.canvas.classList.add("a-grab-cursor");
                  }
                  function c() {
                    d.canvas.classList.remove("a-grab-cursor");
                  }
                  if (!d.canvas) {
                    l ? d.addEventListener("render-target-loaded", p) : d.addEventListener("render-target-loaded", c);
                    return;
                  }
                  if (l) {
                    p();
                    return;
                  }
                  c();
                },
                /**
                 * Save camera pose before entering VR to restore later if exiting.
                 */
                saveCameraPose: function() {
                  var l = this.el;
                  this.savedPose.position.copy(l.object3D.position), this.savedPose.rotation.copy(l.object3D.rotation), this.hasSavedPose = !0;
                },
                /**
                 * Reset camera pose to before entering VR.
                 */
                restoreCameraPose: function() {
                  var l = this.el, d = this.savedPose;
                  this.hasSavedPose && (l.object3D.position.copy(d.position), l.object3D.rotation.copy(d.rotation), this.hasSavedPose = !1);
                }
              });
            }
          ),
          /***/
          "./src/components/magicleap-controls.js": (
            /*!**********************************************!*\
              !*** ./src/components/magicleap-controls.js ***!
              \**********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), E = w.checkControllerPresentAndSetup, y = w.emitIfAxesChanged, l = w.onButtonEvent, d = "magicleap", p = "-one", c = d + p, g = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, A = g + "controllers/magicleap/magicleap-one-controller.glb", u = {
                axes: {
                  touchpad: [0, 1]
                },
                buttons: ["trigger", "grip", "touchpad", "menu"]
              };
              j.exports.Component = C("magicleap-controls", {
                schema: {
                  hand: {
                    default: "none"
                  },
                  model: {
                    default: !0
                  },
                  orientationOffset: {
                    type: "vec3"
                  }
                },
                mapping: u,
                init: function() {
                  var f = this;
                  this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(x) {
                    l(x.detail.id, "down", f);
                  }, this.onButtonUp = function(x) {
                    l(x.detail.id, "up", f);
                  }, this.onButtonTouchEnd = function(x) {
                    l(x.detail.id, "touchend", f);
                  }, this.onButtonTouchStart = function(x) {
                    l(x.detail.id, "touchstart", f);
                  }, this.previousButtonValues = {}, this.bindMethods();
                },
                update: function() {
                  var f = this.data;
                  this.controllerIndex = f.hand === "right" ? 0 : f.hand === "left" ? 1 : 2;
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                bindMethods: function() {
                  this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                addEventListeners: function() {
                  var f = this.el;
                  f.addEventListener("buttonchanged", this.onButtonChanged), f.addEventListener("buttondown", this.onButtonDown), f.addEventListener("buttonup", this.onButtonUp), f.addEventListener("touchstart", this.onButtonTouchStart), f.addEventListener("touchend", this.onButtonTouchEnd), f.addEventListener("axismove", this.onAxisMoved), f.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var f = this.el;
                  f.removeEventListener("buttonchanged", this.onButtonChanged), f.removeEventListener("buttondown", this.onButtonDown), f.removeEventListener("buttonup", this.onButtonUp), f.removeEventListener("touchstart", this.onButtonTouchStart), f.removeEventListener("touchend", this.onButtonTouchEnd), f.removeEventListener("axismove", this.onAxisMoved), f.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
                },
                checkIfControllerPresent: function() {
                  var f = this.data;
                  E(this, c, {
                    index: this.controllerIndex,
                    hand: f.hand
                  });
                },
                injectTrackedControls: function() {
                  var f = this.el, x = this.data;
                  f.setAttribute("tracked-controls", {
                    // TODO: verify expected behavior between reserved prefixes.
                    idPrefix: c,
                    hand: x.hand,
                    controller: this.controllerIndex,
                    orientationOffset: x.orientationOffset
                  }), this.data.model && this.el.setAttribute("gltf-model", A);
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                /**
                 * Rotate the trigger button based on how hard the trigger is pressed.
                 */
                onButtonChanged: function(f) {
                  var x = this.mapping.buttons[f.detail.id], T;
                  x && (x === "trigger" && (T = f.detail.state.value, console.log("analog value of trigger press: " + T)), this.el.emit(x + "changed", f.detail.state));
                },
                onModelLoaded: function(f) {
                  var x = f.detail.model;
                  x.scale.set(0.01, 0.01, 0.01);
                },
                onAxisMoved: function(f) {
                  y(this, this.mapping.axes, f);
                },
                updateModel: function(f, x) {
                },
                setButtonColor: function(f, x) {
                }
              });
            }
          ),
          /***/
          "./src/components/material.js": (
            /*!************************************!*\
              !*** ./src/components/material.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), w = v(
                /*! ../core/component */
                "./src/core/component.js"
              ), E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), y = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ), l = C.debug("components:material:error"), d = w.registerComponent, p = y.shaders, c = y.shaderNames;
              j.exports.Component = d("material", {
                schema: {
                  alphaTest: {
                    default: 0,
                    min: 0,
                    max: 1
                  },
                  depthTest: {
                    default: !0
                  },
                  depthWrite: {
                    default: !0
                  },
                  flatShading: {
                    default: !1
                  },
                  npot: {
                    default: !1
                  },
                  offset: {
                    type: "vec2",
                    default: {
                      x: 0,
                      y: 0
                    }
                  },
                  opacity: {
                    default: 1,
                    min: 0,
                    max: 1
                  },
                  repeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  shader: {
                    default: "standard",
                    oneOf: c,
                    schemaChange: !0
                  },
                  side: {
                    default: "front",
                    oneOf: ["front", "back", "double"]
                  },
                  transparent: {
                    default: !1
                  },
                  vertexColorsEnabled: {
                    default: !1
                  },
                  visible: {
                    default: !0
                  },
                  blending: {
                    default: "normal",
                    oneOf: ["none", "normal", "additive", "subtractive", "multiply"]
                  },
                  dithering: {
                    default: !0
                  },
                  anisotropy: {
                    default: 0,
                    min: 0
                  }
                },
                init: function() {
                  this.material = null;
                },
                /**
                 * Update or create material.
                 *
                 * @param {object|null} oldData
                 */
                update: function(f) {
                  var x = this.data;
                  (!this.shader || x.shader !== f.shader) && this.updateShader(x.shader), this.shader.update(this.data), this.updateMaterial(f);
                },
                updateSchema: function(f) {
                  var x, T, b, D;
                  T = f && f.shader, x = this.oldData && this.oldData.shader, D = T || x, b = p[D] && p[D].schema, b || l("Unknown shader schema " + D), !(x && T === x) && (this.extendSchema(b), this.updateBehavior());
                },
                updateBehavior: function() {
                  var f, x = this.el.sceneEl, T = this.schema, b = this, D;
                  function S(U, G) {
                    var Z;
                    for (Z in D)
                      D[Z] = U;
                    b.shader.update(D);
                  }
                  this.tick = void 0, D = {};
                  for (f in T)
                    T[f].type === "time" && (this.tick = S, D[f] = !0);
                  x && (this.tick ? x.addBehavior(this) : x.removeBehavior(this));
                },
                updateShader: function(f) {
                  var x = this.data, T = p[f] && p[f].Shader, b;
                  if (!T)
                    throw new Error("Unknown shader " + f);
                  b = this.shader = new T(), b.el = this.el, b.init(x), this.setMaterial(b.material), this.updateSchema(x);
                },
                /**
                 * Set and update base material properties.
                 * Set `needsUpdate` when needed.
                 */
                updateMaterial: function(f) {
                  var x = this.data, T = this.material, b;
                  T.alphaTest = x.alphaTest, T.depthTest = x.depthTest !== !1, T.depthWrite = x.depthWrite !== !1, T.opacity = x.opacity, T.flatShading = x.flatShading, T.side = g(x.side), T.transparent = x.transparent !== !1 || x.opacity < 1, T.vertexColors = x.vertexColorsEnabled, T.visible = x.visible, T.blending = A(x.blending), T.dithering = x.dithering;
                  for (b in f)
                    break;
                  b && (f.alphaTest !== x.alphaTest || f.side !== x.side || f.vertexColorsEnabled !== x.vertexColorsEnabled) && (T.needsUpdate = !0);
                },
                /**
                 * Remove material on remove (callback).
                 * Dispose of it from memory and unsubscribe from scene updates.
                 */
                remove: function() {
                  var f = new E.MeshBasicMaterial(), x = this.material, T = this.el.getObject3D("mesh");
                  T && (T.material = f), u(x, this.system);
                },
                /**
                 * (Re)create new material. Has side-effects of setting `this.material` and updating
                 * material registration in scene.
                 *
                 * @param {object} data - Material component data.
                 * @param {object} type - Material type to create.
                 * @returns {object} Material.
                 */
                setMaterial: function(f) {
                  var x = this.el, T, b = this.system;
                  this.material && u(this.material, b), this.material = f, b.registerMaterial(f), T = x.getObject3D("mesh"), T ? T.material = f : x.addEventListener("object3dset", function D(S) {
                    S.detail.type !== "mesh" || S.target !== x || (x.getObject3D("mesh").material = f, x.removeEventListener("object3dset", D));
                  });
                }
              });
              function g(f) {
                switch (f) {
                  case "back":
                    return E.BackSide;
                  case "double":
                    return E.DoubleSide;
                  default:
                    return E.FrontSide;
                }
              }
              function A(f) {
                switch (f) {
                  case "none":
                    return E.NoBlending;
                  case "additive":
                    return E.AdditiveBlending;
                  case "subtractive":
                    return E.SubtractiveBlending;
                  case "multiply":
                    return E.MultiplyBlending;
                  default:
                    return E.NormalBlending;
                }
              }
              function u(f, x) {
                f.dispose(), x.unregisterMaterial(f), Object.keys(f).filter(function(T) {
                  return f[T] && f[T].isTexture;
                }).forEach(function(T) {
                  f[T].dispose();
                });
              }
            }
          ),
          /***/
          "./src/components/obb-collider.js": (
            /*!****************************************!*\
              !*** ./src/components/obb-collider.js ***!
              \****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("obb-collider", {
                schema: {
                  size: {
                    default: 0
                  },
                  trackedObject3D: {
                    default: ""
                  },
                  minimumColliderDimension: {
                    default: 0.02
                  },
                  centerModel: {
                    default: !1
                  }
                },
                init: function() {
                  this.previousScale = new w.Vector3().copy(this.el.object3D.scale), this.auxEuler = new w.Euler(), this.boundingBox = new w.Box3(), this.boundingBoxSize = new w.Vector3(), this.updateCollider = this.updateCollider.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.updateBoundingBox = this.updateBoundingBox.bind(this), this.el.addEventListener("model-loaded", this.onModelLoaded), this.updateCollider(), this.system.addCollider(this.el);
                },
                remove: function() {
                  this.system.removeCollider(this.el);
                },
                update: function() {
                  this.data.trackedObject3D && (this.trackedObject3DPath = this.data.trackedObject3D.split("."));
                },
                onModelLoaded: function() {
                  this.data.centerModel && this.centerModel(), this.updateCollider();
                },
                centerModel: function() {
                  var E = this.el, y = E.components["gltf-model"] && E.components["gltf-model"].model, l, d;
                  y && (this.el.removeObject3D("mesh"), l = new w.Box3().setFromObject(y), d = l.getCenter(new w.Vector3()), y.position.x += y.position.x - d.x, y.position.y += y.position.y - d.y, y.position.z += y.position.z - d.z, this.el.setObject3D("mesh", y));
                },
                updateCollider: function() {
                  var E = this.el, y = this.boundingBoxSize, l = this.aabb = this.aabb || new w.OBB();
                  if (this.obb = this.obb || new w.OBB(), !E.hasLoaded) {
                    E.addEventListener("loaded", this.updateCollider);
                    return;
                  }
                  this.updateBoundingBox(), l.halfSize.copy(y).multiplyScalar(0.5), this.el.sceneEl.systems["obb-collider"].data.showColliders && this.showCollider();
                },
                showCollider: function() {
                  this.updateColliderMesh(), this.renderColliderMesh.visible = !0;
                },
                updateColliderMesh: function() {
                  var E = this.renderColliderMesh, y = this.boundingBoxSize;
                  if (!E) {
                    this.initColliderMesh();
                    return;
                  }
                  E.geometry.dispose(), E.geometry = new w.BoxGeometry(y.x, y.y, y.z);
                },
                hideCollider: function() {
                  this.renderColliderMesh && (this.renderColliderMesh.visible = !1);
                },
                initColliderMesh: function() {
                  var E, y, l;
                  E = this.boundingBoxSize, y = this.renderColliderGeometry = new w.BoxGeometry(E.x, E.y, E.z), l = this.renderColliderMesh = new w.Mesh(y, new w.MeshLambertMaterial({
                    color: 65280,
                    side: w.DoubleSide
                  })), l.matrixAutoUpdate = !1, l.matrixWorldAutoUpdate = !1, l.updateMatrixWorld = function() {
                  }, this.el.sceneEl.object3D.add(l);
                },
                updateBoundingBox: function() {
                  var E = new w.Vector3(), y = new w.Vector3(), l = new w.Quaternion(), d = new w.Quaternion(), p = new w.Matrix4();
                  return function() {
                    var c = this.auxEuler, g = this.boundingBox, A = this.data.size, u = this.trackedObject3D || this.el.object3D, f = this.boundingBoxSize, x = this.data.minimumColliderDimension;
                    if (A) {
                      this.boundingBoxSize.x = A, this.boundingBoxSize.y = A, this.boundingBoxSize.z = A;
                      return;
                    }
                    c.copy(u.rotation), u.rotation.set(0, 0, 0), u.parent.matrixWorld.decompose(E, l, y), p.compose(E, d, y), u.parent.matrixWorld.copy(p), g.setFromObject(u, !0), g.getSize(f), f.x = f.x < x ? x : f.x, f.y = f.y < x ? x : f.y, f.z = f.z < x ? x : f.z, u.parent.matrixWorld.compose(E, l, y), this.el.object3D.rotation.copy(c);
                  };
                }(),
                checkTrackedObject: function() {
                  var E = this.trackedObject3DPath, y;
                  if (E && E.length && !this.trackedObject3D) {
                    y = this.el;
                    for (var l = 0; l < E.length && (y = y[E[l]], !!y); l++)
                      ;
                    y && (this.trackedObject3D = y, this.updateCollider());
                  }
                  return this.trackedObject3D;
                },
                tick: function() {
                  var E = new w.Vector3(), y = new w.Vector3(), l = new w.Quaternion(), d = new w.Matrix4();
                  return function() {
                    var p = this.obb, c = this.renderColliderMesh, g = this.checkTrackedObject() || this.el.object3D;
                    g && (g.updateMatrix(), g.updateMatrixWorld(!0), g.matrixWorld.decompose(E, l, y), (Math.abs(y.x - this.previousScale.x) > 1e-4 || Math.abs(y.y - this.previousScale.y) > 1e-4 || Math.abs(y.z - this.previousScale.z) > 1e-4) && this.updateCollider(), this.previousScale.copy(y), y.set(1, 1, 1), d.compose(E, l, y), c && c.matrixWorld.copy(d), p.copy(this.aabb), p.applyMatrix4(d));
                  };
                }()
              });
            }
          ),
          /***/
          "./src/components/obj-model.js": (
            /*!*************************************!*\
              !*** ./src/components/obj-model.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils/debug */
                "./src/utils/debug.js"
              ), w = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), y = C("components:obj-model:warn");
              j.exports.Component = w("obj-model", {
                schema: {
                  mtl: {
                    type: "model"
                  },
                  obj: {
                    type: "model"
                  }
                },
                init: function() {
                  var l = this;
                  this.model = null, this.objLoader = new E.OBJLoader(), this.mtlLoader = new E.MTLLoader(this.objLoader.manager), this.mtlLoader.crossOrigin = "", this.el.addEventListener("componentinitialized", function(d) {
                    l.model && d.detail.name === "material" && l.applyMaterial();
                  });
                },
                update: function() {
                  var l = this.data;
                  l.obj && (this.resetMesh(), this.loadObj(l.obj, l.mtl));
                },
                remove: function() {
                  this.resetMesh();
                },
                resetMesh: function() {
                  this.model && this.el.removeObject3D("mesh");
                },
                loadObj: function(l, d) {
                  var p = this, c = this.el, g = this.mtlLoader, A = this.objLoader, u = this.el.sceneEl.systems.renderer, f = d.substr(0, d.lastIndexOf("/") + 1);
                  if (d) {
                    c.hasAttribute("material") && y("Material component properties are ignored when a .MTL is provided"), g.setResourcePath(f), g.load(d, function(x) {
                      x.preload(), A.setMaterials(x), A.load(l, function(T) {
                        p.model = T, p.model.traverse(function(b) {
                          if (b.isMesh) {
                            var D = b.material;
                            D.map && u.applyColorCorrection(D.map), D.emissiveMap && u.applyColorCorrection(D.emissiveMap);
                          }
                        }), c.setObject3D("mesh", T), c.emit("model-loaded", {
                          format: "obj",
                          model: T
                        });
                      });
                    });
                    return;
                  }
                  A.load(l, function(T) {
                    p.model = T, p.applyMaterial(), c.setObject3D("mesh", T), c.emit("model-loaded", {
                      format: "obj",
                      model: T
                    });
                  });
                },
                /**
                 * Apply material from material component recursively.
                 */
                applyMaterial: function() {
                  var l = this.el.components.material;
                  l && this.model.traverse(function(d) {
                    d instanceof E.Mesh && (d.material = l.material);
                  });
                }
              });
            }
          ),
          /***/
          "./src/components/oculus-go-controls.js": (
            /*!**********************************************!*\
              !*** ./src/components/oculus-go-controls.js ***!
              \**********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), E = w.checkControllerPresentAndSetup, y = w.emitIfAxesChanged, l = w.onButtonEvent, d = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ).device.isWebXRAvailable, p = "oculus-go", c = "Oculus Go", g = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, A = g + "controllers/oculus/go/oculus-go-controller.gltf", u = d ? p : c, f = {
                axes: {
                  trackpad: [0, 1]
                },
                buttons: ["trackpad", "trigger"]
              }, x = {
                axes: {
                  touchpad: [0, 1]
                },
                buttons: ["trigger", "none", "touchpad"]
              }, T = d ? x : f;
              j.exports.Component = C("oculus-go-controls", {
                schema: {
                  hand: {
                    default: ""
                  },
                  // This informs the degenerate arm model.
                  buttonColor: {
                    type: "color",
                    default: "#FFFFFF"
                  },
                  buttonTouchedColor: {
                    type: "color",
                    default: "#BBBBBB"
                  },
                  buttonHighlightColor: {
                    type: "color",
                    default: "#7A7A7A"
                  },
                  model: {
                    default: !0
                  },
                  orientationOffset: {
                    type: "vec3"
                  },
                  armModel: {
                    default: !0
                  }
                },
                mapping: T,
                bindMethods: function() {
                  this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                init: function() {
                  var b = this;
                  this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(D) {
                    l(D.detail.id, "down", b);
                  }, this.onButtonUp = function(D) {
                    l(D.detail.id, "up", b);
                  }, this.onButtonTouchStart = function(D) {
                    l(D.detail.id, "touchstart", b);
                  }, this.onButtonTouchEnd = function(D) {
                    l(D.detail.id, "touchend", b);
                  }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.bindMethods();
                },
                addEventListeners: function() {
                  var b = this.el;
                  b.addEventListener("buttonchanged", this.onButtonChanged), b.addEventListener("buttondown", this.onButtonDown), b.addEventListener("buttonup", this.onButtonUp), b.addEventListener("touchstart", this.onButtonTouchStart), b.addEventListener("touchend", this.onButtonTouchEnd), b.addEventListener("model-loaded", this.onModelLoaded), b.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var b = this.el;
                  b.removeEventListener("buttonchanged", this.onButtonChanged), b.removeEventListener("buttondown", this.onButtonDown), b.removeEventListener("buttonup", this.onButtonUp), b.removeEventListener("touchstart", this.onButtonTouchStart), b.removeEventListener("touchend", this.onButtonTouchEnd), b.removeEventListener("model-loaded", this.onModelLoaded), b.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
                },
                checkIfControllerPresent: function() {
                  E(this, u, this.data.hand ? {
                    hand: this.data.hand
                  } : {});
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                injectTrackedControls: function() {
                  var b = this.el, D = this.data;
                  b.setAttribute("tracked-controls", {
                    armModel: D.armModel,
                    hand: D.hand,
                    idPrefix: u,
                    orientationOffset: D.orientationOffset
                  }), this.data.model && this.el.setAttribute("gltf-model", A);
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                // No need for onButtonChanged, since Oculus Go controller has no analog buttons.
                onModelLoaded: function(b) {
                  var D = b.detail.model, S;
                  b.target !== this.el || !this.data.model || (S = this.buttonMeshes = {}, S.trigger = D.getObjectByName("oculus_go_button_trigger"), S.trackpad = D.getObjectByName("oculus_go_touchpad"), S.touchpad = D.getObjectByName("oculus_go_touchpad"));
                },
                onButtonChanged: function(b) {
                  var D = this.mapping.buttons[b.detail.id];
                  D && this.el.emit(D + "changed", b.detail.state);
                },
                onAxisMoved: function(b) {
                  y(this, this.mapping.axes, b);
                },
                updateModel: function(b, D) {
                  this.data.model && this.updateButtonModel(b, D);
                },
                updateButtonModel: function(b, D) {
                  var S = this.buttonMeshes;
                  if (!(!S || !S[b])) {
                    var U, G;
                    switch (D) {
                      case "down":
                        U = this.data.buttonHighlightColor;
                        break;
                      case "touchstart":
                        U = this.data.buttonTouchedColor;
                        break;
                      default:
                        U = this.data.buttonColor;
                    }
                    G = S[b], G.material.color.set(U);
                  }
                }
              });
            }
          ),
          /***/
          "./src/components/oculus-touch-controls.js": (
            /*!*************************************************!*\
              !*** ./src/components/oculus-touch-controls.js ***!
              \*************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), y = E.checkControllerPresentAndSetup, l = E.emitIfAxesChanged, d = E.onButtonEvent, p = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ).device.isWebXRAvailable, c = "oculus-touch", g = "Oculus Touch", A = p ? c : g, u = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, f = u + "controllers/oculus/oculus-touch-controller-", x = u + "controllers/meta/", T = {
                left: {
                  modelUrl: f + "left.gltf",
                  rayOrigin: {
                    origin: {
                      x: 8e-3,
                      y: -0.01,
                      z: 0
                    },
                    direction: {
                      x: 0,
                      y: -0.8,
                      z: -1
                    }
                  },
                  modelPivotOffset: new w.Vector3(-5e-3, 3e-3, -0.055),
                  modelPivotRotation: new w.Euler(0, 0, 0)
                },
                right: {
                  modelUrl: f + "right.gltf",
                  rayOrigin: {
                    origin: {
                      x: -8e-3,
                      y: -0.01,
                      z: 0
                    },
                    direction: {
                      x: 0,
                      y: -0.8,
                      z: -1
                    }
                  },
                  modelPivotOffset: new w.Vector3(5e-3, 3e-3, -0.055),
                  modelPivotRotation: new w.Euler(0, 0, 0)
                }
              }, b = {
                left: {
                  modelUrl: f + "left.gltf",
                  rayOrigin: {
                    origin: {
                      x: 2e-3,
                      y: -5e-3,
                      z: -0.03
                    },
                    direction: {
                      x: 0,
                      y: -0.8,
                      z: -1
                    }
                  },
                  modelPivotOffset: new w.Vector3(-5e-3, 0.036, -0.037),
                  modelPivotRotation: new w.Euler(Math.PI / 4.5, 0, 0)
                },
                right: {
                  modelUrl: f + "right.gltf",
                  rayOrigin: {
                    origin: {
                      x: -2e-3,
                      y: -5e-3,
                      z: -0.03
                    },
                    direction: {
                      x: 0,
                      y: -0.8,
                      z: -1
                    }
                  },
                  modelPivotOffset: new w.Vector3(5e-3, 0.036, -0.037),
                  modelPivotRotation: new w.Euler(Math.PI / 4.5, 0, 0)
                }
              }, D = p ? b : T, S = "oculus-touch", U = {
                "oculus-touch": D,
                "oculus-touch-v2": {
                  left: {
                    modelUrl: f + "gen2-left.gltf",
                    rayOrigin: {
                      origin: {
                        x: -6e-3,
                        y: -0.03,
                        z: -0.04
                      },
                      direction: {
                        x: 0,
                        y: -0.9,
                        z: -1
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, -7e-3, -0.021),
                    modelPivotRotation: new w.Euler(-Math.PI / 4, 0, 0)
                  },
                  right: {
                    modelUrl: f + "gen2-right.gltf",
                    rayOrigin: {
                      origin: {
                        x: 6e-3,
                        y: -0.03,
                        z: -0.04
                      },
                      direction: {
                        x: 0,
                        y: -0.9,
                        z: -1
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, -7e-3, -0.021),
                    modelPivotRotation: new w.Euler(-Math.PI / 4, 0, 0)
                  }
                },
                "oculus-touch-v3": {
                  left: {
                    modelUrl: f + "v3-left.glb",
                    rayOrigin: {
                      origin: {
                        x: 65e-4,
                        y: -0.0186,
                        z: -0.05
                      },
                      direction: {
                        x: 0.12394785839500175,
                        y: -0.5944043672340157,
                        z: -0.7945567170519814
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, 0, 0),
                    modelPivotRotation: new w.Euler(0, 0, 0)
                  },
                  right: {
                    modelUrl: f + "v3-right.glb",
                    rayOrigin: {
                      origin: {
                        x: -65e-4,
                        y: -0.0186,
                        z: -0.05
                      },
                      direction: {
                        x: -0.12394785839500175,
                        y: -0.5944043672340157,
                        z: -0.7945567170519814
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, 0, 0),
                    modelPivotRotation: new w.Euler(0, 0, 0)
                  }
                },
                "meta-quest-touch-pro": {
                  left: {
                    modelUrl: x + "quest-touch-pro-left.glb",
                    rayOrigin: {
                      origin: {
                        x: 65e-4,
                        y: -0.0186,
                        z: -0.05
                      },
                      direction: {
                        x: 0.12394785839500175,
                        y: -0.5944043672340157,
                        z: -0.7945567170519814
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, 0, 0),
                    modelPivotRotation: new w.Euler(0, 0, 0)
                  },
                  right: {
                    modelUrl: x + "quest-touch-pro-right.glb",
                    rayOrigin: {
                      origin: {
                        x: -65e-4,
                        y: -0.0186,
                        z: -0.05
                      },
                      direction: {
                        x: -0.12394785839500175,
                        y: -0.5944043672340157,
                        z: -0.7945567170519814
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, 0, 0),
                    modelPivotRotation: new w.Euler(0, 0, 0)
                  }
                },
                "meta-quest-touch-plus": {
                  left: {
                    modelUrl: x + "quest-touch-plus-left.glb",
                    rayOrigin: {
                      origin: {
                        x: 65e-4,
                        y: -0.0186,
                        z: -0.05
                      },
                      direction: {
                        x: 0.12394785839500175,
                        y: -0.5944043672340157,
                        z: -0.7945567170519814
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, 0, 0),
                    modelPivotRotation: new w.Euler(0, 0, 0)
                  },
                  right: {
                    modelUrl: x + "quest-touch-plus-right.glb",
                    rayOrigin: {
                      origin: {
                        x: -65e-4,
                        y: -0.0186,
                        z: -0.05
                      },
                      direction: {
                        x: -0.12394785839500175,
                        y: -0.5944043672340157,
                        z: -0.7945567170519814
                      }
                    },
                    modelPivotOffset: new w.Vector3(0, 0, 0),
                    modelPivotRotation: new w.Euler(0, 0, 0)
                  }
                }
              }, G = {
                left: {
                  axes: {
                    thumbstick: [0, 1]
                  },
                  buttons: ["thumbstick", "trigger", "grip", "xbutton", "ybutton", "surface"]
                },
                right: {
                  axes: {
                    thumbstick: [0, 1]
                  },
                  buttons: ["thumbstick", "trigger", "grip", "abutton", "bbutton", "surface"]
                }
              }, Z = {
                left: {
                  axes: {
                    thumbstick: [2, 3]
                  },
                  buttons: ["trigger", "grip", "none", "thumbstick", "xbutton", "ybutton", "surface"]
                },
                right: {
                  axes: {
                    thumbstick: [2, 3]
                  },
                  buttons: ["trigger", "grip", "none", "thumbstick", "abutton", "bbutton", "surface"]
                }
              }, W = p ? Z : G;
              j.exports.Component = C("oculus-touch-controls", {
                schema: {
                  hand: {
                    default: "left"
                  },
                  buttonColor: {
                    type: "color",
                    default: "#999"
                  },
                  // Off-white.
                  buttonTouchColor: {
                    type: "color",
                    default: "#8AB"
                  },
                  buttonHighlightColor: {
                    type: "color",
                    default: "#2DF"
                  },
                  // Light blue.
                  model: {
                    default: !0
                  },
                  controllerType: {
                    default: "auto",
                    oneOf: ["auto", "oculus-touch", "oculus-touch-v2", "oculus-touch-v3"]
                  },
                  orientationOffset: {
                    type: "vec3",
                    default: {
                      x: 43,
                      y: 0,
                      z: 0
                    }
                  }
                },
                after: ["tracked-controls"],
                mapping: W,
                bindMethods: function() {
                  this.onButtonChanged = this.onButtonChanged.bind(this), this.onThumbstickMoved = this.onThumbstickMoved.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                init: function() {
                  var te = this;
                  this.onButtonDown = function(X) {
                    d(X.detail.id, "down", te, te.data.hand);
                  }, this.onButtonUp = function(X) {
                    d(X.detail.id, "up", te, te.data.hand);
                  }, this.onButtonTouchStart = function(X) {
                    d(X.detail.id, "touchstart", te, te.data.hand);
                  }, this.onButtonTouchEnd = function(X) {
                    d(X.detail.id, "touchend", te, te.data.hand);
                  }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.previousButtonValues = {}, this.bindMethods(), this.triggerEuler = new w.Euler();
                },
                addEventListeners: function() {
                  var te = this.el;
                  te.addEventListener("buttonchanged", this.onButtonChanged), te.addEventListener("buttondown", this.onButtonDown), te.addEventListener("buttonup", this.onButtonUp), te.addEventListener("touchstart", this.onButtonTouchStart), te.addEventListener("touchend", this.onButtonTouchEnd), te.addEventListener("axismove", this.onAxisMoved), te.addEventListener("model-loaded", this.onModelLoaded), te.addEventListener("thumbstickmoved", this.onThumbstickMoved), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var te = this.el;
                  te.removeEventListener("buttonchanged", this.onButtonChanged), te.removeEventListener("buttondown", this.onButtonDown), te.removeEventListener("buttonup", this.onButtonUp), te.removeEventListener("touchstart", this.onButtonTouchStart), te.removeEventListener("touchend", this.onButtonTouchEnd), te.removeEventListener("axismove", this.onAxisMoved), te.removeEventListener("model-loaded", this.onModelLoaded), te.removeEventListener("thumbstickmoved", this.onThumbstickMoved), this.controllerEventsActive = !1;
                },
                checkIfControllerPresent: function() {
                  y(this, A, {
                    hand: this.data.hand,
                    iterateControllerProfiles: !0
                  });
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                loadModel: function(te) {
                  var X = this.data, Q;
                  if (X.model) {
                    if (this.controllerObject3D) {
                      this.el.setObject3D("mesh", this.controllerObject3D);
                      return;
                    }
                    if (this.displayModel = U[X.controllerType] || U[S], X.controllerType === "auto") {
                      var O = this.el.sceneEl.systems["tracked-controls-webvr"];
                      if (O && O.vrDisplay) {
                        var K = O.vrDisplay.displayName;
                        /^Oculus Quest$/.test(K) && (this.displayModel = U["oculus-touch-v2"]);
                      } else {
                        Q = S;
                        for (var ne = Object.keys(U), pe = 0; pe < te.profiles.length; pe++)
                          if (ne.indexOf(te.profiles[pe]) !== -1) {
                            Q = te.profiles[pe];
                            break;
                          }
                        this.displayModel = U[Q];
                      }
                    }
                    var be = this.displayModel[X.hand].modelUrl;
                    this.isTouchV3orPROorPlus = this.displayModel === U["oculus-touch-v3"] || this.displayModel === U["meta-quest-touch-pro"] || this.displayModel === U["meta-quest-touch-plus"], this.el.setAttribute("gltf-model", be);
                  }
                },
                injectTrackedControls: function(te) {
                  var X = this.data, Q = c, O = X.hand === "right" ? "Oculus Touch (Right)" : "Oculus Touch (Left)", K = p ? Q : O;
                  this.el.setAttribute("tracked-controls", {
                    id: K,
                    hand: X.hand,
                    orientationOffset: X.orientationOffset,
                    handTrackingEnabled: !1,
                    iterateControllerProfiles: !0,
                    space: "gripSpace"
                  }), this.loadModel(te);
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                onButtonChanged: function(te) {
                  var X = this.mapping[this.data.hand].buttons[te.detail.id];
                  if (X) {
                    if (this.isTouchV3orPROorPlus)
                      this.onButtonChangedV3orPROorPlus(te);
                    else {
                      var Q = this.buttonMeshes, O;
                      (X === "trigger" || X === "grip") && (O = te.detail.state.value), Q && (X === "trigger" && Q.trigger && (Q.trigger.rotation.x = this.originalXRotationTrigger - O * (Math.PI / 26)), X === "grip" && Q.grip && (O *= this.data.hand === "left" ? -1 : 1, Q.grip.position.x = this.originalXPositionGrip + O * 4e-3));
                    }
                    this.el.emit(X + "changed", te.detail.state);
                  }
                },
                onButtonChangedV3orPROorPlus: function(te) {
                  var X = this.mapping[this.data.hand].buttons[te.detail.id], Q = this.buttonObjects, O;
                  !Q || !Q[X] || (O = te.detail.state.value, Q[X].quaternion.slerpQuaternions(this.buttonRanges[X].min.quaternion, this.buttonRanges[X].max.quaternion, O), Q[X].position.lerpVectors(this.buttonRanges[X].min.position, this.buttonRanges[X].max.position, O));
                },
                onModelLoaded: function(te) {
                  if (!(te.target !== this.el || !this.data.model)) {
                    if (this.isTouchV3orPROorPlus)
                      this.onTouchV3orPROorPlusModelLoaded(te);
                    else {
                      var X = this.controllerObject3D = te.detail.model, Q;
                      Q = this.buttonMeshes = {}, Q.grip = X.getObjectByName("buttonHand"), this.originalXPositionGrip = Q.grip && Q.grip.position.x, Q.trigger = X.getObjectByName("buttonTrigger"), this.originalXRotationTrigger = Q.trigger && Q.trigger.rotation.x, Q.thumbstick = X.getObjectByName("stick"), Q.xbutton = X.getObjectByName("buttonX"), Q.abutton = X.getObjectByName("buttonA"), Q.ybutton = X.getObjectByName("buttonY"), Q.bbutton = X.getObjectByName("buttonB");
                    }
                    for (var O in this.buttonMeshes)
                      this.buttonMeshes[O] && ie(this.buttonMeshes[O]);
                    this.applyOffset(te.detail.model), this.el.emit("controllermodelready", {
                      name: "oculus-touch-controls",
                      model: this.data.model,
                      rayOrigin: this.displayModel[this.data.hand].rayOrigin
                    });
                  }
                },
                applyOffset: function(te) {
                  te.position.copy(this.displayModel[this.data.hand].modelPivotOffset), te.rotation.copy(this.displayModel[this.data.hand].modelPivotRotation);
                },
                onTouchV3orPROorPlusModelLoaded: function(te) {
                  var X = this.controllerObject3D = te.detail.model, Q = this.buttonObjects = {}, O = this.buttonMeshes = {}, K = this.buttonRanges = {};
                  O.grip = X.getObjectByName("squeeze"), Q.grip = X.getObjectByName("xr_standard_squeeze_pressed_value"), K.grip = {
                    min: X.getObjectByName("xr_standard_squeeze_pressed_min"),
                    max: X.getObjectByName("xr_standard_squeeze_pressed_max")
                  }, Q.grip.minX = Q.grip.position.x, O.thumbstick = X.getObjectByName("thumbstick"), Q.thumbstick = X.getObjectByName("xr_standard_thumbstick_pressed_value"), K.thumbstick = {
                    min: X.getObjectByName("xr_standard_thumbstick_pressed_min"),
                    max: X.getObjectByName("xr_standard_thumbstick_pressed_max")
                  }, Q.thumbstickXAxis = X.getObjectByName("xr_standard_thumbstick_xaxis_pressed_value"), K.thumbstickXAxis = {
                    min: X.getObjectByName("xr_standard_thumbstick_xaxis_pressed_min"),
                    max: X.getObjectByName("xr_standard_thumbstick_xaxis_pressed_max")
                  }, Q.thumbstickYAxis = X.getObjectByName("xr_standard_thumbstick_yaxis_pressed_value"), K.thumbstickYAxis = {
                    min: X.getObjectByName("xr_standard_thumbstick_yaxis_pressed_min"),
                    max: X.getObjectByName("xr_standard_thumbstick_yaxis_pressed_max")
                  }, O.trigger = X.getObjectByName("trigger"), Q.trigger = X.getObjectByName("xr_standard_trigger_pressed_value"), K.trigger = {
                    min: X.getObjectByName("xr_standard_trigger_pressed_min"),
                    max: X.getObjectByName("xr_standard_trigger_pressed_max")
                  }, K.trigger.diff = {
                    x: Math.abs(K.trigger.max.rotation.x) - Math.abs(K.trigger.min.rotation.x),
                    y: Math.abs(K.trigger.max.rotation.y) - Math.abs(K.trigger.min.rotation.y),
                    z: Math.abs(K.trigger.max.rotation.z) - Math.abs(K.trigger.min.rotation.z)
                  };
                  var ne = this.data.hand === "left" ? "x" : "a", pe = this.data.hand === "left" ? "y" : "b", be = ne + "button", Te = pe + "button";
                  O[be] = X.getObjectByName(ne + "_button"), Q[be] = X.getObjectByName(ne + "_button_pressed_value"), K[be] = {
                    min: X.getObjectByName(ne + "_button_pressed_min"),
                    max: X.getObjectByName(ne + "_button_pressed_max")
                  }, O[Te] = X.getObjectByName(pe + "_button"), Q[Te] = X.getObjectByName(pe + "_button_pressed_value"), K[Te] = {
                    min: X.getObjectByName(pe + "_button_pressed_min"),
                    max: X.getObjectByName(pe + "_button_pressed_max")
                  };
                },
                onAxisMoved: function(te) {
                  l(this, this.mapping[this.data.hand].axes, te);
                },
                onThumbstickMoved: function(te) {
                  if (!(!this.buttonMeshes || !this.buttonMeshes.thumbstick)) {
                    if (this.isTouchV3orPROorPlus) {
                      this.updateThumbstickTouchV3orPROorPlus(te);
                      return;
                    }
                    for (var X in te.detail)
                      this.buttonObjects.thumbstick.rotation[this.axisMap[X]] = this.buttonRanges.thumbstick.originalRotation[this.axisMap[X]] - Math.PI / 8 * te.detail[X] * (X === "y" || this.data.hand === "right" ? -1 : 1);
                  }
                },
                axisMap: {
                  y: "x",
                  x: "z"
                },
                updateThumbstickTouchV3orPROorPlus: function(te) {
                  var X = (te.detail.x + 1) / 2;
                  this.buttonObjects.thumbstickXAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickXAxis.min.quaternion, this.buttonRanges.thumbstickXAxis.max.quaternion, X);
                  var Q = (te.detail.y + 1) / 2;
                  this.buttonObjects.thumbstickYAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickYAxis.min.quaternion, this.buttonRanges.thumbstickYAxis.max.quaternion, Q);
                },
                updateModel: function(te, X) {
                  this.data.model && this.updateButtonModel(te, X);
                },
                updateButtonModel: function(te, X) {
                  var Q = this.buttonMeshes, O, K;
                  Q && Q[te] && (K = X === "up" || X === "touchend" ? Q[te].originalColor || this.data.buttonColor : X === "touchstart" ? this.data.buttonTouchColor : this.data.buttonHighlightColor, O = Q[te], O.material.color.set(K));
                }
              });
              function ie(te) {
                te.traverse(function(X) {
                  var Q;
                  X.type === "Mesh" && (Q = X.material.clone(), te.originalColor = X.material.color, X.material.dispose(), X.material = Q);
                });
              }
            }
          ),
          /***/
          "./src/components/pico-controls.js": (
            /*!*****************************************!*\
              !*** ./src/components/pico-controls.js ***!
              \*****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), y = E.checkControllerPresentAndSetup, l = E.emitIfAxesChanged, d = E.onButtonEvent, p = "pico-4", c = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, g = c + "controllers/pico/pico4/", A = {
                left: {
                  axes: {
                    touchpad: [2, 3]
                  },
                  buttons: ["trigger", "squeeze", "none", "thumbstick", "xbutton", "ybutton"]
                },
                right: {
                  axes: {
                    touchpad: [2, 3]
                  },
                  buttons: ["trigger", "squeeze", "none", "thumbstick", "abutton", "bbutton"]
                }
              };
              j.exports.Component = C("pico-controls", {
                schema: {
                  hand: {
                    default: "none"
                  },
                  model: {
                    default: !0
                  },
                  orientationOffset: {
                    type: "vec3"
                  }
                },
                mapping: A,
                init: function() {
                  var u = this;
                  this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(f) {
                    d(f.detail.id, "down", u, u.data.hand);
                  }, this.onButtonUp = function(f) {
                    d(f.detail.id, "up", u, u.data.hand);
                  }, this.onButtonTouchEnd = function(f) {
                    d(f.detail.id, "touchend", u, u.data.hand);
                  }, this.onButtonTouchStart = function(f) {
                    d(f.detail.id, "touchstart", u, u.data.hand);
                  }, this.bindMethods();
                },
                update: function() {
                  var u = this.data;
                  this.controllerIndex = u.hand === "right" ? 0 : u.hand === "left" ? 1 : 2;
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                bindMethods: function() {
                  this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                addEventListeners: function() {
                  var u = this.el;
                  u.addEventListener("buttonchanged", this.onButtonChanged), u.addEventListener("buttondown", this.onButtonDown), u.addEventListener("buttonup", this.onButtonUp), u.addEventListener("touchstart", this.onButtonTouchStart), u.addEventListener("touchend", this.onButtonTouchEnd), u.addEventListener("axismove", this.onAxisMoved), u.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var u = this.el;
                  u.removeEventListener("buttonchanged", this.onButtonChanged), u.removeEventListener("buttondown", this.onButtonDown), u.removeEventListener("buttonup", this.onButtonUp), u.removeEventListener("touchstart", this.onButtonTouchStart), u.removeEventListener("touchend", this.onButtonTouchEnd), u.removeEventListener("axismove", this.onAxisMoved), u.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
                },
                checkIfControllerPresent: function() {
                  var u = this.data;
                  y(this, p, {
                    index: this.controllerIndex,
                    hand: u.hand
                  });
                },
                injectTrackedControls: function() {
                  var u = this.el, f = this.data;
                  u.setAttribute("tracked-controls", {
                    // TODO: verify expected behavior between reserved prefixes.
                    idPrefix: p,
                    hand: f.hand,
                    controller: this.controllerIndex,
                    orientationOffset: f.orientationOffset
                  }), this.data.model && this.el.setAttribute("gltf-model", g + this.data.hand + ".glb");
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                onButtonChanged: function(u) {
                  var f = this.mapping[this.data.hand].buttons[u.detail.id], x;
                  f && (f === "trigger" && (x = u.detail.state.value, console.log("analog value of trigger press: " + x)), this.el.emit(f + "changed", u.detail.state));
                },
                onModelLoaded: function(u) {
                  u.target !== this.el || !this.data.model || this.el.emit("controllermodelready", {
                    name: "pico-controls",
                    model: this.data.model,
                    rayOrigin: new w.Vector3(0, 0, 0)
                  });
                },
                onAxisMoved: function(u) {
                  l(this, this.mapping.axes, u);
                }
              });
            }
          ),
          /***/
          "./src/components/position.js": (
            /*!************************************!*\
              !*** ./src/components/position.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("position", {
                schema: {
                  type: "vec3"
                },
                update: function() {
                  var w = this.el.object3D, E = this.data;
                  w.position.set(E.x, E.y, E.z);
                },
                remove: function() {
                  this.el.object3D.position.set(0, 0, 0);
                }
              });
            }
          ),
          /***/
          "./src/components/raycaster.js": (
            /*!*************************************!*\
              !*** ./src/components/raycaster.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), y = E.debug("components:raycaster:warn"), l = /^[\w\s-.,[\]#]*$/, d = {
                childList: !0,
                attributes: !0,
                subtree: !0
              }, p = {
                INTERSECT: "raycaster-intersected",
                INTERSECTION: "raycaster-intersection",
                INTERSECT_CLEAR: "raycaster-intersected-cleared",
                INTERSECTION_CLEAR: "raycaster-intersection-cleared",
                INTERSECTION_CLOSEST_ENTITY_CHANGED: "raycaster-closest-entity-changed"
              };
              j.exports.Component = C("raycaster", {
                schema: {
                  autoRefresh: {
                    default: !0
                  },
                  direction: {
                    type: "vec3",
                    default: {
                      x: 0,
                      y: 0,
                      z: -1
                    }
                  },
                  enabled: {
                    default: !0
                  },
                  far: {
                    default: 1e3
                  },
                  interval: {
                    default: 0
                  },
                  near: {
                    default: 0
                  },
                  objects: {
                    default: ""
                  },
                  origin: {
                    type: "vec3"
                  },
                  showLine: {
                    default: !1
                  },
                  lineColor: {
                    default: "white"
                  },
                  lineOpacity: {
                    default: 1
                  },
                  useWorldCoordinates: {
                    default: !1
                  }
                },
                multiple: !0,
                init: function() {
                  this.clearedIntersectedEls = [], this.unitLineEndVec3 = new w.Vector3(), this.intersectedEls = [], this.intersections = [], this.newIntersectedEls = [], this.newIntersections = [], this.objects = [], this.prevCheckTime = void 0, this.prevIntersectedEls = [], this.rawIntersections = [], this.raycaster = new w.Raycaster(), this.updateOriginDirection(), this.setDirty = this.setDirty.bind(this), this.updateLine = this.updateLine.bind(this), this.observer = new MutationObserver(this.setDirty), this.dirty = !0, this.lineEndVec3 = new w.Vector3(), this.otherLineEndVec3 = new w.Vector3(), this.lineData = {
                    end: this.lineEndVec3
                  }, this.getIntersection = this.getIntersection.bind(this), this.intersectedDetail = {
                    el: this.el,
                    getIntersection: this.getIntersection
                  }, this.intersectedClearedDetail = {
                    el: this.el
                  }, this.intersectionClearedDetail = {
                    clearedEls: this.clearedIntersectedEls
                  }, this.intersectionDetail = {};
                },
                /**
                 * Create or update raycaster object.
                 */
                update: function(g) {
                  var A = this.data, u = this.el, f = this.raycaster;
                  f.far = A.far, f.near = A.near, A.showLine && (A.far !== g.far || A.origin !== g.origin || A.direction !== g.direction || !g.showLine) && (this.unitLineEndVec3.copy(A.direction).normalize(), this.drawLine()), !A.showLine && g.showLine && u.removeAttribute("line"), A.objects !== g.objects && !l.test(A.objects) && y('[raycaster] Selector "' + A.objects + '" may not update automatically with DOM changes.'), A.objects || y('[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'), A.autoRefresh !== g.autoRefresh && u.isPlaying && (A.autoRefresh ? this.addEventListeners() : this.removeEventListeners()), g.enabled && !A.enabled && this.clearAllIntersections(), this.setDirty();
                },
                play: function() {
                  this.addEventListeners();
                },
                pause: function() {
                  this.removeEventListeners();
                },
                remove: function() {
                  this.data.showLine && this.el.removeAttribute("line"), this.clearAllIntersections();
                },
                addEventListeners: function() {
                  this.data.autoRefresh && (this.observer.observe(this.el.sceneEl, d), this.el.sceneEl.addEventListener("object3dset", this.setDirty), this.el.sceneEl.addEventListener("object3dremove", this.setDirty));
                },
                removeEventListeners: function() {
                  this.observer.disconnect(), this.el.sceneEl.removeEventListener("object3dset", this.setDirty), this.el.sceneEl.removeEventListener("object3dremove", this.setDirty);
                },
                /**
                 * Mark the object list as dirty, to be refreshed before next raycast.
                 */
                setDirty: function() {
                  this.dirty = !0;
                },
                /**
                 * Update list of objects to test for intersection.
                 */
                refreshObjects: function() {
                  var g = this.data, A;
                  A = g.objects ? this.el.sceneEl.querySelectorAll(g.objects) : this.el.sceneEl.querySelectorAll("*"), this.objects = this.flattenObject3DMaps(A), this.dirty = !1;
                },
                /**
                 * Check for intersections and cleared intersections on an interval.
                 */
                tock: function(g) {
                  var A = this.data, u = this.prevCheckTime;
                  A.enabled && (u && g - u < A.interval || (this.prevCheckTime = g, this.checkIntersections()));
                },
                /**
                 * Raycast for intersections and emit events for current and cleared intersections.
                 */
                checkIntersections: function() {
                  var g = this.clearedIntersectedEls, A = this.el, u = this.data, f, x = this.intersectedEls, T, b = this.intersections, D = this.newIntersectedEls, S = this.newIntersections, U = this.prevIntersectedEls, G = this.rawIntersections;
                  for (this.dirty && this.refreshObjects(), c(this.prevIntersectedEls, this.intersectedEls), this.updateOriginDirection(), G.length = 0, this.raycaster.intersectObjects(this.objects, !0, G), b.length = 0, x.length = 0, f = 0; f < G.length; f++)
                    T = G[f], !(u.showLine && T.object === A.getObject3D("line")) && T.object.el && (b.push(T), x.push(T.object.el));
                  for (S.length = 0, D.length = 0, f = 0; f < b.length; f++)
                    U.indexOf(b[f].object.el) === -1 && (S.push(b[f]), D.push(b[f].object.el));
                  for (g.length = 0, f = 0; f < U.length; f++)
                    x.indexOf(U[f]) === -1 && (U[f].emit(p.INTERSECT_CLEAR, this.intersectedClearedDetail), g.push(U[f]));
                  for (g.length && A.emit(p.INTERSECTION_CLEAR, this.intersectionClearedDetail), f = 0; f < D.length; f++)
                    D[f].emit(p.INTERSECT, this.intersectedDetail);
                  S.length && (this.intersectionDetail.els = D, this.intersectionDetail.intersections = S, A.emit(p.INTERSECTION, this.intersectionDetail)), (U.length === 0 && b.length > 0 || U.length > 0 && b.length === 0 || U.length && b.length && U[0] !== b[0].object.el) && (this.intersectionDetail.els = this.intersectedEls, this.intersectionDetail.intersections = b, A.emit(p.INTERSECTION_CLOSEST_ENTITY_CHANGED, this.intersectionDetail)), u.showLine && setTimeout(this.updateLine);
                },
                updateLine: function() {
                  var g = this.el, A = this.intersections, u;
                  A.length && (A[0].object.el === g && A[1] ? u = A[1].distance : u = A[0].distance), this.drawLine(u);
                },
                /**
                 * Return the most recent intersection details for a given entity, if any.
                 * @param {AEntity} el
                 * @return {Object}
                 */
                getIntersection: function(g) {
                  var A, u;
                  for (A = 0; A < this.intersections.length; A++)
                    if (u = this.intersections[A], u.object.el === g)
                      return u;
                  return null;
                },
                /**
                 * Update origin and direction of raycaster using entity transforms and supplied origin or
                 * direction offsets.
                 */
                updateOriginDirection: function() {
                  var g = new w.Vector3(), A = new w.Vector3();
                  return function() {
                    var f = this.el, x = this.data;
                    if (x.useWorldCoordinates) {
                      this.raycaster.set(x.origin, x.direction);
                      return;
                    }
                    f.object3D.updateMatrixWorld(), A.setFromMatrixPosition(f.object3D.matrixWorld), (x.origin.x !== 0 || x.origin.y !== 0 || x.origin.z !== 0) && (A = f.object3D.localToWorld(A.copy(x.origin))), g.copy(x.direction).transformDirection(f.object3D.matrixWorld).normalize(), this.raycaster.set(A, g);
                  };
                }(),
                /**
                 * Create or update line to give raycaster visual representation.
                 * Customize the line through through line component.
                 * We draw the line in the raycaster component to customize the line to the
                 * raycaster's origin, direction, and far.
                 *
                 * Unlike the raycaster, we create the line as a child of the object. The line will
                 * be affected by the transforms of the objects, so we don't have to calculate transforms
                 * like we do with the raycaster.
                 *
                 * @param {number} length - Length of line. Pass in to shorten the line to the intersection
                 *   point. If not provided, length will default to the max length, `raycaster.far`.
                 */
                drawLine: function(g) {
                  var A = this.data, u = this.el, f;
                  f = this.lineData.end === this.lineEndVec3 ? this.otherLineEndVec3 : this.lineEndVec3, g === void 0 && (g = A.far === 1 / 0 ? 1e3 : A.far), this.lineData.start = A.origin, this.lineData.end = f.copy(this.unitLineEndVec3).multiplyScalar(g).add(A.origin), this.lineData.color = A.lineColor, this.lineData.opacity = A.lineOpacity, u.setAttribute("line", this.lineData);
                },
                /**
                 * Return A-Frame attachments of each element's object3D group (e.g., mesh).
                 * Children are flattened by one level, removing the THREE.Group wrapper,
                 * so that non-recursive raycasting remains useful.
                 *
                 * Only push children defined as component attachments (e.g., setObject3D),
                 * NOT actual children in the scene graph hierarchy.
                 *
                 * @param  {Array<Element>} els
                 * @return {Array<THREE.Object3D>}
                 */
                flattenObject3DMaps: function(g) {
                  var A, u, f = this.objects, x = this.el.sceneEl.object3D;
                  function T(D) {
                    return D.parent ? T(D.parent) : D === x;
                  }
                  for (f.length = 0, u = 0; u < g.length; u++) {
                    var b = g[u];
                    if (b.isEntity && b.object3D && T(b.object3D))
                      for (A in b.object3DMap)
                        f.push(b.getObject3D(A));
                  }
                  return f;
                },
                clearAllIntersections: function() {
                  var g;
                  for (g = 0; g < this.intersectedEls.length; g++)
                    this.intersectedEls[g].emit(p.INTERSECT_CLEAR, this.intersectedClearedDetail);
                  c(this.clearedIntersectedEls, this.intersectedEls), this.intersectedEls.length = 0, this.intersections.length = 0, this.el.emit(p.INTERSECTION_CLEAR, this.intersectionClearedDetail);
                }
              });
              function c(g, A) {
                var u;
                for (g.length = A.length, u = 0; u < A.length; u++)
                  g[u] = A[u];
              }
            }
          ),
          /***/
          "./src/components/rotation.js": (
            /*!************************************!*\
              !*** ./src/components/rotation.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ).MathUtils.degToRad, w = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = w("rotation", {
                schema: {
                  type: "vec3"
                },
                /**
                 * Updates object3D rotation.
                 */
                update: function() {
                  var E = this.data, y = this.el.object3D;
                  y.rotation.set(C(E.x), C(E.y), C(E.z), "YXZ");
                },
                remove: function() {
                  this.el.object3D.rotation.set(0, 0, 0);
                }
              });
            }
          ),
          /***/
          "./src/components/scale.js": (
            /*!*********************************!*\
              !*** ./src/components/scale.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("scale", {
                schema: {
                  type: "vec3",
                  default: {
                    x: 1,
                    y: 1,
                    z: 1
                  }
                },
                update: function() {
                  var w = this.data, E = this.el.object3D;
                  E.scale.set(w.x, w.y, w.z);
                },
                remove: function() {
                  this.el.object3D.scale.set(1, 1, 1);
                }
              });
            }
          ),
          /***/
          "./src/components/scene/ar-hit-test.js": (
            /*!*********************************************!*\
              !*** ./src/components/scene/ar-hit-test.js ***!
              \*********************************************/
            /***/
            (j, re, v) => {
              var C = "data:image/webp;base64,UklGRkQHAABXRUJQVlA4WAoAAAAQAAAA/wEA/wEAQUxQSL0DAAARDzD/ERGCjrY9sYYFfgo6aa1kJ7K0w9Lo3AadLSVeFxevQwj5kuM8RfR/Atw/C0+ozB/oUBrloFZs6ElSW88j1KA4yExNWQaqRZquIDF0JYmlq0hAuUDTFu66tng3teW7pa3cQf1V1edvur54M/Slm6Wv3Gx9zw0MXlQLntcsBN6wkHjTQuYtC4W3LTw8mGRVG57TbAROtxHfZNhInGkjc5aNwtk2Hg6Mvki14k+NkZzCwQgCxalcAv3kddRTPI1DcUrXId1FLf1uHpzaQz4tquhZVLlKesbVpqKeTj0n0F5PpXDlFN9UqmhalL/ImuZFo6KmToWLoKlddMprqlS8cKovBvHo2kTiFV2LN4msaxKZl3QNiair8xYRdDWivIvXVXmbcMqJ51UebZuFXxZt6xd4laxtciqRtA3Cv0nU1t+kEUFbI8JvCa+tvkm3FDlO/W+OR99+kWEp/YYo+tYfTVnf/K8cE/F///3vv//993eeL+a+uvjawLcX3xjYvJotBFY3kVjTRGFtE+BU2AiMbiQyhpHMWEYeBozAH5qNBYRDB5KBCaTDBKKBAZTDBoKBDjwHAN5ABeCJBsAZcAAC0YHHxAYSMYBiYgGZWEA2MYFCbCCZGAAIANFEB+AnYgMQTDQAYSJ2AN5EBZAm4gDgTDgAeSIu4DGygTIRN1CMLOCZiACykQlg4jsAycgA8AO+BxCNdJyDkcbwRirDGXGnx8w+FDPrkM3MQ9JQZMYhiiwV/RDMtIM3U1/DmXHUo+IR2kSR2ToWkQ1NIn2qf2J8LCqJKiDUiSADHY3whirhdHgZ94HKaR97PhE+twEUJUFoAcgyTct8hfSxSkShASDKdMJ/ritKHwgyQ0sD4D/miCxU5SbhOOUDTnZpccCjYP/i0bZ/8bAgtVGEoGapWIQXyzKVKLwgNJFk2rtMIgoNRJlOZF7SNSSyUEeQmbxBFKEmtYjEe8S8zOZ1AkJVCmS88FJOtF40Ksg4oUaFiygk3C8qlTVNyl8UTevCUdAE2t14PfVqU1FPp57TopKeQZWromddTQp6QOfTOEQt/ZDuipZ11w/wOiqO8dRORcc6BQEkDQMClaHcn5wV9yLbxsNZNgpn2sicYSNxuo34Js1G4FQbnuNsOPa28PCWhcKbFjJvWEi8ZiHwqgXPcxbc5db33Cx95WboSzddX7yp+vyN0+eul7ZyN7Xlu64t3jVt4c5pc4JLV5EYupJE0xUknC4nOjVlmaYpyLit53HCQ0+ScnqceNcS5dzUkd0/CwMAVlA4IGADAAAQXwCdASoAAgACP8ne6Wy/tjCpqJ/IA/A5CWlu4XYBG/Pz8AfwD8APz//f3v8E1fuHZnxKYACtfuHZnxKYACrYTb5mOslhxu843ecbvON3nG7zjd3a0VCn7G1MABVxwH/Xd25gAK1+4dmfEpe2+PHhQaj75++riG6FuYACtfuHZnxKYACRrK3q9xO8Ss3uWKnMhs/rDF1hi6wxdYYusMXWGI5QRcCFDZog5OgqNlse1NDuz/UoFa/cOzPiUwAEsAOK4/nu5eZHK2tlXxJfNYlMABWv3Dsz4bvNJ5YA/LtxJ38SmAArX7h2Z8Sk5vdZUYv7mZPiUwAFa/cOzPh21s5OgZxf1mfEpemRyFr/rM+JS9noA/LtxJ38SmAAlUJIotzAASn6TjdhK+D3Dsz4dyvB7h2Z8O2tnJ0DOL+sz4lL2nKLT4lL/+iSLOocxq639w7M34MNZdm55uJ8v8ra2cpVZnxKTq2F3PN/cNksAfl24k7+JTAASqrD37h2Z7b1W+VtbOUqsz4lJ1bC7nm/uGyWAPy7cSd/EpgAJVVh79w7M9t6rfK2tnKVWZ8Sk6thdzzf3DZLAH5duJO/iUwAEqqw9+4dme29VvlbWzlKrM+JSdWwu55v7hslgD8u3EnfxKYACVVYe/cOzPbeq3ytrZylVme0kYJ8557FLerqFrzIbPrrf3DZLAH5duJO/iUvaVMS9BoaF4p7pSDFTP1XMyfElelrM0DOL+sz4eBJ13nV1OppBGPuKb4YzXQgq9uH19uS/0+JS9t9fr6ZUlQBelDG6GMgq97otb5QMPJwtKyBTbFp8Sl7b6/X0ykkawEOsgdiE6Fi0vb/Eve6xkwsmug0Z4nGNHQO8839bpTsjpz7SWIJxKagvd1QWMa6FYT1KEw3j4XDT6vJ9Xk+nyfT5Pq8n1eEmk5dinMM/9Fcfz4Z3Dsz3KD2dw7LxBRxKrqUUGQPH/7zxr1KIfNpLEJ0MZB2ITM/0Z2EFoh12NlXnEcpYcbvON3nG7zjd5xu84vfcNIAAP7+y8ceyzbVxkakPYY4lcr72fqOnDwipv+yxC71wAADBrjKnAAAAAAAAAAAAAAw7oNGHttqWONcoFN/2WIDc2pa6WVFtFYROlsaMaTXdcOjXHz93+YxAglKa4AAAAA=", w = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, E = v(
                /*! ../../lib/three */
                "./src/lib/three.js"
              ), y = 21, l = function() {
                var g = new E.Quaternion(), A = new E.Vector3();
                function u(f, x, T) {
                  x.position.copy(f.transform.position), x.quaternion.copy(f.transform.orientation), A.copy(T), g.copy(f.transform.orientation), A.applyQuaternion(g), x.position.sub(A);
                }
                return u;
              }();
              l.tempFakePose = {
                transform: {
                  orientation: new E.Quaternion(),
                  position: new E.Vector3()
                }
              };
              function d(g, A) {
                this.renderer = g, this.xrHitTestSource = null, g.xr.addEventListener("sessionend", function() {
                  this.xrHitTestSource = null;
                }.bind(this)), g.xr.addEventListener("sessionstart", function() {
                  this.sessionStart(A);
                }.bind(this)), this.renderer.xr.isPresenting && this.sessionStart(A);
              }
              d.prototype.previousFrameAnchors = /* @__PURE__ */ new Set(), d.prototype.anchorToObject3D = /* @__PURE__ */ new Map();
              function p(g) {
                console.warn(g.message), console.warn('Cannot requestHitTestSource Are you missing: webxr="optionalFeatures: hit-test;" from <a-scene>?');
              }
              d.prototype.sessionStart = function(A) {
                if (this.session = this.renderer.xr.getSession(), !("requestHitTestSource" in this.session)) {
                  p({
                    message: "No requestHitTestSource on the session."
                  });
                  return;
                }
                A.space ? this.session.requestHitTestSource(A).then(function(u) {
                  this.xrHitTestSource = u;
                }.bind(this)).catch(p) : A.profile && this.session.requestHitTestSourceForTransientInput(A).then(function(u) {
                  this.xrHitTestSource = u, this.transient = !0;
                }.bind(this)).catch(p);
              }, d.prototype.anchorFromLastHitTestResult = function(g, A) {
                var u = this.lastHitTest;
                if (u) {
                  var f = {
                    object3D: g,
                    offset: A
                  };
                  Array.from(this.anchorToObject3D.entries()).forEach(function(x) {
                    var T = x[1].object3D, b = x[0];
                    T === g && (this.anchorToObject3D.delete(b), b.delete());
                  }.bind(this)), u.createAnchor && u.createAnchor().then(function(x) {
                    this.anchorToObject3D.set(x, f);
                  }.bind(this)).catch(function(x) {
                    console.warn(x.message), console.warn('Cannot create anchor, are you missing: webxr="optionalFeatures: anchors;" from <a-scene>?');
                  });
                }
              }, d.prototype.doHit = function(A) {
                if (this.renderer.xr.isPresenting) {
                  var u = this.renderer.xr.getReferenceSpace(), f = A.getViewerPose(u), x, T;
                  if (this.xrHitTestSource && f)
                    return this.transient ? (x = A.getHitTestResultsForTransientInput(this.xrHitTestSource), x.length > 0 ? (T = x[0].results, T.length > 0 ? (this.lastHitTest = T[0], T[0].getPose(u)) : !1) : !1) : (x = A.getHitTestResults(this.xrHitTestSource), x.length > 0 ? (this.lastHitTest = x[0], x[0].getPose(u)) : !1);
                }
              }, d.updateAnchorPoses = function(g, A) {
                var u = g.trackedAnchors || d.prototype.previousFrameAnchors;
                d.prototype.previousFrameAnchors.forEach(function(f) {
                  u.has(f) || d.prototype.anchorToObject3D.delete(f);
                }), u.forEach(function(f) {
                  var x, T, b, D;
                  try {
                    x = g.getPose(f.anchorSpace, A);
                  } catch {
                  }
                  if (x) {
                    if (T = d.prototype.anchorToObject3D.get(f), !T)
                      return;
                    b = T.offset, D = T.object3D, l(x, D, b);
                  }
                });
              };
              var c;
              j.exports.Component = w("ar-hit-test", {
                schema: {
                  target: {
                    type: "selector"
                  },
                  enabled: {
                    default: !0
                  },
                  src: {
                    default: C,
                    type: "map"
                  },
                  type: {
                    default: "footprint",
                    oneOf: ["footprint", "map"]
                  },
                  footprintDepth: {
                    default: 0.1
                  },
                  mapSize: {
                    type: "vec2",
                    default: {
                      x: 0.5,
                      y: 0.5
                    }
                  }
                },
                sceneOnly: !0,
                init: function() {
                  this.hitTest = null, this.imageDataArray = new Uint8ClampedArray(1048576), this.imageData = new ImageData(this.imageDataArray, 512, 512), this.textureCache = /* @__PURE__ */ new Map(), this.orthoCam = new E.OrthographicCamera(), this.orthoCam.layers.set(y), this.textureTarget = new E.WebGLRenderTarget(512, 512, {}), this.basicMaterial = new E.MeshBasicMaterial({
                    color: 0,
                    side: E.DoubleSide
                  }), this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.context.imageSmoothingEnabled = !1, this.canvas.width = 512, this.canvas.height = 512, this.canvasTexture = new E.CanvasTexture(this.canvas, {
                    alpha: !0
                  }), this.canvasTexture.flipY = !1;
                  var g = this.el.getAttribute("webxr"), A = g.optionalFeatures;
                  (!A.includes("hit-test") || !A.includes("anchors")) && (A.push("hit-test"), A.push("anchors"), this.el.setAttribute("webxr", g)), this.el.sceneEl.renderer.xr.addEventListener("sessionend", function() {
                    this.hitTest = null;
                  }.bind(this)), this.el.sceneEl.renderer.xr.addEventListener("sessionstart", function() {
                    if (this.el.is("ar-mode")) {
                      var u = this.el.sceneEl.renderer, f = this.session = u.xr.getSession();
                      this.hasPosedOnce = !1, this.bboxMesh.visible = !1, c || (c = /* @__PURE__ */ new Map()), f.requestReferenceSpace("viewer").then(function(b) {
                        this.hitTest = new d(u, {
                          space: b
                        }), c.set(b, this.hitTest), this.el.emit("ar-hit-test-start");
                      }.bind(this));
                      var x = "generic-touchscreen", T = new d(u, {
                        profile: x
                      });
                      f.addEventListener("selectstart", function(b) {
                        if (this.data.enabled === !0) {
                          var D = b.inputSource;
                          this.bboxMesh.visible = !0, this.hasPosedOnce === !0 && (this.el.emit("ar-hit-test-select-start", {
                            inputSource: D,
                            position: this.bboxMesh.position,
                            orientation: this.bboxMesh.quaternion
                          }), D.profiles[0] === x ? this.hitTest = T : (this.hitTest = c.get(D) || new d(u, {
                            space: D.targetRaySpace
                          }), c.set(D, this.hitTest)));
                        }
                      }.bind(this)), f.addEventListener("selectend", function(b) {
                        if (!this.hitTest || this.data.enabled !== !0) {
                          this.hitTest = null;
                          return;
                        }
                        var D = b.inputSource, S;
                        this.hasPosedOnce === !0 && (this.bboxMesh.visible = !1, this.data.target && (S = this.data.target.object3D, S && (l.tempFakePose.transform.position.copy(this.bboxMesh.position), l.tempFakePose.transform.orientation.copy(this.bboxMesh.quaternion), l(l.tempFakePose, S, this.bboxOffset), S.visible = !0, this.hitTest.anchorFromLastHitTestResult(S, this.bboxOffset))), this.el.emit("ar-hit-test-select", {
                          inputSource: D,
                          position: this.bboxMesh.position,
                          orientation: this.bboxMesh.quaternion
                        })), this.hitTest = null;
                      }.bind(this));
                    }
                  }.bind(this)), this.bboxOffset = new E.Vector3(), this.update = this.update.bind(this), this.makeBBox();
                },
                update: function() {
                  this.data.enabled === !1 && (this.hitTest = null, this.bboxMesh.visible = !1), this.data.target && (this.data.target.object3D ? (this.data.target.addEventListener("model-loaded", this.update), this.data.target.object3D.layers.enable(y), this.data.target.object3D.traverse(function(g) {
                    g.layers.enable(y);
                  })) : this.data.target.addEventListener("loaded", this.update, {
                    once: !0
                  })), this.bboxNeedsUpdate = !0;
                },
                makeBBox: function() {
                  var g = new E.PlaneGeometry(1, 1), A = new E.MeshBasicMaterial({
                    transparent: !0,
                    color: 16777215
                  });
                  g.rotateX(-Math.PI / 2), g.rotateY(-Math.PI / 2), this.bbox = new E.Box3(), this.bboxMesh = new E.Mesh(g, A), this.el.setObject3D("ar-hit-test", this.bboxMesh), this.bboxMesh.visible = !1;
                },
                updateFootprint: function() {
                  var g, A = this.el.sceneEl.renderer, u, f, x = A.xr.enabled;
                  this.bboxMesh.material.map = this.canvasTexture, this.bboxMesh.material.needsUpdate = !0, this.orthoCam.rotation.set(-Math.PI / 2, 0, -Math.PI / 2), this.orthoCam.position.copy(this.bboxMesh.position), this.orthoCam.position.y -= this.bboxMesh.scale.y / 2, this.orthoCam.near = 0.1, this.orthoCam.far = this.orthoCam.near + this.data.footprintDepth * this.bboxMesh.scale.y, this.orthoCam.position.y += this.orthoCam.far, this.orthoCam.right = this.bboxMesh.scale.z / 2, this.orthoCam.left = -this.bboxMesh.scale.z / 2, this.orthoCam.top = this.bboxMesh.scale.x / 2, this.orthoCam.bottom = -this.bboxMesh.scale.x / 2, this.orthoCam.updateProjectionMatrix(), u = A.getRenderTarget(), A.setRenderTarget(this.textureTarget), A.xr.enabled = !1, f = this.el.object3D.background, this.el.object3D.overrideMaterial = this.basicMaterial, this.el.object3D.background = null, A.render(this.el.object3D, this.orthoCam), this.el.object3D.background = f, this.el.object3D.overrideMaterial = null, A.xr.enabled = x, A.setRenderTarget(u), A.readRenderTargetPixels(this.textureTarget, 0, 0, 512, 512, this.imageDataArray), this.context.putImageData(this.imageData, 0, 0), this.context.shadowColor = "white", this.context.shadowBlur = 10, this.context.drawImage(this.canvas, 0, 0), g = this.context.getImageData(0, 0, 512, 512);
                  for (var T = 0; T < 262144; T++)
                    g.data[T * 4 + 3] !== 0 && g.data[T * 4 + 3] !== 255 && (g.data[T * 4 + 3] = 128);
                  this.context.putImageData(g, 0, 0), this.canvasTexture.needsUpdate = !0;
                },
                tick: function() {
                  var g, A = this.el.sceneEl.frame, u = this.el.sceneEl.renderer;
                  if (A && d.updateAnchorPoses(A, u.xr.getReferenceSpace()), this.bboxNeedsUpdate) {
                    if (this.bboxNeedsUpdate = !1, !this.data.target || this.data.type === "map") {
                      var f;
                      this.textureCache.has(this.data.src) ? f = this.textureCache.get(this.data.src) : (f = new E.TextureLoader().load(this.data.src), this.textureCache.set(this.data.src, f)), this.bboxMesh.material.map = f, this.bboxMesh.material.needsUpdate = !0;
                    }
                    this.data.target && this.data.target.object3D ? (this.bbox.setFromObject(this.data.target.object3D), this.bbox.getCenter(this.bboxMesh.position), this.bbox.getSize(this.bboxMesh.scale), this.data.type === "footprint" && (this.bboxMesh.scale.x *= 1.04, this.bboxMesh.scale.z *= 1.04, this.updateFootprint()), this.bboxMesh.position.y -= this.bboxMesh.scale.y / 2, this.bboxOffset.copy(this.bboxMesh.position), this.bboxOffset.sub(this.data.target.object3D.position)) : this.bboxMesh.scale.set(this.data.mapSize.x, 1, this.data.mapSize.y);
                  }
                  this.hitTest && (g = this.hitTest.doHit(A), g && (this.hasPosedOnce !== !0 && (this.hasPosedOnce = !0, this.el.emit("ar-hit-test-achieved")), this.bboxMesh.visible = !0, this.bboxMesh.position.copy(g.transform.position), this.bboxMesh.quaternion.copy(g.transform.orientation)));
                }
              });
            }
          ),
          /***/
          "./src/components/scene/background.js": (
            /*!********************************************!*\
              !*** ./src/components/scene/background.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("background", {
                schema: {
                  color: {
                    type: "color",
                    default: "black"
                  },
                  transparent: {
                    default: !1
                  }
                },
                sceneOnly: !0,
                update: function() {
                  var w = this.data, E = this.el.object3D;
                  w.transparent ? E.background = null : E.background = new THREE.Color(w.color);
                },
                remove: function() {
                  var w = this.el.object3D;
                  w.background = null;
                }
              });
            }
          ),
          /***/
          "./src/components/scene/debug.js": (
            /*!***************************************!*\
              !*** ./src/components/scene/debug.js ***!
              \***************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("debug", {
                schema: {
                  default: !0
                },
                sceneOnly: !0
              });
            }
          ),
          /***/
          "./src/components/scene/device-orientation-permission-ui.js": (
            /*!******************************************************************!*\
              !*** ./src/components/scene/device-orientation-permission-ui.js ***!
              \******************************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../constants/ */
                "./src/constants/index.js"
              ), E = "a-modal", y = "a-dialog", l = "a-dialog-text", d = "a-dialog-text-container", p = "a-dialog-buttons-container", c = "a-dialog-button", g = "a-dialog-allow-button", A = "a-dialog-deny-button", u = "a-dialog-ok-button";
              j.exports.Component = C("device-orientation-permission-ui", {
                schema: {
                  enabled: {
                    default: !0
                  },
                  deviceMotionMessage: {
                    default: "This immersive website requires access to your device motion sensors."
                  },
                  httpsMessage: {
                    default: "Access this site over HTTPS to enter VR mode and grant access to the device sensors."
                  },
                  denyButtonText: {
                    default: "Deny"
                  },
                  allowButtonText: {
                    default: "Allow"
                  },
                  cancelButtonText: {
                    default: "Cancel"
                  }
                },
                sceneOnly: !0,
                init: function() {
                  var b = this;
                  if (this.data.enabled) {
                    if (window.isSecureContext || this.showHTTPAlert(), typeof DeviceOrientationEvent > "u" || !DeviceOrientationEvent.requestPermission) {
                      this.permissionGranted = !0;
                      return;
                    }
                    this.onDeviceMotionDialogAllowClicked = this.onDeviceMotionDialogAllowClicked.bind(this), this.onDeviceMotionDialogDenyClicked = this.onDeviceMotionDialogDenyClicked.bind(this), DeviceOrientationEvent.requestPermission().then(function() {
                      b.el.emit("deviceorientationpermissiongranted"), b.permissionGranted = !0;
                    }).catch(function() {
                      b.devicePermissionDialogEl = f(b.data.denyButtonText, b.data.allowButtonText, b.data.deviceMotionMessage, b.onDeviceMotionDialogAllowClicked, b.onDeviceMotionDialogDenyClicked), b.el.appendChild(b.devicePermissionDialogEl);
                    });
                  }
                },
                remove: function() {
                  this.devicePermissionDialogEl && this.el.removeChild(this.devicePermissionDialogEl);
                },
                onDeviceMotionDialogDenyClicked: function() {
                  this.remove();
                },
                showHTTPAlert: function() {
                  var b = this, D = x(b.data.cancelButtonText, b.data.httpsMessage, function() {
                    b.el.removeChild(D);
                  });
                  this.el.appendChild(D);
                },
                /**
                 * Enable device motion permission when clicked.
                 */
                onDeviceMotionDialogAllowClicked: function() {
                  var b = this;
                  this.el.emit("deviceorientationpermissionrequested"), DeviceOrientationEvent.requestPermission().then(function(D) {
                    D === "granted" ? (b.el.emit("deviceorientationpermissiongranted"), b.permissionGranted = !0) : b.el.emit("deviceorientationpermissionrejected"), b.remove();
                  }).catch(console.error);
                }
              });
              function f(b, D, S, U, G) {
                var Z, W, ie;
                return Z = document.createElement("div"), Z.classList.add(p), W = document.createElement("button"), W.classList.add(c, A), W.setAttribute(w.AFRAME_INJECTED, ""), W.innerHTML = b, Z.appendChild(W), ie = document.createElement("button"), ie.classList.add(c, g), ie.setAttribute(w.AFRAME_INJECTED, ""), ie.innerHTML = D, Z.appendChild(ie), ie.addEventListener("click", function(te) {
                  te.stopPropagation(), U();
                }), W.addEventListener("click", function(te) {
                  te.stopPropagation(), G();
                }), T(S, Z);
              }
              function x(b, D, S) {
                var U, G;
                return U = document.createElement("div"), U.classList.add(p), G = document.createElement("button"), G.classList.add(c, u), G.setAttribute(w.AFRAME_INJECTED, ""), G.innerHTML = b, U.appendChild(G), G.addEventListener("click", function(Z) {
                  Z.stopPropagation(), S();
                }), T(D, U);
              }
              function T(b, D) {
                var S, U, G, Z;
                return S = document.createElement("div"), S.classList.add(E), S.setAttribute(w.AFRAME_INJECTED, ""), U = document.createElement("div"), U.className = y, U.setAttribute(w.AFRAME_INJECTED, ""), S.appendChild(U), G = document.createElement("div"), G.classList.add(d), U.appendChild(G), Z = document.createElement("div"), Z.classList.add(l), Z.innerHTML = b, G.appendChild(Z), U.appendChild(D), S;
              }
            }
          ),
          /***/
          "./src/components/scene/embedded.js": (
            /*!******************************************!*\
              !*** ./src/components/scene/embedded.js ***!
              \******************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("embedded", {
                dependencies: ["xr-mode-ui"],
                schema: {
                  default: !0
                },
                sceneOnly: !0,
                update: function() {
                  var w = this.el, E = w.querySelector(".a-enter-vr");
                  this.data === !0 ? (E && E.classList.add("embedded"), w.removeFullScreenStyles()) : (E && E.classList.remove("embedded"), w.addFullScreenStyles());
                }
              });
            }
          ),
          /***/
          "./src/components/scene/fog.js": (
            /*!*************************************!*\
              !*** ./src/components/scene/fog.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../../utils/debug */
                "./src/utils/debug.js"
              );
              E("components:fog:warn"), j.exports.Component = C("fog", {
                schema: {
                  color: {
                    type: "color",
                    default: "#000"
                  },
                  density: {
                    default: 25e-5
                  },
                  far: {
                    default: 1e3,
                    min: 0
                  },
                  near: {
                    default: 1,
                    min: 0
                  },
                  type: {
                    default: "linear",
                    oneOf: ["linear", "exponential"]
                  }
                },
                sceneOnly: !0,
                update: function() {
                  var l = this.data, d = this.el, p = this.el.object3D.fog;
                  if (!p || l.type !== p.name) {
                    d.object3D.fog = y(l);
                    return;
                  }
                  Object.keys(this.schema).forEach(function(c) {
                    var g = l[c];
                    c === "color" && (g = new w.Color(g)), p[c] = g;
                  });
                },
                /**
                 * Remove fog on remove (callback).
                 */
                remove: function() {
                  var l = this.el, d = this.el.object3D.fog;
                  d && (l.object3D.fog = null);
                }
              });
              function y(l) {
                var d;
                return l.type === "exponential" ? d = new w.FogExp2(l.color, l.density) : d = new w.Fog(l.color, l.near, l.far), d.name = l.type, d;
              }
            }
          ),
          /***/
          "./src/components/scene/inspector.js": (
            /*!*******************************************!*\
              !*** ./src/components/scene/inspector.js ***!
              \*******************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../constants */
                "./src/constants/index.js"
              ).AFRAME_INJECTED, w = v(
                /*! ../../../package */
                "./package.json"
              ), E = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, y = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              );
              function l(A) {
                var u = A.split(".");
                return u[2] = "x", u.join(".");
              }
              var d = "https://unpkg.com/aframe-inspector@" + l(w.version) + "/dist/aframe-inspector.min.js", p = d, c = "Loading Inspector", g = "Error loading Inspector";
              j.exports.Component = E("inspector", {
                schema: {
                  url: {
                    default: p
                  }
                },
                sceneOnly: !0,
                init: function() {
                  this.firstPlay = !0, this.onKeydown = this.onKeydown.bind(this), this.onMessage = this.onMessage.bind(this), this.initOverlay(), window.addEventListener("keydown", this.onKeydown), window.addEventListener("message", this.onMessage);
                },
                play: function() {
                  var A;
                  this.firstPlay && (A = y.getUrlParameter("inspector"), A !== "false" && A && (this.openInspector(), this.firstPlay = !1));
                },
                initOverlay: function() {
                  var A = '<span class="dots"><span>.</span><span>.</span><span>.</span></span>';
                  this.loadingMessageEl = document.createElement("div"), this.loadingMessageEl.classList.add("a-inspector-loader"), this.loadingMessageEl.innerHTML = c + A;
                },
                remove: function() {
                  this.removeEventListeners();
                },
                /**
                 * <ctrl> + <alt> + i keyboard shortcut.
                 */
                onKeydown: function(A) {
                  var u = A.keyCode === 73 && (A.ctrlKey && A.altKey || A.getModifierState("AltGraph"));
                  u && this.openInspector();
                },
                showLoader: function() {
                  document.body.appendChild(this.loadingMessageEl);
                },
                hideLoader: function() {
                  document.body.removeChild(this.loadingMessageEl);
                },
                /**
                 * postMessage. aframe.io uses this to create a button on examples to open Inspector.
                 */
                onMessage: function(A) {
                  A.data === "INJECT_AFRAME_INSPECTOR" && this.openInspector();
                },
                openInspector: function(A) {
                  var u = this, f;
                  if (AFRAME.INSPECTOR || AFRAME.inspectorInjected) {
                    AFRAME.INSPECTOR.open(A);
                    return;
                  }
                  this.showLoader(), f = document.createElement("script"), f.src = this.data.url, f.setAttribute("data-name", "aframe-inspector"), f.setAttribute(C, ""), f.onload = function() {
                    AFRAME.INSPECTOR.open(A), u.hideLoader(), u.removeEventListeners();
                  }, f.onerror = function() {
                    u.loadingMessageEl.innerHTML = g;
                  }, document.head.appendChild(f), AFRAME.inspectorInjected = !0;
                },
                removeEventListeners: function() {
                  window.removeEventListener("keydown", this.onKeydown), window.removeEventListener("message", this.onMessage);
                }
              });
            }
          ),
          /***/
          "./src/components/scene/keyboard-shortcuts.js": (
            /*!****************************************************!*\
              !*** ./src/components/scene/keyboard-shortcuts.js ***!
              \****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              ).shouldCaptureKeyEvent;
              j.exports.Component = C("keyboard-shortcuts", {
                schema: {
                  enterVR: {
                    default: !0
                  },
                  exitVR: {
                    default: !0
                  }
                },
                sceneOnly: !0,
                init: function() {
                  this.onKeyup = this.onKeyup.bind(this);
                },
                update: function(E) {
                  var y = this.data;
                  this.enterVREnabled = y.enterVR;
                },
                play: function() {
                  window.addEventListener("keyup", this.onKeyup, !1);
                },
                pause: function() {
                  window.removeEventListener("keyup", this.onKeyup);
                },
                onKeyup: function(E) {
                  var y = this.el;
                  w(E) && (this.enterVREnabled && E.keyCode === 70 && y.enterVR(), this.enterVREnabled && E.keyCode === 27 && y.exitVR());
                }
              });
            }
          ),
          /***/
          "./src/components/scene/pool.js": (
            /*!**************************************!*\
              !*** ./src/components/scene/pool.js ***!
              \**************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../utils/debug */
                "./src/utils/debug.js"
              ), w = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, E = C("components:pool:warn");
              j.exports.Component = w("pool", {
                schema: {
                  container: {
                    default: ""
                  },
                  mixin: {
                    default: ""
                  },
                  size: {
                    default: 0
                  },
                  dynamic: {
                    default: !1
                  }
                },
                sceneOnly: !0,
                multiple: !0,
                initPool: function() {
                  var y;
                  for (this.availableEls = [], this.usedEls = [], this.data.mixin || E("No mixin provided for pool component."), this.data.container && (this.container = document.querySelector(this.data.container), this.container || E("Container " + this.data.container + " not found.")), this.container = this.container || this.el, y = 0; y < this.data.size; ++y)
                    this.createEntity();
                },
                update: function(y) {
                  var l = this.data;
                  (y.mixin !== l.mixin || y.size !== l.size) && this.initPool();
                },
                /**
                 * Add a new entity to the list of available entities.
                 */
                createEntity: function() {
                  var y;
                  y = document.createElement("a-entity"), y.play = this.wrapPlay(y.play), y.setAttribute("mixin", this.data.mixin), y.object3D.visible = !1, y.pause(), this.container.appendChild(y), this.availableEls.push(y);
                  var l = this.usedEls;
                  y.addEventListener("loaded", function() {
                    l.indexOf(y) === -1 && (y.object3DParent = y.object3D.parent, y.object3D.parent.remove(y.object3D));
                  });
                },
                /**
                 * Play wrapper for pooled entities. When pausing and playing a scene, don't want to play
                 * entities that are not in use.
                 */
                wrapPlay: function(y) {
                  var l = this.usedEls;
                  return function() {
                    l.indexOf(this) !== -1 && y.call(this);
                  };
                },
                /**
                 * Used to request one of the available entities of the pool.
                 */
                requestEntity: function() {
                  var y;
                  if (this.availableEls.length === 0) {
                    if (this.data.dynamic === !1) {
                      E("Requested entity from empty pool: " + this.attrName);
                      return;
                    } else
                      E("Requested entity from empty pool. This pool is dynamic and will resize automatically. You might want to increase its initial size: " + this.attrName);
                    this.createEntity();
                  }
                  return y = this.availableEls.shift(), this.usedEls.push(y), y.object3DParent && (y.object3DParent.add(y.object3D), this.updateRaycasters()), y.object3D.visible = !0, y;
                },
                /**
                 * Used to return a used entity to the pool.
                 */
                returnEntity: function(y) {
                  var l = this.usedEls.indexOf(y);
                  if (l === -1) {
                    E("The returned entity was not previously pooled from " + this.attrName);
                    return;
                  }
                  return this.usedEls.splice(l, 1), this.availableEls.push(y), y.object3DParent = y.object3D.parent, y.object3D.parent.remove(y.object3D), this.updateRaycasters(), y.object3D.visible = !1, y.pause(), y;
                },
                updateRaycasters: function() {
                  var y = document.querySelectorAll("[raycaster]");
                  y.forEach(function(l) {
                    l.components.raycaster.setDirty();
                  });
                }
              });
            }
          ),
          /***/
          "./src/components/scene/real-world-meshing.js": (
            /*!****************************************************!*\
              !*** ./src/components/scene/real-world-meshing.js ***!
              \****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../lib/three */
                "./src/lib/three.js"
              );
              j.exports.Component = C("real-world-meshing", {
                schema: {
                  filterLabels: {
                    type: "array"
                  },
                  meshesEnabled: {
                    default: !0
                  },
                  meshMixin: {
                    default: !0
                  },
                  planesEnabled: {
                    default: !0
                  },
                  planeMixin: {
                    default: ""
                  }
                },
                sceneOnly: !0,
                init: function() {
                  var E = this.el.getAttribute("webxr"), y = E.requiredFeatures;
                  y.indexOf("mesh-detection") === -1 && (y.push("mesh-detection"), this.el.setAttribute("webxr", E)), y.indexOf("plane-detection") === -1 && (y.push("plane-detection"), this.el.setAttribute("webxr", E)), this.meshEntities = [], this.initWorldMeshEntity = this.initWorldMeshEntity.bind(this);
                },
                tick: function() {
                  this.el.is("ar-mode") && (this.detectMeshes(), this.updateMeshes());
                },
                detectMeshes: function() {
                  var E = this.data, y, l, d = this.el;
                  d.renderer.xr;
                  var p, c = this.meshEntities, g = !1, A = [], u = this.data.filterLabels;
                  p = d.frame, y = p.detectedMeshes, l = p.detectedPlanes;
                  for (var f = 0; f < c.length; f++)
                    c[f].present = !1;
                  if (E.meshesEnabled) {
                    for (var x of y.values())
                      if (!(u.length && u.indexOf(x.semanticLabel) === -1)) {
                        for (f = 0; f < c.length; f++)
                          if (x === c[f].mesh) {
                            g = !0, c[f].present = !0, c[f].lastChangedTime < x.lastChangedTime && this.updateMeshGeometry(c[f].el, x), c[f].lastChangedTime = x.lastChangedTime;
                            break;
                          }
                        g || A.push(x), g = !1;
                      }
                  }
                  if (E.planesEnabled) {
                    for (x of l.values())
                      if (!(u.length && u.indexOf(x.semanticLabel) === -1)) {
                        for (f = 0; f < c.length; f++)
                          if (x === c[f].mesh) {
                            g = !0, c[f].present = !0, c[f].lastChangedTime < x.lastChangedTime && this.updateMeshGeometry(c[f].el, x), c[f].lastChangedTime = x.lastChangedTime;
                            break;
                          }
                        g || A.push(x), g = !1;
                      }
                  }
                  this.deleteMeshes(), this.createNewMeshes(A);
                },
                updateMeshes: function() {
                  var E = new w.Matrix4();
                  return function() {
                    for (var y, l = this.el, d, p = l.frame, c = this.meshEntities, g = l.renderer.xr.getReferenceSpace(), A, u = 0; u < c.length; u++)
                      A = c[u].mesh.meshSpace || c[u].mesh.planeSpace, y = p.getPose(A, g), d = c[u].el, d.hasLoaded && (E.fromArray(y.transform.matrix), E.decompose(d.object3D.position, d.object3D.quaternion, d.object3D.scale));
                  };
                }(),
                deleteMeshes: function() {
                  for (var E = this.meshEntities, y = [], l = 0; l < E.length; l++)
                    E[l].present ? y.push(E[l]) : this.el.removeChild(E[l]);
                  this.meshEntities = y;
                },
                createNewMeshes: function(E) {
                  for (var y, l = 0; l < E.length; l++)
                    y = document.createElement("a-entity"), this.meshEntities.push({
                      mesh: E[l],
                      el: y
                    }), y.addEventListener("loaded", this.initWorldMeshEntity), this.el.appendChild(y);
                },
                initMeshGeometry: function(E) {
                  var y, l, d;
                  if (E instanceof XRPlane) {
                    l = new w.Shape(), d = E.polygon;
                    for (var p = 0; p < d.length; ++p)
                      p === 0 ? l.moveTo(d[p].x, d[p].z) : l.lineTo(d[p].x, d[p].z);
                    return y = new w.ShapeGeometry(l), y.rotateX(Math.PI / 2), y;
                  }
                  return y = new w.BufferGeometry(), y.setAttribute("position", new w.BufferAttribute(E.vertices, 3)), y.setIndex(new w.BufferAttribute(E.indices, 1)), y;
                },
                initWorldMeshEntity: function(E) {
                  for (var y = E.target, l, d, p, c = this.meshEntities, g = 0; g < c.length; g++)
                    if (c[g].el === y) {
                      p = c[g];
                      break;
                    }
                  l = this.initMeshGeometry(p.mesh), d = new w.Mesh(l, new w.MeshBasicMaterial({
                    color: Math.random() * 16777215,
                    side: w.DoubleSide
                  })), y.setObject3D("mesh", d), p.mesh instanceof XRPlane && this.data.planeMixin ? y.setAttribute("mixin", this.data.planeMixin) : this.data.meshMixin && y.setAttribute("mixin", this.data.meshMixin), y.setAttribute("data-world-mesh", p.mesh.semanticLabel);
                },
                updateMeshGeometry: function(E, y) {
                  var l = E.getObject3D("mesh");
                  l.geometry.dispose(), l.geometry = this.initMeshGeometry(y);
                }
              });
            }
          ),
          /***/
          "./src/components/scene/reflection.js": (
            /*!********************************************!*\
              !*** ./src/components/scene/reflection.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent;
              function w(E, y, l, d) {
                var p = Math.max(E.primaryLightIntensity.x, Math.max(E.primaryLightIntensity.y, E.primaryLightIntensity.z));
                y.sh.fromArray(E.sphericalHarmonicsCoefficients), y.intensity = 1, l && (l.color.setRGB(E.primaryLightIntensity.x / p, E.primaryLightIntensity.y / p, E.primaryLightIntensity.z / p), l.intensity = p, d.copy(E.primaryLightDirection));
              }
              j.exports.Component = C("reflection", {
                schema: {
                  directionalLight: {
                    type: "selector"
                  }
                },
                sceneOnly: !0,
                init: function() {
                  var E = this;
                  this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(16), this.cubeCamera = new THREE.CubeCamera(0.1, 1e3, this.cubeRenderTarget), this.lightingEstimationTexture = new THREE.WebGLCubeRenderTarget(16).texture, this.needsVREnvironmentUpdate = !0;
                  var y = this.el.getAttribute("webxr"), l = y.optionalFeatures;
                  l.includes("light-estimation") || (l.push("light-estimation"), this.el.setAttribute("webxr", y)), this.el.addEventListener("enter-vr", function() {
                    if (E.el.is("ar-mode")) {
                      var d = E.el.renderer, p = d.xr.getSession();
                      p.requestLightProbe && E.startLightProbe();
                    }
                  }), this.el.addEventListener("exit-vr", function() {
                    E.xrLightProbe && E.stopLightProbe();
                  }), this.el.object3D.environment = this.cubeRenderTarget.texture;
                },
                stopLightProbe: function() {
                  this.xrLightProbe = null, this.probeLight && (this.probeLight.components.light.light.intensity = 0), this.needsVREnvironmentUpdate = !0, this.el.object3D.environment = this.cubeRenderTarget.texture;
                },
                startLightProbe: function() {
                  this.needsLightProbeUpdate = !0;
                },
                setupLightProbe: function() {
                  var E = this.el.renderer, y = E.xr.getSession(), l = this, d = E.getContext();
                  if (!this.probeLight) {
                    var p = document.createElement("a-light");
                    p.setAttribute("type", "probe"), p.setAttribute("intensity", 0), this.el.appendChild(p), this.probeLight = p;
                  }
                  switch (y.preferredReflectionFormat) {
                    case "srgba8":
                      d.getExtension("EXT_sRGB");
                      break;
                    case "rgba16f":
                      d.getExtension("OES_texture_half_float");
                      break;
                  }
                  this.glBinding = new XRWebGLBinding(y, d), d.getExtension("EXT_sRGB"), d.getExtension("OES_texture_half_float"), y.requestLightProbe().then(function(c) {
                    l.xrLightProbe = c, c.addEventListener("reflectionchange", l.updateXRCubeMap.bind(l));
                  }).catch(function(c) {
                    console.warn("Lighting estimation not supported: " + c.message), console.warn('Are you missing: webxr="optionalFeatures: light-estimation;" from <a-scene>?');
                  });
                },
                updateXRCubeMap: function() {
                  var E = this.el.renderer, y = this.glBinding.getReflectionCubeMap(this.xrLightProbe);
                  if (y) {
                    var l = E.properties.get(this.lightingEstimationTexture);
                    l.__webglTexture = y, this.lightingEstimationTexture.needsPMREMUpdate = !0, this.el.object3D.environment = this.lightingEstimationTexture;
                  }
                },
                tick: function() {
                  var E = this.el.object3D, y = this.el.renderer, l = this.el.frame;
                  if (l && this.xrLightProbe) {
                    var d = l.getLightEstimate(this.xrLightProbe);
                    d && w(d, this.probeLight.components.light.light, this.data.directionalLight && this.data.directionalLight.components.light.light, this.data.directionalLight && this.data.directionalLight.object3D.position);
                  }
                  this.needsVREnvironmentUpdate && (E.environment = null, this.needsVREnvironmentUpdate = !1, this.cubeCamera.position.set(0, 1.6, 0), this.cubeCamera.update(y, E), E.environment = this.cubeRenderTarget.texture), this.needsLightProbeUpdate && l && (this.setupLightProbe(), this.needsLightProbeUpdate = !1);
                },
                remove: function() {
                  this.el.object3D.environment = null, this.probeLight && this.el.removeChild(this.probeLight);
                }
              });
            }
          ),
          /***/
          "./src/components/scene/screenshot.js": (
            /*!********************************************!*\
              !*** ./src/components/scene/screenshot.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../lib/three */
                "./src/lib/three.js"
              ), E = ["attribute vec3 position;", "attribute vec2 uv;", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "varying vec2 vUv;", "void main()  {", "  vUv = vec2( 1.- uv.x, uv.y );", "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), y = ["precision mediump float;", "uniform samplerCube map;", "varying vec2 vUv;", "#define M_PI 3.141592653589793238462643383279", "void main() {", "  vec2 uv = vUv;", "  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;", "  float latitude = uv.y * M_PI;", "  vec3 dir = vec3(", "    - sin( longitude ) * sin( latitude ),", "    cos( latitude ),", "    - cos( longitude ) * sin( latitude )", "  );", "  normalize( dir );", "  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );", "}"].join(`
`);
              j.exports.Component = C("screenshot", {
                schema: {
                  width: {
                    default: 4096
                  },
                  height: {
                    default: 2048
                  },
                  camera: {
                    type: "selector"
                  }
                },
                sceneOnly: !0,
                setup: function() {
                  var l = this.el;
                  if (!this.canvas) {
                    var d = l.renderer.getContext();
                    d && (this.cubeMapSize = d.getParameter(d.MAX_CUBE_MAP_TEXTURE_SIZE), this.material = new w.RawShaderMaterial({
                      uniforms: {
                        map: {
                          type: "t",
                          value: null
                        }
                      },
                      vertexShader: E,
                      fragmentShader: y,
                      side: w.DoubleSide
                    }), this.quad = new w.Mesh(new w.PlaneGeometry(1, 1), this.material), this.quad.visible = !1, this.camera = new w.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1e4, 1e4), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), l.object3D.add(this.quad), this.onKeyDown = this.onKeyDown.bind(this));
                  }
                },
                getRenderTarget: function(l, d) {
                  return new w.WebGLRenderTarget(l, d, {
                    colorSpace: this.el.sceneEl.renderer.outputColorSpace,
                    minFilter: w.LinearFilter,
                    magFilter: w.LinearFilter,
                    wrapS: w.ClampToEdgeWrapping,
                    wrapT: w.ClampToEdgeWrapping,
                    format: w.RGBAFormat,
                    type: w.UnsignedByteType
                  });
                },
                resize: function(l, d) {
                  this.quad.scale.set(l, d, 1), this.camera.left = -1 * l / 2, this.camera.right = l / 2, this.camera.top = d / 2, this.camera.bottom = -1 * d / 2, this.camera.updateProjectionMatrix(), this.canvas.width = l, this.canvas.height = d;
                },
                play: function() {
                  window.addEventListener("keydown", this.onKeyDown);
                },
                /**
                 * <ctrl> + <alt> + s = Regular screenshot.
                 * <ctrl> + <alt> + <shift> + s = Equirectangular screenshot.
                */
                onKeyDown: function(l) {
                  var d = l.keyCode === 83 && l.ctrlKey && l.altKey;
                  if (!(!this.data || !d)) {
                    var p = l.shiftKey ? "equirectangular" : "perspective";
                    this.capture(p);
                  }
                },
                /**
                 * Capture a screenshot of the scene.
                 *
                 * @param {string} projection - Screenshot projection (equirectangular or perspective).
                 */
                setCapture: function(l) {
                  var d = this.el, p, c, g, A;
                  return l === "perspective" ? (this.quad.visible = !1, c = this.data.camera && this.data.camera.components.camera.camera || d.camera, p = {
                    width: this.data.width,
                    height: this.data.height
                  }) : (c = this.camera, A = new w.WebGLCubeRenderTarget(Math.min(this.cubeMapSize, 2048), {
                    format: w.RGBFormat,
                    generateMipmaps: !0,
                    minFilter: w.LinearMipmapLinearFilter,
                    colorSpace: w.SRGBColorSpace
                  }), g = new w.CubeCamera(d.camera.near, d.camera.far, A), d.camera.getWorldPosition(g.position), d.camera.getWorldQuaternion(g.quaternion), g.update(d.renderer, d.object3D), this.quad.material.uniforms.map.value = g.renderTarget.texture, p = {
                    width: this.data.width,
                    height: this.data.height
                  }, this.quad.visible = !0), {
                    camera: c,
                    size: p,
                    projection: l
                  };
                },
                /**
                 * Maintained for backwards compatibility.
                 */
                capture: function(l) {
                  var d = this.el.renderer.xr.enabled, p = this.el.renderer, c;
                  this.setup(), p.xr.enabled = !1, c = this.setCapture(l), this.renderCapture(c.camera, c.size, c.projection), this.saveCapture(), p.xr.enabled = d;
                },
                /**
                 * Return canvas instead of triggering download (e.g., for uploading blob to server).
                 */
                getCanvas: function(l) {
                  var d = this.el.renderer.xr.enabled, p = this.el.renderer;
                  this.setup();
                  var c = this.setCapture(l);
                  return p.xr.enabled = !1, this.renderCapture(c.camera, c.size, c.projection), p.xr.enabled = d, this.canvas;
                },
                renderCapture: function(l, d, p) {
                  var c = this.el.renderer.autoClear, g = this.el, A, u, f, x = g.renderer;
                  u = this.getRenderTarget(d.width, d.height), f = new Uint8Array(4 * d.width * d.height), this.resize(d.width, d.height), x.autoClear = !0, x.clear(), x.setRenderTarget(u), x.render(g.object3D, l), x.autoClear = c, x.readRenderTargetPixels(u, 0, 0, d.width, d.height, f), x.setRenderTarget(null), p === "perspective" && (f = this.flipPixelsVertically(f, d.width, d.height)), A = new ImageData(new Uint8ClampedArray(f), d.width, d.height), this.quad.visible = !1, this.ctx.putImageData(A, 0, 0);
                },
                flipPixelsVertically: function(l, d, p) {
                  for (var c = l.slice(0), g = 0; g < d; ++g)
                    for (var A = 0; A < p; ++A)
                      c[g * 4 + A * d * 4] = l[g * 4 + (p - A) * d * 4], c[g * 4 + 1 + A * d * 4] = l[g * 4 + 1 + (p - A) * d * 4], c[g * 4 + 2 + A * d * 4] = l[g * 4 + 2 + (p - A) * d * 4], c[g * 4 + 3 + A * d * 4] = l[g * 4 + 3 + (p - A) * d * 4];
                  return c;
                },
                /**
                 * Download capture to file.
                 */
                saveCapture: function() {
                  this.canvas.toBlob(function(l) {
                    var d = "screenshot-" + document.title.toLowerCase() + "-" + Date.now() + ".png", p = document.createElement("a"), c = URL.createObjectURL(l);
                    p.href = c, p.setAttribute("download", d), p.innerHTML = "downloading...", p.style.display = "none", document.body.appendChild(p), setTimeout(function() {
                      p.click(), document.body.removeChild(p);
                    }, 1);
                  }, "image/png");
                }
              });
            }
          ),
          /***/
          "./src/components/scene/stats.js": (
            /*!***************************************!*\
              !*** ./src/components/scene/stats.js ***!
              \***************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../../vendor/rStats */
                "./vendor/rStats.js"
              ), E = v(
                /*! ../../utils */
                "./src/utils/index.js"
              );
              v(
                /*! ../../../vendor/rStats.extras */
                "./vendor/rStats.extras.js"
              ), v(
                /*! ../../lib/rStatsAframe */
                "./src/lib/rStatsAframe.js"
              );
              var y = window.aframeStats, l = "a-hidden", d = window.threeStats;
              j.exports.Component = C("stats", {
                schema: {
                  default: !0
                },
                sceneOnly: !0,
                init: function() {
                  var c = this.el;
                  E.getUrlParameter("stats") !== "false" && (this.stats = p(c), this.statsEl = document.querySelector(".rs-base"), this.hideBound = this.hide.bind(this), this.showBound = this.show.bind(this), c.addEventListener("enter-vr", this.hideBound), c.addEventListener("exit-vr", this.showBound));
                },
                update: function() {
                  if (this.stats)
                    return this.data ? this.show() : this.hide();
                },
                remove: function() {
                  this.el.removeEventListener("enter-vr", this.hideBound), this.el.removeEventListener("exit-vr", this.showBound), this.statsEl && this.statsEl.parentNode.removeChild(this.statsEl);
                },
                tick: function() {
                  var c = this.stats;
                  c && (c("rAF").tick(), c("FPS").frame(), c().update());
                },
                hide: function() {
                  this.statsEl.classList.add(l);
                },
                show: function() {
                  this.statsEl.classList.remove(l);
                }
              });
              function p(c) {
                var g = new d(c.renderer), A = new y(c), u = c.isMobile ? [] : [g, A];
                return new w({
                  css: [],
                  // Our stylesheet is injected from `src/index.js`.
                  values: {
                    fps: {
                      caption: "fps",
                      below: 30
                    }
                  },
                  groups: [{
                    caption: "Framerate",
                    values: ["fps", "raf"]
                  }],
                  plugins: u
                });
              }
            }
          ),
          /***/
          "./src/components/scene/xr-mode-ui.js": (
            /*!********************************************!*\
              !*** ./src/components/scene/xr-mode-ui.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../constants/ */
                "./src/constants/index.js"
              ), E = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              ), y = "a-enter-vr", l = "a-enter-ar", d = "a-enter-vr-button", p = "a-enter-ar-button", c = "a-hidden", g = "a-orientation-modal";
              j.exports.Component = C("xr-mode-ui", {
                dependencies: ["canvas"],
                schema: {
                  enabled: {
                    default: !0
                  },
                  cardboardModeEnabled: {
                    default: !1
                  },
                  enterVRButton: {
                    default: ""
                  },
                  enterVREnabled: {
                    default: !0
                  },
                  enterARButton: {
                    default: ""
                  },
                  enterAREnabled: {
                    default: !0
                  },
                  XRMode: {
                    default: "vr",
                    oneOf: ["vr", "ar", "xr"]
                  }
                },
                sceneOnly: !0,
                init: function() {
                  var T = this, b = this.el;
                  E.getUrlParameter("ui") !== "false" && (this.insideLoader = !1, this.enterVREl = null, this.enterAREl = null, this.orientationModalEl = null, this.bindMethods(), b.addEventListener("enter-vr", this.updateEnterInterfaces), b.addEventListener("exit-vr", this.updateEnterInterfaces), b.addEventListener("update-vr-devices", this.updateEnterInterfaces), window.addEventListener("message", function(D) {
                    D.data.type === "loaderReady" && (T.insideLoader = !0, T.remove());
                  }), window.addEventListener("orientationchange", this.toggleOrientationModalIfNeeded));
                },
                bindMethods: function() {
                  this.onEnterVRButtonClick = this.onEnterVRButtonClick.bind(this), this.onEnterARButtonClick = this.onEnterARButtonClick.bind(this), this.onModalClick = this.onModalClick.bind(this), this.toggleOrientationModalIfNeeded = this.toggleOrientationModalIfNeeded.bind(this), this.updateEnterInterfaces = this.updateEnterInterfaces.bind(this);
                },
                /**
                 * Exit VR when modal clicked.
                 */
                onModalClick: function() {
                  this.el.exitVR();
                },
                /**
                 * Enter VR when clicked.
                 */
                onEnterVRButtonClick: function() {
                  this.el.enterVR();
                },
                /**
                 * Enter AR when clicked.
                 */
                onEnterARButtonClick: function() {
                  this.el.enterAR();
                },
                update: function() {
                  var T = this.data, b = this.el;
                  if (!T.enabled || this.insideLoader || E.getUrlParameter("ui") === "false")
                    return this.remove();
                  this.enterVREl || this.enterAREl || this.orientationModalEl || (!this.enterVREl && T.enterVREnabled && (T.XRMode === "xr" || T.XRMode === "vr") && (T.enterVRButton ? (this.enterVREl = document.querySelector(T.enterVRButton), this.enterVREl.addEventListener("click", this.onEnterVRButtonClick)) : (this.enterVREl = A(this.onEnterVRButtonClick), b.appendChild(this.enterVREl))), !this.enterAREl && T.enterAREnabled && (T.XRMode === "xr" || T.XRMode === "ar") && (T.enterARButton ? (this.enterAREl = document.querySelector(T.enterARButton), this.enterAREl.addEventListener("click", this.onEnterARButtonClick)) : (this.enterAREl = u(this.onEnterARButtonClick, T.XRMode === "xr"), b.appendChild(this.enterAREl))), this.orientationModalEl = f(this.onModalClick), b.appendChild(this.orientationModalEl), this.updateEnterInterfaces());
                },
                remove: function() {
                  [this.enterVREl, this.enterAREl, this.orientationModalEl].forEach(function(T) {
                    T && T.parentNode && T.parentNode.removeChild(T);
                  }), this.enterVREl = void 0, this.enterAREl = void 0, this.orientationModalEl = void 0;
                },
                updateEnterInterfaces: function() {
                  this.toggleEnterVRButtonIfNeeded(), this.toggleEnterARButtonIfNeeded(), this.toggleOrientationModalIfNeeded();
                },
                toggleEnterVRButtonIfNeeded: function() {
                  var T = this.el;
                  this.enterVREl && (T.is("vr-mode") || (T.isMobile || E.device.isMobileDeviceRequestingDesktopSite()) && !this.data.cardboardModeEnabled && !E.device.checkVRSupport() ? this.enterVREl.classList.add(c) : (E.device.checkVRSupport() || this.enterVREl.classList.add("fullscreen"), this.enterVREl.classList.remove(c), T.enterVR(!1, !0)));
                },
                toggleEnterARButtonIfNeeded: function() {
                  var T = this.el;
                  this.enterAREl && (T.is("vr-mode") || !E.device.checkARSupport() ? this.enterAREl.classList.add(c) : (this.enterAREl.classList.remove(c), T.enterVR(!0, !0)));
                },
                toggleOrientationModalIfNeeded: function() {
                  var T = this.el, b = this.orientationModalEl;
                  !b || !T.isMobile || (!E.device.isLandscape() && T.is("vr-mode") ? b.classList.remove(c) : b.classList.add(c));
                }
              });
              function A(T) {
                var b, D;
                return D = document.createElement("div"), D.classList.add(y), D.setAttribute(w.AFRAME_INJECTED, ""), b = document.createElement("button"), b.className = d, b.setAttribute("title", "Enter VR mode with a headset or fullscreen without"), b.setAttribute(w.AFRAME_INJECTED, ""), E.device.isMobile() && x(b), D.appendChild(b), b.addEventListener("click", function(S) {
                  T(), S.stopPropagation();
                }), D;
              }
              function u(T, b) {
                var D, S;
                return S = document.createElement("div"), S.classList.add(l), b && S.classList.add("xr"), S.setAttribute(w.AFRAME_INJECTED, ""), D = document.createElement("button"), D.className = p, D.setAttribute("title", "Enter AR mode with a headset or handheld device."), D.setAttribute(w.AFRAME_INJECTED, ""), E.device.isMobile() && x(D), S.appendChild(D), D.addEventListener("click", function(U) {
                  T(), U.stopPropagation();
                }), S;
              }
              function f(T) {
                var b = document.createElement("div");
                b.className = g, b.classList.add(c), b.setAttribute(w.AFRAME_INJECTED, "");
                var D = document.createElement("button");
                return D.setAttribute(w.AFRAME_INJECTED, ""), D.innerHTML = "Exit VR", D.addEventListener("click", T), b.appendChild(D), b;
              }
              function x(T) {
                T.addEventListener("touchstart", function() {
                  T.classList.remove("resethover");
                }, {
                  passive: !0
                }), T.addEventListener("touchend", function() {
                  T.classList.add("resethover");
                }, {
                  passive: !0
                });
              }
            }
          ),
          /***/
          "./src/components/shadow.js": (
            /*!**********************************!*\
              !*** ./src/components/shadow.js ***!
              \**********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ), w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = C.registerComponent;
              j.exports.Component = E("shadow", {
                schema: {
                  cast: {
                    default: !0
                  },
                  receive: {
                    default: !0
                  }
                },
                init: function() {
                  this.onMeshChanged = this.update.bind(this), this.el.addEventListener("object3dset", this.onMeshChanged), this.system.setShadowMapEnabled(!0);
                },
                update: function() {
                  var y = this.data;
                  this.updateDescendants(y.cast, y.receive);
                },
                remove: function() {
                  var y = this.el;
                  y.removeEventListener("object3dset", this.onMeshChanged), this.updateDescendants(!1, !1);
                },
                updateDescendants: function(y, l) {
                  var d = this.el.sceneEl;
                  this.el.object3D.traverse(function(p) {
                    if (p instanceof w.Mesh && (p.castShadow = y, p.receiveShadow = l, d.hasLoaded && p.material))
                      for (var c = Array.isArray(p.material) ? p.material : [p.material], g = 0; g < c.length; g++)
                        c[g].needsUpdate = !0;
                  });
                }
              });
            }
          ),
          /***/
          "./src/components/sound.js": (
            /*!*********************************!*\
              !*** ./src/components/sound.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/debug */
                "./src/utils/debug.js"
              ), E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), y = w("components:sound:warn");
              j.exports.Component = C("sound", {
                schema: {
                  autoplay: {
                    default: !1
                  },
                  distanceModel: {
                    default: "inverse",
                    oneOf: ["linear", "inverse", "exponential"]
                  },
                  loop: {
                    default: !1
                  },
                  loopStart: {
                    default: 0
                  },
                  loopEnd: {
                    default: 0
                  },
                  maxDistance: {
                    default: 1e4
                  },
                  on: {
                    default: ""
                  },
                  poolSize: {
                    default: 1
                  },
                  positional: {
                    default: !0
                  },
                  refDistance: {
                    default: 1
                  },
                  rolloffFactor: {
                    default: 1
                  },
                  src: {
                    type: "audio"
                  },
                  volume: {
                    default: 1
                  }
                },
                multiple: !0,
                init: function() {
                  var l = this;
                  this.listener = null, this.audioLoader = new E.AudioLoader(), this.pool = new E.Group(), this.loaded = !1, this.mustPlay = !1, this.playSoundBound = function() {
                    l.playSound();
                  };
                },
                update: function(l) {
                  var d = this.data, p, c, g = d.src !== l.src;
                  if (g) {
                    if (!d.src)
                      return;
                    this.setupSound();
                  }
                  for (p = 0; p < this.pool.children.length; p++)
                    c = this.pool.children[p], d.positional && (c.setDistanceModel(d.distanceModel), c.setMaxDistance(d.maxDistance), c.setRefDistance(d.refDistance), c.setRolloffFactor(d.rolloffFactor)), c.setLoop(d.loop), c.setLoopStart(d.loopStart), d.loopStart !== 0 && d.loopEnd === 0 ? c.setLoopEnd(c.buffer.duration) : c.setLoopEnd(d.loopEnd), c.setVolume(d.volume), c.isPaused = !1;
                  if (d.on !== l.on && this.updateEventListener(l.on), g) {
                    var A = this;
                    this.loaded = !1, this.audioLoader.load(d.src, function(u) {
                      for (p = 0; p < A.pool.children.length; p++)
                        c = A.pool.children[p], c.setBuffer(u);
                      A.loaded = !0, E.Cache.remove(d.src), (A.data.autoplay || A.mustPlay) && A.playSound(A.processSound), A.el.emit("sound-loaded", A.evtDetail, !1);
                    });
                  }
                },
                pause: function() {
                  this.stopSound(), this.removeEventListener();
                },
                play: function() {
                  this.data.autoplay && this.playSound(), this.updateEventListener();
                },
                remove: function() {
                  var l, d;
                  this.removeEventListener(), this.el.getObject3D(this.attrName) && this.el.removeObject3D(this.attrName);
                  try {
                    for (l = 0; l < this.pool.children.length; l++)
                      d = this.pool.children[l], d.disconnect();
                  } catch {
                    y("Audio source not properly disconnected");
                  }
                },
                /**
                *  Update listener attached to the user defined on event.
                */
                updateEventListener: function(l) {
                  var d = this.el;
                  l && d.removeEventListener(l, this.playSoundBound), d.addEventListener(this.data.on, this.playSoundBound);
                },
                removeEventListener: function() {
                  this.el.removeEventListener(this.data.on, this.playSoundBound);
                },
                /**
                 * Removes current sound object, creates new sound object, adds to entity.
                 *
                 * @returns {object} sound
                 */
                setupSound: function() {
                  var l = this.el, d, p = l.sceneEl, c = this, g;
                  this.pool.children.length > 0 && (this.stopSound(), l.removeObject3D("sound"));
                  var A = this.listener = p.audioListener || new E.AudioListener();
                  for (p.audioListener = A, p.camera && p.camera.add(A), p.addEventListener("camera-set-active", function(u) {
                    u.detail.cameraEl.getObject3D("camera").add(A);
                  }), this.pool = new E.Group(), d = 0; d < this.data.poolSize; d++)
                    g = this.data.positional ? new E.PositionalAudio(A) : new E.Audio(A), this.pool.add(g);
                  for (l.setObject3D(this.attrName, this.pool), d = 0; d < this.pool.children.length; d++)
                    g = this.pool.children[d], g.onEnded = function() {
                      this.isPlaying = !1, c.el.emit("sound-ended", c.evtDetail, !1);
                    };
                },
                /**
                 * Pause all the sounds in the pool.
                 */
                pauseSound: function() {
                  var l, d;
                  for (this.isPlaying = !1, l = 0; l < this.pool.children.length; l++)
                    d = this.pool.children[l], !(!d.source || !d.source.buffer || !d.isPlaying || d.isPaused) && (d.isPaused = !0, d.pause());
                },
                /**
                 * Look for an unused sound in the pool and play it if found.
                 */
                playSound: function(l) {
                  var d, p, c;
                  if (!this.loaded) {
                    y("Sound not loaded yet. It will be played once it finished loading"), this.mustPlay = !0, this.processSound = l;
                    return;
                  }
                  for (d = !1, this.isPlaying = !0, p = 0; p < this.pool.children.length; p++)
                    if (c = this.pool.children[p], !c.isPlaying && c.buffer && !d) {
                      l && l(c), c.play(), c.isPaused = !1, d = !0;
                      continue;
                    }
                  if (!d) {
                    y("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.", this.el);
                    return;
                  }
                  this.mustPlay = !1, this.processSound = void 0;
                },
                /**
                 * Stop all the sounds in the pool.
                 */
                stopSound: function() {
                  var l, d;
                  for (this.isPlaying = !1, l = 0; l < this.pool.children.length; l++) {
                    if (d = this.pool.children[l], !d.source || !d.source.buffer)
                      return;
                    d.stop();
                  }
                }
              });
            }
          ),
          /***/
          "./src/components/text.js": (
            /*!********************************!*\
              !*** ./src/components/text.js ***!
              \********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! three-bmfont-text */
                "./node_modules/three-bmfont-text/index.js"
              ), w = v(
                /*! load-bmfont */
                "./node_modules/load-bmfont/browser.js"
              ), E = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, y = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ), l = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), d = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), p = d.debug("components:text:error"), c = y.shaders, g = d.debug("components:text:warn"), A = 1, u = 16, f = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, x = f + "fonts/", T = {
                aileronsemibold: x + "Aileron-Semibold.fnt",
                dejavu: x + "DejaVu-sdf.fnt",
                exo2bold: x + "Exo2Bold.fnt",
                exo2semibold: x + "Exo2SemiBold.fnt",
                kelsonsans: x + "KelsonSans.fnt",
                monoid: x + "Monoid.fnt",
                mozillavr: x + "mozillavr.fnt",
                roboto: x + "Roboto-msdf.json",
                sourcecodepro: x + "SourceCodePro.fnt"
              }, b = ["roboto"], D = "roboto";
              j.exports.FONTS = T;
              var S = new K(), U = {}, G = {}, Z = /^\w+:/;
              j.exports.Component = E("text", {
                multiple: !0,
                schema: {
                  align: {
                    type: "string",
                    default: "left",
                    oneOf: ["left", "right", "center"]
                  },
                  alphaTest: {
                    default: 0.5
                  },
                  // `anchor` defaults to center to match geometries.
                  anchor: {
                    default: "center",
                    oneOf: ["left", "right", "center", "align"]
                  },
                  baseline: {
                    default: "center",
                    oneOf: ["top", "center", "bottom"]
                  },
                  color: {
                    type: "color",
                    default: "#FFF"
                  },
                  font: {
                    type: "string",
                    default: D
                  },
                  // `fontImage` defaults to the font name as a .png (e.g., mozillavr.fnt -> mozillavr.png).
                  fontImage: {
                    type: "string"
                  },
                  // `height` has no default, will be populated at layout.
                  height: {
                    type: "number"
                  },
                  letterSpacing: {
                    type: "number",
                    default: 0
                  },
                  // `lineHeight` defaults to font's `lineHeight` value.
                  lineHeight: {
                    type: "number"
                  },
                  // `negate` must be true for fonts generated with older versions of msdfgen (white background).
                  negate: {
                    type: "boolean",
                    default: !0
                  },
                  opacity: {
                    type: "number",
                    default: 1
                  },
                  shader: {
                    default: "sdf",
                    oneOf: c
                  },
                  side: {
                    default: "front",
                    oneOf: ["front", "back", "double"]
                  },
                  tabSize: {
                    default: 4
                  },
                  transparent: {
                    default: !0
                  },
                  value: {
                    type: "string"
                  },
                  whiteSpace: {
                    default: "normal",
                    oneOf: ["normal", "pre", "nowrap"]
                  },
                  // `width` defaults to geometry width if present, else `DEFAULT_WIDTH`.
                  width: {
                    type: "number"
                  },
                  // `wrapCount` units are about one default font character. Wrap roughly at this number.
                  wrapCount: {
                    type: "number",
                    default: 40
                  },
                  // `wrapPixels` will wrap using bmfont pixel units (e.g., dejavu's is 32 pixels).
                  wrapPixels: {
                    type: "number"
                  },
                  // `xOffset` to add padding.
                  xOffset: {
                    type: "number",
                    default: 0
                  },
                  // `yOffset` to adjust generated fonts from tools that may have incorrect metrics.
                  yOffset: {
                    type: "number",
                    default: 0
                  },
                  // `zOffset` will provide a small z offset to avoid z-fighting.
                  zOffset: {
                    type: "number",
                    default: 1e-3
                  }
                },
                init: function() {
                  this.shaderData = {}, this.geometry = C(), this.createOrUpdateMaterial(), this.explicitGeoDimensionsChecked = !1;
                },
                update: function(ne) {
                  var pe = this.data, be = this.currentFont;
                  if (G[pe.font] ? this.texture = G[pe.font] : (this.texture = G[pe.font] = new l.Texture(), this.texture.anisotropy = u), this.createOrUpdateMaterial(), ne.font !== pe.font) {
                    this.updateFont();
                    return;
                  }
                  be && (this.updateGeometry(this.geometry, be), this.updateLayout());
                },
                /**
                 * Clean up geometry, material, texture, mesh, objects.
                 */
                remove: function() {
                  this.geometry.dispose(), this.geometry = null, this.el.removeObject3D(this.attrName), this.material.dispose(), this.material = null, this.texture.dispose(), this.texture = null, this.shaderObject && delete this.shaderObject;
                },
                /**
                 * Update the shader of the material.
                 */
                createOrUpdateMaterial: function() {
                  var ne = this.data, pe, be = this.material, Te, ke = this.shaderData, Ve;
                  if (Ve = ne.shader, b.indexOf(ne.font) !== -1 || ne.font.indexOf("-msdf.") >= 0 ? Ve = "msdf" : ne.font in T && b.indexOf(ne.font) === -1 && (Ve = "sdf"), pe = (this.shaderObject && this.shaderObject.name) !== Ve, ke.alphaTest = ne.alphaTest, ke.color = ne.color, ke.map = this.texture, ke.opacity = ne.opacity, ke.side = W(ne.side), ke.transparent = ne.transparent, ke.negate = ne.negate, !pe) {
                    this.shaderObject.update(ke), be.transparent = ke.transparent, be.side = ke.side;
                    return;
                  }
                  Te = X(this.el, Ve, ke), this.material = Te.material, this.shaderObject = Te.shader, this.material.side = ke.side, this.mesh && (this.mesh.material = this.material);
                },
                /**
                 * Load font for geometry, load font image for material, and apply.
                 */
                updateFont: function() {
                  var ne = this.data, pe = this.el, be, Te = this.geometry, ke = this;
                  ne.font || g("No font specified. Using the default font."), this.mesh && (this.mesh.visible = !1), be = this.lookupFont(ne.font || D) || ne.font, S.get(be, function() {
                    return ie(be, ne.yOffset);
                  }).then(function(st) {
                    var ut;
                    if (st.pages.length !== 1)
                      throw new Error("Currently only single-page bitmap fonts are supported.");
                    U[be] || (st.widthFactor = U[st] = O(st)), ke.currentFont = st, ut = ke.getFontImageSrc(), S.get(ut, function() {
                      return te(ut);
                    }).then(function(It) {
                      var ht = ke.texture;
                      ht && (ht.image = It, ht.needsUpdate = !0, G[ne.font] = ht, ke.texture = ht, ke.initMesh(), ke.currentFont = st, ke.updateGeometry(Te, st), ke.updateLayout(), ke.mesh.visible = !0, pe.emit("textfontset", {
                        font: ne.font,
                        fontObj: st
                      }));
                    }).catch(function(It) {
                      p(It.message), p(It.stack);
                    });
                  }).catch(function(Ve) {
                    p(Ve.message), p(Ve.stack);
                  });
                },
                initMesh: function() {
                  this.mesh || (this.mesh = new l.Mesh(this.geometry, this.material), this.el.setObject3D(this.attrName, this.mesh));
                },
                getFontImageSrc: function() {
                  if (this.data.fontImage)
                    return this.data.fontImage;
                  var ne = this.lookupFont(this.data.font || D) || this.data.font, pe = this.currentFont.pages[0];
                  return pe.match(Z) && pe.indexOf("http") !== 0 ? ne.replace(/(\.fnt)|(\.json)/, ".png") : l.LoaderUtils.extractUrlBase(ne) + pe;
                },
                /**
                 * Update layout with anchor, alignment, baseline, and considering any meshes.
                 */
                updateLayout: function() {
                  var ne, pe, be = this.el, Te = this.data, ke = this.geometry, Ve, st, ut, It = this.mesh, ht, Rt, Qt, cn, Cn;
                  if (!(!It || !ke.layout)) {
                    if (Ve = be.getAttribute("geometry"), Qt = Te.width || Ve && Ve.width || A, ht = Q(Te.wrapPixels, Te.wrapCount, this.currentFont.widthFactor), Rt = Qt / ht, ut = ke.layout, st = Rt * (ut.height + ut.descender), Ve && Ve.primitive === "plane" && (this.explicitGeoDimensionsChecked || (this.explicitGeoDimensionsChecked = !0, this.hasExplicitGeoWidth = !!Ve.width, this.hasExplicitGeoHeight = !!Ve.height), this.hasExplicitGeoWidth || be.setAttribute("geometry", "width", Qt), this.hasExplicitGeoHeight || be.setAttribute("geometry", "height", st)), ne = Te.anchor === "align" ? Te.align : Te.anchor, ne === "left")
                      cn = 0;
                    else if (ne === "right")
                      cn = -1 * ut.width;
                    else if (ne === "center")
                      cn = -1 * ut.width / 2;
                    else
                      throw new TypeError("Invalid text.anchor property value", ne);
                    if (pe = Te.baseline, pe === "bottom")
                      Cn = 0;
                    else if (pe === "top")
                      Cn = -1 * ut.height + ut.ascender;
                    else if (pe === "center")
                      Cn = -1 * ut.height / 2;
                    else
                      throw new TypeError("Invalid text.baseline property value", pe);
                    It.position.x = cn * Rt + Te.xOffset, It.position.y = Cn * Rt, It.position.z = Te.zOffset, It.scale.set(Rt, -1 * Rt, Rt);
                  }
                },
                /**
                 * Grab font from the constant.
                 * Set as a method for test stubbing purposes.
                 */
                lookupFont: function(ne) {
                  return T[ne];
                },
                /**
                 * Update the text geometry using `three-bmfont-text.update`.
                 */
                updateGeometry: /* @__PURE__ */ function() {
                  var ne = {}, pe = {}, be = /\\n/g, Te = /\\t/g;
                  return function(ke, Ve) {
                    var st = this.data;
                    pe.font = Ve, pe.lineHeight = st.lineHeight && isFinite(st.lineHeight) ? st.lineHeight : Ve.common.lineHeight, pe.text = st.value.toString().replace(be, `
`).replace(Te, "	"), pe.width = Q(st.wrapPixels, st.wrapCount, Ve.widthFactor), ke.update(d.extend(ne, st, pe));
                  };
                }()
              });
              function W(ne) {
                switch (ne) {
                  case "back":
                    return l.FrontSide;
                  case "double":
                    return l.DoubleSide;
                  default:
                    return l.BackSide;
                }
              }
              function ie(ne, pe) {
                return new Promise(function(be, Te) {
                  w(ne, function(ke, Ve) {
                    if (ke) {
                      p("Error loading font", ne), Te(ke);
                      return;
                    }
                    ne.indexOf("/Roboto-msdf.json") >= 0 && (pe = 30), pe && Ve.chars.map(function(ut) {
                      ut.yoffset += pe;
                    }), be(Ve);
                  });
                });
              }
              function te(ne) {
                return new Promise(function(pe, be) {
                  new l.ImageLoader().load(ne, function(Te) {
                    pe(Te);
                  }, void 0, function() {
                    p("Error loading font image", ne), be(null);
                  });
                });
              }
              function X(ne, pe, be) {
                var Te, ke;
                return ke = new c[pe].Shader(), ke.el = ne, ke.init(be), ke.update(be), Te = ke.material, Te.transparent = be.transparent, {
                  material: Te,
                  shader: ke
                };
              }
              function Q(ne, pe, be) {
                return ne || (0.5 + pe) * be;
              }
              function O(ne) {
                var pe = 0, be = 0, Te = 0;
                return ne.chars.map(function(ke) {
                  pe += ke.xadvance, ke.id >= 48 && ke.id <= 57 && (Te++, be += ke.xadvance);
                }), Te ? be / Te : pe / ne.chars.length;
              }
              function K() {
                var ne = this.cache = {};
                this.get = function(pe, be) {
                  return pe in ne || (ne[pe] = be()), ne[pe];
                };
              }
            }
          ),
          /***/
          "./src/components/tracked-controls-webvr.js": (
            /*!**************************************************!*\
              !*** ./src/components/tracked-controls-webvr.js ***!
              \**************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), E = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).DEFAULT_CAMERA_HEIGHT, y = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), l = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).DEFAULT_HANDEDNESS, d = {
                x: 0.175,
                y: -0.3,
                z: -0.03
              }, p = {
                x: 0,
                y: 0,
                z: -0.175
              }, c = {
                touches: []
              }, g = {
                AXISMOVE: "axismove",
                BUTTONCHANGED: "buttonchanged",
                BUTTONDOWN: "buttondown",
                BUTTONUP: "buttonup",
                TOUCHSTART: "touchstart",
                TOUCHEND: "touchend"
              };
              j.exports.Component = C("tracked-controls-webvr", {
                schema: {
                  autoHide: {
                    default: !0
                  },
                  controller: {
                    default: 0
                  },
                  id: {
                    type: "string",
                    default: ""
                  },
                  hand: {
                    type: "string",
                    default: ""
                  },
                  idPrefix: {
                    type: "string",
                    default: ""
                  },
                  orientationOffset: {
                    type: "vec3"
                  },
                  // Arm model parameters when not 6DoF.
                  armModel: {
                    default: !1
                  },
                  headElement: {
                    type: "selector"
                  }
                },
                init: function() {
                  this.axis = this.el.components["tracked-controls"].axis = [0, 0, 0], this.buttonStates = this.el.components["tracked-controls"].buttonStates = {}, this.changedAxes = [], this.targetControllerNumber = this.data.controller, this.axisMoveEventDetail = {
                    axis: this.axis,
                    changed: this.changedAxes
                  }, this.deltaControllerPosition = new y.Vector3(), this.controllerQuaternion = new y.Quaternion(), this.controllerEuler = new y.Euler(), this.updateGamepad(), this.buttonEventDetails = {};
                },
                tick: function(A, u) {
                  var f = this.el.getObject3D("mesh");
                  f && f.update && f.update(u / 1e3), this.updateGamepad(), this.updatePose(), this.updateButtons();
                },
                /**
                 * Return default user height to use for non-6DOF arm model.
                 */
                defaultUserHeight: function() {
                  return E;
                },
                /**
                 * Return head element to use for non-6DOF arm model.
                 */
                getHeadElement: function() {
                  return this.data.headElement || this.el.sceneEl.camera.el;
                },
                /**
                 * Handle update controller match criteria (such as `id`, `idPrefix`, `hand`, `controller`)
                 */
                updateGamepad: function() {
                  var A = this.data, u = w.findMatchingControllerWebVR(this.system.controllers, A.id, A.idPrefix, A.hand, A.controller);
                  this.controller = u, this.el.components["tracked-controls"].controller = u, this.data.autoHide && (this.el.object3D.visible = !!this.controller);
                },
                /**
                 * Applies an artificial arm model to simulate elbow to wrist positioning
                 * based on the orientation of the controller.
                 *
                 * @param {object} controllerPosition - Existing vector to update with controller position.
                 */
                applyArmModel: function(A) {
                  var u = this.controller, f = this.controllerEuler, x = this.controllerQuaternion, T = this.deltaControllerPosition, b, D, S, U, G;
                  D = this.getHeadElement(), S = D.object3D, G = this.defaultUserHeight(), U = u.pose, b = (u ? u.hand : void 0) || l, A.copy(S.position), T.set(
                    d.x * (b === "left" ? -1 : b === "right" ? 1 : 0),
                    d.y,
                    // Lower than our eyes.
                    d.z
                  ), T.multiplyScalar(G), T.applyAxisAngle(S.up, S.rotation.y), A.add(T), T.set(p.x, p.y, p.z), T.multiplyScalar(G), U.orientation ? x.fromArray(U.orientation) : x.copy(S.quaternion), f.setFromQuaternion(x), f.set(f.x, f.y, 0), T.applyEuler(f), A.add(T);
                },
                /**
                 * Read pose from controller (from Gamepad API), apply transforms, apply to entity.
                 */
                updatePose: function() {
                  var A = this.controller, u = this.data, f = this.el.object3D, x, T = this.system.vrDisplay, b;
                  A && (x = A.pose, x.position ? f.position.fromArray(x.position) : u.armModel && this.applyArmModel(f.position), x.orientation && f.quaternion.fromArray(x.orientation), T && x.position && (b = this.el.sceneEl.renderer.xr.getStandingMatrix(), f.matrix.compose(f.position, f.quaternion, f.scale), f.matrix.multiplyMatrices(b, f.matrix), f.matrix.decompose(f.position, f.quaternion, f.scale)), f.rotateX(this.data.orientationOffset.x * y.MathUtils.DEG2RAD), f.rotateY(this.data.orientationOffset.y * y.MathUtils.DEG2RAD), f.rotateZ(this.data.orientationOffset.z * y.MathUtils.DEG2RAD));
                },
                /**
                 * Handle button changes including axes, presses, touches, values.
                 */
                updateButtons: function() {
                  var A, u = this.controller, f;
                  if (u) {
                    for (f = 0; f < u.buttons.length; ++f)
                      this.buttonStates[f] || (this.buttonStates[f] = {
                        pressed: !1,
                        touched: !1,
                        value: 0
                      }), this.buttonEventDetails[f] || (this.buttonEventDetails[f] = {
                        id: f,
                        state: this.buttonStates[f]
                      }), A = u.buttons[f], this.handleButton(f, A);
                    this.handleAxes();
                  }
                },
                /**
                 * Handle presses and touches for a single button.
                 *
                 * @param {number} id - Index of button in Gamepad button array.
                 * @param {number} buttonState - Value of button state from 0 to 1.
                 * @returns {boolean} Whether button has changed in any way.
                 */
                handleButton: function(A, u) {
                  var f;
                  return f = this.handlePress(A, u) | this.handleTouch(A, u) | this.handleValue(A, u), f ? (this.el.emit(g.BUTTONCHANGED, this.buttonEventDetails[A], !1), !0) : !1;
                },
                /**
                 * An axis is an array of values from -1 (up, left) to 1 (down, right).
                 * Compare each component of the axis to the previous value to determine change.
                 *
                 * @returns {boolean} Whether axes changed.
                 */
                handleAxes: function() {
                  var A = !1, u = this.controller.axes, f, x = this.axis, T = this.changedAxes;
                  for (this.changedAxes.splice(0, this.changedAxes.length), f = 0; f < u.length; ++f)
                    T.push(x[f] !== u[f]), T[f] && (A = !0);
                  if (!A)
                    return !1;
                  for (this.axis.splice(0, this.axis.length), f = 0; f < u.length; f++)
                    this.axis.push(u[f]);
                  return this.el.emit(g.AXISMOVE, this.axisMoveEventDetail, !1), !0;
                },
                /**
                 * Determine whether a button press has occurred and emit events as appropriate.
                 *
                 * @param {string} id - ID of the button to check.
                 * @param {object} buttonState - State of the button to check.
                 * @returns {boolean} Whether button press state changed.
                 */
                handlePress: function(A, u) {
                  var f, x = this.buttonStates[A];
                  return u.pressed === x.pressed ? !1 : (f = u.pressed ? g.BUTTONDOWN : g.BUTTONUP, this.el.emit(f, this.buttonEventDetails[A], !1), x.pressed = u.pressed, !0);
                },
                /**
                 * Determine whether a button touch has occurred and emit events as appropriate.
                 *
                 * @param {string} id - ID of the button to check.
                 * @param {object} buttonState - State of the button to check.
                 * @returns {boolean} Whether button touch state changed.
                 */
                handleTouch: function(A, u) {
                  var f, x = this.buttonStates[A];
                  return u.touched === x.touched ? !1 : (f = u.touched ? g.TOUCHSTART : g.TOUCHEND, this.el.emit(f, this.buttonEventDetails[A], !1, c), x.touched = u.touched, !0);
                },
                /**
                 * Determine whether a button value has changed.
                 *
                 * @param {string} id - Id of the button to check.
                 * @param {object} buttonState - State of the button to check.
                 * @returns {boolean} Whether button value changed.
                 */
                handleValue: function(A, u) {
                  var f = this.buttonStates[A];
                  return u.value === f.value ? !1 : (f.value = u.value, !0);
                }
              });
            }
          ),
          /***/
          "./src/components/tracked-controls-webxr.js": (
            /*!**************************************************!*\
              !*** ./src/components/tracked-controls-webxr.js ***!
              \**************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), w = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, E = {
                AXISMOVE: "axismove",
                BUTTONCHANGED: "buttonchanged",
                BUTTONDOWN: "buttondown",
                BUTTONUP: "buttonup",
                TOUCHSTART: "touchstart",
                TOUCHEND: "touchend"
              };
              j.exports.Component = w("tracked-controls-webxr", {
                schema: {
                  id: {
                    type: "string",
                    default: ""
                  },
                  hand: {
                    type: "string",
                    default: ""
                  },
                  handTrackingEnabled: {
                    default: !1
                  },
                  index: {
                    type: "int",
                    default: -1
                  },
                  iterateControllerProfiles: {
                    default: !1
                  },
                  space: {
                    type: "string",
                    oneOf: ["targetRaySpace", "gripSpace"],
                    default: "gripSpace"
                  }
                },
                init: function() {
                  this.updateController = this.updateController.bind(this), this.buttonEventDetails = {}, this.buttonStates = this.el.components["tracked-controls"].buttonStates = {}, this.axis = this.el.components["tracked-controls"].axis = [0, 0, 0], this.changedAxes = [], this.axisMoveEventDetail = {
                    axis: this.axis,
                    changed: this.changedAxes
                  };
                },
                update: function() {
                  this.updateController();
                },
                play: function() {
                  var y = this.el.sceneEl;
                  this.updateController(), y.addEventListener("controllersupdated", this.updateController);
                },
                pause: function() {
                  var y = this.el.sceneEl;
                  y.removeEventListener("controllersupdated", this.updateController);
                },
                isControllerPresent: function(y) {
                  return !(!this.controller || this.controller.gamepad || y.inputSource.handedness !== "none" && y.inputSource.handedness !== this.data.hand);
                },
                /**
                 * Handle update controller match criteria (such as `id`, `idPrefix`, `hand`, `controller`)
                 */
                updateController: function() {
                  this.controller = C.findMatchingControllerWebXR(this.system.controllers, this.data.id, this.data.hand, this.data.index, this.data.iterateControllerProfiles, this.data.handTrackingEnabled), this.el.components["tracked-controls"].controller = this.controller, this.data.autoHide && (this.el.object3D.visible = !!this.controller);
                },
                tick: function() {
                  var y = this.el.sceneEl, l = this.controller, d = y.frame;
                  !l || !y.frame || !this.system.referenceSpace || l.hand || (this.pose = d.getPose(l[this.data.space], this.system.referenceSpace), this.updatePose(), this.updateButtons());
                },
                updatePose: function() {
                  var y = this.el.object3D, l = this.pose;
                  l && (y.matrix.elements = l.transform.matrix, y.matrix.decompose(y.position, y.rotation, y.scale));
                },
                /**
                 * Handle button changes including axes, presses, touches, values.
                 */
                updateButtons: function() {
                  var y, l, d = this.controller, p;
                  if (!(!d || !d.gamepad)) {
                    for (p = d.gamepad, l = 0; l < p.buttons.length; ++l)
                      this.buttonStates[l] || (this.buttonStates[l] = {
                        pressed: !1,
                        touched: !1,
                        value: 0
                      }), this.buttonEventDetails[l] || (this.buttonEventDetails[l] = {
                        id: l,
                        state: this.buttonStates[l]
                      }), y = p.buttons[l], this.handleButton(l, y);
                    this.handleAxes();
                  }
                },
                /**
                 * Handle presses and touches for a single button.
                 *
                 * @param {number} id - Index of button in Gamepad button array.
                 * @param {number} buttonState - Value of button state from 0 to 1.
                 * @returns {boolean} Whether button has changed in any way.
                 */
                handleButton: function(y, l) {
                  var d;
                  return d = this.handlePress(y, l) | this.handleTouch(y, l) | this.handleValue(y, l), d ? (this.el.emit(E.BUTTONCHANGED, this.buttonEventDetails[y], !1), !0) : !1;
                },
                /**
                 * An axis is an array of values from -1 (up, left) to 1 (down, right).
                 * Compare each component of the axis to the previous value to determine change.
                 *
                 * @returns {boolean} Whether axes changed.
                 */
                handleAxes: function() {
                  var y = !1, l = this.controller.gamepad.axes, d, p = this.axis, c = this.changedAxes;
                  for (this.changedAxes.splice(0, this.changedAxes.length), d = 0; d < l.length; ++d)
                    c.push(p[d] !== l[d]), c[d] && (y = !0);
                  if (!y)
                    return !1;
                  for (this.axis.splice(0, this.axis.length), d = 0; d < l.length; d++)
                    this.axis.push(l[d]);
                  return this.el.emit(E.AXISMOVE, this.axisMoveEventDetail, !1), !0;
                },
                /**
                 * Determine whether a button press has occurred and emit events as appropriate.
                 *
                 * @param {string} id - ID of the button to check.
                 * @param {object} buttonState - State of the button to check.
                 * @returns {boolean} Whether button press state changed.
                 */
                handlePress: function(y, l) {
                  var d, p = this.buttonStates[y];
                  return l.pressed === p.pressed ? !1 : (d = l.pressed ? E.BUTTONDOWN : E.BUTTONUP, this.el.emit(d, this.buttonEventDetails[y], !1), p.pressed = l.pressed, !0);
                },
                /**
                 * Determine whether a button touch has occurred and emit events as appropriate.
                 *
                 * @param {string} id - ID of the button to check.
                 * @param {object} buttonState - State of the button to check.
                 * @returns {boolean} Whether button touch state changed.
                 */
                handleTouch: function(y, l) {
                  var d, p = this.buttonStates[y];
                  return l.touched === p.touched ? !1 : (d = l.touched ? E.TOUCHSTART : E.TOUCHEND, this.el.emit(d, this.buttonEventDetails[y], !1), p.touched = l.touched, !0);
                },
                /**
                 * Determine whether a button value has changed.
                 *
                 * @param {string} id - Id of the button to check.
                 * @param {object} buttonState - State of the button to check.
                 * @returns {boolean} Whether button value changed.
                 */
                handleValue: function(y, l) {
                  var d = this.buttonStates[y];
                  return l.value === d.value ? !1 : (d.value = l.value, !0);
                }
              });
            }
          ),
          /***/
          "./src/components/tracked-controls.js": (
            /*!********************************************!*\
              !*** ./src/components/tracked-controls.js ***!
              \********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("tracked-controls", {
                schema: {
                  autoHide: {
                    default: !0
                  },
                  controller: {
                    default: -1
                  },
                  id: {
                    type: "string",
                    default: ""
                  },
                  hand: {
                    type: "string",
                    default: ""
                  },
                  idPrefix: {
                    type: "string",
                    default: ""
                  },
                  handTrackingEnabled: {
                    default: !1
                  },
                  orientationOffset: {
                    type: "vec3"
                  },
                  // Arm model parameters when not 6DoF.
                  armModel: {
                    default: !1
                  },
                  headElement: {
                    type: "selector"
                  },
                  iterateControllerProfiles: {
                    default: !1
                  },
                  space: {
                    type: "string",
                    oneOf: ["targetRaySpace", "gripSpace"],
                    default: "targetRaySpace"
                  }
                },
                // Run after both tracked-controls-webvr and tracked-controls-webxr to allow other components
                // to be after either without having to list them both.
                after: ["tracked-controls-webvr", "tracked-controls-webxr"],
                update: function() {
                  var w = this.data, E = this.el;
                  E.sceneEl.hasWebXR ? E.setAttribute("tracked-controls-webxr", {
                    id: w.id,
                    hand: w.hand,
                    index: w.controller,
                    iterateControllerProfiles: w.iterateControllerProfiles,
                    handTrackingEnabled: w.handTrackingEnabled,
                    space: w.space
                  }) : E.setAttribute("tracked-controls-webvr", w);
                }
              });
            }
          ),
          /***/
          "./src/components/valve-index-controls.js": (
            /*!************************************************!*\
              !*** ./src/components/valve-index-controls.js ***!
              \************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), y = E.checkControllerPresentAndSetup, l = E.emitIfAxesChanged, d = E.onButtonEvent, p = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, c = p + "controllers/valve/index/valve-index-", g = {
                left: c + "left.glb",
                right: c + "right.glb"
              }, A = "valve", u = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ).device.isWebXRAvailable, f = {
                left: {
                  x: -23692678902063457e-20,
                  y: 0.04724540367838371,
                  z: -0.061959880395271096
                },
                right: {
                  x: 0.002471558599671131,
                  y: 0.055765208987076195,
                  z: -0.061068168708348844
                }
              }, x = {
                left: {
                  x: 0,
                  y: -0.05,
                  z: 0.06
                },
                right: {
                  x: 0,
                  y: -0.05,
                  z: 0.06
                }
              }, T = {
                left: {
                  _x: 0.692295102620542,
                  _y: -0.0627618864318427,
                  _z: -0.06265893149611756,
                  _order: "XYZ"
                },
                right: {
                  _x: 0.6484021229942998,
                  _y: -0.032563619881892894,
                  _z: -0.1327973171917482,
                  _order: "XYZ"
                }
              }, b = {
                left: {
                  _x: Math.PI / 3,
                  _y: 0,
                  _z: 0,
                  _order: "XYZ"
                },
                right: {
                  _x: Math.PI / 3,
                  _y: 0,
                  _z: 0,
                  _order: "XYZ"
                }
              }, D = u ? b : T, S = u ? x : f;
              j.exports.Component = C("valve-index-controls", {
                schema: {
                  hand: {
                    default: "left"
                  },
                  buttonColor: {
                    type: "color",
                    default: "#FAFAFA"
                  },
                  // Off-white.
                  buttonHighlightColor: {
                    type: "color",
                    default: "#22D1EE"
                  },
                  // Light blue.
                  model: {
                    default: !0
                  },
                  orientationOffset: {
                    type: "vec3"
                  }
                },
                after: ["tracked-controls"],
                mapping: {
                  axes: {
                    trackpad: [0, 1],
                    thumbstick: [2, 3]
                  },
                  buttons: ["trigger", "grip", "trackpad", "thumbstick", "abutton"]
                },
                init: function() {
                  var U = this;
                  this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(G) {
                    d(G.detail.id, "down", U);
                  }, this.onButtonUp = function(G) {
                    d(G.detail.id, "up", U);
                  }, this.onButtonTouchEnd = function(G) {
                    d(G.detail.id, "touchend", U);
                  }, this.onButtonTouchStart = function(G) {
                    d(G.detail.id, "touchstart", U);
                  }, this.previousButtonValues = {}, this.bindMethods();
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                bindMethods: function() {
                  this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                addEventListeners: function() {
                  var U = this.el;
                  U.addEventListener("buttonchanged", this.onButtonChanged), U.addEventListener("buttondown", this.onButtonDown), U.addEventListener("buttonup", this.onButtonUp), U.addEventListener("touchend", this.onButtonTouchEnd), U.addEventListener("touchstart", this.onButtonTouchStart), U.addEventListener("model-loaded", this.onModelLoaded), U.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var U = this.el;
                  U.removeEventListener("buttonchanged", this.onButtonChanged), U.removeEventListener("buttondown", this.onButtonDown), U.removeEventListener("buttonup", this.onButtonUp), U.removeEventListener("touchend", this.onButtonTouchEnd), U.removeEventListener("touchstart", this.onButtonTouchStart), U.removeEventListener("model-loaded", this.onModelLoaded), U.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
                },
                /**
                 * Once OpenVR returns correct hand data in supporting browsers, we can use hand property.
                 * var isPresent = checkControllerPresentAndSetup(this.el.sceneEl, GAMEPAD_ID_PREFIX,
                                                                      { hand: data.hand });
                 * Until then, use hardcoded index.
                 */
                checkIfControllerPresent: function() {
                  var U = this.data, G = U.hand === "right" ? 0 : U.hand === "left" ? 1 : 2;
                  y(this, A, {
                    index: G,
                    iterateControllerProfiles: !0,
                    hand: U.hand
                  });
                },
                injectTrackedControls: function() {
                  var U = this.el, G = this.data;
                  U.setAttribute("tracked-controls", {
                    idPrefix: A,
                    // Hand IDs: 1 = right, 0 = left, 2 = anything else.
                    controller: G.hand === "right" ? 1 : G.hand === "left" ? 0 : 2,
                    hand: G.hand,
                    orientationOffset: G.orientationOffset
                  }), this.loadModel();
                },
                loadModel: function() {
                  var U = this.data;
                  U.model && this.el.setAttribute("gltf-model", "" + g[U.hand]);
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                /**
                 * Rotate the trigger button based on how hard the trigger is pressed.
                 */
                onButtonChanged: function(U) {
                  var G = this.mapping.buttons[U.detail.id], Z = this.buttonMeshes, W;
                  G && (G === "trigger" && (W = U.detail.state.value, Z && Z.trigger && (Z.trigger.rotation.x = this.triggerOriginalRotationX - W * (Math.PI / 40))), this.el.emit(G + "changed", U.detail.state));
                },
                onModelLoaded: function(U) {
                  var G, Z = U.detail.model, W = this;
                  U.target !== this.el || !this.data.model || (G = this.buttonMeshes = {}, G.grip = {
                    left: Z.getObjectByName("leftgrip"),
                    right: Z.getObjectByName("rightgrip")
                  }, G.menu = Z.getObjectByName("menubutton"), G.system = Z.getObjectByName("systembutton"), G.trackpad = Z.getObjectByName("touchpad"), G.trigger = Z.getObjectByName("trigger"), this.triggerOriginalRotationX = G.trigger.rotation.x, Object.keys(G).forEach(function(ie) {
                    W.setButtonColor(ie, W.data.buttonColor);
                  }), Z.position.copy(S[this.data.hand]), Z.rotation.copy(D[this.data.hand]), this.el.emit("controllermodelready", {
                    name: "valve-index-controls",
                    model: this.data.model,
                    rayOrigin: new w.Vector3(0, 0, 0)
                  }));
                },
                onAxisMoved: function(U) {
                  l(this, this.mapping.axes, U);
                },
                updateModel: function(U, G) {
                  var Z, W;
                  this.data.model && (W = G.indexOf("touch") !== -1, !W && (Z = G === "up" ? this.data.buttonColor : this.data.buttonHighlightColor, this.setButtonColor(U, Z)));
                },
                setButtonColor: function(U, G) {
                }
              });
            }
          ),
          /***/
          "./src/components/visible.js": (
            /*!***********************************!*\
              !*** ./src/components/visible.js ***!
              \***********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent;
              j.exports.Component = C("visible", {
                schema: {
                  default: !0
                },
                update: function() {
                  this.el.object3D.visible = this.data;
                }
              });
            }
          ),
          /***/
          "./src/components/vive-controls.js": (
            /*!*****************************************!*\
              !*** ./src/components/vive-controls.js ***!
              \*****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), E = w.checkControllerPresentAndSetup, y = w.emitIfAxesChanged, l = w.onButtonEvent, d = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, p = d + "controllers/vive/vr_controller_vive.obj", c = d + "controllers/vive/vr_controller_vive.mtl", g = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ).device.isWebXRAvailable, A = "htc-vive", u = "OpenVR ", f = g ? A : u, x = {
                axes: {
                  trackpad: [0, 1]
                },
                buttons: ["trackpad", "trigger", "grip", "menu", "system"]
              }, T = {
                axes: {
                  touchpad: [0, 1]
                },
                buttons: ["trigger", "grip", "touchpad", "none"]
              }, b = g ? T : x;
              j.exports.Component = C("vive-controls", {
                schema: {
                  hand: {
                    default: "left"
                  },
                  buttonColor: {
                    type: "color",
                    default: "#FAFAFA"
                  },
                  // Off-white.
                  buttonHighlightColor: {
                    type: "color",
                    default: "#22D1EE"
                  },
                  // Light blue.
                  model: {
                    default: !0
                  },
                  orientationOffset: {
                    type: "vec3"
                  }
                },
                after: ["tracked-controls"],
                mapping: b,
                init: function() {
                  var D = this;
                  this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(S) {
                    l(S.detail.id, "down", D);
                  }, this.onButtonUp = function(S) {
                    l(S.detail.id, "up", D);
                  }, this.onButtonTouchEnd = function(S) {
                    l(S.detail.id, "touchend", D);
                  }, this.onButtonTouchStart = function(S) {
                    l(S.detail.id, "touchstart", D);
                  }, this.previousButtonValues = {}, this.bindMethods();
                },
                update: function() {
                  var D = this.data;
                  this.controllerIndex = D.hand === "right" ? 0 : D.hand === "left" ? 1 : 2;
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                bindMethods: function() {
                  this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                addEventListeners: function() {
                  var D = this.el;
                  D.addEventListener("buttonchanged", this.onButtonChanged), D.addEventListener("buttondown", this.onButtonDown), D.addEventListener("buttonup", this.onButtonUp), D.addEventListener("touchend", this.onButtonTouchEnd), D.addEventListener("touchstart", this.onButtonTouchStart), D.addEventListener("model-loaded", this.onModelLoaded), D.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var D = this.el;
                  D.removeEventListener("buttonchanged", this.onButtonChanged), D.removeEventListener("buttondown", this.onButtonDown), D.removeEventListener("buttonup", this.onButtonUp), D.removeEventListener("touchend", this.onButtonTouchEnd), D.removeEventListener("touchstart", this.onButtonTouchStart), D.removeEventListener("model-loaded", this.onModelLoaded), D.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
                },
                /**
                 * Once OpenVR returns correct hand data in supporting browsers, we can use hand property.
                 * var isPresent = checkControllerPresentAndSetup(this.el.sceneEl, GAMEPAD_ID_PREFIX,
                                                                      { hand: data.hand });
                 * Until then, use hardcoded index.
                 */
                checkIfControllerPresent: function() {
                  var D = this.data;
                  E(this, f, {
                    index: this.controllerIndex,
                    hand: D.hand
                  });
                },
                injectTrackedControls: function() {
                  var D = this.el, S = this.data;
                  D.setAttribute("tracked-controls", {
                    idPrefix: f,
                    hand: S.hand,
                    controller: this.controllerIndex,
                    orientationOffset: S.orientationOffset
                  }), this.data.model && this.el.setAttribute("obj-model", {
                    obj: p,
                    mtl: c
                  });
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                /**
                 * Rotate the trigger button based on how hard the trigger is pressed.
                 */
                onButtonChanged: function(D) {
                  var S = this.mapping.buttons[D.detail.id], U = this.buttonMeshes, G;
                  S && (S === "trigger" && (G = D.detail.state.value, U && U.trigger && (U.trigger.rotation.x = -G * (Math.PI / 12))), this.el.emit(S + "changed", D.detail.state));
                },
                onModelLoaded: function(D) {
                  var S, U = D.detail.model, G = this;
                  D.target !== this.el || !this.data.model || (S = this.buttonMeshes = {}, S.grip = {
                    left: U.getObjectByName("leftgrip"),
                    right: U.getObjectByName("rightgrip")
                  }, S.menu = U.getObjectByName("menubutton"), S.system = U.getObjectByName("systembutton"), S.trackpad = U.getObjectByName("touchpad"), S.touchpad = U.getObjectByName("touchpad"), S.trigger = U.getObjectByName("trigger"), Object.keys(S).forEach(function(Z) {
                    G.setButtonColor(Z, G.data.buttonColor);
                  }), U.position.set(0, -0.015, 0.04));
                },
                onAxisMoved: function(D) {
                  y(this, this.mapping.axes, D);
                },
                updateModel: function(D, S) {
                  var U, G;
                  this.data.model && (G = S.indexOf("touch") !== -1, !G && (U = S === "up" ? this.data.buttonColor : this.data.buttonHighlightColor, this.setButtonColor(D, U)));
                },
                setButtonColor: function(D, S) {
                  var U = this.buttonMeshes;
                  if (U) {
                    if (D === "grip") {
                      U.grip.left.material.color.set(S), U.grip.right.material.color.set(S);
                      return;
                    }
                    U[D].material.color.set(S);
                  }
                }
              });
            }
          ),
          /***/
          "./src/components/vive-focus-controls.js": (
            /*!***********************************************!*\
              !*** ./src/components/vive-focus-controls.js ***!
              \***********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), E = w.checkControllerPresentAndSetup, y = w.emitIfAxesChanged, l = w.onButtonEvent, d = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, p = d + "controllers/vive/focus-controller/focus-controller.gltf", c = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ).device.isWebXRAvailable, g = "htc-vive-focus", A = "HTC Vive Focus ", u = c ? g : A, f = {
                axes: {
                  trackpad: [0, 1]
                },
                buttons: ["trackpad", "trigger"]
              }, x = {
                axes: {
                  touchpad: [0, 1]
                },
                buttons: ["trigger", "none", "touchpad", "none", "menu"]
              }, T = c ? x : f;
              j.exports.Component = C("vive-focus-controls", {
                schema: {
                  hand: {
                    default: ""
                  },
                  // This informs the degenerate arm model.
                  buttonTouchedColor: {
                    type: "color",
                    default: "#BBBBBB"
                  },
                  buttonHighlightColor: {
                    type: "color",
                    default: "#7A7A7A"
                  },
                  model: {
                    default: !0
                  },
                  orientationOffset: {
                    type: "vec3"
                  },
                  armModel: {
                    default: !0
                  }
                },
                after: ["tracked-controls"],
                mapping: T,
                bindMethods: function() {
                  this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                init: function() {
                  var b = this;
                  this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(D) {
                    l(D.detail.id, "down", b);
                  }, this.onButtonUp = function(D) {
                    l(D.detail.id, "up", b);
                  }, this.onButtonTouchStart = function(D) {
                    l(D.detail.id, "touchstart", b);
                  }, this.onButtonTouchEnd = function(D) {
                    l(D.detail.id, "touchend", b);
                  }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.bindMethods();
                },
                addEventListeners: function() {
                  var b = this.el;
                  b.addEventListener("buttonchanged", this.onButtonChanged), b.addEventListener("buttondown", this.onButtonDown), b.addEventListener("buttonup", this.onButtonUp), b.addEventListener("touchstart", this.onButtonTouchStart), b.addEventListener("touchend", this.onButtonTouchEnd), b.addEventListener("model-loaded", this.onModelLoaded), b.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0, this.addControllersUpdateListener();
                },
                removeEventListeners: function() {
                  var b = this.el;
                  b.removeEventListener("buttonchanged", this.onButtonChanged), b.removeEventListener("buttondown", this.onButtonDown), b.removeEventListener("buttonup", this.onButtonUp), b.removeEventListener("touchstart", this.onButtonTouchStart), b.removeEventListener("touchend", this.onButtonTouchEnd), b.removeEventListener("model-loaded", this.onModelLoaded), b.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1, this.removeControllersUpdateListener();
                },
                checkIfControllerPresent: function() {
                  E(this, u, this.data.hand ? {
                    hand: this.data.hand
                  } : {});
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                injectTrackedControls: function() {
                  var b = this.el, D = this.data;
                  b.setAttribute("tracked-controls", {
                    armModel: D.armModel,
                    idPrefix: u,
                    orientationOffset: D.orientationOffset
                  }), this.data.model && this.el.setAttribute("gltf-model", p);
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                onModelLoaded: function(b) {
                  var D = b.detail.model, S;
                  b.target !== this.el || !this.data.model || (S = this.buttonMeshes = {}, S.trigger = D.getObjectByName("BumperKey"), S.triggerPressed = D.getObjectByName("BumperKey_Press"), S.triggerPressed && (S.triggerPressed.visible = !1), S.trackpad = D.getObjectByName("TouchPad"), S.trackpadPressed = D.getObjectByName("TouchPad_Press"), S.trackpadPressed && (S.trackpadPressed.visible = !1));
                },
                // No analog buttons, only emits 0/1 values
                onButtonChanged: function(b) {
                  var D = this.mapping.buttons[b.detail.id];
                  D && this.el.emit(D + "changed", b.detail.state);
                },
                onAxisMoved: function(b) {
                  y(this, this.mapping.axes, b);
                },
                updateModel: function(b, D) {
                  this.data.model && this.updateButtonModel(b, D);
                },
                updateButtonModel: function(b, D) {
                  var S = this.buttonMeshes, U = b + "Pressed";
                  if (!(!S || !S[b] || !S[U])) {
                    var G;
                    switch (D) {
                      case "down":
                        G = this.data.buttonHighlightColor;
                        break;
                      case "touchstart":
                        G = this.data.buttonTouchedColor;
                        break;
                    }
                    G && S[U].material.color.set(G), S[U].visible = !!G, S[b].visible = !G;
                  }
                }
              });
            }
          ),
          /***/
          "./src/components/wasd-controls.js": (
            /*!*****************************************!*\
              !*** ./src/components/wasd-controls.js ***!
              \*****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).keyboardevent.KEYCODE_TO_CODE, w = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), y = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), l = y.shouldCaptureKeyEvent, d = 1e-5, p = 0.2, c = ["KeyW", "KeyA", "KeyS", "KeyD", "ArrowUp", "ArrowLeft", "ArrowRight", "ArrowDown"];
              j.exports.Component = w("wasd-controls", {
                schema: {
                  acceleration: {
                    default: 65
                  },
                  adAxis: {
                    default: "x",
                    oneOf: ["x", "y", "z"]
                  },
                  adEnabled: {
                    default: !0
                  },
                  adInverted: {
                    default: !1
                  },
                  enabled: {
                    default: !0
                  },
                  fly: {
                    default: !1
                  },
                  wsAxis: {
                    default: "z",
                    oneOf: ["x", "y", "z"]
                  },
                  wsEnabled: {
                    default: !0
                  },
                  wsInverted: {
                    default: !1
                  }
                },
                after: ["look-controls"],
                init: function() {
                  this.keys = {}, this.easing = 1.1, this.velocity = new E.Vector3(), this.onBlur = this.onBlur.bind(this), this.onContextMenu = this.onContextMenu.bind(this), this.onFocus = this.onFocus.bind(this), this.onKeyDown = this.onKeyDown.bind(this), this.onKeyUp = this.onKeyUp.bind(this), this.onVisibilityChange = this.onVisibilityChange.bind(this), this.attachVisibilityEventListeners();
                },
                tick: function(A, u) {
                  var f = this.data, x = this.el, T = this.velocity;
                  !T[f.adAxis] && !T[f.wsAxis] && g(this.keys) || (u = u / 1e3, this.updateVelocity(u), !(!T[f.adAxis] && !T[f.wsAxis]) && x.object3D.position.add(this.getMovementVector(u)));
                },
                update: function(A) {
                  A.adAxis !== this.data.adAxis && (this.velocity[A.adAxis] = 0), A.wsAxis !== this.data.wsAxis && (this.velocity[A.wsAxis] = 0);
                },
                remove: function() {
                  this.removeKeyEventListeners(), this.removeVisibilityEventListeners();
                },
                play: function() {
                  this.attachKeyEventListeners();
                },
                pause: function() {
                  this.keys = {}, this.removeKeyEventListeners();
                },
                updateVelocity: function(A) {
                  var u, f, x, T = this.data, b = this.keys, D = this.velocity, S, U;
                  if (f = T.adAxis, S = T.wsAxis, A > p) {
                    D[f] = 0, D[S] = 0;
                    return;
                  }
                  var G = Math.pow(1 / this.easing, A * 60);
                  D[f] !== 0 && (D[f] = D[f] * G), D[S] !== 0 && (D[S] = D[S] * G), Math.abs(D[f]) < d && (D[f] = 0), Math.abs(D[S]) < d && (D[S] = 0), T.enabled && (u = T.acceleration, T.adEnabled && (x = T.adInverted ? -1 : 1, (b.KeyA || b.ArrowLeft) && (D[f] -= x * u * A), (b.KeyD || b.ArrowRight) && (D[f] += x * u * A)), T.wsEnabled && (U = T.wsInverted ? -1 : 1, (b.KeyW || b.ArrowUp) && (D[S] -= U * u * A), (b.KeyS || b.ArrowDown) && (D[S] += U * u * A)));
                },
                getMovementVector: function() {
                  var A = new E.Vector3(0, 0, 0), u = new E.Euler(0, 0, 0, "YXZ");
                  return function(f) {
                    var x = this.el.getAttribute("rotation"), T = this.velocity, b;
                    return A.copy(T), A.multiplyScalar(f), x && (b = this.data.fly ? x.x : 0, u.set(E.MathUtils.degToRad(b), E.MathUtils.degToRad(x.y), 0), A.applyEuler(u)), A;
                  };
                }(),
                attachVisibilityEventListeners: function() {
                  window.oncontextmenu = this.onContextMenu, window.addEventListener("blur", this.onBlur), window.addEventListener("focus", this.onFocus), document.addEventListener("visibilitychange", this.onVisibilityChange);
                },
                removeVisibilityEventListeners: function() {
                  window.removeEventListener("blur", this.onBlur), window.removeEventListener("focus", this.onFocus), document.removeEventListener("visibilitychange", this.onVisibilityChange);
                },
                attachKeyEventListeners: function() {
                  window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp);
                },
                removeKeyEventListeners: function() {
                  window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
                },
                onContextMenu: function() {
                  for (var A = Object.keys(this.keys), u = 0; u < A.length; u++)
                    delete this.keys[A[u]];
                },
                onBlur: function() {
                  this.pause();
                },
                onFocus: function() {
                  this.play();
                },
                onVisibilityChange: function() {
                  document.hidden ? this.onBlur() : this.onFocus();
                },
                onKeyDown: function(A) {
                  var u;
                  l(A) && (u = A.code || C[A.keyCode], c.indexOf(u) !== -1 && (this.keys[u] = !0));
                },
                onKeyUp: function(A) {
                  var u;
                  u = A.code || C[A.keyCode], delete this.keys[u];
                }
              });
              function g(A) {
                var u;
                for (u in A)
                  return !1;
                return !0;
              }
            }
          ),
          /***/
          "./src/components/windows-motion-controls.js": (
            /*!***************************************************!*\
              !*** ./src/components/windows-motion-controls.js ***!
              \***************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../utils/tracked-controls */
                "./src/utils/tracked-controls.js"
              ), E = w.checkControllerPresentAndSetup, y = w.emitIfAxesChanged, l = w.onButtonEvent, d = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), p = d.debug("components:windows-motion-controls:debug"), c = d.debug("components:windows-motion-controls:warn"), g = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).DEFAULT_HANDEDNESS, A = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).AFRAME_CDN_ROOT, u = A + "controllers/microsoft/", f = {
                left: "left.glb",
                right: "right.glb",
                default: "universal.glb"
              }, x = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ).device.isWebXRAvailable, T = "windows-mixed-reality", b = "Spatial Controller (Spatial Interaction Source) ", D = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/, S = x ? T : b, U = {
                // A-Frame specific semantic axis names
                axes: {
                  thumbstick: [0, 1],
                  trackpad: [2, 3]
                },
                // A-Frame specific semantic button names
                buttons: ["thumbstick", "trigger", "grip", "menu", "trackpad"],
                // A mapping of the semantic name to node name in the glTF model file,
                // that should be transformed by axis value.
                // This array mirrors the browser Gamepad.axes array, such that
                // the mesh corresponding to axis 0 is in this array index 0.
                axisMeshNames: ["THUMBSTICK_X", "THUMBSTICK_Y", "TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_Y"],
                // A mapping of the semantic name to button node name in the glTF model file,
                // that should be transformed by button value.
                buttonMeshNames: {
                  trigger: "SELECT",
                  menu: "MENU",
                  grip: "GRASP",
                  thumbstick: "THUMBSTICK_PRESS",
                  trackpad: "TOUCHPAD_PRESS"
                },
                pointingPoseMeshName: "POINTING_POSE"
              }, G = {
                // A-Frame specific semantic axis names
                axes: {
                  touchpad: [0, 1],
                  thumbstick: [2, 3]
                },
                // A-Frame specific semantic button names
                buttons: ["trigger", "squeeze", "touchpad", "thumbstick", "menu"],
                // A mapping of the semantic name to node name in the glTF model file,
                // that should be transformed by axis value.
                // This array mirrors the browser Gamepad.axes array, such that
                // the mesh corresponding to axis 0 is in this array index 0.
                axisMeshNames: ["TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_X", "THUMBSTICK_X", "THUMBSTICK_Y"],
                // A mapping of the semantic name to button node name in the glTF model file,
                // that should be transformed by button value.
                buttonMeshNames: {
                  trigger: "SELECT",
                  menu: "MENU",
                  squeeze: "GRASP",
                  thumbstick: "THUMBSTICK_PRESS",
                  touchpad: "TOUCHPAD_PRESS"
                },
                pointingPoseMeshName: "POINTING_POSE"
              }, Z = x ? G : U;
              j.exports.Component = C("windows-motion-controls", {
                schema: {
                  hand: {
                    default: g
                  },
                  // It is possible to have multiple pairs of controllers attached (a pair has both left and right).
                  // Set this to 1 to use a controller from the second pair, 2 from the third pair, etc.
                  pair: {
                    default: 0
                  },
                  // If true, loads the controller glTF asset.
                  model: {
                    default: !0
                  },
                  // If true, will hide the model from the scene if no matching gamepad (based on ID & hand) is connected.
                  hideDisconnected: {
                    default: !0
                  }
                },
                after: ["tracked-controls"],
                mapping: Z,
                bindMethods: function() {
                  this.onModelError = this.onModelError.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
                },
                init: function() {
                  var W = this, ie = this.el;
                  this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(te) {
                    l(te.detail.id, "down", W);
                  }, this.onButtonUp = function(te) {
                    l(te.detail.id, "up", W);
                  }, this.onButtonTouchStart = function(te) {
                    l(te.detail.id, "touchstart", W);
                  }, this.onButtonTouchEnd = function(te) {
                    l(te.detail.id, "touchend", W);
                  }, this.onControllerConnected = function() {
                    W.setModelVisibility(!0);
                  }, this.onControllerDisconnected = function() {
                    W.setModelVisibility(!1);
                  }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.previousButtonValues = {}, this.bindMethods(), this.loadedMeshInfo = {
                    buttonMeshes: null,
                    axisMeshes: null
                  }, this.rayOrigin = {
                    origin: new THREE.Vector3(),
                    direction: new THREE.Vector3(0, 0, -1),
                    createdFromMesh: !1
                  }, ie.addEventListener("controllerconnected", this.onControllerConnected), ie.addEventListener("controllerdisconnected", this.onControllerDisconnected);
                },
                addEventListeners: function() {
                  var W = this.el;
                  W.addEventListener("buttonchanged", this.onButtonChanged), W.addEventListener("buttondown", this.onButtonDown), W.addEventListener("buttonup", this.onButtonUp), W.addEventListener("touchstart", this.onButtonTouchStart), W.addEventListener("touchend", this.onButtonTouchEnd), W.addEventListener("axismove", this.onAxisMoved), W.addEventListener("model-error", this.onModelError), W.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
                },
                removeEventListeners: function() {
                  var W = this.el;
                  W.removeEventListener("buttonchanged", this.onButtonChanged), W.removeEventListener("buttondown", this.onButtonDown), W.removeEventListener("buttonup", this.onButtonUp), W.removeEventListener("touchstart", this.onButtonTouchStart), W.removeEventListener("touchend", this.onButtonTouchEnd), W.removeEventListener("axismove", this.onAxisMoved), W.removeEventListener("model-error", this.onModelError), W.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
                },
                checkIfControllerPresent: function() {
                  E(this, S, {
                    hand: this.data.hand,
                    index: this.data.pair,
                    iterateControllerProfiles: !0
                  });
                },
                play: function() {
                  this.checkIfControllerPresent(), this.addControllersUpdateListener();
                },
                pause: function() {
                  this.removeEventListeners(), this.removeControllersUpdateListener();
                },
                updateControllerModel: function() {
                  if (!this.data.model || this.rayOrigin.createdFromMesh) {
                    this.modelReady();
                    return;
                  }
                  var W = this.createControllerModelUrl();
                  this.loadModel(W);
                },
                /**
                 * Helper function that constructs a URL from the controller ID suffix, for future proofed
                 * art assets.
                 */
                createControllerModelUrl: function(W) {
                  var ie = this.el.components["tracked-controls"], te = ie ? ie.controller : null, X = "default", Q = this.data.hand, O;
                  if (te && !window.hasNativeWebXRImplementation && (Q = te.hand, !W)) {
                    var K = te.id.match(D);
                    X = K && K[0] || X;
                  }
                  return O = f[Q] || f.default, u + X + "/" + O;
                },
                injectTrackedControls: function() {
                  var W = this.data;
                  this.el.setAttribute("tracked-controls", {
                    idPrefix: S,
                    controller: W.pair,
                    hand: W.hand,
                    armModel: !1
                  }), this.updateControllerModel();
                },
                addControllersUpdateListener: function() {
                  this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                removeControllersUpdateListener: function() {
                  this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
                },
                onControllersUpdate: function() {
                  this.checkIfControllerPresent();
                },
                onModelError: function(W) {
                  var ie = this.createControllerModelUrl(!0);
                  W.detail.src !== ie ? (c("Failed to load controller model for device, attempting to load default."), this.loadModel(ie)) : c("Failed to load default controller model.");
                },
                loadModel: function(W) {
                  this.el.setAttribute("gltf-model", "url(" + W + ")");
                },
                onModelLoaded: function(W) {
                  var ie = this.controllerModel = W.detail.model, te = this.loadedMeshInfo, X, Q, O, K;
                  if (W.target !== this.el)
                    return;
                  if (p("Processing model"), te.buttonMeshes = {}, te.axisMeshes = {}, ie) {
                    for (X = 0; X < this.mapping.buttons.length; X++) {
                      if (Q = this.mapping.buttonMeshNames[this.mapping.buttons[X]], !Q) {
                        p("Skipping unknown button at index: " + X + " with mapped name: " + this.mapping.buttons[X]);
                        continue;
                      }
                      if (O = ie.getObjectByName(Q), !O) {
                        c("Missing button mesh with name: " + Q);
                        continue;
                      }
                      K = {
                        index: X,
                        value: ne(O, "VALUE"),
                        pressed: ne(O, "PRESSED"),
                        unpressed: ne(O, "UNPRESSED")
                      }, K.value && K.pressed && K.unpressed ? te.buttonMeshes[this.mapping.buttons[X]] = K : c("Missing button submesh under mesh with name: " + Q + "(VALUE: " + !!K.value + ", PRESSED: " + !!K.pressed + ", UNPRESSED:" + !!K.unpressed + ")");
                    }
                    for (X = 0; X < this.mapping.axisMeshNames.length; X++) {
                      if (Q = this.mapping.axisMeshNames[X], !Q) {
                        p("Skipping unknown axis at index: " + X);
                        continue;
                      }
                      if (O = ie.getObjectByName(Q), !O) {
                        c("Missing axis mesh with name: " + Q);
                        continue;
                      }
                      K = {
                        index: X,
                        value: ne(O, "VALUE"),
                        min: ne(O, "MIN"),
                        max: ne(O, "MAX")
                      }, K.value && K.min && K.max ? te.axisMeshes[X] = K : c("Missing axis submesh under mesh with name: " + Q + "(VALUE: " + !!K.value + ", MIN: " + !!K.min + ", MAX:" + !!K.max + ")");
                    }
                    this.calculateRayOriginFromMesh(ie), this.setModelVisibility();
                  }
                  p("Model load complete.");
                  function ne(pe, be) {
                    for (var Te = 0, ke = pe.children.length; Te < ke; Te++) {
                      var Ve = pe.children[Te];
                      if (Ve && Ve.name === be)
                        return Ve;
                    }
                  }
                },
                calculateRayOriginFromMesh: function() {
                  var W = new THREE.Quaternion();
                  return function(ie) {
                    var te;
                    if (this.rayOrigin.origin.set(0, 0, 0), this.rayOrigin.direction.set(0, 0, -1), this.rayOrigin.createdFromMesh = !0, te = ie.getObjectByName(this.mapping.pointingPoseMeshName), te) {
                      var X = ie.parent;
                      X && (ie.parent = null, ie.updateMatrixWorld(!0), ie.parent = X), te.getWorldPosition(this.rayOrigin.origin), te.getWorldQuaternion(W), this.rayOrigin.direction.applyQuaternion(W), X && ie.updateMatrixWorld(!0);
                    } else
                      p("Mesh does not contain pointing origin data, defaulting to none.");
                    this.modelReady();
                  };
                }(),
                lerpAxisTransform: function() {
                  var W = new THREE.Quaternion();
                  return function(ie, te) {
                    var X = this.loadedMeshInfo.axisMeshes[ie];
                    if (X) {
                      var Q = X.min, O = X.max, K = X.value, ne = te * 0.5 + 0.5;
                      K.setRotationFromQuaternion(W.copy(Q.quaternion).slerp(O.quaternion, ne)), K.position.lerpVectors(Q.position, O.position, ne);
                    }
                  };
                }(),
                lerpButtonTransform: function() {
                  var W = new THREE.Quaternion();
                  return function(ie, te) {
                    var X = this.loadedMeshInfo.buttonMeshes[ie];
                    if (X) {
                      var Q = X.unpressed, O = X.pressed, K = X.value;
                      K.setRotationFromQuaternion(W.copy(Q.quaternion).slerp(O.quaternion, te)), K.position.lerpVectors(Q.position, O.position, te);
                    }
                  };
                }(),
                modelReady: function() {
                  this.el.emit("controllermodelready", {
                    name: "windows-motion-controls",
                    model: this.data.model,
                    rayOrigin: this.rayOrigin
                  });
                },
                onButtonChanged: function(W) {
                  var ie = this.mapping.buttons[W.detail.id];
                  ie && (this.loadedMeshInfo && this.loadedMeshInfo.buttonMeshes && this.lerpButtonTransform(ie, W.detail.state.value), this.el.emit(ie + "changed", W.detail.state));
                },
                onAxisMoved: function(W) {
                  var ie = this.mapping.axisMeshNames.length;
                  if (this.loadedMeshInfo && this.loadedMeshInfo.axisMeshes)
                    for (var te = 0; te < ie; te++)
                      this.lerpAxisTransform(te, W.detail.axis[te] || 0);
                  y(this, this.mapping.axes, W);
                },
                setModelVisibility: function(W) {
                  var ie = this.el.getObject3D("mesh");
                  this.controllerPresent && (W = W !== void 0 ? W : this.modelVisible, this.modelVisible = W, ie && (ie.visible = W));
                }
              });
            }
          ),
          /***/
          "./src/constants/index.js": (
            /*!********************************!*\
              !*** ./src/constants/index.js ***!
              \********************************/
            /***/
            (j, re, v) => {
              j.exports = {
                AFRAME_CDN_ROOT: window.AFRAME_CDN_ROOT || "https://cdn.aframe.io/",
                AFRAME_INJECTED: "aframe-injected",
                DEFAULT_CAMERA_HEIGHT: 1.6,
                DEFAULT_HANDEDNESS: "right",
                keyboardevent: v(
                  /*! ./keyboardevent */
                  "./src/constants/keyboardevent.js"
                )
              };
            }
          ),
          /***/
          "./src/constants/keyboardevent.js": (
            /*!****************************************!*\
              !*** ./src/constants/keyboardevent.js ***!
              \****************************************/
            /***/
            (j) => {
              j.exports = {
                // Tiny KeyboardEvent.code polyfill.
                KEYCODE_TO_CODE: {
                  38: "ArrowUp",
                  37: "ArrowLeft",
                  40: "ArrowDown",
                  39: "ArrowRight",
                  87: "KeyW",
                  65: "KeyA",
                  83: "KeyS",
                  68: "KeyD"
                }
              };
            }
          ),
          /***/
          "./src/core/a-assets.js": (
            /*!******************************!*\
              !*** ./src/core/a-assets.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./a-node */
                "./src/core/a-node.js"
              ).ANode, w = v(
                /*! ../utils/debug */
                "./src/utils/debug.js"
              ), E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), y = new E.FileLoader(), l = w("core:a-assets:warn");
              class d extends C {
                constructor() {
                  super(), this.isAssets = !0, this.fileLoader = y, this.timeout = null;
                }
                doConnectedCallback() {
                  var b = this, D, S = [], U, G, Z, W, ie, te;
                  if (super.doConnectedCallback(), !this.parentNode.isScene)
                    throw new Error("<a-assets> must be a child of a <a-scene>.");
                  for (W = this.querySelectorAll("img"), D = 0; D < W.length; D++)
                    Z = g(W[D]), S.push(new Promise(function(X, Q) {
                      if (E.Cache.add(W[D].getAttribute("src"), Z), Z.complete) {
                        X();
                        return;
                      }
                      Z.onload = X, Z.onerror = Q;
                    }));
                  for (G = this.querySelectorAll("audio, video"), D = 0; D < G.length; D++)
                    U = g(G[D]), !U.src && !U.srcObject && l("Audio/video asset has neither `src` nor `srcObject` attributes."), S.push(c(U));
                  te = this.getChildren(), te.forEach(function(X) {
                    !X.isAssetItem || !X.hasAttribute("src") || S.push(new Promise(function(O, K) {
                      if (X.hasLoaded)
                        return O();
                      X.addEventListener("loaded", O), X.addEventListener("error", K);
                    }));
                  }), Promise.allSettled(S).then(function() {
                    b.timeout !== null && b.load();
                  }), ie = parseInt(this.getAttribute("timeout"), 10) || 3e3, this.timeout = setTimeout(function() {
                    b.hasLoaded || (l("Asset loading timed out in", ie, "ms"), b.timeout = null, b.emit("timeout"), b.load());
                  }, ie);
                }
                disconnectedCallback() {
                  super.disconnectedCallback(), this.timeout && clearTimeout(this.timeout);
                }
                load() {
                  super.load.call(this, null, function() {
                    return !1;
                  });
                }
              }
              customElements.define("a-assets", d);
              class p extends C {
                constructor() {
                  super(), this.data = null, this.isAssetItem = !0;
                }
                connectedCallback() {
                  var b = this, D = this.getAttribute("src");
                  y.setResponseType(this.getAttribute("response-type") || f(D)), y.load(D, function(U) {
                    b.data = U, C.prototype.load.call(b);
                  }, function(U) {
                    b.emit("progress", {
                      loadedBytes: U.loaded,
                      totalBytes: U.total,
                      xhr: U
                    });
                  }, function(U) {
                    b.emit("error", {
                      xhr: U
                    });
                  });
                }
              }
              customElements.define("a-asset-item", p);
              function c(T) {
                if (!(!T.hasAttribute("autoplay") && T.getAttribute("preload") !== "auto"))
                  return new Promise(function(b, D) {
                    if (T.readyState === 4)
                      return b();
                    if (T.error)
                      return D();
                    T.addEventListener("loadeddata", S, !1), T.addEventListener("progress", S, !1), T.addEventListener("error", D, !1);
                    function S() {
                      for (var U = 0, G = 0; G < T.buffered.length; G++)
                        U += T.buffered.end(G) - T.buffered.start(G);
                      U >= T.duration && (T.tagName === "VIDEO" && E.Cache.add(T.getAttribute("src"), T), b());
                    }
                  });
              }
              function g(T) {
                var b = A(T);
                return b.tagName && b.tagName.toLowerCase() === "video" && (b.setAttribute("playsinline", ""), b.setAttribute("webkit-playsinline", "")), b !== T && (T.parentNode.appendChild(b), T.parentNode.removeChild(T)), b;
              }
              function A(T) {
                var b, D;
                return T.hasAttribute("crossorigin") || (D = T.getAttribute("src"), D !== null && (D.indexOf("://") === -1 || u(D) === window.location.host)) ? T : (l('Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)', D), T.crossOrigin = "anonymous", b = T.cloneNode(!0), b);
              }
              function u(T) {
                var b = T.indexOf("://") > -1 ? T.split("/")[2] : T.split("/")[0];
                return b.substring(0, b.indexOf(":"));
              }
              function f(T) {
                var b = x(T), D = b.lastIndexOf(".");
                if (D >= 0) {
                  var S = b.slice(D, T.search(/\?|#|$/));
                  if (S === ".glb")
                    return "arraybuffer";
                }
                return "text";
              }
              j.exports.inferResponseType = f;
              function x(T) {
                var b = document.createElement("a");
                b.href = T;
                var D = b.search.replace(/^\?/, ""), S = T.replace(D, "").replace("?", "");
                return S.substring(S.lastIndexOf("/") + 1);
              }
              j.exports.getFileNameFromURL = x;
            }
          ),
          /***/
          "./src/core/a-cubemap.js": (
            /*!*******************************!*\
              !*** ./src/core/a-cubemap.js ***!
              \*******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils/debug */
                "./src/utils/debug.js"
              ), w = C("core:cubemap:warn");
              class E extends HTMLElement {
                /**
                 * Calculates this.srcs.
                 */
                constructor(l) {
                  return l = super(l), l;
                }
                onReadyStateChange() {
                  document.readyState === "complete" && this.doConnectedCallback();
                }
                connectedCallback() {
                  if (document.readyState !== "complete") {
                    document.addEventListener("readystatechange", this.onReadyStateChange.bind(this));
                    return;
                  }
                  E.prototype.doConnectedCallback.call(this);
                }
                doConnectedCallback() {
                  this.srcs = this.validate();
                }
                /**
                 * Checks for exactly six elements with [src].
                 * When <img>s are used they will be prefetched.
                 *
                 * @returns {Array|null} - six URLs or <img> elements if valid, else null.
                 */
                validate() {
                  var l = this.querySelectorAll("[src]"), d, p = [];
                  if (l.length === 6) {
                    for (d = 0; d < l.length; d++)
                      l[d].tagName === "IMG" ? p.push(l[d]) : p.push(l[d].getAttribute("src"));
                    return p;
                  }
                  w("<a-cubemap> did not contain exactly six elements each with a `src` attribute.");
                }
              }
              customElements.define("a-cubemap", E);
            }
          ),
          /***/
          "./src/core/a-entity.js": (
            /*!******************************!*\
              !*** ./src/core/a-entity.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./a-node */
                "./src/core/a-node.js"
              ).ANode, w = v(
                /*! ./component */
                "./src/core/component.js"
              ).components, E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), y = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), l = y.debug("core:a-entity:debug"), d = y.debug("core:a-entity:warn"), p = "__", c = ["position", "rotation", "scale", "visible"], g = {
                once: !0
              };
              class A extends C {
                constructor() {
                  super(), this.components = {}, this.initializingComponents = {}, this.componentsToUpdate = {}, this.isEntity = !0, this.isPlaying = !1, this.object3D = new E.Group(), this.object3D.rotation.order = "YXZ", this.object3D.el = this, this.object3DMap = {}, this.parentEl = null, this.rotationObj = {}, this.states = [];
                }
                /**
                 * Handle changes coming from the browser DOM inspector.
                 */
                attributeChangedCallback(S, U, G) {
                  var Z = this.components[S];
                  if (super.attributeChangedCallback(), Z && Z.justInitialized && G === "") {
                    delete Z.justInitialized;
                    return;
                  }
                  !Z && G === null || this.setEntityAttribute(S, U, G);
                }
                doConnectedCallback() {
                  var S = this, U, G;
                  if (super.doConnectedCallback(), G = this.sceneEl, this.addToParent(), !this.isScene) {
                    if (!G) {
                      this.load();
                      return;
                    }
                    if (U = G.querySelector("a-assets"), U && !U.hasLoaded) {
                      U.addEventListener("loaded", function() {
                        S.load();
                      });
                      return;
                    }
                    this.load();
                  }
                }
                /**
                 * Tell parent to remove this element's object3D from its object3D.
                 * Do not call on scene element because that will cause a call to document.body.remove().
                 */
                disconnectedCallback() {
                  var S;
                  if (this.parentEl) {
                    for (S in this.components)
                      this.removeComponent(S, !1);
                    this.isScene || (this.removeFromParent(), super.disconnectedCallback(), this.object3D.el = null);
                  }
                }
                getObject3D(S) {
                  return this.object3DMap[S];
                }
                /**
                 * Set a THREE.Object3D into the map.
                 *
                 * @param {string} type - Developer-set name of the type of object, will be unique per type.
                 * @param {object} obj - A THREE.Object3D.
                 */
                setObject3D(S, U) {
                  var G, Z = this;
                  if (!(U instanceof E.Object3D))
                    throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");
                  G = this.getObject3D(S), G && this.object3D.remove(G), U.el = this, U.children.length && U.traverse(function(ie) {
                    ie.el = Z;
                  }), this.object3D.add(U), this.object3DMap[S] = U, this.emit("object3dset", {
                    object: U,
                    type: S
                  });
                }
                /**
                 * Remove object from scene and entity object3D map.
                 */
                removeObject3D(S) {
                  var U = this.getObject3D(S);
                  if (!U) {
                    d("Tried to remove `Object3D` of type:", S, "which was not defined.");
                    return;
                  }
                  this.object3D.remove(U), delete this.object3DMap[S], this.emit("object3dremove", {
                    type: S
                  });
                }
                /**
                 * Gets or creates an object3D of a given type.
                 *
                 * @param {string} type - Type of the object3D.
                 * @param {string} Constructor - Constructor to use to create the object3D if needed.
                 * @returns {object}
                 */
                getOrCreateObject3D(S, U) {
                  var G = this.getObject3D(S);
                  return !G && U && (G = new U(), this.setObject3D(S, G)), d("`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."), G;
                }
                /**
                 * Add child entity.
                 *
                 * @param {Element} el - Child entity.
                 */
                add(S) {
                  if (!S.object3D)
                    throw new Error("Trying to add an element that doesn't have an `object3D`");
                  this.object3D.add(S.object3D), this.emit("child-attached", {
                    el: S
                  });
                }
                /**
                 * Tell parentNode to add this entity to itself.
                 */
                addToParent() {
                  var S = this.parentEl = this.parentNode;
                  !S || !S.add || this.attachedToParent || (S.add(this), this.attachedToParent = !0);
                }
                /**
                 * Tell parentNode to remove this entity from itself.
                 */
                removeFromParent() {
                  var S = this.parentEl;
                  this.parentEl.remove(this), this.attachedToParent = !1, this.parentEl = null, S.emit("child-detached", {
                    el: this
                  });
                }
                load() {
                  var S = this;
                  this.hasLoaded || !this.parentEl || super.load.call(this, function() {
                    S.parentEl && (S.updateComponents(), (S.isScene || S.parentEl.isPlaying) && S.play());
                  });
                }
                /**
                 * Remove child entity.
                 *
                 * @param {Element} el - Child entity.
                 */
                remove(S) {
                  S ? this.object3D.remove(S.object3D) : this.parentNode.removeChild(this);
                }
                /**
                 * @returns {array} Direct children that are entities.
                 */
                getChildEntities() {
                  for (var S = this.children, U = [], G = 0; G < S.length; G++) {
                    var Z = S[G];
                    Z instanceof A && U.push(Z);
                  }
                  return U;
                }
                /**
                 * Initialize component.
                 *
                 * @param {string} attrName - Attribute name associated to the component.
                 * @param {object} data - Component data
                 * @param {boolean} isDependency - True if the component is a dependency.
                 */
                initComponent(S, U, G) {
                  var Z, W, ie, te, X;
                  ie = y.split(S, p), te = ie[0], W = ie.length > 2 ? ie.slice(1).join("__") : ie[1], w[te] && (X = u(this, S) || U !== void 0, !(!X && !G) && (S in this.components || (this.initComponentDependencies(te), Z = new w[te].Component(this, U, W), this.isPlaying && Z.play(), this.hasAttribute(S) || (Z.justInitialized = !0, window.HTMLElement.prototype.setAttribute.call(this, S, "")), l("Component initialized: %s", S))));
                }
                /**
                 * Initialize dependencies of a component.
                 *
                 * @param {string} name - Root component name.
                 */
                initComponentDependencies(S) {
                  var U = this, G = w[S], Z, W;
                  if (G && (Z = w[S].dependencies, !!Z))
                    for (W = 0; W < Z.length; W++)
                      U.initComponent(Z[W], window.HTMLElement.prototype.getAttribute.call(U, Z[W]) || void 0, !0);
                }
                removeComponent(S, U) {
                  var G;
                  if (G = this.components[S], !!G) {
                    if (!G.initialized) {
                      this.addEventListener("componentinitialized", function Z(W) {
                        W.detail.name === S && (this.removeComponent(S, U), this.removeEventListener("componentinitialized", Z));
                      });
                      return;
                    }
                    G.pause(), G.remove(), U && (G.destroy(), delete this.components[S], this.hasAttribute(S) && window.HTMLElement.prototype.removeAttribute.call(this, S)), this.emit("componentremoved", G.evtDetail, !1);
                  }
                }
                /**
                 * Initialize or update all components.
                 * Build data using initial components, defined attributes, mixins, and defaults.
                 * Update default components before the rest.
                 *
                 * @member {function} getExtraComponents - Can be implemented to include component data
                 *   from other sources (e.g., implemented by primitives).
                 */
                updateComponents() {
                  var S, U, G, Z, W = this.componentsToUpdate;
                  if (!(!this.hasLoaded && !this.isLoading)) {
                    for (G = 0; G < this.mixinEls.length; G++)
                      for (Z in this.mixinEls[G].componentCache)
                        T(Z) && (W[Z] = !0);
                    if (this.getExtraComponents) {
                      U = this.getExtraComponents();
                      for (Z in U)
                        T(Z) && (W[Z] = !0);
                    }
                    for (G = 0; G < this.attributes.length; ++G)
                      Z = this.attributes[G].name, c.indexOf(Z) === -1 && T(Z) && (W[Z] = !0);
                    for (G = 0; G < c.length; G++)
                      Z = c[G], this.hasAttribute(Z) && this.updateComponent(Z, this.getDOMAttribute(Z));
                    for (Z in W)
                      S = x(this.getDOMAttribute(Z), U && U[Z]), this.updateComponent(Z, S), delete W[Z];
                  }
                }
                /**
                 * Initialize, update, or remove a single component.
                 *
                 * When initializing, we set the component on `this.components`.
                 *
                 * @param {string} attr - Component name.
                 * @param {object} attrValue - Value of the DOM attribute.
                 * @param {boolean} clobber - If new attrValue completely replaces previous properties.
                 */
                updateComponent(S, U, G) {
                  var Z = this.components[S];
                  if (Z) {
                    if (U === null && !u(this, S)) {
                      this.removeComponent(S, !0);
                      return;
                    }
                    Z.updateProperties(U, G);
                    return;
                  }
                  this.initComponent(S, U, !1);
                }
                /**
                 * If `attr` is a component name, detach the component from the entity.
                 *
                 * If `propertyName` is given, reset the component property value to its default.
                 *
                 * @param {string} attr - Attribute name, which could also be a component name.
                 * @param {string} propertyName - Component prop name, if resetting an individual prop.
                 */
                removeAttribute(S, U) {
                  var G = this.components[S];
                  if (G && U === void 0 && this.removeComponent(S, !0), G && U !== void 0) {
                    G.resetProperty(U);
                    return;
                  }
                  S === "mixin" && this.mixinUpdate(""), window.HTMLElement.prototype.removeAttribute.call(this, S);
                }
                /**
                 * Start dynamic behavior associated with entity such as dynamic components and animations.
                 * Tell all children entities to also play.
                 */
                play() {
                  var S, U, G;
                  if (!(this.isPlaying || !this.hasLoaded && !this.isLoading)) {
                    this.isPlaying = !0;
                    for (G in this.components)
                      this.components[G].play();
                    for (S = this.getChildEntities(), U = 0; U < S.length; U++)
                      S[U].play();
                    this.emit("play");
                  }
                }
                /**
                 * Pause dynamic behavior associated with entity such as dynamic components and animations.
                 * Tell all children entities to also pause.
                 */
                pause() {
                  var S, U, G;
                  if (this.isPlaying) {
                    this.isPlaying = !1;
                    for (G in this.components)
                      this.components[G].pause();
                    for (S = this.getChildEntities(), U = 0; U < S.length; U++)
                      S[U].pause();
                    this.emit("pause");
                  }
                }
                /**
                 * Deals with updates on entity-specific attributes (i.e., components and mixins).
                 *
                 * @param {string} attr
                 * @param {string} oldVal
                 * @param {string|object} newVal
                 */
                setEntityAttribute(S, U, G) {
                  if (w[S] || this.components[S]) {
                    this.updateComponent(S, G);
                    return;
                  }
                  if (S === "mixin") {
                    if (G === this.computedMixinStr)
                      return;
                    this.mixinUpdate(G, U);
                  }
                }
                /**
                 * When mixins updated, trigger init or optimized-update of relevant components.
                 */
                mixinUpdate(S, U, G) {
                  var Z = A.componentsUpdated, W, ie, te, X, Q = this;
                  if (G || (U = U || this.getAttribute("mixin")), !this.hasLoaded) {
                    this.addEventListener("loaded-private", function() {
                      Q.mixinUpdate(S, U, !0);
                    }, g);
                    return;
                  }
                  for (te = this.updateMixins(S, U), Z.length = 0, X = 0; X < this.mixinEls.length; X++)
                    for (W in this.mixinEls[X].componentCache)
                      Z.indexOf(W) === -1 && (this.components[W] ? this.components[W].handleMixinUpdate() : this.initComponent(W, null), Z.push(W));
                  for (X = 0; X < te.oldMixinIds.length; X++)
                    if (ie = document.getElementById(te.oldMixinIds[X]), !!ie)
                      for (W in ie.componentCache)
                        Z.indexOf(W) === -1 && this.components[W] && (this.getDOMAttribute(W) ? this.components[W].handleMixinUpdate() : this.removeComponent(W, !0));
                }
                /**
                 * setAttribute can:
                 *
                 * 1. Set a single property of a multi-property component.
                 * 2. Set multiple properties of a multi-property component.
                 * 3. Replace properties of a multi-property component.
                 * 4. Set a value for a single-property component, mixin, or normal HTML attribute.
                 *
                 * @param {string} attrName - Component or attribute name.
                 * @param {*} arg1 - Can be a value, property name, CSS-style property string, or
                 *   object of properties.
                 * @param {*|bool} arg2 - If arg1 is a property name, this should be a value. Otherwise,
                 *   it is a boolean indicating whether to clobber previous values (defaults to false).
                 */
                setAttribute(S, U, G) {
                  var Z = A.singlePropUpdate, W, ie, te, X, Q, O;
                  if (X = S.indexOf(p), te = X > 0 ? S.substring(0, X) : S, !w[te]) {
                    S === "mixin" && this.mixinUpdate(U), super.setAttribute.call(this, S, U);
                    return;
                  }
                  if (!this.components[S] && this.hasAttribute(S) && this.updateComponent(S, window.HTMLElement.prototype.getAttribute.call(this, S)), typeof G < "u" && typeof U == "string" && U.length > 0 && typeof y.styleParser.parse(U) == "string") {
                    for (O in Z)
                      delete Z[O];
                    W = Z, W[U] = G, ie = !1;
                  } else
                    W = U, ie = G === !0;
                  this.updateComponent(S, W, ie), Q = this.sceneEl && this.sceneEl.getAttribute("debug"), Q && this.components[S].flushToDOM();
                }
                /**
                 * Reflect component data in the DOM (as seen from the browser DOM Inspector).
                 *
                 * @param {bool} recursive - Also flushToDOM on the children.
                 **/
                flushToDOM(S) {
                  var U = this.components, G, Z = this.children, W, ie;
                  for (ie in U)
                    U[ie].flushToDOM();
                  if (S)
                    for (W = 0; W < Z.length; ++W)
                      G = Z[W], G.flushToDOM && G.flushToDOM(S);
                }
                /**
                 * If `attr` is a component, returns ALL component data including applied mixins and
                 * defaults.
                 *
                 * If `attr` is not a component, fall back to HTML getAttribute.
                 *
                 * @param {string} attr
                 * @returns {object|string} Object if component, else string.
                 */
                getAttribute(S) {
                  var U;
                  return S === "position" ? this.object3D.position : S === "rotation" ? b(this) : S === "scale" ? this.object3D.scale : S === "visible" ? this.object3D.visible : (U = this.components[S], U ? U.data : window.HTMLElement.prototype.getAttribute.call(this, S));
                }
                /**
                 * If `attr` is a component, returns JUST the component data defined on the entity.
                 * Like a partial version of `getComputedAttribute` as returned component data
                 * does not include applied mixins or defaults.
                 *
                 * If `attr` is not a component, fall back to HTML getAttribute.
                 *
                 * @param {string} attr
                 * @returns {object|string} Object if component, else string.
                 */
                getDOMAttribute(S) {
                  var U = this.components[S];
                  return U ? U.attrValue : window.HTMLElement.prototype.getAttribute.call(this, S);
                }
                addState(S) {
                  this.is(S) || (this.states.push(S), this.emit("stateadded", S));
                }
                removeState(S) {
                  var U = this.states.indexOf(S);
                  U !== -1 && (this.states.splice(U, 1), this.emit("stateremoved", S));
                }
                /**
                 * Checks if the element is in a given state. e.g. el.is('alive');
                 * @type {string} state - Name of the state we want to check
                 */
                is(S) {
                  return this.states.indexOf(S) !== -1;
                }
                /**
                 * Open Inspector to this entity.
                 */
                inspect() {
                  this.sceneEl.components.inspector.openInspector(this);
                }
                /**
                 * Clean up memory and return memory to object pools.
                 */
                destroy() {
                  var S;
                  if (this.parentNode) {
                    d("Entity can only be destroyed if detached from scenegraph.");
                    return;
                  }
                  for (S in this.components)
                    this.components[S].destroy();
                }
              }
              function u(D, S) {
                return D.components[S] && D.components[S].attrValue ? !0 : f(S, D.mixinEls);
              }
              function f(D, S) {
                var U, G = !1;
                for (U = 0; U < S.length && (G = S[U].hasAttribute(D), !G); ++U)
                  ;
                return G;
              }
              function x(D, S) {
                return S ? S.constructor === Object ? y.extend(S, y.styleParser.parse(D || {})) : D || S : D;
              }
              function T(D) {
                return D.indexOf(p) !== -1 && (D = y.split(D, p)[0]), !!w[D];
              }
              function b(D) {
                var S = E.MathUtils.radToDeg, U = D.object3D.rotation, G = D.rotationObj;
                return G.x = S(U.x), G.y = S(U.y), G.z = S(U.z), G;
              }
              A.componentsUpdated = [], A.singlePropUpdate = {}, customElements.define("a-entity", A), j.exports.AEntity = A;
            }
          ),
          /***/
          "./src/core/a-mixin.js": (
            /*!*****************************!*\
              !*** ./src/core/a-mixin.js ***!
              \*****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./a-node */
                "./src/core/a-node.js"
              ).ANode, w = v(
                /*! ./component */
                "./src/core/component.js"
              ).components, E = v(
                /*! ../utils */
                "./src/utils/index.js"
              ), y = E.styleParser, l = "__";
              class d extends C {
                constructor() {
                  super(), this.componentCache = {}, this.rawAttributeCache = {}, this.isMixin = !0;
                }
                doConnectedCallback() {
                  super.doConnectedCallback(), this.sceneEl = this.closestScene(), this.id = this.getAttribute("id"), this.cacheAttributes(), this.updateEntities(), this.load();
                }
                attributeChangedCallback(c, g, A) {
                  super.attributeChangedCallback(), this.cacheAttribute(c, A), this.updateEntities();
                }
                /**
                 * setAttribute that parses and caches component values.
                 */
                setAttribute(c, g) {
                  window.HTMLElement.prototype.setAttribute.call(this, c, g), this.cacheAttribute(c, g);
                }
                /**
                 * If `attr` is a component, then parse the value using the schema and store it.
                 */
                cacheAttribute(c, g) {
                  var A, u;
                  u = E.split(c, l)[0], A = w[u], g === void 0 && (g = window.HTMLElement.prototype.getAttribute.call(this, c)), this.rawAttributeCache[c] = g, A && (this.componentCache[c] = this.parseComponentAttrValue(A, g));
                }
                /**
                 * Given an HTML attribute value parses the string based on the component schema.
                 * To avoid double parsing of strings when mixed into the actual component,
                 * we store the original instead of the parsed one.
                 *
                 * @param {object} component - The component to parse for.
                 * @param {string} attrValue - HTML attribute value.
                 */
                parseComponentAttrValue(c, g) {
                  var A;
                  return typeof g != "string" ? g : (c.isSingleProperty ? (A = c.schema.parse(g), typeof A == "string" && (A = g)) : A = y.parse(g), A);
                }
                /**
                 * If `attr` is a component, then grab pre-parsed value from the cache.
                 * Else do a normal getAttribute.
                 */
                getAttribute(c) {
                  return this.componentCache[c] || window.HTMLElement.prototype.getAttribute.call(this, c);
                }
                /**
                 * Parse and cache every component defined on the mixin.
                 */
                cacheAttributes() {
                  var c = this.attributes, g, A;
                  for (A = 0; A < c.length; A++)
                    g = c[A].name, this.cacheAttribute(g);
                }
                /**
                 * For entities that already have been loaded by the time the mixin was attached, tell
                 * those entities to register the mixin and refresh their component data.
                 */
                updateEntities() {
                  var c, g, A;
                  if (this.sceneEl)
                    for (g = this.sceneEl.querySelectorAll("[mixin~=" + this.id + "]"), A = 0; A < g.length; A++)
                      c = g[A], !(!c.hasLoaded || c.isMixin) && c.mixinUpdate(this.id);
                }
              }
              customElements.define("a-mixin", d);
            }
          ),
          /***/
          "./src/core/a-node.js": (
            /*!****************************!*\
              !*** ./src/core/a-node.js ***!
              \****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), w = v(
                /*! ./readyState */
                "./src/core/readyState.js"
              ), E = C.debug("core:a-node:warn"), y = {
                "a-scene": !0,
                "a-assets": !0,
                "a-assets-items": !0,
                "a-cubemap": !0,
                "a-mixin": !0,
                "a-node": !0,
                "a-entity": !0
              };
              function l(p) {
                return p.tagName.toLowerCase() in y || p.isNode;
              }
              class d extends HTMLElement {
                constructor() {
                  super(), this.computedMixinStr = "", this.hasLoaded = !1, this.isNode = !0, this.mixinEls = [];
                }
                connectedCallback() {
                  if (!w.canInitializeElements) {
                    document.addEventListener("aframeready", this.connectedCallback.bind(this));
                    return;
                  }
                  this.doConnectedCallback();
                }
                doConnectedCallback() {
                  var c;
                  this.sceneEl = this.closestScene(), this.sceneEl || E("You are attempting to attach <" + this.tagName + "> outside of an A-Frame scene. Append this element to `<a-scene>` instead."), this.hasLoaded = !1, this.emit("nodeready", void 0, !1), this.isMixin || (c = this.getAttribute("mixin"), c && this.updateMixins(c));
                }
                /**
                 * Handle mixin.
                 */
                attributeChangedCallback(c, g, A) {
                  A !== this.computedMixinStr && c === "mixin" && !this.isMixin && this.updateMixins(A, g);
                }
                /**
                 * Returns the first scene by traversing up the tree starting from and
                 * including receiver element.
                 */
                closestScene() {
                  for (var c = this; c && !c.isScene; )
                    c = c.parentElement;
                  return c;
                }
                /**
                 * Returns first element matching a selector by traversing up the tree starting
                 * from and including receiver element.
                 *
                 * @param {string} selector - Selector of element to find.
                 */
                closest(c) {
                  for (var g = this.matches || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector, A = this; A && !g.call(A, c); )
                    A = A.parentElement;
                  return A;
                }
                disconnectedCallback() {
                  this.hasLoaded = !1;
                }
                /**
                 * Wait for children to load, if any.
                 * Then emit `loaded` event and set `hasLoaded`.
                 */
                load(c, g) {
                  var A, u, f = this;
                  this.hasLoaded || (g = g || l, A = this.getChildren(), u = A.filter(g).map(function(x) {
                    return new Promise(function(b, D) {
                      if (x.hasLoaded)
                        return b();
                      x.addEventListener("loaded", b), x.addEventListener("error", D);
                    });
                  }), Promise.allSettled(u).then(function(T) {
                    T.forEach(function(D) {
                      D.status === "rejected" && E("Rendering scene with errors on node: ", D.reason.target);
                    }), f.isLoading = !0, f.setupMutationObserver(), c && c(), f.isLoading = !1, f.hasLoaded = !0, f.emit("loaded-private", void 0, !1), f.emit("loaded", void 0, !1);
                  }));
                }
                /**
                 * With custom elements V1 attributeChangedCallback only fires
                 * for attributes defined statically via observedAttributes.
                 * One can assign any arbitrary components to an A-Frame entity
                 * hence we can't know the list of attributes beforehand.
                 * This function setup a mutation observer to keep track of the entity attribute changes
                 * in the DOM and update components accordingly.
                 */
                setupMutationObserver() {
                  var c = this, g = {
                    attributes: !0,
                    attributeOldValue: !0
                  }, A = new MutationObserver(function(f) {
                    var x;
                    for (x = 0; x < f.length; x++)
                      if (f[x].type === "attributes") {
                        var T = f[x].attributeName, b = window.HTMLElement.prototype.getAttribute.call(c, T), D = f[x].oldValue;
                        c.attributeChangedCallback(T, D, b);
                      }
                  });
                  A.observe(this, g);
                }
                getChildren() {
                  return Array.prototype.slice.call(this.children, 0);
                }
                /**
                 * Unregister old mixins and listeners.
                 * Register new mixins and listeners.
                 * Registering means to update `this.mixinEls` with listeners.
                 */
                updateMixins(c, g) {
                  var A = d.newMixinIdArray, u = d.oldMixinIdArray, f = d.mixinIds, x, T, b;
                  for (A.length = 0, u.length = 0, T = c ? C.split(c.trim(), /\s+/) : A, b = g ? C.split(g.trim(), /\s+/) : u, f.newMixinIds = T, f.oldMixinIds = b, x = 0; x < b.length; x++)
                    T.indexOf(b[x]) === -1 && this.unregisterMixin(b[x]);
                  for (this.computedMixinStr = "", this.mixinEls.length = 0, x = 0; x < T.length; x++)
                    this.registerMixin(T[x]);
                  return this.computedMixinStr && (this.computedMixinStr = this.computedMixinStr.trim(), window.HTMLElement.prototype.setAttribute.call(this, "mixin", this.computedMixinStr)), T.length === 0 && window.HTMLElement.prototype.removeAttribute.call(this, "mixin"), f;
                }
                /**
                 * From mixin ID, add mixin element to `mixinEls`.
                 *
                 * @param {string} mixinId - ID of the mixin to register.
                 */
                registerMixin(c) {
                  var g, A, u, f = document.getElementById(c);
                  if (!f) {
                    E("No mixin was found with id `%s`", c);
                    return;
                  }
                  if (u = f.getAttribute("mixin"), u)
                    for (g = C.split(u.trim(), /\s+/), A = 0; A < g.length; A++)
                      this.registerMixin(g[A]);
                  this.computedMixinStr = this.computedMixinStr + " " + f.id, this.mixinEls.push(f);
                }
                setAttribute(c, g) {
                  c === "mixin" && this.updateMixins(g), window.HTMLElement.prototype.setAttribute.call(this, c, g);
                }
                /**
                 * Removes the mixin element from `mixinEls`.
                 *
                 * @param {string} mixinId - ID of the mixin to remove.
                 */
                unregisterMixin(c) {
                  var g, A = this.mixinEls, u;
                  for (g = 0; g < A.length; ++g)
                    if (u = A[g], c === u.id) {
                      A.splice(g, 1);
                      break;
                    }
                }
                /**
                 * Emit a DOM event.
                 *
                 * @param {string} name - Name of event.
                 * @param {object} [detail={}] - Custom data to pass as `detail` to the event.
                 * @param {boolean} [bubbles=true] - Whether the event should bubble.
                 * @param {object} [extraData] - Extra data to pass to the event, if any.
                 */
                emit(c, g, A, u) {
                  var f = d.evtData;
                  A === void 0 && (A = !0), f.bubbles = !!A, f.detail = g, u && (f = C.extend({}, u, f)), this.dispatchEvent(new CustomEvent(c, f));
                }
              }
              d.evtData = {}, d.newMixinIdArray = [], d.oldMixinIdArray = [], d.mixinIds = {}, customElements.define("a-node", d), j.exports.ANode = d, j.exports.knownTags = y;
            }
          ),
          /***/
          "./src/core/component.js": (
            /*!*******************************!*\
              !*** ./src/core/component.js ***!
              \*******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./schema */
                "./src/core/schema.js"
              ), w = v(
                /*! ./scene/scenes */
                "./src/core/scene/scenes.js"
              ), E = v(
                /*! ./system */
                "./src/core/system.js"
              ), y = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), l = j.exports.components = {}, d = C.parseProperty, p = C.process, c = C.isSingleProperty, g = C.stringifyProperties, A = C.stringifyProperty, u = y.styleParser, f = y.debug("core:component:warn"), x = document.currentScript, T = new RegExp("[A-Z]+"), b = {}, D = Object.freeze({}), S = [], U = {
                get: function(O, K) {
                  return O.getComputedPropertyValue(K);
                },
                set: function(O, K, ne) {
                  return K in O.schema ? O.recomputeProperty(K, ne) : ne !== void 0 && O.handleUnknownProperty(K, ne), !0;
                }
              }, G = j.exports.Component = function(O, K, ne) {
                var pe = this;
                if (this.sceneOnly && !O.isScene)
                  throw new Error("Component `" + this.name + "` can only be applied to <a-scene>");
                if (ne && !this.multiple)
                  throw new Error("Trying to initialize multiple components of type `" + this.name + "`. There can only be one component of this type per entity.");
                this.el = O, this.id = ne, this.attrName = this.name + (ne ? "__" + ne : ""), this.evtDetail = {
                  id: this.id,
                  name: this.name
                }, this.initialized = !1, this.el.components[this.attrName] = this, this.objectPool = b[this.name];
                var be = this.events;
                this.events = {}, Z(this, be), this.attrValue = void 0, this.isObjectBased ? (this.data = this.objectPool.use(), y.objectPool.removeUnusedKeys(this.data, this.schema), this.oldData = this.objectPool.use(), y.objectPool.removeUnusedKeys(this.oldData, this.schema), this.attrValueProxy = new Proxy(this, U)) : (this.data = void 0, this.oldData = void 0, this.attrValueProxy = void 0), this.deferUnknownPropertyWarnings = !!this.updateSchema, this.silenceUnknownPropertyWarnings = !1, this.throttledEmitComponentChanged = y.throttleLeadingAndTrailing(function() {
                  O.emit("componentchanged", pe.evtDetail, !1);
                }, 200), this.updateProperties(K, !0);
              };
              G.prototype = {
                /**
                 * Contains the type schema and defaults for the data values.
                 * Data is coerced into the types of the values of the defaults.
                 */
                schema: {},
                /**
                 * Init handler. Similar to attachedCallback.
                 * Called during component initialization and is only run once.
                 * Components can use this to set initial state.
                 */
                init: function() {
                },
                /**
                 * Map of event names to bound event handlers that will be lifecycle-handled.
                 * Will be detached on pause / remove.
                 * Will be attached on play.
                 */
                events: {},
                /**
                 * Update handler. Similar to attributeChangedCallback.
                 * Called whenever component's data changes.
                 * Also called on component initialization when the component receives initial data.
                 *
                 * @param {object} prevData - Previous attributes of the component.
                 */
                update: function(O) {
                },
                /**
                 * Update schema handler. Allows the component to dynamically change its schema.
                 * Called whenever a property marked as schemaChange changes.
                 * Also called on initialization when the component receives initial data.
                 *
                 * @param {object} data - The data causing the schema change
                 */
                updateSchema: void 0,
                /**
                 * Tick handler.
                 * Called on each tick of the scene render loop.
                 * Affected by play and pause.
                 *
                 * @param {number} time - Scene tick time.
                 * @param {number} timeDelta - Difference in current render time and previous render time.
                 */
                tick: void 0,
                /**
                 * Tock handler.
                 * Called on each tock of the scene render loop.
                 * Affected by play and pause.
                 *
                 * @param {number} time - Scene tick time.
                 * @param {number} timeDelta - Difference in current render time and previous render time.
                 * @param {object} camera - Camera used to render the last frame.
                 */
                tock: void 0,
                /**
                 * Called to start any dynamic behavior (e.g., animation, AI, events, physics).
                 */
                play: function() {
                },
                /**
                 * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).
                 */
                pause: function() {
                },
                /**
                 * Remove handler. Similar to detachedCallback.
                 * Called whenever component is removed from the entity (i.e., removeAttribute).
                 * Components can use this to reset behavior on the entity.
                 */
                remove: function() {
                },
                /**
                 * Stringify properties if necessary.
                 *
                 * Only called from `Entity.setAttribute` for properties whose parsers accept a non-string
                 * value (e.g., selector, vec3 property types).
                 *
                 * @param {object} data - Complete component data.
                 * @returns {string}
                 */
                stringify: function(O) {
                  var K = this.schema;
                  return typeof O == "string" ? O : this.isSingleProperty ? A(O, K) : (O = g(O, K), u.stringify(O));
                },
                /**
                 * Write cached attribute data to the entity DOM element.
                 *
                 * @param {boolean} isDefault - Whether component is a default component. Always flush for
                 *   default components.
                 */
                flushToDOM: function(O) {
                  var K = O ? this.data : this.attrValue;
                  K != null && window.HTMLElement.prototype.setAttribute.call(this.el, this.attrName, this.stringify(K));
                },
                /**
                 * Apply new component data if data has changed (from setAttribute).
                 *
                 * @param {string} attrValue - HTML attribute value.
                 *        If undefined, use the cached attribute value and continue updating properties.
                 * @param {boolean} clobber - The previous component data is overwritten by the attrValue.
                 */
                updateProperties: function(O, K) {
                  var ne = this.el;
                  this.updateData(O, K), !(!ne.hasLoaded && !ne.isLoading) && (this.initialized ? this.callUpdateHandler() : this.initComponent());
                },
                initComponent: function() {
                  var O = this.el, K;
                  O.initializingComponents[this.name] || (O.initializingComponents[this.name] = !0, this.init(), this.initialized = !0, delete O.initializingComponents[this.name], K = this.isObjectBased ? D : void 0, this.dataChanged = !1, this.storeOldData(), this.update(K), O.isPlaying && this.play(), O.emit("componentinitialized", this.evtDetail, !1));
                },
                /**
                 * @param {string|object} attrValue - Passed argument from setAttribute.
                 * @param {bool} clobber - Whether or not to overwrite previous data by the attrValue.
                 */
                updateData: function(O, K) {
                  if (this.isSingleProperty) {
                    this.recomputeProperty(void 0, O);
                    return;
                  }
                  K ? (y.objectPool.clearObject(this.attrValue), this.recomputeData(O), this.schemaChangeRequired = !!this.updateSchema) : typeof O == "string" ? u.parse(O, this.attrValueProxy) : y.extend(this.attrValueProxy, O), this.updateSchemaIfNeeded(O);
                },
                updateSchemaIfNeeded: function(O) {
                  if (!this.schemaChangeRequired || !this.updateSchema) {
                    for (var K = 0; K < S.length; K++)
                      f("Unknown property `" + S[K] + "` for component `" + this.name + "`.");
                    S.length = 0;
                    return;
                  }
                  S.length = 0, this.updateSchema(this.data), y.objectPool.removeUnusedKeys(this.data, this.schema), this.silenceUnknownPropertyWarnings = !0, this.recomputeData(O), this.silenceUnknownPropertyWarnings = !1, this.schemaChangeRequired = !1;
                },
                /**
                 * Check if component should fire update and fire update lifecycle handler.
                 */
                callUpdateHandler: function() {
                  if (!(!this.isPositionRotationScale && !this.dataChanged)) {
                    this.dataChanged = !1;
                    var O = this.oldData;
                    this.oldDataInUse = !0, this.update(O), O !== this.oldData && this.objectPool.recycle(O), this.oldDataInUse = !1, this.storeOldData(), this.throttledEmitComponentChanged();
                  }
                },
                handleMixinUpdate: function() {
                  this.recomputeData(), this.updateSchemaIfNeeded(), this.callUpdateHandler();
                },
                /**
                 * Reset value of a property to the property's default value.
                 * If single-prop component, reset value to component's default value.
                 *
                 * @param {string} propertyName - Name of property to reset.
                 */
                resetProperty: function(O) {
                  !this.isSingleProperty && !(O in this.schema) || (O ? this.attrValue[O] = void 0 : (this.isObjectBased && this.objectPool.recycle(this.attrValue), this.attrValue = void 0), this.recomputeProperty(O, void 0), this.updateSchemaIfNeeded(), this.callUpdateHandler());
                },
                /**
                 * Extend schema of component given a partial schema.
                 *
                 * Some components might want to mutate their schema based on certain properties.
                 * e.g., Material component changes its schema based on `shader` to account for different
                 * uniforms.
                 *
                 * @param {object} schemaAddon - Schema chunk that extend base schema.
                 */
                extendSchema: function(O) {
                  var K;
                  K = y.extend({}, l[this.name].schema), y.extend(K, O), this.schema = p(K), this.el.emit("schemachanged", this.evtDetail);
                },
                getComputedPropertyValue: function(O) {
                  var K = this.el.mixinEls, ne = this.attrValue && O ? this.attrValue[O] : this.attrValue;
                  if (ne !== void 0)
                    return ne;
                  for (var pe = K.length - 1; pe >= 0; pe--) {
                    var be = K[pe].getAttribute(this.attrName);
                    if (!(be === null || O && !(O in be)))
                      return O ? be[O] : be;
                  }
                  var Te = O ? this.schema[O].default : this.schema.default;
                  return Te;
                },
                recomputeProperty: function(O, K) {
                  var ne = O ? this.schema[O] : this.schema;
                  if (K != null) {
                    this.attrValue === void 0 && this.isObjectBased && (this.attrValue = this.objectPool.use());
                    var pe = O ? this.attrValue[O] : this.attrValue;
                    pe = ne.isCacheable ? d(K, ne, pe) : K, typeof pe == "string" && (pe = K === "" ? void 0 : K), O ? this.attrValue[O] = pe : this.attrValue = pe;
                  }
                  this.oldDataInUse && (this.oldData = this.objectPool.use(), y.objectPool.removeUnusedKeys(this.oldData, this.schema), this.storeOldData(), this.oldDataInUse = !1);
                  var be = O ? this.oldData[O] : this.oldData, Te = O ? this.data[O] : this.data, ke = d(this.getComputedPropertyValue(O), ne, Te);
                  return ne.type === "array" && !O && (ke = y.clone(ke)), ne.equals(ke, be) || (this.dataChanged = !0, ne.schemaChange && (this.schemaChangeRequired = !0)), O ? this.data[O] = ke : this.data = ke, ke;
                },
                handleUnknownProperty: function(O, K) {
                  this.attrValue === void 0 && (this.attrValue = this.objectPool.use()), this.attrValue[O] = K, this.silenceUnknownPropertyWarnings || (this.deferUnknownPropertyWarnings ? S.push(O) : this.silenceUnknownPropertyWarnings || f("Unknown property `" + O + "` for component `" + this.name + "`."));
                },
                /**
                 * Updates oldData to the current state of data taking care to
                 * copy and clone objects where necessary.
                 */
                storeOldData: function() {
                  if (!this.isObjectBased) {
                    this.oldData = this.data;
                    return;
                  }
                  if (this.isSingleProperty) {
                    this.oldData = d(this.data, this.schema, this.oldData);
                    return;
                  }
                  var O;
                  for (O in this.schema)
                    this.data[O] !== void 0 && (this.data[O] && typeof this.data[O] == "object" ? this.oldData[O] = d(this.data[O], this.schema[O], this.oldData[O]) : this.oldData[O] = this.data[O]);
                },
                /**
                 * Triggers a recompute of the data object.
                 *
                 * @param {string|object} attrValue - Optional additional data updates
                 */
                recomputeData: function(O) {
                  var K;
                  if (this.isSingleProperty) {
                    this.recomputeProperty(void 0, O);
                    return;
                  }
                  if (O && typeof O == "object")
                    for (K in this.schema)
                      this.attrValueProxy[K] = O[K];
                  else
                    for (K in this.schema)
                      this.attrValueProxy[K] = void 0;
                  typeof O == "string" && u.parse(O, this.attrValueProxy);
                  for (K in this.attrValue)
                    this.attrValue[K] !== void 0 && S.indexOf(K) !== -1 && (K in this.schema || f("Unknown property `" + K + "` for component `" + this.name + "`."));
                },
                /**
                 * Attach events from component-defined events map.
                 */
                eventsAttach: function() {
                  var O;
                  this.eventsDetach();
                  for (O in this.events)
                    this.el.addEventListener(O, this.events[O]);
                },
                /**
                 * Detach events from component-defined events map.
                 */
                eventsDetach: function() {
                  var O;
                  for (O in this.events)
                    this.el.removeEventListener(O, this.events[O]);
                },
                /**
                 * Release and free memory.
                 */
                destroy: function() {
                  this.objectPool.recycle(this.attrValue), this.objectPool.recycle(this.data), this.objectPool.recycle(this.oldData), this.attrValue = this.data = this.oldData = this.attrValueProxy = void 0;
                }
              };
              function Z(O, K) {
                var ne;
                for (ne in K)
                  O.events[ne] = K[ne].bind(O);
              }
              if (window.debug)
                var W = j.exports.registrationOrderWarnings = {};
              j.exports.registerComponent = function(O, K) {
                var ne, pe = {}, be, Te;
                if (document.currentScript && document.currentScript !== x && w.forEach(function(st) {
                  st.hasLoaded || document.currentScript.compareDocumentPosition(st) !== Node.DOCUMENT_POSITION_FOLLOWING && (f("The component `" + O + "` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."), window.debug && (W[O] = !0));
                }), T.test(O) === !0 && f("The component name `" + O + "` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `" + O.toLowerCase() + "`"), O.indexOf("__") !== -1)
                  throw new Error("The component name `" + O + "` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");
                if (Object.keys(K).forEach(function(Ve) {
                  pe[Ve] = {
                    value: K[Ve],
                    writable: !0
                  };
                }), l[O])
                  throw new Error("The component `" + O + "` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");
                ne = function(Ve, st, ut) {
                  G.call(this, Ve, st, ut);
                }, ne.prototype = Object.create(G.prototype, pe), ne.prototype.name = O, ne.prototype.isPositionRotationScale = O === "position" || O === "rotation" || O === "scale", ne.prototype.constructor = ne, ne.prototype.system = E && E.systems[O], ne.prototype.play = X(ne.prototype.play), ne.prototype.pause = te(ne.prototype.pause), be = y.extend(p(ne.prototype.schema, ne.prototype.name)), ne.prototype.isSingleProperty = Te = c(ne.prototype.schema), ne.prototype.isObjectBased = !Te || Te && (Q(be.default) || Q(d(void 0, be))), b[O] = y.objectPool.createPool(), l[O] = {
                  Component: ne,
                  dependencies: ne.prototype.dependencies,
                  before: ne.prototype.before,
                  after: ne.prototype.after,
                  isSingleProperty: ne.prototype.isSingleProperty,
                  isObjectBased: ne.prototype.isObjectBased,
                  multiple: ne.prototype.multiple,
                  sceneOnly: ne.prototype.sceneOnly,
                  name: O,
                  schema: be,
                  stringify: ne.prototype.stringify
                };
                for (var ke = 0; ke < w.length; ke++)
                  w[ke].emit("componentregistered", {
                    name: O
                  }, !1);
                return ne;
              };
              function ie(O) {
                return O.tick || O.tock;
              }
              function te(O) {
                return function() {
                  var ne = this.el.sceneEl;
                  this.isPlaying && (O.call(this), this.isPlaying = !1, this.eventsDetach(), ie(this) && ne.removeBehavior(this));
                };
              }
              function X(O) {
                return function() {
                  var ne = this.el.sceneEl, pe = this.el.isPlaying && !this.isPlaying;
                  !this.initialized || !pe || (O.call(this), this.isPlaying = !0, this.eventsAttach(), ie(this) && ne.addBehavior(this));
                };
              }
              function Q(O) {
                return O && O.constructor === Object && !(O instanceof window.HTMLElement);
              }
            }
          ),
          /***/
          "./src/core/geometry.js": (
            /*!******************************!*\
              !*** ./src/core/geometry.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./schema */
                "./src/core/schema.js"
              ), w = C.process, E = j.exports.geometries = {}, y = j.exports.geometryNames = [], l = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), d = j.exports.Geometry = function() {
              };
              d.prototype = {
                /**
                 * Contains the type schema and defaults for the data values.
                 * Data is coerced into the types of the values of the defaults.
                 */
                schema: {},
                /**
                 * Init handler. Similar to attachedCallback.
                 * Called during shader initialization and is only run once.
                 */
                init: function(p) {
                  return this.geometry = new l.BufferGeometry(), this.geometry;
                },
                /**
                 * Update handler. Similar to attributeChangedCallback.
                 * Called whenever the associated geometry data changes.
                 *
                 * @param {object} data - New geometry data.
                 */
                update: function(p) {
                }
              }, j.exports.registerGeometry = function(p, c) {
                var g, A = {};
                if (Object.keys(c).forEach(function(f) {
                  A[f] = {
                    value: c[f],
                    writable: !0
                  };
                }), E[p])
                  throw new Error("The geometry `" + p + "` has been already registered");
                return g = function() {
                  d.call(this);
                }, g.prototype = Object.create(d.prototype, A), g.prototype.name = p, g.prototype.constructor = g, E[p] = {
                  Geometry: g,
                  schema: w(g.prototype.schema)
                }, y.push(p), g;
              };
            }
          ),
          /***/
          "./src/core/propertyTypes.js": (
            /*!***********************************!*\
              !*** ./src/core/propertyTypes.js ***!
              \***********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils/coordinates */
                "./src/utils/coordinates.js"
              ), w = v(
                /*! debug */
                "./node_modules/debug/src/browser.js"
              ), E = w("core:propertyTypes:warn"), y = j.exports.propertyTypes = {}, l = /[,> .[\]:]/, d = /url\((.+)\)/;
              p("audio", "", u), p("array", [], c, g, A), p("asset", "", u), p("boolean", !1, b), p("color", "#FFF"), p("int", 0, D), p("number", 0, S), p("map", "", u), p("model", "", u), p("selector", null, U, Z, T, !1), p("selectorAll", null, G, W, A, !1), p("src", "", ie), p("string", ""), p("time", 0, D), p("vec2", {
                x: 0,
                y: 0
              }, te, C.stringify, C.equals), p("vec3", {
                x: 0,
                y: 0,
                z: 0
              }, te, C.stringify, C.equals), p("vec4", {
                x: 0,
                y: 0,
                z: 0,
                w: 1
              }, te, C.stringify, C.equals);
              function p(O, K, ne, pe, be, Te) {
                if (O in y)
                  throw new Error("Property type " + O + " is already registered.");
                y[O] = {
                  default: K,
                  parse: ne || f,
                  stringify: pe || x,
                  equals: be || T,
                  isCacheable: Te !== !1
                };
              }
              j.exports.registerPropertyType = p;
              function c(O) {
                if (Array.isArray(O))
                  return O;
                if (!O || typeof O != "string")
                  return [];
                return O.split(",").map(K);
                function K(ne) {
                  return ne.trim();
                }
              }
              function g(O) {
                return O.join(", ");
              }
              function A(O, K) {
                if (!Array.isArray(O) || !Array.isArray(K))
                  return O === K;
                if (O.length !== K.length)
                  return !1;
                for (var ne = 0; ne < O.length; ne++)
                  if (O[ne] !== K[ne])
                    return !1;
                return !0;
              }
              function u(O) {
                var K, ne;
                if (typeof O != "string")
                  return O;
                if (ne = O.match(d), ne)
                  return ne[1];
                if (O.charAt(0) === "#") {
                  if (K = document.getElementById(O.substring(1)), K)
                    return K.tagName === "CANVAS" || K.tagName === "VIDEO" || K.tagName === "IMG" ? K : K.getAttribute("src");
                  E('"' + O + '" asset not found.');
                  return;
                }
                return O;
              }
              function f(O) {
                return O;
              }
              function x(O) {
                return O === null ? "null" : O.toString();
              }
              function T(O, K) {
                return O === K;
              }
              function b(O) {
                return O !== "false" && O !== !1;
              }
              function D(O) {
                return parseInt(O, 10);
              }
              function S(O) {
                return parseFloat(O, 10);
              }
              function U(O) {
                return O ? typeof O != "string" ? O : O[0] === "#" && !l.test(O) ? document.getElementById(O.substring(1)) : document.querySelector(O) : null;
              }
              function G(O) {
                return O ? typeof O != "string" ? O : Array.prototype.slice.call(document.querySelectorAll(O), 0) : null;
              }
              function Z(O) {
                return O.getAttribute ? "#" + O.getAttribute("id") : x(O);
              }
              function W(O) {
                return O instanceof Array ? O.map(function(K) {
                  return "#" + K.getAttribute("id");
                }).join(", ") : x(O);
              }
              function ie(O) {
                return E("`src` property type is deprecated. Use `asset` instead."), u(O);
              }
              function te(O, K, ne) {
                return C.parse(O, K, ne);
              }
              function X(O, K) {
                return O === "audio" && typeof K != "string" || O === "array" && !Array.isArray(K) || O === "asset" && typeof K != "string" || O === "boolean" && typeof K != "boolean" || O === "color" && typeof K != "string" || O === "int" && typeof K != "number" || O === "number" && typeof K != "number" || O === "map" && typeof K != "string" || O === "model" && typeof K != "string" || O === "selector" && typeof K != "string" && K !== null || O === "selectorAll" && typeof K != "string" && K !== null || O === "src" && typeof K != "string" || O === "string" && typeof K != "string" || O === "time" && typeof K != "number" ? !1 : O === "vec2" ? Q(K, 2) : O === "vec3" ? Q(K, 3) : O === "vec4" ? Q(K, 4) : !0;
              }
              j.exports.isValidDefaultValue = X;
              function Q(O, K) {
                if (O === null)
                  return !0;
                if (typeof O != "object" || Object.keys(O).length !== K)
                  return !1;
                var ne = O.x, pe = O.y, be = O.z, Te = O.w;
                return !(typeof ne != "number" || typeof pe != "number" || K > 2 && typeof be != "number" || K > 3 && typeof Te != "number");
              }
              j.exports.isValidDefaultCoordinate = Q;
            }
          ),
          /***/
          "./src/core/readyState.js": (
            /*!********************************!*\
              !*** ./src/core/readyState.js ***!
              \********************************/
            /***/
            (j) => {
              j.exports.canInitializeElements = !1;
              function re() {
                if (document.readyState === "complete") {
                  v();
                  return;
                }
                document.addEventListener("readystatechange", function C() {
                  document.readyState === "complete" && (document.removeEventListener("readystatechange", C), v());
                });
              }
              j.exports.waitForDocumentReadyState = re;
              function v() {
                j.exports.canInitializeElements || (j.exports.canInitializeElements = !0, setTimeout(function() {
                  document.dispatchEvent(new CustomEvent("aframeready"));
                }));
              }
              j.exports.emitReady = v;
            }
          ),
          /***/
          "./src/core/scene/a-scene.js": (
            /*!***********************************!*\
              !*** ./src/core/scene/a-scene.js ***!
              \***********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./metaTags */
                "./src/core/scene/metaTags.js"
              ).inject, w = v(
                /*! ./wakelock */
                "./src/core/scene/wakelock.js"
              ), E = v(
                /*! ./loadingScreen */
                "./src/core/scene/loadingScreen.js"
              ), y = v(
                /*! ./scenes */
                "./src/core/scene/scenes.js"
              ), l = v(
                /*! ../system */
                "./src/core/system.js"
              ).systems, d = v(
                /*! ../component */
                "./src/core/component.js"
              ).components, p = v(
                /*! ../../lib/three */
                "./src/lib/three.js"
              ), c = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              ), g = c.debug("core:a-scene:warn"), A = v(
                /*! ../a-entity */
                "./src/core/a-entity.js"
              ).AEntity, u = v(
                /*! ../a-node */
                "./src/core/a-node.js"
              ).ANode, f = v(
                /*! ./postMessage */
                "./src/core/scene/postMessage.js"
              ), x = c.device.isIOS(), T = c.device.isMobile(), b = c.device.isWebXRAvailable;
              x && v(
                /*! ../../utils/ios-orientationchange-blank-bug */
                "./src/utils/ios-orientationchange-blank-bug.js"
              );
              class D extends A {
                constructor() {
                  var Q;
                  super(), Q = this, Q.clock = new p.Clock(), Q.isIOS = x, Q.isMobile = T, Q.hasWebXR = b, Q.isAR = !1, Q.isScene = !0, Q.object3D = new p.Scene(), Q.object3D.onAfterRender = function(O, K, ne) {
                    Q.isPlaying && Q.tock(Q.time, Q.delta, ne);
                  }, Q.resize = Q.resize.bind(Q), Q.render = Q.render.bind(Q), Q.systems = {}, Q.systemNames = [], Q.time = Q.delta = 0, Q.usedOfferSession = !1, Q.componentOrder = [], Q.behaviors = {}, Q.hasLoaded = !1, Q.isPlaying = !1, Q.originalHTML = Q.innerHTML;
                }
                addFullScreenStyles() {
                  document.documentElement.classList.add("a-fullscreen");
                }
                removeFullScreenStyles() {
                  document.documentElement.classList.remove("a-fullscreen");
                }
                doConnectedCallback() {
                  var Q = this, O = this.hasAttribute("embedded");
                  this.setAttribute("inspector", ""), this.setAttribute("keyboard-shortcuts", ""), this.setAttribute("screenshot", ""), this.setAttribute("xr-mode-ui", ""), this.setAttribute("device-orientation-permission-ui", ""), super.doConnectedCallback(), te(this), this.setupRenderer(), E.setup(this, G), this.resize(), O || this.addFullScreenStyles(), f(this), C(this), w(this), this.onVRPresentChangeBound = this.onVRPresentChange.bind(this), window.addEventListener("vrdisplaypresentchange", this.onVRPresentChangeBound), this.enterVRBound = function() {
                    Q.enterVR();
                  }, this.exitVRBound = function() {
                    Q.exitVR();
                  }, this.exitVRTrueBound = function() {
                    Q.exitVR(!0);
                  }, this.pointerRestrictedBound = function() {
                    Q.pointerRestricted();
                  }, this.pointerUnrestrictedBound = function() {
                    Q.pointerUnrestricted();
                  }, Q.hasWebXR || (window.addEventListener("vrdisplaydeactivate", this.exitVRBound), window.addEventListener("vrdisplaydisconnect", this.exitVRTrueBound), window.addEventListener("vrdisplaypointerrestricted", this.pointerRestrictedBound), window.addEventListener("vrdisplaypointerunrestricted", this.pointerUnrestrictedBound)), window.addEventListener("sessionend", this.resize), this.addEventListener("cameraready", function() {
                    Q.attachedCallbackPostCamera();
                  }), this.initSystems(), this.componentOrder = S(d, this.componentOrder), this.addEventListener("componentregistered", function() {
                    Q.componentOrder = S(d, Q.componentOrder);
                  }), this.hasWebXR && navigator.xr && navigator.xr.addEventListener && navigator.xr.addEventListener("sessiongranted", function() {
                    Q.enterVR();
                  });
                }
                attachedCallbackPostCamera() {
                  var Q, O = this;
                  window.addEventListener("load", Q), window.addEventListener("resize", function() {
                    O.isIOS ? setTimeout(O.resize, 100) : O.resize();
                  }), this.play(), y.push(this);
                }
                /**
                 * Initialize all systems.
                 */
                initSystems() {
                  var Q;
                  this.initSystem("camera");
                  for (Q in l)
                    Q !== "camera" && this.initSystem(Q);
                }
                /**
                 * Initialize a system.
                 */
                initSystem(Q) {
                  this.systems[Q] || (this.systems[Q] = new l[Q](this), this.systemNames.push(Q));
                }
                /**
                 * Shut down scene on detach.
                 */
                disconnectedCallback() {
                  var Q = y.indexOf(this);
                  super.disconnectedCallback(), y.splice(Q, 1), window.removeEventListener("vrdisplaypresentchange", this.onVRPresentChangeBound), window.removeEventListener("vrdisplayactivate", this.enterVRBound), window.removeEventListener("vrdisplaydeactivate", this.exitVRBound), window.removeEventListener("vrdisplayconnect", this.enterVRBound), window.removeEventListener("vrdisplaydisconnect", this.exitVRTrueBound), window.removeEventListener("vrdisplaypointerrestricted", this.pointerRestrictedBound), window.removeEventListener("vrdisplaypointerunrestricted", this.pointerUnrestrictedBound), window.removeEventListener("sessionend", this.resize), this.renderer.dispose();
                }
                /**
                 * Add ticks and tocks.
                 *
                 * @param {object} behavior - A component.
                 */
                addBehavior(Q) {
                  var O, K = this.behaviors[Q.name], ne;
                  K || (K = this.behaviors[Q.name] = {
                    tick: {
                      inUse: !1,
                      array: [],
                      markedForRemoval: []
                    },
                    tock: {
                      inUse: !1,
                      array: [],
                      markedForRemoval: []
                    }
                  });
                  for (ne in K)
                    if (Q[ne]) {
                      if (O = K[ne], O.inUse) {
                        var pe = O.markedForRemoval.indexOf(Q);
                        pe !== -1 && O.markedForRemoval.splice(pe, 1);
                      }
                      O.array.indexOf(Q) === -1 && O.array.push(Q);
                    }
                }
                /**
                 * For tests.
                 */
                getPointerLockElement() {
                  return document.pointerLockElement;
                }
                /**
                 * For tests.
                 */
                checkHeadsetConnected() {
                  return c.device.checkHeadsetConnected();
                }
                enterAR() {
                  var Q;
                  if (!this.hasWebXR)
                    throw Q = "Failed to enter AR mode, WebXR not supported.", new Error(Q);
                  if (!c.device.checkARSupport())
                    throw Q = "Failed to enter AR, WebXR immersive-ar mode not supported in your browser or device.", new Error(Q);
                  return this.enterVR(!0);
                }
                /**
                 * Call `requestPresent` if WebVR or WebVR polyfill.
                 * Call `requestFullscreen` on desktop.
                 * Handle events, states, fullscreen styles.
                 *
                 * @param {bool?} useAR - if true, try immersive-ar mode
                 * @returns {Promise}
                 */
                enterVR(Q, O) {
                  var K = this, ne, pe = K.renderer.xr, be;
                  if (O && (!navigator.xr || !navigator.xr.offerSession))
                    return Promise.resolve("OfferSession is not supported.");
                  if (K.usedOfferSession && O)
                    return Promise.resolve("OfferSession was already called.");
                  if (this.is("vr-mode"))
                    return Promise.resolve("Already in VR.");
                  if (this.checkHeadsetConnected() || this.isMobile) {
                    var Te = K.getAttribute("renderer");
                    if (pe.enabled = !0, this.hasWebXR) {
                      this.xrSession && this.xrSession.removeEventListener("end", this.exitVRBound);
                      var ke = this.sceneEl.systems.webxr.sessionReferenceSpaceType;
                      pe.setReferenceSpaceType(ke);
                      var Ve = Q ? "immersive-ar" : "immersive-vr";
                      return be = this.sceneEl.systems.webxr.sessionConfiguration, new Promise(function(ht, Rt) {
                        var Qt = O ? navigator.xr.offerSession.bind(navigator.xr) : navigator.xr.requestSession.bind(navigator.xr);
                        K.usedOfferSession |= O, Qt(Ve, be).then(function(Cn) {
                          O && (K.usedOfferSession = !1), pe.layersEnabled = be.requiredFeatures.indexOf("layers") !== -1, pe.setSession(Cn).then(function() {
                            pe.setFoveation(Te.foveationLevel), K.xrSession = Cn, K.systems.renderer.setWebXRFrameRate(Cn), Cn.addEventListener("end", K.exitVRBound), ut(ht);
                          });
                        }, function(Cn) {
                          var Tn = Ve === "immersive-ar", wn = Tn ? "AR" : "VR";
                          Rt(new Error("Failed to enter " + wn + " mode (`requestSession`)", {
                            cause: Cn
                          }));
                        });
                      });
                    } else {
                      if (ne = c.device.getVRDisplay(), pe.setDevice(ne), ne.isPresenting && !window.hasNativeWebVRImplementation)
                        return ut(), Promise.resolve();
                      var st = {
                        highRefreshRate: Te.highRefreshRate
                      };
                      return ne.requestPresent([{
                        source: this.canvas,
                        attributes: st
                      }]).then(ut, It);
                    }
                  }
                  return ut(), Promise.resolve();
                  function ut(ht) {
                    var Rt;
                    window.hasNativeWebVRImplementation && !window.hasNativeWebXRImplementation && (Rt = new CustomEvent("vrdisplaypresentchange", {
                      detail: {
                        display: c.device.getVRDisplay()
                      }
                    }), window.dispatchEvent(Rt)), Q ? K.addState("ar-mode") : K.addState("vr-mode"), K.emit("enter-vr", {
                      target: K
                    }), !K.hasWebXR && K.isMobile && screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape"), K.addFullScreenStyles(), !K.isMobile && !K.checkHeadsetConnected() && W(K.canvas), K.resize(), ht && ht();
                  }
                  function It(ht) {
                    throw K.removeState("vr-mode"), ht && ht.message ? new Error("Failed to enter VR mode (`requestPresent`): " + ht.message) : new Error("Failed to enter VR mode (`requestPresent`).");
                  }
                }
                /**
                * Call `exitPresent` if WebVR / WebXR or WebVR polyfill.
                * Handle events, states, fullscreen styles.
                *
                * @returns {Promise}
                */
                exitVR() {
                  var Q = this, O, K = this.renderer.xr;
                  if (!this.is("vr-mode") && !this.is("ar-mode"))
                    return Promise.resolve("Not in immersive mode.");
                  if (this.checkHeadsetConnected() || this.isMobile) {
                    if (K.enabled = !1, O = c.device.getVRDisplay(), this.hasWebXR)
                      this.xrSession.removeEventListener("end", this.exitVRBound), this.xrSession.end().then(function() {
                      }, function() {
                      }), this.xrSession = void 0;
                    else if (O.isPresenting)
                      return O.exitPresent().then(ne, pe);
                  } else
                    ie();
                  return ne(), Promise.resolve();
                  function ne() {
                    Q.removeState("vr-mode"), Q.removeState("ar-mode"), Q.isMobile && screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), Q.hasAttribute("embedded") && Q.removeFullScreenStyles(), Q.resize(), Q.isIOS && c.forceCanvasResizeSafariMobile(Q.canvas), Q.renderer.setPixelRatio(window.devicePixelRatio), Q.emit("exit-vr", {
                      target: Q
                    });
                  }
                  function pe(be) {
                    throw be && be.message ? new Error("Failed to exit VR mode (`exitPresent`): " + be.message) : new Error("Failed to exit VR mode (`exitPresent`).");
                  }
                }
                pointerRestricted() {
                  if (this.canvas) {
                    var Q = this.getPointerLockElement();
                    Q && Q !== this.canvas && document.exitPointerLock && document.exitPointerLock(), this.canvas.requestPointerLock && this.canvas.requestPointerLock();
                  }
                }
                pointerUnrestricted() {
                  var Q = this.getPointerLockElement();
                  Q && Q === this.canvas && document.exitPointerLock && document.exitPointerLock();
                }
                /**
                 * Handle `vrdisplaypresentchange` event for exiting VR through other means than
                 * `<ESC>` key. For example, GearVR back button on Oculus Browser.
                 */
                onVRPresentChange(Q) {
                  var O = Q.display || Q.detail.display;
                  if (O && O.isPresenting) {
                    this.enterVR();
                    return;
                  }
                  this.exitVR();
                }
                /**
                 * Wraps Entity.getAttribute to take into account for systems.
                 * If system exists, then return system data rather than possible component data.
                 */
                getAttribute(Q) {
                  var O = this.systems[Q];
                  return O ? O.data : A.prototype.getAttribute.call(this, Q);
                }
                /**
                 * Wraps Entity.getDOMAttribute to take into account for systems.
                 * If system exists, then return system data rather than possible component data.
                 */
                getDOMAttribute(Q) {
                  var O = this.systems[Q];
                  return O ? O.data : A.prototype.getDOMAttribute.call(this, Q);
                }
                /**
                 * Wrap Entity.setAttribute to take into account for systems.
                 * If system exists, then skip component initialization checks and do a normal
                 * setAttribute.
                 */
                setAttribute(Q, O, K) {
                  if (l[Q]) {
                    u.prototype.setAttribute.call(this, Q, O);
                    var ne = this.systems[Q];
                    ne && ne.updateProperties(O);
                    return;
                  }
                  A.prototype.setAttribute.call(this, Q, O, K);
                }
                /**
                 * @param {object} behavior - A component.
                 */
                removeBehavior(Q) {
                  var O, K, ne = this.behaviors[Q.name], pe;
                  for (K in ne)
                    Q[K] && (O = ne[K], pe = O.array.indexOf(Q), pe !== -1 && (O.inUse ? O.markedForRemoval.indexOf(Q) === -1 && O.markedForRemoval.push(Q) : (O.array[pe] = O.array[O.array.length - 1], O.array.pop())));
                }
                resize() {
                  var Q = this.camera, O = this.canvas, K, ne, pe, be = this.renderer.xr.isPresenting;
                  ne = this.renderer.xr.enabled && be, !(!Q || !O || this.is("vr-mode") && (this.isMobile || ne)) && (K = this.getAttribute("embedded") && !this.is("vr-mode"), pe = G(O, K, this.maxCanvasSize, this.is("vr-mode")), Q.aspect = pe.width / pe.height, Q.updateProjectionMatrix(), this.renderer.setSize(pe.width, pe.height, !1), this.emit("rendererresize", null, !1));
                }
                setupRenderer() {
                  var Q = this, O, K, ne, pe;
                  pe = {
                    alpha: !0,
                    antialias: !T,
                    canvas: this.canvas,
                    logarithmicDepthBuffer: !1,
                    powerPreference: "high-performance"
                  }, this.maxCanvasSize = {
                    height: -1,
                    width: -1
                  }, this.hasAttribute("renderer") && (ne = this.getAttribute("renderer"), K = c.styleParser.parse(ne), K.precision && (pe.precision = K.precision + "p"), K.antialias && K.antialias !== "auto" && (pe.antialias = K.antialias === "true"), K.logarithmicDepthBuffer && K.logarithmicDepthBuffer !== "auto" && (pe.logarithmicDepthBuffer = K.logarithmicDepthBuffer === "true"), K.alpha && (pe.alpha = K.alpha === "true"), K.stencil && (pe.stencil = K.stencil === "true"), K.multiviewStereo && (pe.multiviewStereo = K.multiviewStereo === "true"), this.maxCanvasSize = {
                    width: K.maxCanvasWidth ? parseInt(K.maxCanvasWidth) : this.maxCanvasSize.width,
                    height: K.maxCanvasHeight ? parseInt(K.maxCanvasHeight) : this.maxCanvasSize.height
                  }), O = this.renderer = new p.WebGLRenderer(pe), O.setPixelRatio(window.devicePixelRatio), this.camera && O.xr.setPoseTarget(this.camera.el.object3D), this.addEventListener("camera-set-active", function() {
                    O.xr.setPoseTarget(Q.camera.el.object3D);
                  });
                }
                /**
                 * Handler attached to elements to help scene know when to kick off.
                 * Scene waits for all entities to load.
                 */
                play() {
                  var Q = this, O = this;
                  if (this.renderStarted) {
                    A.prototype.play.call(this);
                    return;
                  }
                  this.addEventListener("loaded", function() {
                    var K = this.renderer, ne, pe = this.renderer.xr;
                    A.prototype.play.call(this), !O.renderStarted && (O.resize(), O.renderer && (window.performance && window.performance.mark("render-started"), E.remove(), ne = c.device.getVRDisplay(), ne && ne.isPresenting && (pe.setDevice(ne), pe.enabled = !0, O.enterVR()), K.setAnimationLoop(this.render), O.renderStarted = !0, O.emit("renderstart")));
                  }), setTimeout(function() {
                    A.prototype.load.call(Q);
                  });
                }
                /**
                 * Wrap `updateComponent` to not initialize the component if the component has a system
                 * (aframevr/aframe#2365).
                 */
                updateComponent(Q) {
                  Q in l || A.prototype.updateComponent.apply(this, arguments);
                }
                /**
                 * Behavior-updater meant to be called from scene render.
                 * Abstracted to a different function to facilitate unit testing (`scene.tick()`) without
                 * needing to render.
                 */
                tick(Q, O) {
                  var K, ne = this.systems;
                  for (this.callComponentBehaviors("tick", Q, O), K = 0; K < this.systemNames.length; K++)
                    ne[this.systemNames[K]].tick && ne[this.systemNames[K]].tick(Q, O);
                }
                /**
                 * Behavior-updater meant to be called after scene render for post processing purposes.
                 * Abstracted to a different function to facilitate unit testing (`scene.tock()`) without
                 * needing to render.
                 */
                tock(Q, O, K) {
                  var ne, pe = this.systems;
                  for (this.callComponentBehaviors("tock", Q, O), ne = 0; ne < this.systemNames.length; ne++)
                    pe[this.systemNames[ne]].tock && pe[this.systemNames[ne]].tock(Q, O, K);
                }
                /**
                 * The render loop.
                 *
                 * Updates animations.
                 * Updates behaviors.
                 * Renders with request animation frame.
                 */
                render(Q, O) {
                  var K = this.renderer;
                  this.frame = O, this.delta = this.clock.getDelta() * 1e3, this.time = this.clock.elapsedTime * 1e3, this.isPlaying && this.tick(this.time, this.delta);
                  var ne = null;
                  this.is("ar-mode") && (ne = this.object3D.background, this.object3D.background = null), K.render(this.object3D, this.camera), ne && (this.object3D.background = ne);
                }
                callComponentBehaviors(Q, O, K) {
                  for (var ne, pe = 0; pe < this.componentOrder.length; pe++) {
                    var be = this.behaviors[this.componentOrder[pe]];
                    if (be) {
                      var Te = be[Q];
                      for (Te.inUse = !0, ne = 0; ne < Te.array.length; ne++)
                        Te.array[ne].isPlaying && Te.array[ne][Q](O, K);
                      for (Te.inUse = !1, ne = 0; ne < Te.markedForRemoval.length; ne++)
                        this.removeBehavior(Te.markedForRemoval[ne]);
                      Te.markedForRemoval.length = 0;
                    }
                  }
                }
              }
              function S(X, Q) {
                var O = {}, K, ne, pe = Q || [];
                pe.length = 0;
                for (ne in X) {
                  var be = X[ne];
                  if (be !== void 0) {
                    var Te = be.before ? be.before.slice(0) : [], ke = be.after ? be.after.slice(0) : [];
                    O[ne] = {
                      before: Te,
                      after: ke,
                      visited: !1,
                      done: !1
                    };
                  }
                }
                for (ne in O)
                  for (K = 0; K < O[ne].before.length; K++) {
                    var Ve = O[ne].before[K];
                    if (!(Ve in O)) {
                      g("Invalid ordering constraint, no component named `" + Ve + "` referenced by `" + ne + "`");
                      continue;
                    }
                    O[Ve].after.push(ne);
                  }
                function st(ut) {
                  if (!(!(ut in O) || O[ut].done)) {
                    if (O[ut].visited) {
                      g("Cycle detected, ignoring one or more before/after constraints. The resulting order might be incorrect");
                      return;
                    }
                    O[ut].visited = !0;
                    for (var It = 0; It < O[ut].after.length; It++) {
                      var ht = O[ut].after[It];
                      ht in O || g("Invalid before/after constraint, no component named `" + ht + "` referenced in `" + ut + "`"), st(ht);
                    }
                    O[ut].done = !0, pe.push(ut);
                  }
                }
                for (ne in O)
                  O[ne].done || st(ne);
                return pe;
              }
              j.exports.determineComponentBehaviorOrder = S;
              function U(X, Q) {
                var O, K = window.devicePixelRatio;
                return !Q || Q.width === -1 && Q.height === -1 || X.width * K < Q.width && X.height * K < Q.height || (O = X.width / X.height, X.width * K > Q.width && Q.width !== -1 && (X.width = Math.round(Q.width / K), X.height = Math.round(Q.width / O / K)), X.height * K > Q.height && Q.height !== -1 && (X.height = Math.round(Q.height / K), X.width = Math.round(Q.height * O / K))), X;
              }
              customElements.define("a-scene", D);
              function G(X, Q, O, K) {
                if (!X.parentElement)
                  return {
                    height: 0,
                    width: 0
                  };
                if (Q) {
                  var ne;
                  return ne = {
                    height: X.parentElement.offsetHeight,
                    width: X.parentElement.offsetWidth
                  }, U(ne, O);
                }
                return Z(O, K);
              }
              function Z(X, Q) {
                var O;
                return O = {
                  height: document.body.offsetHeight,
                  width: document.body.offsetWidth
                }, Q ? O : U(O, X);
              }
              function W(X) {
                var Q = X.requestFullscreen || X.webkitRequestFullscreen || X.mozRequestFullScreen || // The capitalized `S` is not a typo.
                X.msRequestFullscreen;
                Q.apply(X, [{
                  navigationUI: "hide"
                }]);
              }
              function ie() {
                var X = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement;
                X && (document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen());
              }
              function te(X) {
                var Q;
                Q = document.createElement("canvas"), Q.classList.add("a-canvas"), Q.dataset.aframeCanvas = !0, X.appendChild(Q), document.addEventListener("fullscreenchange", O), document.addEventListener("mozfullscreenchange", O), document.addEventListener("webkitfullscreenchange", O), document.addEventListener("MSFullscreenChange", O), Q.addEventListener("touchmove", function(K) {
                  K.preventDefault();
                }, {
                  passive: !1
                }), X.canvas = Q, X.emit("render-target-loaded", {
                  target: Q
                }), setTimeout(X.resize.bind(X), 0);
                function O() {
                  var K = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
                  K || X.exitVR(), document.activeElement.blur(), document.body.focus();
                }
              }
              j.exports.setupCanvas = te, j.exports.AScene = D;
            }
          ),
          /***/
          "./src/core/scene/loadingScreen.js": (
            /*!*****************************************!*\
              !*** ./src/core/scene/loadingScreen.js ***!
              \*****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              ), w = C.styleParser, E, y, l, d = "loading-screen", p = "a-loader-title";
              j.exports.setup = function(u, f) {
                E = u, l = f;
                var x = E.hasAttribute(d) ? w.parse(E.getAttribute(d)) : void 0, T = x && x.dotsColor || "white", b = x && x.backgroundColor || "#24CAFF", D = x === void 0 || x.enabled === "true" || x.enabled === void 0, S, U, G, Z, W, ie, te, X, Q, O;
                D && (S = new THREE.Scene(), U = new THREE.SphereGeometry(0.2, 36, 18, 0, 2 * Math.PI, 0, Math.PI), G = new THREE.MeshBasicMaterial({
                  color: T
                }), Z = new THREE.Mesh(U, G), W = Z.clone(), ie = Z.clone(), te = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 5e-4, 1e4), X = new THREE.Clock(), Q = 0, O = function() {
                  E.renderer.render(S, te), Q = X.getElapsedTime() % 4, Z.visible = Q >= 1, W.visible = Q >= 2, ie.visible = Q >= 3;
                }, S.background = new THREE.Color(b), S.add(te), Z.position.set(-1, 0, -15), W.position.set(0, 0, -15), ie.position.set(1, 0, -15), te.add(Z), te.add(W), te.add(ie), g(), setTimeout(function() {
                  E.hasLoaded || (c(te), y.style.display = "block", window.addEventListener("resize", function() {
                    c(te);
                  }), E.renderer.setAnimationLoop(O));
                }, 200));
              }, j.exports.remove = function() {
                window.removeEventListener("resize", c), y && (y.style.display = "none");
              };
              function c(A) {
                var u = E.hasAttribute("embedded"), f = l(E.canvas, u, E.maxCanvasSize, E.is("vr-mode"));
                A.aspect = f.width / f.height, A.updateProjectionMatrix(), E.renderer.setSize(f.width, f.height, !1);
              }
              function g() {
                y = document.createElement("div"), y.className = p, y.innerHTML = document.title, y.style.display = "none", E.appendChild(y);
              }
            }
          ),
          /***/
          "./src/core/scene/metaTags.js": (
            /*!************************************!*\
              !*** ./src/core/scene/metaTags.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../constants/ */
                "./src/constants/index.js"
              ), w = v(
                /*! ../../utils */
                "./src/utils/index.js"
              ).extend, E = j.exports.MOBILE_HEAD_TAGS = [
                l({
                  name: "viewport",
                  content: "width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover"
                }),
                // W3C-standardised meta tags.
                l({
                  name: "mobile-web-app-capable",
                  content: "yes"
                }),
                l({
                  name: "theme-color",
                  content: "black"
                })
              ], y = [
                // iOS-specific meta tags for fullscreen when pinning to homescreen.
                l({
                  name: "apple-mobile-web-app-capable",
                  content: "yes"
                }),
                l({
                  name: "apple-mobile-web-app-status-bar-style",
                  content: "black"
                }),
                d({
                  rel: "apple-touch-icon",
                  href: "https://aframe.io/images/aframe-logo-152.png"
                })
              ];
              function l(c) {
                return {
                  tagName: "meta",
                  attributes: c,
                  exists: function() {
                    return document.querySelector('meta[name="' + c.name + '"]');
                  }
                };
              }
              function d(c) {
                return {
                  tagName: "link",
                  attributes: c,
                  exists: function() {
                    return document.querySelector('link[rel="' + c.rel + '"]');
                  }
                };
              }
              j.exports.inject = function(g) {
                var A = document.head, u = A.querySelector("script"), f, x = [];
                return E.forEach(T), g.isIOS && y.forEach(T), x;
                function T(b) {
                  !b || b.exists() || (f = p(b), f && (u ? u.parentNode.insertBefore(f, u) : A.appendChild(f), x.push(f)));
                }
              };
              function p(c) {
                if (!(!c || !c.tagName)) {
                  var g = document.createElement(c.tagName);
                  return g.setAttribute(C.AFRAME_INJECTED, ""), w(g, c.attributes);
                }
              }
            }
          ),
          /***/
          "./src/core/scene/postMessage.js": (
            /*!***************************************!*\
              !*** ./src/core/scene/postMessage.js ***!
              \***************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              ).isIframed;
              j.exports = function(y) {
                C() && window.addEventListener("message", w.bind(y));
              };
              function w(E) {
                var y = this;
                if (E.data)
                  switch (E.data.type) {
                    case "vr":
                      switch (E.data.data) {
                        case "enter":
                          y.enterVR();
                          break;
                        case "exit":
                          y.exitVR();
                          break;
                      }
                  }
              }
            }
          ),
          /***/
          "./src/core/scene/scenes.js": (
            /*!**********************************!*\
              !*** ./src/core/scene/scenes.js ***!
              \**********************************/
            /***/
            (j) => {
              j.exports = [];
            }
          ),
          /***/
          "./src/core/scene/wakelock.js": (
            /*!************************************!*\
              !*** ./src/core/scene/wakelock.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../../vendor/wakelock/wakelock */
                "./vendor/wakelock/wakelock.js"
              );
              j.exports = function(E) {
                if (E.isMobile) {
                  var y = E.wakelock = new C();
                  E.addEventListener("enter-vr", function() {
                    y.request();
                  }), E.addEventListener("exit-vr", function() {
                    y.release();
                  });
                }
              };
            }
          ),
          /***/
          "./src/core/schema.js": (
            /*!****************************!*\
              !*** ./src/core/schema.js ***!
              \****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), w = v(
                /*! ./propertyTypes */
                "./src/core/propertyTypes.js"
              ), E = C.debug, y = w.isValidDefaultValue, l = w.propertyTypes, d = E("core:schema:warn");
              function p(u) {
                return "type" in u ? typeof u.type == "string" : "default" in u;
              }
              j.exports.isSingleProperty = p, j.exports.process = function(u, f) {
                var x;
                if (p(u))
                  return c(u, f);
                for (x in u)
                  u[x] = c(u[x], f);
                return u;
              };
              function c(u, f) {
                var x = u.default, T, b, D = u.type;
                return u.type ? u.type === "bool" ? D = "boolean" : u.type === "float" && (D = "number") : x !== void 0 && (typeof x == "boolean" || typeof x == "number") ? D = typeof x : Array.isArray(x) ? D = "array" : D = "string", b = l[D], b || d("Unknown property type for component `" + f + "`: " + D), T = !!u.parse, u.parse = u.parse || b.parse, u.stringify = u.stringify || b.stringify, u.equals = u.equals || b.equals, u.isCacheable = u.isCacheable === !0 || b.isCacheable, u.type = D, "default" in u ? !T && !y(D, x) && d("Default value `" + x + "` does not match type `" + D + "` in component `" + f + "`") : u.default = b.default, u;
              }
              j.exports.processPropertyDefinition = c, j.exports.parseProperties = /* @__PURE__ */ function() {
                var u = [];
                return function(f, x, T, b, D) {
                  var S, U, G, Z;
                  u.length = 0;
                  for (U in T ? f : x)
                    T && f[U] === void 0 || u.push(U);
                  if (f === null || typeof f != "object")
                    return f;
                  for (U in f)
                    f[U] !== void 0 && !x[U] && !D && d("Unknown property `" + U + "` for component/system `" + b + "`.");
                  for (S = 0; S < u.length; S++) {
                    if (U = u[S], G = x[U], Z = f[U], !x[U])
                      return;
                    f[U] = g(Z, G);
                  }
                  return f;
                };
              }();
              function g(u, f, x) {
                return (u == null || u === "") && (u = f.default, Array.isArray(u) && (u = u.slice())), f.parse(u, f.default, x);
              }
              j.exports.parseProperty = g, j.exports.stringifyProperties = function(u, f) {
                var x, T, b, D = {}, S;
                for (x in u)
                  T = f[x], b = u[x], S = b, typeof S == "object" && (S = A(b, T), T || d("Unknown component property: " + x)), D[x] = S;
                return D;
              };
              function A(u, f) {
                return typeof u != "object" ? u : !f || u === null ? JSON.stringify(u) : f.stringify(u);
              }
              j.exports.stringifyProperty = A;
            }
          ),
          /***/
          "./src/core/shader.js": (
            /*!****************************!*\
              !*** ./src/core/shader.js ***!
              \****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./schema */
                "./src/core/schema.js"
              ), w = C.process, E = j.exports.shaders = {}, y = j.exports.shaderNames = [], l = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), d = v(
                /*! ../utils */
                "./src/utils/index.js"
              ), p = {
                array: "v3",
                color: "v3",
                int: "i",
                number: "f",
                map: "t",
                time: "f",
                vec2: "v2",
                vec3: "v3",
                vec4: "v4"
              }, c = j.exports.Shader = function() {
              };
              c.prototype = {
                /**
                 * Contains the type schema and defaults for the data values.
                 * Data is coerced into the types of the values of the defaults.
                 */
                schema: {},
                vertexShader: "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",
                fragmentShader: "void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",
                /**
                 * Init handler. Similar to attachedCallback.
                 * Called during shader initialization and is only run once.
                 */
                init: function(g) {
                  return this.uniforms = this.initUniforms(), this.material = new (this.raw ? l.RawShaderMaterial : l.ShaderMaterial)({
                    uniforms: this.uniforms,
                    glslVersion: this.raw || this.glsl3 ? l.GLSL3 : null,
                    vertexShader: this.vertexShader,
                    fragmentShader: this.fragmentShader
                  }), this.material;
                },
                initUniforms: function() {
                  var g, A = this.schema, u = {}, f;
                  for (g in A)
                    A[g].is === "uniform" && (f = p[A[g].type], u[g] = {
                      type: f,
                      value: void 0
                      // Let update handle setting these.
                    });
                  return u;
                },
                /**
                 * Update handler. Similar to attributeChangedCallback.
                 * Called whenever the associated material data changes.
                 *
                 * @param {object} data - New material data.
                 */
                update: function(g) {
                  var A, u, f = this.schema, x = this.uniforms;
                  for (A in g)
                    if (!(!f[A] || f[A].is !== "uniform")) {
                      if (f[A].type === "map") {
                        if (!x[A] || x[A].value === g[A])
                          continue;
                        u = "_texture_" + A, this.setMapOnTextureLoad(x, A, u), d.material.updateMapMaterialFromData(u, A, this, g);
                        continue;
                      }
                      x[A].value = this.parseValue(f[A].type, g[A]), x[A].needsUpdate = !0;
                    }
                },
                parseValue: function(g, A) {
                  var u;
                  switch (g) {
                    case "vec2":
                      return new l.Vector2(A.x, A.y);
                    case "vec3":
                      return new l.Vector3(A.x, A.y, A.z);
                    case "vec4":
                      return new l.Vector4(A.x, A.y, A.z, A.w);
                    case "color":
                      return u = new l.Color(A), new l.Vector3(u.r, u.g, u.b);
                    default:
                      return A;
                  }
                },
                setMapOnTextureLoad: function(g, A, u) {
                  var f = this;
                  this.el.addEventListener("materialtextureloaded", function() {
                    g[A].value = f.material[u], g[A].needsUpdate = !0;
                  });
                }
              }, j.exports.registerShader = function(g, A) {
                var u, f = {};
                if (Object.keys(A).forEach(function(x) {
                  f[x] = {
                    value: A[x],
                    writable: !0
                  };
                }), E[g])
                  throw new Error("The shader " + g + " has already been registered");
                return u = function() {
                  c.call(this);
                }, u.prototype = Object.create(c.prototype, f), u.prototype.name = g, u.prototype.constructor = u, E[g] = {
                  Shader: u,
                  schema: w(u.prototype.schema)
                }, y.push(g), u;
              };
            }
          ),
          /***/
          "./src/core/system.js": (
            /*!****************************!*\
              !*** ./src/core/system.js ***!
              \****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./component */
                "./src/core/component.js"
              ), w = v(
                /*! ./schema */
                "./src/core/schema.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), y = v(
                /*! ./readyState */
                "./src/core/readyState.js"
              ), l = w.parseProperties, d = w.parseProperty, p = w.process, c = w.isSingleProperty, g = E.styleParser, A = j.exports.systems = {}, u = j.exports.System = function(f) {
                var x = C && C.components[this.name];
                this.el = f, this.sceneEl = f, x && (x.Component.prototype.system = this), this.buildData(), this.init(), this.update({});
              };
              u.prototype = {
                /**
                 * Schema to configure system.
                 */
                schema: {},
                /**
                 * Init handler. Called during scene initialization and is only run once.
                 * Systems can use this to set initial state.
                 */
                init: function() {
                },
                /**
                 * Update handler. Called during scene attribute updates.
                 * Systems can use this to dynamically update their state.
                 */
                update: function(f) {
                },
                /**
                 * Build data and call update handler.
                 *
                 * @private
                 */
                updateProperties: function(f) {
                  var x = this.data;
                  Object.keys(w).length && (this.buildData(f), this.update(x));
                },
                /**
                 * Parse data.
                 */
                buildData: function(f) {
                  var x = this.schema;
                  Object.keys(x).length && (f = f || window.HTMLElement.prototype.getAttribute.call(this.sceneEl, this.name), c(x) ? this.data = d(f, x) : this.data = l(g.parse(f) || {}, x, !1, this.name));
                },
                /**
                 * Tick handler.
                 * Called on each tick of the scene render loop.
                 * Affected by play and pause.
                 *
                 * @param {number} time - Scene tick time.
                 * @param {number} timeDelta - Difference in current render time and previous render time.
                 */
                tick: void 0,
                /**
                 * Tock handler.
                 * Called on each tock of the scene render loop.
                 * Affected by play and pause.
                 *
                 * @param {number} time - Scene tick time.
                 * @param {number} timeDelta - Difference in current render time and previous render time.
                 */
                tock: void 0,
                /**
                 * Called to start any dynamic behavior (e.g., animation, AI, events, physics).
                 */
                play: function() {
                },
                /**
                 * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).
                 */
                pause: function() {
                }
              }, j.exports.registerSystem = function(f, x) {
                var T, b, D = {}, S = E.findAllScenes(document);
                if (Object.keys(x).forEach(function(U) {
                  D[U] = {
                    value: x[U],
                    writable: !0
                  };
                }), A[f])
                  throw new Error("The system `" + f + "` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");
                if (b = function(U) {
                  u.call(this, U);
                }, b.prototype = Object.create(u.prototype, D), b.prototype.name = f, b.prototype.constructor = b, b.prototype.schema = E.extend(p(b.prototype.schema)), A[f] = b, y.canInitializeElements)
                  for (T = 0; T < S.length; T++)
                    S[T].initSystem(f);
              };
            }
          ),
          /***/
          "./src/extras/components/index.js": (
            /*!****************************************!*\
              !*** ./src/extras/components/index.js ***!
              \****************************************/
            /***/
            (j, re, v) => {
              v(
                /*! ./pivot */
                "./src/extras/components/pivot.js"
              );
            }
          ),
          /***/
          "./src/extras/components/pivot.js": (
            /*!****************************************!*\
              !*** ./src/extras/components/pivot.js ***!
              \****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).registerComponent, w = v(
                /*! ../../lib/three */
                "./src/lib/three.js"
              ), E = new w.Vector3(), y = new w.Vector3();
              C("pivot", {
                dependencies: ["position"],
                schema: {
                  type: "vec3"
                },
                init: function() {
                  var l = this.data, d = this.el, p = d.object3D.parent, c = d.object3D, g = new w.Group();
                  E.copy(c.position), y.copy(c.rotation), p.remove(c), g.add(c), p.add(g), d.object3D = g, c.position.set(-1 * l.x, -1 * l.y, -1 * l.z), g.position.set(l.x + E.x, l.y + E.y, l.z + E.z), g.rotation.copy(c.rotation), c.rotation.set(0, 0, 0);
                }
              });
            }
          ),
          /***/
          "./src/extras/primitives/getMeshMixin.js": (
            /*!***********************************************!*\
              !*** ./src/extras/primitives/getMeshMixin.js ***!
              \***********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).components, w = v(
                /*! ../../core/shader */
                "./src/core/shader.js"
              ).shaders, E = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              ), y = {};
              Object.keys(C.material.schema).forEach(l), Object.keys(w.standard.schema).forEach(l);
              function l(d) {
                var p = d.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                d === "fog" && (p = "material-fog"), d === "visible" && (p = "material-visible"), y[p] = "material." + d;
              }
              j.exports = function() {
                return {
                  defaultComponents: {
                    material: {}
                  },
                  mappings: E.extend({}, y)
                };
              };
            }
          ),
          /***/
          "./src/extras/primitives/index.js": (
            /*!****************************************!*\
              !*** ./src/extras/primitives/index.js ***!
              \****************************************/
            /***/
            (j, re, v) => {
              v(
                /*! ./primitives/a-camera */
                "./src/extras/primitives/primitives/a-camera.js"
              ), v(
                /*! ./primitives/a-cursor */
                "./src/extras/primitives/primitives/a-cursor.js"
              ), v(
                /*! ./primitives/a-curvedimage */
                "./src/extras/primitives/primitives/a-curvedimage.js"
              ), v(
                /*! ./primitives/a-gltf-model */
                "./src/extras/primitives/primitives/a-gltf-model.js"
              ), v(
                /*! ./primitives/a-image */
                "./src/extras/primitives/primitives/a-image.js"
              ), v(
                /*! ./primitives/a-light */
                "./src/extras/primitives/primitives/a-light.js"
              ), v(
                /*! ./primitives/a-link */
                "./src/extras/primitives/primitives/a-link.js"
              ), v(
                /*! ./primitives/a-obj-model */
                "./src/extras/primitives/primitives/a-obj-model.js"
              ), v(
                /*! ./primitives/a-sky */
                "./src/extras/primitives/primitives/a-sky.js"
              ), v(
                /*! ./primitives/a-sound */
                "./src/extras/primitives/primitives/a-sound.js"
              ), v(
                /*! ./primitives/a-text */
                "./src/extras/primitives/primitives/a-text.js"
              ), v(
                /*! ./primitives/a-video */
                "./src/extras/primitives/primitives/a-video.js"
              ), v(
                /*! ./primitives/a-videosphere */
                "./src/extras/primitives/primitives/a-videosphere.js"
              ), v(
                /*! ./primitives/meshPrimitives */
                "./src/extras/primitives/primitives/meshPrimitives.js"
              );
            }
          ),
          /***/
          "./src/extras/primitives/primitives.js": (
            /*!*********************************************!*\
              !*** ./src/extras/primitives/primitives.js ***!
              \*********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../../core/a-node */
                "./src/core/a-node.js"
              ).knownTags, w = v(
                /*! ../../core/a-entity */
                "./src/core/a-entity.js"
              ).AEntity, E = v(
                /*! ../../core/component */
                "./src/core/component.js"
              ).components, y = v(
                /*! ../../utils/ */
                "./src/utils/index.js"
              ), l = y.debug, d = y.entity.setComponentProperty, p = l("extras:primitives:debug"), c = l("extras:primitives:warn"), g = l("extras:primitives:error"), A = j.exports.primitives = {};
              j.exports.registerPrimitive = function(b, D) {
                if (b = b.toLowerCase(), C[b]) {
                  g("Trying to register primitive " + b + " that has been already previously registered");
                  return;
                }
                C[b] = !0, p("Registering <%s>", b), D.defaultAttributes && c("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");
                var S = D.mappings || {}, U = class extends w {
                  constructor() {
                    super(), this.defaultComponentsFromPrimitive = D.defaultComponents || D.defaultAttributes || {}, this.deprecated = D.deprecated || null, this.deprecatedMappings = D.deprecatedMappings || {}, this.mappings = S, D.deprecated && console.warn(D.deprecated), this.resolveMappingCollisions();
                  }
                  /**
                   * If a mapping collides with a registered component name
                   * it renames the mapping to componentname-property
                   */
                  resolveMappingCollisions() {
                    var G = this.mappings, Z = this;
                    Object.keys(G).forEach(function(ie) {
                      var te;
                      ie !== ie.toLowerCase() && c("Mapping keys should be specified in lower case. The mapping key " + ie + " may not be recognized"), E[ie] && (te = G[ie].replace(".", "-"), G[te] = G[ie], delete G[ie], console.warn("The primitive " + Z.tagName.toLowerCase() + " has a mapping collision. The attribute " + ie + " has the same name as a registered component and has been renamed to " + te));
                    });
                  }
                  getExtraComponents() {
                    var G, Z, W, ie, te, X = this;
                    for (Z = y.clone(this.defaultComponentsFromPrimitive), te = this.getAttribute("mixin"), te && (te = y.split(te.trim(), /\s+/), te.forEach(function(be) {
                      var Te = document.getElementById(be);
                      if (Te) {
                        var ke = Te.rawAttributeCache, Ve = Te.componentCache;
                        for (var st in ke) {
                          if (ie = X.mappings[st], ie) {
                            u(ie, ke[st], Z);
                            return;
                          }
                          st in Ve && (Z[st] = Q(Z[st], Ve[st]));
                        }
                      }
                    })), W = 0; W < this.attributes.length; W++)
                      G = this.attributes[W], ie = this.mappings[G.name], ie && u(ie, G.value, Z);
                    return Z;
                    function Q(pe, be) {
                      return O(pe) ? K(be) : O(be) ? K(pe) : ne(pe) && ne(be) ? y.extendDeep(pe, be) : K(be);
                    }
                    function O(pe) {
                      return typeof pe > "u";
                    }
                    function K(pe) {
                      return ne(pe) ? y.extendDeep({}, pe) : pe;
                    }
                    function ne(pe) {
                      return pe !== null && pe.constructor === Object;
                    }
                  }
                  /**
                   * Sync to attribute to component property whenever mapped attribute changes.
                   * If attribute is mapped to a component property, set the component property using
                   * the attribute value.
                   */
                  attributeChangedCallback(G, Z, W) {
                    var ie = this.mappings[G];
                    if (G in this.deprecatedMappings && console.warn(this.deprecatedMappings[G]), !G || !ie) {
                      super.attributeChangedCallback(G, Z, W);
                      return;
                    }
                    d(this, ie, W);
                  }
                };
                return customElements.define(b, U), U.mappings = S, A[b] = U, U;
              };
              function u(T, b, D) {
                var S = y.entity.getComponentPropertyPath(T);
                S.constructor === Array ? (D[S[0]] = D[S[0]] || {}, D[S[0]][S[1]] = b.trim()) : D[S] = b.trim();
              }
              function f(T, b) {
                var D = E[T].schema;
                Object.keys(D).map(function(S) {
                  var U = S.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                  b[U] !== void 0 && (U = T + "-" + S), b[U] = T + "." + S;
                });
              }
              function x(T, b, D) {
                D = D || {}, Object.keys(b).map(function(U) {
                  f(U, D);
                }), j.exports.registerPrimitive(T, y.extendDeep({}, null, {
                  defaultComponents: b,
                  mappings: D
                }));
              }
              j.exports.definePrimitive = x;
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-camera.js": (
            /*!******************************************************!*\
              !*** ./src/extras/primitives/primitives/a-camera.js ***!
              \******************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive;
              C("a-camera", {
                defaultComponents: {
                  camera: {},
                  "look-controls": {},
                  "wasd-controls": {},
                  position: {
                    x: 0,
                    y: 1.6,
                    z: 0
                  }
                },
                mappings: {
                  active: "camera.active",
                  far: "camera.far",
                  fov: "camera.fov",
                  "look-controls-enabled": "look-controls.enabled",
                  near: "camera.near",
                  "pointer-lock-enabled": "look-controls.pointerLockEnabled",
                  "wasd-controls-enabled": "wasd-controls.enabled",
                  "reverse-mouse-drag": "look-controls.reverseMouseDrag",
                  zoom: "camera.zoom"
                }
              });
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-cursor.js": (
            /*!******************************************************!*\
              !*** ./src/extras/primitives/primitives/a-cursor.js ***!
              \******************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              ), w = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, E = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              );
              w("a-cursor", E.extendDeep({}, C(), {
                defaultComponents: {
                  cursor: {},
                  geometry: {
                    primitive: "ring",
                    radiusOuter: 0.016,
                    radiusInner: 0.01,
                    segmentsTheta: 32
                  },
                  material: {
                    color: "#000",
                    shader: "flat",
                    opacity: 0.8
                  },
                  position: {
                    x: 0,
                    y: 0,
                    z: -1
                  }
                },
                mappings: {
                  far: "raycaster.far",
                  fuse: "cursor.fuse",
                  "fuse-timeout": "cursor.fuseTimeout",
                  interval: "raycaster.interval",
                  objects: "raycaster.objects"
                }
              }));
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-curvedimage.js": (
            /*!***********************************************************!*\
              !*** ./src/extras/primitives/primitives/a-curvedimage.js ***!
              \***********************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              ), w = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, E = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              );
              w("a-curvedimage", E.extendDeep({}, C(), {
                defaultComponents: {
                  geometry: {
                    height: 1,
                    primitive: "cylinder",
                    radius: 2,
                    segmentsRadial: 48,
                    thetaLength: 270,
                    openEnded: !0,
                    thetaStart: 0
                  },
                  material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "double",
                    transparent: !0,
                    repeat: "-1 1"
                  }
                },
                mappings: {
                  height: "geometry.height",
                  "open-ended": "geometry.openEnded",
                  radius: "geometry.radius",
                  segments: "geometry.segmentsRadial",
                  start: "geometry.thetaStart",
                  "theta-length": "geometry.thetaLength",
                  "theta-start": "geometry.thetaStart",
                  width: "geometry.thetaLength"
                }
              }));
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-gltf-model.js": (
            /*!**********************************************************!*\
              !*** ./src/extras/primitives/primitives/a-gltf-model.js ***!
              \**********************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive;
              C("a-gltf-model", {
                mappings: {
                  src: "gltf-model"
                }
              });
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-image.js": (
            /*!*****************************************************!*\
              !*** ./src/extras/primitives/primitives/a-image.js ***!
              \*****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              ), w = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, E = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              );
              w("a-image", E.extendDeep({}, C(), {
                defaultComponents: {
                  geometry: {
                    primitive: "plane"
                  },
                  material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "double",
                    transparent: !0
                  }
                },
                mappings: {
                  height: "geometry.height",
                  width: "geometry.width"
                }
              }));
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-light.js": (
            /*!*****************************************************!*\
              !*** ./src/extras/primitives/primitives/a-light.js ***!
              \*****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive;
              C("a-light", {
                defaultComponents: {
                  light: {}
                },
                mappings: {
                  angle: "light.angle",
                  color: "light.color",
                  "ground-color": "light.groundColor",
                  decay: "light.decay",
                  distance: "light.distance",
                  intensity: "light.intensity",
                  penumbra: "light.penumbra",
                  type: "light.type",
                  target: "light.target",
                  envmap: "light.envMap",
                  "shadow-camera-automatic": "light.shadowCameraAutomatic"
                }
              });
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-link.js": (
            /*!****************************************************!*\
              !*** ./src/extras/primitives/primitives/a-link.js ***!
              \****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive;
              C("a-link", {
                defaultComponents: {
                  link: {
                    visualAspectEnabled: !0
                  }
                },
                mappings: {
                  href: "link.href",
                  image: "link.image",
                  title: "link.title"
                }
              });
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-obj-model.js": (
            /*!*********************************************************!*\
              !*** ./src/extras/primitives/primitives/a-obj-model.js ***!
              \*********************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              )(), w = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, E = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              );
              w("a-obj-model", E.extendDeep({}, C, {
                defaultComponents: {
                  "obj-model": {}
                },
                mappings: {
                  src: "obj-model.obj",
                  mtl: "obj-model.mtl"
                }
              }));
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-sky.js": (
            /*!***************************************************!*\
              !*** ./src/extras/primitives/primitives/a-sky.js ***!
              \***************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              ), w = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, E = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              ), y = v(
                /*! ./meshPrimitives */
                "./src/extras/primitives/primitives/meshPrimitives.js"
              );
              w("a-sky", E.extendDeep({}, C(), {
                defaultComponents: {
                  geometry: {
                    primitive: "sphere",
                    radius: 500,
                    segmentsWidth: 64,
                    segmentsHeight: 32
                  },
                  material: {
                    color: "#FFF",
                    side: "back",
                    shader: "flat",
                    npot: !0
                  },
                  scale: "-1 1 1"
                },
                mappings: E.extendDeep({}, y["a-sphere"].mappings)
              }));
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-sound.js": (
            /*!*****************************************************!*\
              !*** ./src/extras/primitives/primitives/a-sound.js ***!
              \*****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive;
              C("a-sound", {
                defaultComponents: {
                  sound: {}
                },
                mappings: {
                  src: "sound.src",
                  on: "sound.on",
                  autoplay: "sound.autoplay",
                  loop: "sound.loop",
                  volume: "sound.volume"
                }
              });
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-text.js": (
            /*!****************************************************!*\
              !*** ./src/extras/primitives/primitives/a-text.js ***!
              \****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).definePrimitive;
              C("a-text", {
                text: {
                  anchor: "align",
                  width: 5
                }
              });
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-video.js": (
            /*!*****************************************************!*\
              !*** ./src/extras/primitives/primitives/a-video.js ***!
              \*****************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              ), w = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, E = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              );
              w("a-video", E.extendDeep({}, C(), {
                defaultComponents: {
                  geometry: {
                    primitive: "plane"
                  },
                  material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "double",
                    transparent: !0
                  }
                },
                mappings: {
                  height: "geometry.height",
                  width: "geometry.width"
                }
              }));
            }
          ),
          /***/
          "./src/extras/primitives/primitives/a-videosphere.js": (
            /*!***********************************************************!*\
              !*** ./src/extras/primitives/primitives/a-videosphere.js ***!
              \***********************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              ), w = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, E = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              );
              w("a-videosphere", E.extendDeep({}, C(), {
                defaultComponents: {
                  geometry: {
                    primitive: "sphere",
                    radius: 500,
                    segmentsWidth: 64,
                    segmentsHeight: 32
                  },
                  material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "back",
                    npot: !0
                  },
                  scale: "-1 1 1"
                },
                mappings: {
                  radius: "geometry.radius",
                  "segments-height": "geometry.segmentsHeight",
                  "segments-width": "geometry.segmentsWidth"
                }
              }));
            }
          ),
          /***/
          "./src/extras/primitives/primitives/meshPrimitives.js": (
            /*!************************************************************!*\
              !*** ./src/extras/primitives/primitives/meshPrimitives.js ***!
              \************************************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../getMeshMixin */
                "./src/extras/primitives/getMeshMixin.js"
              ), w = v(
                /*! ../../../core/geometry */
                "./src/core/geometry.js"
              ).geometries, E = v(
                /*! ../../../core/geometry */
                "./src/core/geometry.js"
              ).geometryNames, y = v(
                /*! ../primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, l = v(
                /*! ../../../utils/ */
                "./src/utils/index.js"
              ), d = j.exports = {};
              E.forEach(function(g) {
                var A = w[g], u = p(g), f = {};
                Object.keys(A.schema).forEach(function(D) {
                  f[p(D)] = "geometry." + D;
                });
                var x = "a-" + u, T = y(x, l.extendDeep({}, C(), {
                  defaultComponents: {
                    geometry: {
                      primitive: g
                    }
                  },
                  mappings: f
                }));
                d[x] = T;
              });
              function p(c) {
                return c.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
              }
            }
          ),
          /***/
          "./src/geometries/box.js": (
            /*!*******************************!*\
              !*** ./src/geometries/box.js ***!
              \*******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("box", {
                schema: {
                  depth: {
                    default: 1,
                    min: 0
                  },
                  height: {
                    default: 1,
                    min: 0
                  },
                  width: {
                    default: 1,
                    min: 0
                  },
                  segmentsHeight: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                  },
                  segmentsWidth: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                  },
                  segmentsDepth: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                  }
                },
                init: function(E) {
                  this.geometry = new w.BoxGeometry(E.width, E.height, E.depth, E.segmentsWidth, E.segmentsHeight, E.segmentsDepth);
                }
              });
            }
          ),
          /***/
          "./src/geometries/circle.js": (
            /*!**********************************!*\
              !*** ./src/geometries/circle.js ***!
              \**********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = w.MathUtils.degToRad;
              C("circle", {
                schema: {
                  radius: {
                    default: 1,
                    min: 0
                  },
                  segments: {
                    default: 32,
                    min: 3,
                    type: "int"
                  },
                  thetaLength: {
                    default: 360,
                    min: 0
                  },
                  thetaStart: {
                    default: 0
                  }
                },
                init: function(y) {
                  this.geometry = new w.CircleGeometry(y.radius, y.segments, E(y.thetaStart), E(y.thetaLength));
                }
              });
            }
          ),
          /***/
          "./src/geometries/cone.js": (
            /*!********************************!*\
              !*** ./src/geometries/cone.js ***!
              \********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = w.MathUtils.degToRad;
              C("cone", {
                schema: {
                  height: {
                    default: 1,
                    min: 0
                  },
                  openEnded: {
                    default: !1
                  },
                  radiusBottom: {
                    default: 1,
                    min: 0
                  },
                  radiusTop: {
                    default: 0.01,
                    min: 0
                  },
                  segmentsHeight: {
                    default: 18,
                    min: 1,
                    type: "int"
                  },
                  segmentsRadial: {
                    default: 36,
                    min: 3,
                    type: "int"
                  },
                  thetaLength: {
                    default: 360,
                    min: 0
                  },
                  thetaStart: {
                    default: 0
                  }
                },
                init: function(y) {
                  this.geometry = new w.CylinderGeometry(y.radiusTop, y.radiusBottom, y.height, y.segmentsRadial, y.segmentsHeight, y.openEnded, E(y.thetaStart), E(y.thetaLength));
                }
              });
            }
          ),
          /***/
          "./src/geometries/cylinder.js": (
            /*!************************************!*\
              !*** ./src/geometries/cylinder.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = w.MathUtils.degToRad;
              C("cylinder", {
                schema: {
                  height: {
                    default: 1,
                    min: 0
                  },
                  openEnded: {
                    default: !1
                  },
                  radius: {
                    default: 1,
                    min: 0
                  },
                  segmentsHeight: {
                    default: 18,
                    min: 1,
                    type: "int"
                  },
                  segmentsRadial: {
                    default: 36,
                    min: 3,
                    type: "int"
                  },
                  thetaLength: {
                    default: 360,
                    min: 0
                  },
                  thetaStart: {
                    default: 0
                  }
                },
                init: function(y) {
                  this.geometry = new w.CylinderGeometry(y.radius, y.radius, y.height, y.segmentsRadial, y.segmentsHeight, y.openEnded, E(y.thetaStart), E(y.thetaLength));
                }
              });
            }
          ),
          /***/
          "./src/geometries/dodecahedron.js": (
            /*!****************************************!*\
              !*** ./src/geometries/dodecahedron.js ***!
              \****************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("dodecahedron", {
                schema: {
                  detail: {
                    default: 0,
                    min: 0,
                    max: 5,
                    type: "int"
                  },
                  radius: {
                    default: 1,
                    min: 0
                  }
                },
                init: function(E) {
                  this.geometry = new w.DodecahedronGeometry(E.radius, E.detail);
                }
              });
            }
          ),
          /***/
          "./src/geometries/icosahedron.js": (
            /*!***************************************!*\
              !*** ./src/geometries/icosahedron.js ***!
              \***************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("icosahedron", {
                schema: {
                  detail: {
                    default: 0,
                    min: 0,
                    max: 5,
                    type: "int"
                  },
                  radius: {
                    default: 1,
                    min: 0
                  }
                },
                init: function(E) {
                  this.geometry = new w.IcosahedronGeometry(E.radius, E.detail);
                }
              });
            }
          ),
          /***/
          "./src/geometries/index.js": (
            /*!*********************************!*\
              !*** ./src/geometries/index.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              v(
                /*! ./box.js */
                "./src/geometries/box.js"
              ), v(
                /*! ./circle.js */
                "./src/geometries/circle.js"
              ), v(
                /*! ./cone.js */
                "./src/geometries/cone.js"
              ), v(
                /*! ./cylinder.js */
                "./src/geometries/cylinder.js"
              ), v(
                /*! ./dodecahedron.js */
                "./src/geometries/dodecahedron.js"
              ), v(
                /*! ./icosahedron.js */
                "./src/geometries/icosahedron.js"
              ), v(
                /*! ./octahedron.js */
                "./src/geometries/octahedron.js"
              ), v(
                /*! ./plane.js */
                "./src/geometries/plane.js"
              ), v(
                /*! ./ring.js */
                "./src/geometries/ring.js"
              ), v(
                /*! ./sphere.js */
                "./src/geometries/sphere.js"
              ), v(
                /*! ./tetrahedron.js */
                "./src/geometries/tetrahedron.js"
              ), v(
                /*! ./torus.js */
                "./src/geometries/torus.js"
              ), v(
                /*! ./torusKnot.js */
                "./src/geometries/torusKnot.js"
              ), v(
                /*! ./triangle.js */
                "./src/geometries/triangle.js"
              );
            }
          ),
          /***/
          "./src/geometries/octahedron.js": (
            /*!**************************************!*\
              !*** ./src/geometries/octahedron.js ***!
              \**************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("octahedron", {
                schema: {
                  detail: {
                    default: 0,
                    min: 0,
                    max: 5,
                    type: "int"
                  },
                  radius: {
                    default: 1,
                    min: 0
                  }
                },
                init: function(E) {
                  this.geometry = new w.OctahedronGeometry(E.radius, E.detail);
                }
              });
            }
          ),
          /***/
          "./src/geometries/plane.js": (
            /*!*********************************!*\
              !*** ./src/geometries/plane.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("plane", {
                schema: {
                  height: {
                    default: 1,
                    min: 0
                  },
                  width: {
                    default: 1,
                    min: 0
                  },
                  segmentsHeight: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                  },
                  segmentsWidth: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                  }
                },
                init: function(E) {
                  this.geometry = new w.PlaneGeometry(E.width, E.height, E.segmentsWidth, E.segmentsHeight);
                }
              });
            }
          ),
          /***/
          "./src/geometries/ring.js": (
            /*!********************************!*\
              !*** ./src/geometries/ring.js ***!
              \********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = w.MathUtils.degToRad;
              C("ring", {
                schema: {
                  radiusInner: {
                    default: 0.8,
                    min: 0
                  },
                  radiusOuter: {
                    default: 1.2,
                    min: 0
                  },
                  segmentsPhi: {
                    default: 10,
                    min: 1,
                    type: "int"
                  },
                  segmentsTheta: {
                    default: 32,
                    min: 3,
                    type: "int"
                  },
                  thetaLength: {
                    default: 360,
                    min: 0
                  },
                  thetaStart: {
                    default: 0
                  }
                },
                init: function(y) {
                  this.geometry = new w.RingGeometry(y.radiusInner, y.radiusOuter, y.segmentsTheta, y.segmentsPhi, E(y.thetaStart), E(y.thetaLength));
                }
              });
            }
          ),
          /***/
          "./src/geometries/sphere.js": (
            /*!**********************************!*\
              !*** ./src/geometries/sphere.js ***!
              \**********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = w.MathUtils.degToRad;
              C("sphere", {
                schema: {
                  radius: {
                    default: 1,
                    min: 0
                  },
                  phiLength: {
                    default: 360
                  },
                  phiStart: {
                    default: 0,
                    min: 0
                  },
                  thetaLength: {
                    default: 180,
                    min: 0
                  },
                  thetaStart: {
                    default: 0
                  },
                  segmentsHeight: {
                    default: 18,
                    min: 2,
                    type: "int"
                  },
                  segmentsWidth: {
                    default: 36,
                    min: 3,
                    type: "int"
                  }
                },
                init: function(y) {
                  this.geometry = new w.SphereGeometry(y.radius, y.segmentsWidth, y.segmentsHeight, E(y.phiStart), E(y.phiLength), E(y.thetaStart), E(y.thetaLength));
                }
              });
            }
          ),
          /***/
          "./src/geometries/tetrahedron.js": (
            /*!***************************************!*\
              !*** ./src/geometries/tetrahedron.js ***!
              \***************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("tetrahedron", {
                schema: {
                  detail: {
                    default: 0,
                    min: 0,
                    max: 5,
                    type: "int"
                  },
                  radius: {
                    default: 1,
                    min: 0
                  }
                },
                init: function(E) {
                  this.geometry = new w.TetrahedronGeometry(E.radius, E.detail);
                }
              });
            }
          ),
          /***/
          "./src/geometries/torus.js": (
            /*!*********************************!*\
              !*** ./src/geometries/torus.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = w.MathUtils.degToRad;
              C("torus", {
                schema: {
                  arc: {
                    default: 360
                  },
                  radius: {
                    default: 1,
                    min: 0
                  },
                  radiusTubular: {
                    default: 0.2,
                    min: 0
                  },
                  segmentsRadial: {
                    default: 36,
                    min: 2,
                    type: "int"
                  },
                  segmentsTubular: {
                    default: 32,
                    min: 3,
                    type: "int"
                  }
                },
                init: function(y) {
                  this.geometry = new w.TorusGeometry(y.radius, y.radiusTubular * 2, y.segmentsRadial, y.segmentsTubular, E(y.arc));
                }
              });
            }
          ),
          /***/
          "./src/geometries/torusKnot.js": (
            /*!*************************************!*\
              !*** ./src/geometries/torusKnot.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              C("torusKnot", {
                schema: {
                  p: {
                    default: 2,
                    min: 1
                  },
                  q: {
                    default: 3,
                    min: 1
                  },
                  radius: {
                    default: 1,
                    min: 0
                  },
                  radiusTubular: {
                    default: 0.2,
                    min: 0
                  },
                  segmentsRadial: {
                    default: 8,
                    min: 3,
                    type: "int"
                  },
                  segmentsTubular: {
                    default: 100,
                    min: 3,
                    type: "int"
                  }
                },
                init: function(E) {
                  this.geometry = new w.TorusKnotGeometry(E.radius, E.radiusTubular * 2, E.segmentsTubular, E.segmentsRadial, E.p, E.q);
                }
              });
            }
          ),
          /***/
          "./src/geometries/triangle.js": (
            /*!************************************!*\
              !*** ./src/geometries/triangle.js ***!
              \************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = new w.Quaternion(), y = new w.Vector3(0, 0, 1), l = new w.Vector2(), d = new w.Vector2(), p = new w.Vector2();
              C("triangle", {
                schema: {
                  vertexA: {
                    type: "vec3",
                    default: {
                      x: 0,
                      y: 0.5,
                      z: 0
                    }
                  },
                  vertexB: {
                    type: "vec3",
                    default: {
                      x: -0.5,
                      y: -0.5,
                      z: 0
                    }
                  },
                  vertexC: {
                    type: "vec3",
                    default: {
                      x: 0.5,
                      y: -0.5,
                      z: 0
                    }
                  }
                },
                init: function(c) {
                  var g, A, u, f, x, T, b, D, S;
                  u = new w.Triangle(), u.a.set(c.vertexA.x, c.vertexA.y, c.vertexA.z), u.b.set(c.vertexB.x, c.vertexB.y, c.vertexB.z), u.c.set(c.vertexC.x, c.vertexC.y, c.vertexC.z), A = u.getNormal(new w.Vector3()), E.setFromUnitVectors(A, y), f = u.a.clone().applyQuaternion(E), x = u.b.clone().applyQuaternion(E), T = u.c.clone().applyQuaternion(E), l.set(Math.min(f.x, x.x, T.x), Math.min(f.y, x.y, T.y)), d.set(Math.max(f.x, x.x, T.x), Math.max(f.y, x.y, T.y)), p.set(0, 0).subVectors(d, l), f = new w.Vector2().subVectors(f, l).divide(p), x = new w.Vector2().subVectors(x, l).divide(p), T = new w.Vector2().subVectors(T, l).divide(p), g = this.geometry = new w.BufferGeometry(), b = [u.a.x, u.a.y, u.a.z, u.b.x, u.b.y, u.b.z, u.c.x, u.c.y, u.c.z], D = [A.x, A.y, A.z, A.x, A.y, A.z, A.x, A.y, A.z], S = [f.x, f.y, x.x, x.y, T.x, T.y], g.setAttribute("position", new w.Float32BufferAttribute(b, 3)), g.setAttribute("normal", new w.Float32BufferAttribute(D, 3)), g.setAttribute("uv", new w.Float32BufferAttribute(S, 2));
                }
              });
            }
          ),
          /***/
          "./src/index.js": (
            /*!**********************!*\
              !*** ./src/index.js ***!
              \**********************/
            /***/
            (j, re, v) => {
              if (window.hasNativeWebVRImplementation = !!window.navigator.getVRDisplays || !!window.navigator.getVRDevices, window.hasNativeWebXRImplementation = navigator.xr !== void 0, !window.hasNativeWebXRImplementation && !window.hasNativeWebVRImplementation) {
                var C = v(
                  /*! ./utils/isIOSOlderThan10 */
                  "./src/utils/isIOSOlderThan10.js"
                ), w = C(window.navigator.userAgent) ? 1 / window.devicePixelRatio : 1, E = v(
                  /*! webvr-polyfill */
                  "./node_modules/webvr-polyfill/build/webvr-polyfill.js"
                ), y = {
                  BUFFER_SCALE: w,
                  CARDBOARD_UI_DISABLED: !0,
                  ROTATE_INSTRUCTIONS_DISABLED: !0,
                  MOBILE_WAKE_LOCK: !!window.cordova
                };
                window.webvrpolyfill = new E(y);
              }
              var l = v(
                /*! ./utils/ */
                "./src/utils/index.js"
              ), d = l.debug, p = d("A-Frame:error"), c = d("A-Frame:warn");
              window.document.currentScript && window.document.currentScript.parentNode !== window.document.head && !window.debug && c("Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."), !window.cordova && window.location.protocol === "file:" && p("This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/1.4.0/introduction/installation.html#use-a-local-server."), l.device.isBrowserEnvironment && (v(
                /*! ./style/aframe.css */
                "./src/style/aframe.css"
              ), v(
                /*! ./style/rStats.css */
                "./src/style/rStats.css"
              ));
              var g = v(
                /*! ./core/scene/a-scene */
                "./src/core/scene/a-scene.js"
              ).AScene, A = v(
                /*! ./core/component */
                "./src/core/component.js"
              ).components, u = v(
                /*! ./core/component */
                "./src/core/component.js"
              ).registerComponent, f = v(
                /*! ./core/geometry */
                "./src/core/geometry.js"
              ).registerGeometry, x = v(
                /*! ./extras/primitives/primitives */
                "./src/extras/primitives/primitives.js"
              ).registerPrimitive, T = v(
                /*! ./core/shader */
                "./src/core/shader.js"
              ).registerShader, b = v(
                /*! ./core/system */
                "./src/core/system.js"
              ).registerSystem, D = v(
                /*! ./core/shader */
                "./src/core/shader.js"
              ).shaders, S = v(
                /*! ./core/system */
                "./src/core/system.js"
              ).systems, U = window.THREE = v(
                /*! ./lib/three */
                "./src/lib/three.js"
              ), G = v(
                /*! ./core/readyState */
                "./src/core/readyState.js"
              ), Z = v(
                /*! ../package */
                "./package.json"
              );
              v(
                /*! ./components/index */
                "./src/components/index.js"
              ), v(
                /*! ./geometries/index */
                "./src/geometries/index.js"
              ), v(
                /*! ./shaders/index */
                "./src/shaders/index.js"
              ), v(
                /*! ./systems/index */
                "./src/systems/index.js"
              );
              var W = v(
                /*! ./core/a-node */
                "./src/core/a-node.js"
              ).ANode, ie = v(
                /*! ./core/a-entity */
                "./src/core/a-entity.js"
              ).AEntity;
              v(
                /*! ./core/a-assets */
                "./src/core/a-assets.js"
              ), v(
                /*! ./core/a-cubemap */
                "./src/core/a-cubemap.js"
              ), v(
                /*! ./core/a-mixin */
                "./src/core/a-mixin.js"
              ), v(
                /*! ./extras/components/ */
                "./src/extras/components/index.js"
              ), v(
                /*! ./extras/primitives/ */
                "./src/extras/primitives/index.js"
              ), console.log("A-Frame Version: 1.6.0 (Date 2024-05-23, Commit #e6c47761)"), console.log("THREE Version (https://github.com/supermedium/three.js):", U.REVISION), console.log("WebVR Polyfill Version:", Z.dependencies["webvr-polyfill"]), window.AFRAME_ASYNC || G.waitForDocumentReadyState(), j.exports = window.AFRAME = {
                AComponent: v(
                  /*! ./core/component */
                  "./src/core/component.js"
                ).Component,
                AEntity: ie,
                ANode: W,
                ANIME: v(
                  /*! super-animejs */
                  "./node_modules/super-animejs/lib/anime.es.js"
                ).default,
                AScene: g,
                components: A,
                coreComponents: Object.keys(A),
                geometries: v(
                  /*! ./core/geometry */
                  "./src/core/geometry.js"
                ).geometries,
                registerComponent: u,
                registerGeometry: f,
                registerPrimitive: x,
                registerShader: T,
                registerSystem: b,
                primitives: {
                  getMeshMixin: v(
                    /*! ./extras/primitives/getMeshMixin */
                    "./src/extras/primitives/getMeshMixin.js"
                  ),
                  primitives: v(
                    /*! ./extras/primitives/primitives */
                    "./src/extras/primitives/primitives.js"
                  ).primitives
                },
                scenes: v(
                  /*! ./core/scene/scenes */
                  "./src/core/scene/scenes.js"
                ),
                schema: v(
                  /*! ./core/schema */
                  "./src/core/schema.js"
                ),
                shaders: D,
                systems: S,
                emitReady: G.emitReady,
                THREE: U,
                utils: l,
                version: Z.version
              };
            }
          ),
          /***/
          "./src/lib/rStatsAframe.js": (
            /*!*********************************!*\
              !*** ./src/lib/rStatsAframe.js ***!
              \*********************************/
            /***/
            (j) => {
              window.aframeStats = function(re) {
                var v = null, C = re, w = {
                  te: {
                    caption: "Entities"
                  },
                  lt: {
                    caption: "Load Time"
                  }
                }, E = [{
                  caption: "A-Frame",
                  values: ["te", "lt"]
                }];
                function y() {
                  v("te").set(l()), window.performance.getEntriesByName && v("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0));
                }
                function l() {
                  var g = C.querySelectorAll("*");
                  return Array.prototype.slice.call(g).filter(function(A) {
                    return A.isEntity;
                  }), g.length;
                }
                function d() {
                }
                function p() {
                }
                function c(g) {
                  v = g;
                }
                return {
                  update: y,
                  start: d,
                  end: p,
                  attach: c,
                  values: w,
                  groups: E,
                  fractions: []
                };
              }, j.exports = {
                aframeStats: window.aframeStats
              };
            }
          ),
          /***/
          "./src/lib/three.js": (
            /*!**************************!*\
              !*** ./src/lib/three.js ***!
              \**************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./three.mjs */
                "./src/lib/three.mjs"
              ).default;
              v.g.THREE = C, v(
                /*! ../../vendor/DeviceOrientationControls */
                "./vendor/DeviceOrientationControls.js"
              ), C.Cache && (C.Cache.enabled = !0), j.exports = C;
            }
          ),
          /***/
          "./src/shaders/flat.js": (
            /*!*****************************!*\
              !*** ./src/shaders/flat.js ***!
              \*****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ).registerShader, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              );
              j.exports.Shader = C("flat", {
                schema: {
                  color: {
                    type: "color"
                  },
                  fog: {
                    default: !0
                  },
                  height: {
                    default: 256
                  },
                  offset: {
                    type: "vec2",
                    default: {
                      x: 0,
                      y: 0
                    }
                  },
                  repeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  src: {
                    type: "map"
                  },
                  width: {
                    default: 512
                  },
                  wireframe: {
                    default: !1
                  },
                  wireframeLinewidth: {
                    default: 2
                  },
                  toneMapped: {
                    default: !0
                  }
                },
                /**
                 * Initializes the shader.
                 * Adds a reference from the scene to this entity as the camera.
                 */
                init: function(l) {
                  this.materialData = {
                    color: new w.Color()
                  }, y(l, this.materialData), this.material = new w.MeshBasicMaterial(this.materialData);
                },
                update: function(l) {
                  this.updateMaterial(l), E.material.updateMap(this, l);
                },
                /**
                 * Updating existing material.
                 *
                 * @param {object} data - Material component data.
                 */
                updateMaterial: function(l) {
                  var d;
                  y(l, this.materialData);
                  for (d in this.materialData)
                    this.material[d] = this.materialData[d];
                }
              });
              function y(l, d) {
                return d.color.set(l.color), d.fog = l.fog, d.wireframe = l.wireframe, d.toneMapped = l.toneMapped, d.wireframeLinewidth = l.wireframeLinewidth, d;
              }
            }
          ),
          /***/
          "./src/shaders/index.js": (
            /*!******************************!*\
              !*** ./src/shaders/index.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              v(
                /*! ./flat */
                "./src/shaders/flat.js"
              ), v(
                /*! ./standard */
                "./src/shaders/standard.js"
              ), v(
                /*! ./phong */
                "./src/shaders/phong.js"
              ), v(
                /*! ./sdf */
                "./src/shaders/sdf.js"
              ), v(
                /*! ./msdf */
                "./src/shaders/msdf.js"
              ), v(
                /*! ./shadow */
                "./src/shaders/shadow.js"
              );
            }
          ),
          /***/
          "./src/shaders/msdf.js": (
            /*!*****************************!*\
              !*** ./src/shaders/msdf.js ***!
              \*****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ).registerShader, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = ["#include <common>", "#include <fog_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "out vec2 vUV;", "void main(void) {", "  vUV = uv;", "  #include <begin_vertex>", "  #include <project_vertex>", "  #include <logdepthbuf_vertex>", "  #include <fog_vertex>", "}"].join(`
`), y = [
                "#include <common>",
                "#include <fog_pars_fragment>",
                "#include <logdepthbuf_pars_fragment>",
                "uniform bool negate;",
                "uniform float alphaTest;",
                "uniform float opacity;",
                "uniform sampler2D map;",
                "uniform vec3 color;",
                "in vec2 vUV;",
                "float median(float r, float g, float b) {",
                "  return max(min(r, g), min(max(r, g), b));",
                "}",
                // FIXME: Experimentally determined constants.
                "#define BIG_ENOUGH 0.001",
                "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)",
                "void main() {",
                "  vec3 sampleColor = texture(map, vUV).rgb;",
                "  if (negate) { sampleColor = 1.0 - sampleColor; }",
                "  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;",
                "  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);",
                "  float dscale = 0.353505;",
                "  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));",
                "  float isBigEnough = max(abs(duv.x), abs(duv.y));",
                // When texel is too small, blend raw alpha value rather than supersampling.
                // FIXME: Experimentally determined constant.
                "  // Do modified alpha test.",
                "  if (isBigEnough > BIG_ENOUGH) {",
                "    float ratio = BIG_ENOUGH / isBigEnough;",
                "    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);",
                "  }",
                "  // Do modified alpha test.",
                "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }",
                "  gl_FragColor = vec4(color.xyz, alpha * opacity);",
                "  #include <logdepthbuf_fragment>",
                "  #include <tonemapping_fragment>",
                "  #include <colorspace_fragment>",
                "  #include <fog_fragment>",
                "}"
              ].join(`
`);
              j.exports.Shader = C("msdf", {
                schema: {
                  alphaTest: {
                    type: "number",
                    is: "uniform",
                    default: 0.5
                  },
                  color: {
                    type: "color",
                    is: "uniform",
                    default: "white"
                  },
                  map: {
                    type: "map",
                    is: "uniform"
                  },
                  negate: {
                    type: "boolean",
                    is: "uniform",
                    default: !0
                  },
                  opacity: {
                    type: "number",
                    is: "uniform",
                    default: 1
                  }
                },
                vertexShader: E,
                fragmentShader: y,
                init: function() {
                  return this.uniforms = w.UniformsUtils.merge([w.UniformsLib.fog, this.initUniforms()]), this.material = new w.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: this.vertexShader,
                    fragmentShader: this.fragmentShader,
                    fog: !0
                  }), this.material;
                }
              });
            }
          ),
          /***/
          "./src/shaders/phong.js": (
            /*!******************************!*\
              !*** ./src/shaders/phong.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ).registerShader, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              );
              j.exports.Shader = C("phong", {
                schema: {
                  color: {
                    type: "color"
                  },
                  emissive: {
                    type: "color",
                    default: "black"
                  },
                  emissiveIntensity: {
                    default: 1
                  },
                  specular: {
                    type: "color",
                    default: "#111111"
                  },
                  transparent: {
                    default: !1
                  },
                  fog: {
                    default: !0
                  },
                  offset: {
                    type: "vec2",
                    default: {
                      x: 0,
                      y: 0
                    }
                  },
                  repeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  src: {
                    type: "map"
                  },
                  envMap: {
                    default: ""
                  },
                  sphericalEnvMap: {
                    type: "map"
                  },
                  shininess: {
                    default: 30
                  },
                  flatShading: {
                    default: !1
                  },
                  wireframe: {
                    default: !1
                  },
                  wireframeLinewidth: {
                    default: 2
                  },
                  combine: {
                    oneOF: ["multiply", "mix", "add"],
                    default: "mix"
                  },
                  reflectivity: {
                    default: 0.9
                  },
                  refractionRatio: {
                    default: 0.98
                  },
                  refract: {
                    default: !1
                  },
                  normalMap: {
                    type: "map"
                  },
                  normalScale: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  normalTextureOffset: {
                    type: "vec2"
                  },
                  normalTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  ambientOcclusionMap: {
                    type: "map"
                  },
                  ambientOcclusionMapIntensity: {
                    default: 1
                  },
                  displacementMap: {
                    type: "map"
                  },
                  displacementScale: {
                    default: 1
                  },
                  displacementBias: {
                    default: 0.5
                  },
                  displacementTextureOffset: {
                    type: "vec2"
                  },
                  displacementTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  bumpMap: {
                    type: "map"
                  },
                  bumpMapScale: {
                    default: 1
                  },
                  bumpTextureOffset: {
                    type: "vec2"
                  },
                  bumpTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  }
                },
                /**
                 * Initializes the shader.
                 * Adds a reference from the scene to this entity as the camera.
                 */
                init: function(l) {
                  this.materialData = {
                    color: new w.Color(),
                    specular: new w.Color(),
                    emissive: new w.Color()
                  }, y(l, this.materialData), this.material = new w.MeshPhongMaterial(this.materialData);
                  var d = this.el.sceneEl;
                  Object.defineProperty(this.material, "envMap", {
                    get: function() {
                      return this._envMap || d.object3D.environment;
                    },
                    set: function(p) {
                      this._envMap = p;
                    }
                  });
                },
                update: function(l) {
                  this.updateMaterial(l), E.material.updateMap(this, l), E.material.updateDistortionMap("normal", this, l), E.material.updateDistortionMap("displacement", this, l), E.material.updateDistortionMap("ambientOcclusion", this, l), E.material.updateDistortionMap("bump", this, l), E.material.updateEnvMap(this, l);
                },
                /**
                 * Updating existing material.
                 *
                 * @param {object} data - Material component data.
                 */
                updateMaterial: function(l) {
                  var d;
                  y(l, this.materialData);
                  for (d in this.materialData)
                    this.material[d] = this.materialData[d];
                }
              });
              function y(l, d) {
                switch (d.color.set(l.color), d.specular.set(l.specular), d.emissive.set(l.emissive), d.emissiveIntensity = l.emissiveIntensity, d.fog = l.fog, d.transparent = l.transparent, d.wireframe = l.wireframe, d.wireframeLinewidth = l.wireframeLinewidth, d.shininess = l.shininess, d.flatShading = l.flatShading, d.wireframe = l.wireframe, d.wireframeLinewidth = l.wireframeLinewidth, d.reflectivity = l.reflectivity, d.refractionRatio = l.refractionRatio, l.combine) {
                  case "mix":
                    d.combine = w.MixOperation;
                    break;
                  case "multiply":
                    d.combine = w.MultiplyOperation;
                    break;
                  case "add":
                    d.combine = w.AddOperation;
                    break;
                }
                return l.normalMap && (d.normalScale = l.normalScale), l.ambientOcclusionMap && (d.aoMapIntensity = l.ambientOcclusionMapIntensity), l.bumpMap && (d.bumpScale = l.bumpMapScale), l.displacementMap && (d.displacementScale = l.displacementScale, d.displacementBias = l.displacementBias), d;
              }
            }
          ),
          /***/
          "./src/shaders/sdf.js": (
            /*!****************************!*\
              !*** ./src/shaders/sdf.js ***!
              \****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ).registerShader, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = ["#include <common>", "#include <fog_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "out vec2 vUV;", "void main(void) {", "  vUV = uv;", "  #include <begin_vertex>", "  #include <project_vertex>", "  #include <logdepthbuf_vertex>", "  #include <fog_vertex>", "}"].join(`
`), y = [
                "#include <common>",
                "#include <fog_pars_fragment>",
                "#include <logdepthbuf_pars_fragment>",
                "uniform float alphaTest;",
                "uniform float opacity;",
                "uniform sampler2D map;",
                "uniform vec3 color;",
                "in vec2 vUV;",
                "float contour(float width, float value) {",
                "  return smoothstep(0.5 - value, 0.5 + value, width);",
                "}",
                // FIXME: Experimentally determined constants.
                "#define BIG_ENOUGH 0.001",
                "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)",
                "void main() {",
                "  vec2 uv = vUV;",
                "  vec4 texColor = texture(map, uv);",
                "  float dist = texColor.a;",
                "  float width = fwidth(dist);",
                "  float alpha = contour(dist, width);",
                "  float dscale = 0.353505;",
                "  vec2 duv = dscale * (dFdx(uv) + dFdy(uv));",
                "  float isBigEnough = max(abs(duv.x), abs(duv.y));",
                // When texel is too small, blend raw alpha value rather than supersampling.
                // FIXME: experimentally determined constant
                "  if (isBigEnough > BIG_ENOUGH) {",
                "    float ratio = BIG_ENOUGH / isBigEnough;",
                "    alpha = ratio * alpha + (1.0 - ratio) * dist;",
                "  }",
                // Otherwise do weighted supersampling.
                // FIXME: why this weighting?
                "  if (isBigEnough <= BIG_ENOUGH) {",
                "    vec4 box = vec4 (uv - duv, uv + duv);",
                "    alpha = (alpha + 0.5 * (",
                "      contour(texture(map, box.xy).a, width)",
                "      + contour(texture(map, box.zw).a, width)",
                "      + contour(texture(map, box.xw).a, width)",
                "      + contour(texture(map, box.zy).a, width)",
                "    )) / 3.0;",
                "  }",
                // Do modified alpha test.
                "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }",
                "  gl_FragColor = vec4(color, opacity * alpha);",
                "  #include <logdepthbuf_fragment>",
                "  #include <tonemapping_fragment>",
                "  #include <colorspace_fragment>",
                "  #include <fog_fragment>",
                "}"
              ].join(`
`);
              j.exports.Shader = C("sdf", {
                schema: {
                  alphaTest: {
                    type: "number",
                    is: "uniform",
                    default: 0.5
                  },
                  color: {
                    type: "color",
                    is: "uniform",
                    default: "white"
                  },
                  map: {
                    type: "map",
                    is: "uniform"
                  },
                  opacity: {
                    type: "number",
                    is: "uniform",
                    default: 1
                  }
                },
                vertexShader: E,
                fragmentShader: y,
                init: function() {
                  return this.uniforms = w.UniformsUtils.merge([w.UniformsLib.fog, this.initUniforms()]), this.material = new w.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: this.vertexShader,
                    fragmentShader: this.fragmentShader,
                    fog: !0
                  }), this.material;
                }
              });
            }
          ),
          /***/
          "./src/shaders/shadow.js": (
            /*!*******************************!*\
              !*** ./src/shaders/shadow.js ***!
              \*******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ).registerShader, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              j.exports.Shader = C("shadow", {
                schema: {
                  opacity: {
                    default: 0.5
                  },
                  transparent: {
                    default: !0
                  },
                  alphaToCoverage: {
                    default: !0
                  }
                },
                /**
                 * Initializes the shader.
                 * Adds a reference from the scene to this entity as the camera.
                 */
                init: function(E) {
                  this.material = new w.ShadowMaterial();
                },
                update: function(E) {
                  this.material.opacity = E.opacity, this.material.alphaToCoverage = E.alphaToCoverage, this.material.transparent = E.transparent;
                }
              });
            }
          ),
          /***/
          "./src/shaders/standard.js": (
            /*!*********************************!*\
              !*** ./src/shaders/standard.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/shader */
                "./src/core/shader.js"
              ).registerShader, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              );
              j.exports.Shader = C("standard", {
                schema: {
                  ambientOcclusionMap: {
                    type: "map"
                  },
                  ambientOcclusionMapIntensity: {
                    default: 1
                  },
                  ambientOcclusionTextureOffset: {
                    type: "vec2"
                  },
                  ambientOcclusionTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  color: {
                    type: "color"
                  },
                  displacementMap: {
                    type: "map"
                  },
                  displacementScale: {
                    default: 1
                  },
                  displacementBias: {
                    default: 0.5
                  },
                  displacementTextureOffset: {
                    type: "vec2"
                  },
                  displacementTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  emissive: {
                    type: "color",
                    default: "#000"
                  },
                  emissiveIntensity: {
                    default: 1
                  },
                  envMap: {
                    default: ""
                  },
                  fog: {
                    default: !0
                  },
                  height: {
                    default: 256
                  },
                  metalness: {
                    default: 0,
                    min: 0,
                    max: 1
                  },
                  metalnessMap: {
                    type: "map"
                  },
                  metalnessTextureOffset: {
                    type: "vec2"
                  },
                  metalnessTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  normalMap: {
                    type: "map"
                  },
                  normalScale: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  normalTextureOffset: {
                    type: "vec2"
                  },
                  normalTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  offset: {
                    type: "vec2",
                    default: {
                      x: 0,
                      y: 0
                    }
                  },
                  repeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  roughness: {
                    default: 0.5,
                    min: 0,
                    max: 1
                  },
                  roughnessMap: {
                    type: "map"
                  },
                  roughnessTextureOffset: {
                    type: "vec2"
                  },
                  roughnessTextureRepeat: {
                    type: "vec2",
                    default: {
                      x: 1,
                      y: 1
                    }
                  },
                  sphericalEnvMap: {
                    type: "map"
                  },
                  src: {
                    type: "map"
                  },
                  width: {
                    default: 512
                  },
                  wireframe: {
                    default: !1
                  },
                  wireframeLinewidth: {
                    default: 2
                  }
                },
                /**
                 * Initializes the shader.
                 * Adds a reference from the scene to this entity as the camera.
                 */
                init: function(l) {
                  this.materialData = {
                    color: new w.Color(),
                    emissive: new w.Color()
                  }, y(l, this.materialData), this.material = new w.MeshStandardMaterial(this.materialData);
                },
                update: function(l) {
                  this.updateMaterial(l), E.material.updateMap(this, l), E.material.updateDistortionMap("normal", this, l), E.material.updateDistortionMap("displacement", this, l), E.material.updateDistortionMap("ambientOcclusion", this, l), E.material.updateDistortionMap("metalness", this, l), E.material.updateDistortionMap("roughness", this, l), E.material.updateEnvMap(this, l);
                },
                /**
                 * Updating existing material.
                 *
                 * @param {object} data - Material component data.
                 * @returns {object} Material.
                 */
                updateMaterial: function(l) {
                  var d, p = this.material;
                  y(l, this.materialData);
                  for (d in this.materialData)
                    p[d] = this.materialData[d];
                }
              });
              function y(l, d) {
                return d.color.set(l.color), d.emissive.set(l.emissive), d.emissiveIntensity = l.emissiveIntensity, d.fog = l.fog, d.metalness = l.metalness, d.roughness = l.roughness, d.wireframe = l.wireframe, d.wireframeLinewidth = l.wireframeLinewidth, l.normalMap && (d.normalScale = l.normalScale), l.ambientOcclusionMap && (d.aoMapIntensity = l.ambientOcclusionMapIntensity), l.displacementMap && (d.displacementScale = l.displacementScale, d.displacementBias = l.displacementBias), d;
              }
            }
          ),
          /***/
          "./src/systems/camera.js": (
            /*!*******************************!*\
              !*** ./src/systems/camera.js ***!
              \*******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../constants/ */
                "./src/constants/index.js"
              ), w = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, E = "data-aframe-default-camera";
              j.exports.System = w("camera", {
                init: function() {
                  this.activeCameraEl = null, this.render = this.render.bind(this), this.unwrapRender = this.unwrapRender.bind(this), this.wrapRender = this.wrapRender.bind(this), this.initialCameraFound = !1, this.numUserCameras = 0, this.numUserCamerasChecked = 0, this.setupInitialCamera();
                },
                /**
                 * Setup initial camera, either searching for camera or
                 * creating a default camera if user has not added one during the initial scene traversal.
                 * We want sceneEl.camera to be ready, set, and initialized before the rest of the scene
                 * loads.
                 *
                 * Default camera offset height is at average eye level (~1.6m).
                 */
                setupInitialCamera: function() {
                  var l, d, p = this.sceneEl, c = this;
                  if (p.camera && !p.camera.el.getAttribute("camera").spectator) {
                    p.emit("cameraready", {
                      cameraEl: p.camera.el
                    });
                    return;
                  }
                  if (l = p.querySelectorAll("a-camera, :not(a-mixin)[camera]"), !l.length) {
                    this.createDefaultCamera();
                    return;
                  }
                  for (this.numUserCameras = l.length, d = 0; d < l.length; d++)
                    l[d].addEventListener("object3dset", function(g) {
                      g.detail.type === "camera" && c.checkUserCamera(this);
                    }), l[d].isNode ? l[d].load() : l[d].addEventListener("nodeready", function() {
                      this.load();
                    });
                },
                /**
                 * Check if a user-defined camera entity is appropriate to be initial camera.
                 * (active + non-spectator).
                 *
                 * Keep track of the number of cameras we checked and whether we found one.
                 */
                checkUserCamera: function(l) {
                  var d, p = this.el.sceneEl;
                  if (this.numUserCamerasChecked++, !this.initialCameraFound) {
                    if (d = l.getAttribute("camera"), !d.active || d.spectator) {
                      this.numUserCamerasChecked === this.numUserCameras && this.createDefaultCamera();
                      return;
                    }
                    this.initialCameraFound = !0, p.camera = l.getObject3D("camera"), p.emit("cameraready", {
                      cameraEl: l
                    });
                  }
                },
                createDefaultCamera: function() {
                  var l, d = this.sceneEl;
                  l = document.createElement("a-entity"), l.setAttribute("camera", {
                    active: !0
                  }), l.setAttribute("position", {
                    x: 0,
                    y: C.DEFAULT_CAMERA_HEIGHT,
                    z: 0
                  }), l.setAttribute("wasd-controls", ""), l.setAttribute("look-controls", ""), l.setAttribute(C.AFRAME_INJECTED, ""), l.addEventListener("object3dset", function(p) {
                    p.detail.type === "camera" && (d.camera = p.detail.object, d.emit("cameraready", {
                      cameraEl: l
                    }));
                  }), d.appendChild(l);
                },
                /**
                 * Set a different active camera.
                 * When we choose a (sort of) random scene camera as the replacement, set its `active` to
                 * true. The camera component will call `setActiveCamera` and handle passing the torch to
                 * the new camera.
                 */
                disableActiveCamera: function() {
                  var l, d;
                  l = this.sceneEl.querySelectorAll(":not(a-mixin)[camera]"), d = l[l.length - 1], d.setAttribute("camera", "active", !0);
                },
                /**
                 * Set active camera to be used by renderer.
                 * Removes the default camera (if present).
                 * Disables all other cameras in the scene.
                 *
                 * @param {Element} newCameraEl - Entity with camera component.
                 */
                setActiveCamera: function(l) {
                  var d, p, c, g, A = this.activeCameraEl, u = this.sceneEl;
                  if (g = l.getObject3D("camera"), !(!g || l === this.activeCameraEl)) {
                    var f = u.querySelector("[" + E + "]"), x = f && f.querySelector(":not(a-mixin)[camera]");
                    for (l !== x && y(u), this.activeCameraEl = l, this.activeCameraEl.play(), u.camera = g, A && A.setAttribute("camera", "active", !1), p = u.querySelectorAll(":not(a-mixin)[camera]"), c = 0; c < p.length; c++)
                      d = p[c], !(!d.isEntity || l === d) && (d.setAttribute("camera", "active", !1), d.pause());
                    u.emit("camera-set-active", {
                      cameraEl: l
                    });
                  }
                },
                /**
                 * Set spectator camera to render the scene on a 2D display.
                 *
                 * @param {Element} newCameraEl - Entity with camera component.
                 */
                setSpectatorCamera: function(l) {
                  var d, p = this.spectatorCameraEl, c = this.sceneEl, g;
                  d = l.getObject3D("camera"), !(!d || l === this.spectatorCameraEl) && (p && p.setAttribute("camera", "spectator", !1), g = this.spectatorCameraEl = l, c.addEventListener("enter-vr", this.wrapRender), c.addEventListener("exit-vr", this.unwrapRender), g.setAttribute("camera", "active", !1), g.play(), c.emit("camera-set-spectator", {
                    cameraEl: l
                  }));
                },
                /**
                 * Disables current spectator camera.
                 */
                disableSpectatorCamera: function() {
                  this.spectatorCameraEl = void 0;
                },
                /**
                 * Wrap the render method of the renderer to render
                 * the spectator camera after vrDisplay.submitFrame.
                 */
                wrapRender: function() {
                  !this.spectatorCameraEl || this.originalRender || (this.originalRender = this.sceneEl.renderer.render, this.sceneEl.renderer.render = this.render);
                },
                unwrapRender: function() {
                  this.originalRender && (this.sceneEl.renderer.render = this.originalRender, this.originalRender = void 0);
                },
                render: function(l, d) {
                  var p, c = this.sceneEl, g;
                  p = c.renderer.xr.enabled, this.originalRender.call(c.renderer, l, d), !(!this.spectatorCameraEl || c.isMobile || !p) && (g = this.spectatorCameraEl.components.camera.camera, c.renderer.xr.enabled = !1, this.originalRender.call(c.renderer, l, g), c.renderer.xr.enabled = p);
                }
              });
              function y(l) {
                var d, p = l.camera;
                p && (d = l.querySelector("[" + E + "]"), d && l.removeChild(d));
              }
            }
          ),
          /***/
          "./src/systems/geometry.js": (
            /*!*********************************!*\
              !*** ./src/systems/geometry.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/geometry */
                "./src/core/geometry.js"
              ).geometries, w = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem;
              j.exports.System = w("geometry", {
                init: function() {
                  this.cache = {}, this.cacheCount = {};
                },
                /**
                 * Reset cache. Mainly for testing.
                 */
                clearCache: function() {
                  this.cache = {}, this.cacheCount = {};
                },
                /**
                 * Attempt to retrieve from cache.
                 *
                 * @returns {Object|null} A geometry if it exists, else null.
                 */
                getOrCreateGeometry: function(d) {
                  var p = this.cache, c, g;
                  return d.skipCache ? E(d) : (g = this.hash(d), c = p[g], l(this.cacheCount, g), c || (c = E(d), p[g] = c, c));
                },
                /**
                 * Let system know that an entity is no longer using a geometry.
                 */
                unuseGeometry: function(d) {
                  var p = this.cache, c = this.cacheCount, g, A;
                  d.skipCache || (A = this.hash(d), p[A] && (y(c, A), !(c[A] > 0) && (g = p[A], g.dispose(), delete p[A], delete c[A])));
                },
                /**
                 * Use JSON.stringify to turn component data into hash.
                 * Should be deterministic within a single browser engine.
                 * If not, then look into json-stable-stringify.
                 */
                hash: function(d) {
                  return JSON.stringify(d);
                }
              });
              function E(d) {
                var p = d.primitive, c = C[p] && C[p].Geometry, g = new c();
                if (!c)
                  throw new Error("Unknown geometry `" + p + "`");
                return g.init(d), g.geometry;
              }
              function y(d, p) {
                d[p]--;
              }
              function l(d, p) {
                d[p] = d[p] === void 0 ? 1 : d[p] + 1;
              }
            }
          ),
          /***/
          "./src/systems/gltf-model.js": (
            /*!***********************************!*\
              !*** ./src/systems/gltf-model.js ***!
              \***********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              );
              function E(y) {
                return new Promise(function(l, d) {
                  var p = document.createElement("script");
                  document.body.appendChild(p), p.onload = l, p.onerror = d, p.async = !0, p.src = y;
                });
              }
              j.exports.System = C("gltf-model", {
                schema: {
                  dracoDecoderPath: {
                    default: "https://www.gstatic.com/draco/versioned/decoders/1.5.6/"
                  },
                  basisTranscoderPath: {
                    default: ""
                  },
                  meshoptDecoderPath: {
                    default: ""
                  }
                },
                init: function() {
                  this.update();
                },
                update: function() {
                  var y = this.data.dracoDecoderPath, l = this.data.basisTranscoderPath, d = this.data.meshoptDecoderPath;
                  !this.dracoLoader && y && (this.dracoLoader = new w.DRACOLoader(), this.dracoLoader.setDecoderPath(y)), !this.ktx2Loader && l && (this.ktx2Loader = new w.KTX2Loader(), this.ktx2Loader.setTranscoderPath(l).detectSupport(this.el.renderer)), !this.meshoptDecoder && d && (this.meshoptDecoder = E(d).then(function() {
                    return window.MeshoptDecoder.ready;
                  }).then(function() {
                    return window.MeshoptDecoder;
                  }));
                },
                getDRACOLoader: function() {
                  return this.dracoLoader;
                },
                getKTX2Loader: function() {
                  return this.ktx2Loader;
                },
                getMeshoptDecoder: function() {
                  return this.meshoptDecoder;
                }
              });
            }
          ),
          /***/
          "./src/systems/index.js": (
            /*!******************************!*\
              !*** ./src/systems/index.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              v(
                /*! ./camera */
                "./src/systems/camera.js"
              ), v(
                /*! ./geometry */
                "./src/systems/geometry.js"
              ), v(
                /*! ./gltf-model */
                "./src/systems/gltf-model.js"
              ), v(
                /*! ./light */
                "./src/systems/light.js"
              ), v(
                /*! ./material */
                "./src/systems/material.js"
              ), v(
                /*! ./obb-collider */
                "./src/systems/obb-collider.js"
              ), v(
                /*! ./renderer */
                "./src/systems/renderer.js"
              ), v(
                /*! ./shadow */
                "./src/systems/shadow.js"
              ), v(
                /*! ./tracked-controls-webvr */
                "./src/systems/tracked-controls-webvr.js"
              ), v(
                /*! ./tracked-controls-webxr */
                "./src/systems/tracked-controls-webxr.js"
              ), v(
                /*! ./webxr */
                "./src/systems/webxr.js"
              );
            }
          ),
          /***/
          "./src/systems/light.js": (
            /*!******************************!*\
              !*** ./src/systems/light.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../constants/ */
                "./src/constants/index.js"
              ), E = "data-aframe-default-light";
              j.exports.System = C("light", {
                schema: {
                  defaultLightsEnabled: {
                    default: !0
                  }
                },
                init: function() {
                  this.defaultLights = !1, this.userDefinedLights = !1, this.sceneEl.addEventListener("loaded", this.setupDefaultLights.bind(this));
                },
                /**
                 * Notify scene that light has been added and to remove the default.
                 *
                 * @param {object} el - element holding the light component.
                 */
                registerLight: function(y) {
                  y.hasAttribute(E) || (this.removeDefaultLights(), this.userDefinedLights = !0);
                },
                removeDefaultLights: function() {
                  var y, l = this.sceneEl;
                  if (this.defaultLights) {
                    y = document.querySelectorAll("[" + E + "]");
                    for (var d = 0; d < y.length; d++)
                      l.removeChild(y[d]);
                    this.defaultLights = !1;
                  }
                },
                /**
                 * Prescribe default lights to the scene.
                 * Does so by injecting markup such that this state is not invisible.
                 * These lights are removed if the user adds any lights.
                 */
                setupDefaultLights: function() {
                  var y = this.sceneEl, l, d;
                  this.userDefinedLights || this.defaultLights || !this.data.defaultLightsEnabled || (l = document.createElement("a-entity"), l.setAttribute("light", {
                    color: "#BBB",
                    type: "ambient"
                  }), l.setAttribute(E, ""), l.setAttribute(w.AFRAME_INJECTED, ""), y.appendChild(l), d = document.createElement("a-entity"), d.setAttribute("light", {
                    color: "#FFF",
                    intensity: 0.6,
                    castShadow: !0
                  }), d.setAttribute("position", {
                    x: -0.5,
                    y: 1,
                    z: 1
                  }), d.setAttribute(E, ""), d.setAttribute(w.AFRAME_INJECTED, ""), y.appendChild(d), this.defaultLights = !0);
                }
              });
            }
          ),
          /***/
          "./src/systems/material.js": (
            /*!*********************************!*\
              !*** ./src/systems/material.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), y = v(
                /*! ../utils/material */
                "./src/utils/material.js"
              ).setTextureProperties, l = v(
                /*! ../utils/material */
                "./src/utils/material.js"
              ).createCompatibleTexture, d = E.debug, p = d("components:texture:error"), c = d("components:texture:warn"), g = new w.ImageLoader();
              j.exports.System = C("material", {
                init: function() {
                  this.materials = {}, this.sourceCache = {};
                },
                clearTextureSourceCache: function() {
                  this.sourceCache = {};
                },
                /**
                 * Loads and creates a texture for a given `src`.
                 *
                 * @param {string, or element} src - URL or element
                 * @param {object} data - Relevant texture properties
                 * @param {function} cb - Callback to pass texture to
                 */
                loadTexture: function(x, T, b) {
                  this.loadTextureSource(x, function(S) {
                    var U = l(S);
                    y(U, T), b(U);
                  });
                },
                /**
                 * Determine whether `src` is an image or video. Then try to load the asset, then call back.
                 *
                 * @param {string, or element} src - URL or element.
                 * @param {function} cb - Callback to pass texture source to.
                 */
                loadTextureSource: function(x, T) {
                  var b = this, D = this.sourceCache, S = this.hash(x);
                  if (D[S]) {
                    D[S].then(T);
                    return;
                  }
                  if (x.tagName === "CANVAS") {
                    G(new w.Source(x));
                    return;
                  }
                  G(new Promise(U));
                  function U(Z, W) {
                    E.srcLoader.validateSrc(x, ie, te);
                    function ie(X) {
                      b.loadImage(X, Z);
                    }
                    function te(X) {
                      b.loadVideo(X, Z);
                    }
                  }
                  function G(Z) {
                    D[S] = Promise.resolve(Z), D[S].then(T);
                  }
                },
                /**
                 * Load the six individual sides and construct a cube texture, then call back.
                 *
                 * @param {Array} srcs - Array of six texture URLs or elements.
                 * @param {function} cb - Callback to pass cube texture to.
                 */
                loadCubeMapTexture: function(x, T) {
                  var b = this, D = 0, S = new w.CubeTexture();
                  S.colorSpace = w.SRGBColorSpace;
                  function U(Z) {
                    b.loadTextureSource(x[Z], function(W) {
                      S.images[Z] = W, D++, D === 6 && (S.needsUpdate = !0, T(S));
                    });
                  }
                  if (x.length !== 6) {
                    c("Cube map texture requires exactly 6 sources, got only %s sources", x.length);
                    return;
                  }
                  for (var G = 0; G < x.length; G++)
                    U(G);
                },
                /**
                 * High-level function for loading image textures (THREE.Texture).
                 *
                 * @param {Element|string} src - Texture source.
                 * @param {function} cb - Callback to pass texture to.
                 */
                loadImage: function(x, T) {
                  if (typeof x != "string") {
                    T(new w.Source(x));
                    return;
                  }
                  T(A(x));
                },
                /**
                 * Load video texture (THREE.VideoTexture).
                 * Which is just an image texture that RAFs + needsUpdate.
                 * Note that creating a video texture is synchronous unlike loading an image texture.
                 * Made asynchronous to be consistent with image textures.
                 *
                 * @param {Element|string} src - Texture source.
                 * @param {function} cb - Callback to pass texture to.
                 */
                loadVideo: function(x, T) {
                  var b;
                  typeof x != "string" && (b = x, f(b)), b = b || u(x), T(new w.Source(b));
                },
                /**
                 * Create a hash for a given source.
                 */
                hash: function(x) {
                  return x.tagName && (x.id || x.src) || x;
                },
                /**
                 * Keep track of material in case an update trigger is needed (e.g., fog).
                 *
                 * @param {object} material
                 */
                registerMaterial: function(x) {
                  this.materials[x.uuid] = x;
                },
                /**
                 * Stop tracking material, and dispose of any textures not being used by
                 * another material component.
                 *
                 * @param {object} material
                 */
                unregisterMaterial: function(x) {
                  delete this.materials[x.uuid];
                }
              });
              function A(x) {
                return new Promise(T);
                function T(b, D) {
                  g.load(x, S, function() {
                  }, function(U) {
                    p("`$s` could not be fetched (Error code: %s; Response: %s)", U.status, U.statusText);
                  });
                  function S(U) {
                    b(new w.Source(U));
                  }
                }
              }
              function u(x) {
                var T = document.createElement("video");
                return T.setAttribute("playsinline", ""), T.setAttribute("webkit-playsinline", ""), T.autoplay = !0, T.loop = !0, T.crossOrigin = "anonymous", T.addEventListener("error", function() {
                  c("`%s` is not a valid video", x);
                }, !0), T.src = x, T;
              }
              function f(x) {
                return x.autoplay = x.hasAttribute("autoplay") && x.getAttribute("autoplay") !== "false", x.controls = x.hasAttribute("controls") && x.getAttribute("controls") !== "false", x.getAttribute("loop") === "false" && x.removeAttribute("loop"), x.getAttribute("preload") === "false" && (x.preload = "none"), x.crossOrigin = x.crossOrigin || "anonymous", x.setAttribute("playsinline", ""), x.setAttribute("webkit-playsinline", ""), x;
              }
            }
          ),
          /***/
          "./src/systems/obb-collider.js": (
            /*!*************************************!*\
              !*** ./src/systems/obb-collider.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem;
              C("obb-collider", {
                schema: {
                  showColliders: {
                    default: !1
                  }
                },
                init: function() {
                  this.collisions = [], this.colliderEls = [];
                },
                addCollider: function(w) {
                  this.colliderEls.push(w), this.data.showColliders ? w.components["obb-collider"].showCollider() : w.components["obb-collider"].hideCollider(), this.tick = this.detectCollisions;
                },
                removeCollider: function(w) {
                  var E = this.colliderEls, y = E.indexOf(w);
                  w.components["obb-collider"].hideCollider(), y > -1 && E.splice(y, 1), E.length === 0 && (this.tick = void 0);
                },
                registerCollision: function(w, E) {
                  var y = this.collisions, l = !1, d = w.obb, p = E.obb, c = w.renderColliderMesh, g = E.renderColliderMesh;
                  c && c.material.color.set(16711680), g && g.material.color.set(16711680);
                  for (var A = 0; A < y.length; A++)
                    if (y[A].componentA.obb === d && y[A].componentB.obb === p || y[A].componentA.obb === p && y[A].componentB.obb === d) {
                      l = !0, y[A].detected = !0;
                      break;
                    }
                  l || (y.push({
                    componentA: w,
                    componentB: E,
                    detected: !0
                  }), w.el.emit("obbcollisionstarted", {
                    trackedObject3D: w.trackedObject3D,
                    withEl: E.el
                  }), E.el.emit("obbcollisionstarted", {
                    trackedObject3D: E.trackedObject3D,
                    withEl: w.el
                  }));
                },
                resetCollisions: function() {
                  for (var w = this.collisions, E = 0; E < w.length; E++)
                    w[E].detected = !1;
                },
                clearCollisions: function() {
                  for (var w = this.collisions, E = [], y, l, d, p, c = 0; c < w.length; c++)
                    w[c].detected ? E.push(w[c]) : (y = w[c].componentA, l = w[c].componentB, d = y.renderColliderMesh, p = l.renderColliderMesh, d && d.material.color.set(65280), y.el.emit("obbcollisionended", {
                      trackedObject3D: this.trackedObject3D,
                      withEl: l.el
                    }), p && p.material.color.set(65280), l.el.emit("obbcollisionended", {
                      trackedObject3D: this.trackedObject3D,
                      withEl: y.el
                    }));
                  this.collisions = E;
                },
                detectCollisions: function() {
                  var w, E, y, l, d = this.colliderEls;
                  if (!(d.length < 2)) {
                    this.resetCollisions();
                    for (var p = 0; p < d.length; p++)
                      if (y = d[p].components["obb-collider"], w = d[p].components["obb-collider"].obb, !(w.halfSize.x === 0 || w.halfSize.y === 0 || w.halfSize.z === 0))
                        for (var c = p + 1; c < d.length; c++)
                          l = d[c].components["obb-collider"], E = l.obb, !(E.halfSize.x === 0 || E.halfSize.y === 0 || E.halfSize.z === 0) && w.intersectsOBB(E) && this.registerCollision(y, l);
                    this.clearCollisions();
                  }
                }
              });
            }
          ),
          /***/
          "./src/systems/renderer.js": (
            /*!*********************************!*\
              !*** ./src/systems/renderer.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), E = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), y = w.debug, l = y("components:renderer:warn");
              j.exports.System = C("renderer", {
                schema: {
                  antialias: {
                    default: "auto",
                    oneOf: ["true", "false", "auto"]
                  },
                  highRefreshRate: {
                    default: w.device.isOculusBrowser()
                  },
                  logarithmicDepthBuffer: {
                    default: "auto",
                    oneOf: ["true", "false", "auto"]
                  },
                  maxCanvasWidth: {
                    default: -1
                  },
                  maxCanvasHeight: {
                    default: -1
                  },
                  multiviewStereo: {
                    default: !1
                  },
                  physicallyCorrectLights: {
                    default: !1
                  },
                  exposure: {
                    default: 1,
                    if: {
                      toneMapping: ["ACESFilmic", "linear", "reinhard", "cineon"]
                    }
                  },
                  toneMapping: {
                    default: "no",
                    oneOf: ["no", "ACESFilmic", "linear", "reinhard", "cineon"]
                  },
                  precision: {
                    default: "high",
                    oneOf: ["high", "medium", "low"]
                  },
                  anisotropy: {
                    default: 1
                  },
                  sortTransparentObjects: {
                    default: !1
                  },
                  colorManagement: {
                    default: !0
                  },
                  alpha: {
                    default: !0
                  },
                  stencil: {
                    default: !1
                  },
                  foveationLevel: {
                    default: 1
                  }
                },
                init: function() {
                  var g = this.data, A = this.el, u = this.data.toneMapping.charAt(0).toUpperCase() + this.data.toneMapping.slice(1), f = A.renderer;
                  g.physicallyCorrectLights || (f.useLegacyLights = !g.physicallyCorrectLights), f.toneMapping = E[u + "ToneMapping"], E.Texture.DEFAULT_ANISOTROPY = g.anisotropy, E.ColorManagement.enabled = g.colorManagement, f.outputColorSpace = g.colorManagement ? E.SRGBColorSpace : E.LinearSRGBColorSpace, A.hasAttribute("antialias") && l('Component `antialias` is deprecated. Use `renderer="antialias: true"` instead.'), A.hasAttribute("logarithmicDepthBuffer") && l('Component `logarithmicDepthBuffer` is deprecated. Use `renderer="logarithmicDepthBuffer: true"` instead.'), f.sortObjects = !0, f.setOpaqueSort(d);
                },
                update: function() {
                  var g = this.data, A = this.el, u = A.renderer, f = this.data.toneMapping.charAt(0).toUpperCase() + this.data.toneMapping.slice(1);
                  u.toneMapping = E[f + "ToneMapping"], u.toneMappingExposure = g.exposure, u.xr.setFoveation(g.foveationLevel), g.sortObjects && l('`sortObjects` property is deprecated. Use `renderer="sortTransparentObjects: true"` instead.'), g.sortTransparentObjects ? u.setTransparentSort(c) : u.setTransparentSort(p);
                },
                applyColorCorrection: function(g) {
                  !this.data.colorManagement || !g || g.isTexture && g.colorSpace !== E.SRGBColorSpace && (g.colorSpace = E.SRGBColorSpace, g.needsUpdate = !0);
                },
                setWebXRFrameRate: function(g) {
                  var A = this.data, u = g.supportedFrameRates;
                  if (u && g.updateTargetFrameRate) {
                    var f;
                    u.includes(90) ? f = A.highRefreshRate ? 90 : 72 : f = A.highRefreshRate ? 72 : 60, g.updateTargetFrameRate(f).catch(function(x) {
                      console.warn("failed to set target frame rate of " + f + ". Error info: " + x);
                    });
                  }
                }
              });
              function d(g, A) {
                return g.groupOrder !== A.groupOrder ? g.groupOrder - A.groupOrder : g.renderOrder !== A.renderOrder ? g.renderOrder - A.renderOrder : g.z - A.z;
              }
              function p(g, A) {
                return g.groupOrder !== A.groupOrder ? g.groupOrder - A.groupOrder : g.renderOrder - A.renderOrder;
              }
              function c(g, A) {
                return g.groupOrder !== A.groupOrder ? g.groupOrder - A.groupOrder : g.renderOrder !== A.renderOrder ? g.renderOrder - A.renderOrder : A.z - g.z;
              }
              j.exports.sortFrontToBack = d, j.exports.sortRenderOrderOnly = p, j.exports.sortBackToFront = c;
            }
          ),
          /***/
          "./src/systems/shadow.js": (
            /*!*******************************!*\
              !*** ./src/systems/shadow.js ***!
              \*******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), E = {
                basic: w.BasicShadowMap,
                pcf: w.PCFShadowMap,
                pcfsoft: w.PCFSoftShadowMap
              };
              j.exports.System = C("shadow", {
                schema: {
                  enabled: {
                    default: !0
                  },
                  autoUpdate: {
                    default: !0
                  },
                  type: {
                    default: "pcf",
                    oneOf: ["basic", "pcf", "pcfsoft"]
                  }
                },
                init: function() {
                  var l = this.sceneEl, d = this.data;
                  this.shadowMapEnabled = !1, l.renderer.shadowMap.type = E[d.type], l.renderer.shadowMap.autoUpdate = d.autoUpdate;
                },
                update: function(l) {
                  l.enabled !== this.data.enabled && this.setShadowMapEnabled(this.shadowMapEnabled);
                },
                /**
                 * Enables/disables the renderer shadow map.
                 * @param {boolean} enabled
                 */
                setShadowMapEnabled: function(l) {
                  var d = this.sceneEl, p = this.sceneEl.renderer;
                  this.shadowMapEnabled = l;
                  var c = this.data.enabled && this.shadowMapEnabled;
                  p && c !== p.shadowMap.enabled && (p.shadowMap.enabled = c, y(d));
                }
              });
              function y(l) {
                l.hasLoaded && l.object3D.traverse(function(d) {
                  if (d.material)
                    for (var p = Array.isArray(d.material) ? d.material : [d.material], c = 0; c < p.length; c++)
                      p[c].needsUpdate = !0;
                });
              }
            }
          ),
          /***/
          "./src/systems/tracked-controls-webvr.js": (
            /*!***********************************************!*\
              !*** ./src/systems/tracked-controls-webvr.js ***!
              \***********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../utils */
                "./src/utils/index.js"
              ), E = w.device.isWebXRAvailable;
              j.exports.System = C("tracked-controls-webvr", {
                init: function() {
                  var y = this;
                  this.controllers = [], this.isChrome = navigator.userAgent.indexOf("Chrome") !== -1, this.updateControllerList(), this.throttledUpdateControllerList = w.throttle(this.updateControllerList, 500, this), !E && navigator.getVRDisplays && this.sceneEl.addEventListener("enter-vr", function() {
                    navigator.getVRDisplays().then(function(l) {
                      l.length && (y.vrDisplay = l[0]);
                    });
                  });
                },
                tick: function() {
                  this.isChrome ? this.updateControllerList() : this.throttledUpdateControllerList();
                },
                /**
                 * Update controller list.
                 */
                updateControllerList: function() {
                  var y = this.controllers, l, d, p, c;
                  if (d = navigator.getGamepads && navigator.getGamepads(), !!d) {
                    for (c = y.length, y.length = 0, p = 0; p < d.length; ++p)
                      l = d[p], l && l.pose && y.push(l);
                    y.length !== c && this.el.emit("controllersupdated", void 0, !1);
                  }
                }
              });
            }
          ),
          /***/
          "./src/systems/tracked-controls-webxr.js": (
            /*!***********************************************!*\
              !*** ./src/systems/tracked-controls-webxr.js ***!
              \***********************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../utils */
                "./src/utils/index.js"
              );
              j.exports.System = C("tracked-controls-webxr", {
                init: function() {
                  this.controllers = [], this.oldControllers = [], this.oldControllersLength = 0, this.throttledUpdateControllerList = w.throttle(this.updateControllerList, 500, this), this.updateReferenceSpace = this.updateReferenceSpace.bind(this), this.el.addEventListener("enter-vr", this.updateReferenceSpace), this.el.addEventListener("exit-vr", this.updateReferenceSpace);
                },
                tick: function() {
                  this.throttledUpdateControllerList();
                },
                updateReferenceSpace: function() {
                  var E = this, y = this.el.xrSession;
                  if (!y) {
                    this.referenceSpace = void 0, this.controllers = [], this.oldControllersLength > 0 && (this.oldControllersLength = 0, this.el.emit("controllersupdated", void 0, !1));
                    return;
                  }
                  var l = E.el.sceneEl.systems.webxr.sessionReferenceSpaceType;
                  y.requestReferenceSpace(l).then(function(d) {
                    E.referenceSpace = d;
                  }).catch(function(d) {
                    throw E.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(l, 'tracked-controls-webxr uses reference space "' + l + '".'), d;
                  });
                },
                updateControllerList: function() {
                  var E = this.el.xrSession, y = this.oldControllers, l;
                  if (!E) {
                    if (this.oldControllersLength === 0)
                      return;
                    this.oldControllersLength = 0, this.controllers = [], this.el.emit("controllersupdated", void 0, !1);
                    return;
                  }
                  if (E.inputSources) {
                    if (this.controllers = E.inputSources, this.oldControllersLength === this.controllers.length) {
                      var d = !0;
                      for (l = 0; l < this.controllers.length; ++l)
                        if (!(this.controllers[l] === y[l] && this.controllers[l].gamepad === y[l].gamepad)) {
                          d = !1;
                          break;
                        }
                      if (d)
                        return;
                    }
                    for (y.length = 0, l = 0; l < this.controllers.length; l++)
                      y.push(this.controllers[l]);
                    this.oldControllersLength = this.controllers.length, this.el.emit("controllersupdated", void 0, !1);
                  }
                }
              });
            }
          ),
          /***/
          "./src/systems/webxr.js": (
            /*!******************************!*\
              !*** ./src/systems/webxr.js ***!
              \******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../core/system */
                "./src/core/system.js"
              ).registerSystem, w = v(
                /*! ../utils/ */
                "./src/utils/index.js"
              ), E = w.debug("systems:webxr:warn");
              j.exports.System = C("webxr", {
                schema: {
                  referenceSpaceType: {
                    type: "string",
                    default: "local-floor"
                  },
                  requiredFeatures: {
                    type: "array",
                    default: ["local-floor"]
                  },
                  optionalFeatures: {
                    type: "array",
                    default: ["bounded-floor"]
                  },
                  overlayElement: {
                    type: "selector"
                  }
                },
                update: function() {
                  var y = this.data;
                  this.sessionConfiguration = {
                    requiredFeatures: y.requiredFeatures,
                    optionalFeatures: y.optionalFeatures
                  }, this.sessionReferenceSpaceType = y.referenceSpaceType, y.overlayElement && (y.overlayElement.classList.remove("a-dom-overlay"), y.optionalFeatures.includes("dom-overlay") || (y.optionalFeatures.push("dom-overlay"), this.el.setAttribute("webxr", y)), this.warnIfFeatureNotRequested("dom-overlay"), this.sessionConfiguration.domOverlay = {
                    root: y.overlayElement
                  }, y.overlayElement.classList.add("a-dom-overlay"));
                },
                wasFeatureRequested: function(y) {
                  return !!(y === "viewer" || y === "local" || this.sessionConfiguration.requiredFeatures.includes(y) || this.sessionConfiguration.optionalFeatures.includes(y));
                },
                warnIfFeatureNotRequested: function(y, l) {
                  if (!this.wasFeatureRequested(y)) {
                    var d = 'Please add the feature "' + y + `" to a-scene's webxr system options in requiredFeatures/optionalFeatures.`;
                    E((l ? l + " " : "") + d);
                  }
                }
              });
            }
          ),
          /***/
          "./src/utils/coordinates.js": (
            /*!**********************************!*\
              !*** ./src/utils/coordinates.js ***!
              \**********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./debug */
                "./src/utils/debug.js"
              ), w = C("utils:coordinates:warn"), E = ["x", "y", "z", "w"], y = /^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/;
              j.exports.regex = y;
              var l = /\s+/g;
              function d(u, f, x) {
                var T, b, D, S, U = x && typeof x == "object" ? x : {}, G, Z, W, ie;
                if (u && u instanceof Object)
                  return G = u.x === void 0 ? f && f.x : u.x, Z = u.y === void 0 ? f && f.y : u.y, W = u.z === void 0 ? f && f.z : u.z, ie = u.w === void 0 ? f && f.w : u.w, G != null && (U.x = A(G)), Z != null && (U.y = A(Z)), W != null && (U.z = A(W)), ie != null && (U.w = A(ie)), U;
                if (u == null)
                  return typeof f == "object" ? Object.assign(U, f) : f;
                for (T = u.trim().split(l), S = 0; S < E.length; S++)
                  if (D = E[S], T[S])
                    U[D] = parseFloat(T[S], 10);
                  else {
                    if (b = f && f[D], b === void 0)
                      continue;
                    U[D] = A(b);
                  }
                return U;
              }
              j.exports.parse = d;
              function p(u) {
                var f;
                return typeof u != "object" ? u : (f = u.x + " " + u.y, u.z != null && (f += " " + u.z), u.w != null && (f += " " + u.w), f);
              }
              j.exports.stringify = p;
              function c(u, f) {
                return typeof u != "object" || typeof f != "object" ? u === f : u.x === f.x && u.y === f.y && u.z === f.z && u.w === f.w;
              }
              j.exports.equals = c;
              function g(u) {
                return y.test(u);
              }
              j.exports.isCoordinates = g, j.exports.isCoordinate = function(u) {
                return w("`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"), g(u);
              };
              function A(u) {
                return u != null && u.constructor === String ? parseFloat(u, 10) : u;
              }
              j.exports.toVector3 = function(u) {
                return new THREE.Vector3(u.x, u.y, u.z);
              };
            }
          ),
          /***/
          "./src/utils/debug.js": (
            /*!****************************!*\
              !*** ./src/utils/debug.js ***!
              \****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! debug */
                "./node_modules/debug/src/browser.js"
              ), w = v(
                /*! ./device */
                "./src/utils/device.js"
              ).isBrowserEnvironment, E = {
                colors: {
                  debug: "gray",
                  error: "red",
                  info: "gray",
                  warn: "orange"
                }
              };
              C.formatArgs = y;
              function y(g) {
                if (g[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + g[0] + (this.useColors ? "%c " : " "), !!this.useColors) {
                  this.color = d(this.namespace);
                  var A = "color: " + this.color;
                  g.splice(1, 0, A, "color: inherit");
                  var u = 0, f = 0;
                  g[0].replace(/%[a-zA-Z%]/g, function(x) {
                    x !== "%%" && (u++, x === "%c" && (f = u));
                  }), g.splice(f, 0, A);
                }
              }
              function l(g) {
                var A = g.split(":");
                return A[A.length - 1];
              }
              function d(g) {
                var A = l(g), u = E.colors[A];
                return u || null;
              }
              function p() {
                try {
                  return window.localStorage;
                } catch {
                }
              }
              var c = p();
              c && (parseInt(c.logs, 10) || c.logs === "true") ? C.enable("*") : C.enable("*:error,*:info,*:warn"), w && (window.logs = C), j.exports = C;
            }
          ),
          /***/
          "./src/utils/device.js": (
            /*!*****************************!*\
              !*** ./src/utils/device.js ***!
              \*****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! debug */
                "./node_modules/debug/src/browser.js"
              )("device:error"), w, E = !1, y = !1, l = j.exports.isWebXRAvailable = navigator.xr !== void 0;
              if (window.addEventListener("vrdisplayactivate", function(W) {
                var ie;
                l || (ie = document.createElement("canvas"), w = W.display, ie.getContext("webgl", {}), w.requestPresent([{
                  source: ie
                }]).then(function() {
                }, function() {
                }));
              }), l) {
                var d = function() {
                  var W = document.querySelector("a-scene");
                  if (!W) {
                    window.addEventListener("DOMContentLoaded", d);
                    return;
                  }
                  W.hasLoaded ? W.components["xr-mode-ui"].updateEnterInterfaces() : W.addEventListener("loaded", d);
                }, p = function(W) {
                  C("WebXR session support error: " + W.message);
                };
                navigator.xr.isSessionSupported ? (navigator.xr.isSessionSupported("immersive-vr").then(function(W) {
                  E = W, d();
                }).catch(p), navigator.xr.isSessionSupported("immersive-ar").then(function(W) {
                  y = W, d();
                }).catch(function() {
                })) : navigator.xr.supportsSession ? (navigator.xr.supportsSession("immersive-vr").then(function() {
                  E = !0, d();
                }).catch(p), navigator.xr.supportsSession("immersive-ar").then(function() {
                  y = !0, d();
                }).catch(function() {
                })) : C("WebXR has neither isSessionSupported or supportsSession?!");
              } else
                navigator.getVRDisplays && navigator.getVRDisplays().then(function(W) {
                  var ie = document.querySelector("a-scene");
                  w = W.length && W[0], ie && ie.emit("displayconnected", {
                    vrDisplay: w
                  });
                });
              function c() {
                return w;
              }
              j.exports.getVRDisplay = c;
              function g() {
                return E || y || !!c();
              }
              j.exports.checkHeadsetConnected = g;
              function A() {
                return y;
              }
              j.exports.checkARSupport = A;
              function u() {
                return E;
              }
              j.exports.checkVRSupport = u;
              var f = function() {
                var W = !1;
                return function(ie) {
                  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(ie) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ie.substr(0, 4))) && (W = !0), (b() || x() || Z()) && (W = !0), G() && (W = !1);
                }(window.navigator.userAgent || window.navigator.vendor || window.opera), function() {
                  return W;
                };
              }();
              j.exports.isMobile = f;
              function x(W) {
                var ie = W || window.navigator.userAgent, te = /Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(ie);
                return te || T();
              }
              j.exports.isTablet = x;
              function T(W, ie, te) {
                var X = W || window.navigator.userAgent, Q = ie || window.navigator.platform, O = te || window.navigator.maxTouchPoints || 0;
                return (Q === "iPad" || Q === "MacIntel") && O > 0 && /Macintosh|Intel|iPad|ipad/i.test(X) && !window.MSStream;
              }
              j.exports.isIpad = T;
              function b() {
                return /iPad|iPhone|iPod/.test(window.navigator.platform);
              }
              j.exports.isIOS = b;
              function D() {
                return !f() && !G() && window.orientation !== void 0;
              }
              j.exports.isMobileDeviceRequestingDesktopSite = D;
              function S() {
                return /(OculusBrowser)/i.test(window.navigator.userAgent);
              }
              j.exports.isOculusBrowser = S;
              function U() {
                return /(Mobile VR)/i.test(window.navigator.userAgent);
              }
              j.exports.isFirefoxReality = U;
              function G() {
                return S() || U();
              }
              j.exports.isMobileVR = G;
              function Z() {
                return /R7 Build/.test(window.navigator.userAgent);
              }
              j.exports.isR7 = Z, j.exports.isLandscape = function() {
                var W = window.orientation;
                return Z() && (W += 90), W === 90 || W === -90;
              }, j.exports.isBrowserEnvironment = typeof process > "u" || process.browser === !0, j.exports.isNodeEnvironment = !j.exports.isBrowserEnvironment;
            }
          ),
          /***/
          "./src/utils/entity.js": (
            /*!*****************************!*\
              !*** ./src/utils/entity.js ***!
              \*****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./split */
                "./src/utils/split.js"
              ).split;
              function w(E, y) {
                y = y || ".";
                var l = C(E, y);
                return l.length === 1 ? l[0] : l;
              }
              j.exports.getComponentPropertyPath = w, j.exports.getComponentProperty = function(E, y, l) {
                var d;
                return l = l || ".", y.indexOf(l) !== -1 ? (d = w(y, l), d.constructor === String ? E.getAttribute(d) : E.getAttribute(d[0])[d[1]]) : E.getAttribute(y);
              }, j.exports.setComponentProperty = function(E, y, l, d) {
                var p;
                if (d = d || ".", y.indexOf(d) !== -1) {
                  p = w(y, d), p.constructor === String ? E.setAttribute(p, l) : E.setAttribute(p[0], p[1], l);
                  return;
                }
                E.setAttribute(y, l);
              };
            }
          ),
          /***/
          "./src/utils/forceCanvasResizeSafariMobile.js": (
            /*!****************************************************!*\
              !*** ./src/utils/forceCanvasResizeSafariMobile.js ***!
              \****************************************************/
            /***/
            (j) => {
              j.exports = function(v) {
                var C = v.style.width, w = v.style.height;
                v.style.width = parseInt(C, 10) + 1 + "px", v.style.height = parseInt(w, 10) + 1 + "px", setTimeout(function() {
                  v.style.width = C, v.style.height = w;
                }, 200);
              };
            }
          ),
          /***/
          "./src/utils/index.js": (
            /*!****************************!*\
              !*** ./src/utils/index.js ***!
              \****************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./debug */
                "./src/utils/debug.js"
              ), w = v(
                /*! deep-assign */
                "./node_modules/deep-assign/index.js"
              ), E = v(
                /*! ./device */
                "./src/utils/device.js"
              ), y = v(
                /*! ./object-pool */
                "./src/utils/object-pool.js"
              ), l = C("utils:warn");
              j.exports.bind = function(p) {
                return p.bind.apply(p, Array.prototype.slice.call(arguments, 1));
              }, j.exports.coordinates = v(
                /*! ./coordinates */
                "./src/utils/coordinates.js"
              ), j.exports.debug = C, j.exports.device = E, j.exports.entity = v(
                /*! ./entity */
                "./src/utils/entity.js"
              ), j.exports.forceCanvasResizeSafariMobile = v(
                /*! ./forceCanvasResizeSafariMobile */
                "./src/utils/forceCanvasResizeSafariMobile.js"
              ), j.exports.material = v(
                /*! ./material */
                "./src/utils/material.js"
              ), j.exports.objectPool = y, j.exports.split = v(
                /*! ./split */
                "./src/utils/split.js"
              ).split, j.exports.styleParser = v(
                /*! ./styleParser */
                "./src/utils/styleParser.js"
              ), j.exports.trackedControls = v(
                /*! ./tracked-controls */
                "./src/utils/tracked-controls.js"
              ), j.exports.checkHeadsetConnected = function() {
                return l("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"), E.checkHeadsetConnected(arguments);
              }, j.exports.isGearVR = j.exports.device.isGearVR = function() {
                l("`utils.isGearVR` has been deprecated, use `utils.device.isMobileVR`");
              }, j.exports.isIOS = function() {
                return l("`utils.isIOS` has moved to `utils.device.isIOS`"), E.isIOS(arguments);
              }, j.exports.isOculusGo = j.exports.device.isOculusGo = function() {
                l("`utils.isOculusGo` has been deprecated, use `utils.device.isMobileVR`");
              }, j.exports.isMobile = function() {
                return l("`utils.isMobile has moved to `utils.device.isMobile`"), E.isMobile(arguments);
              }, j.exports.throttle = function(p, c, g) {
                var A;
                return g && (p = p.bind(g)), function() {
                  var u = Date.now(), f = typeof A > "u" ? c : u - A;
                  (typeof A > "u" || f >= c) && (A = u, p.apply(null, arguments));
                };
              }, j.exports.throttleLeadingAndTrailing = function(p, c, g) {
                var A, u;
                g && (p = p.bind(g));
                var f, x = function() {
                  A = Date.now(), p.apply(this, f), u = void 0;
                };
                return function() {
                  var T = Date.now(), b = typeof A > "u" ? c : T - A;
                  b >= c ? (clearTimeout(u), u = void 0, A = T, p.apply(null, arguments)) : (u = u || setTimeout(x, c - b), f = arguments);
                };
              }, j.exports.throttleTick = function(p, c, g) {
                var A;
                return g && (p = p.bind(g)), function(u, f) {
                  var x = typeof A > "u" ? f : u - A;
                  (typeof A > "u" || x >= c) && (A = u, p(u, x));
                };
              }, j.exports.debounce = function(p, c, g) {
                var A;
                return function() {
                  var u = this, f = arguments, x = function() {
                    A = null, g || p.apply(u, f);
                  }, T = g && !A;
                  clearTimeout(A), A = setTimeout(x, c), T && p.apply(u, f);
                };
              }, j.exports.extend = Object.assign, j.exports.extendDeep = w, j.exports.clone = function(p) {
                return JSON.parse(JSON.stringify(p));
              };
              var d = function() {
                var p = y.createPool(function() {
                  return [];
                });
                return function(c, g) {
                  var A, u, f, x, T, b;
                  if (c === void 0 || g === void 0 || c === null || g === null || !(c && g && c.constructor === Object && g.constructor === Object || c.constructor === Array && g.constructor === Array))
                    return c === g;
                  u = p.use(), f = p.use(), u.length = 0, f.length = 0;
                  for (A in c)
                    u.push(A);
                  for (A in g)
                    f.push(A);
                  if (u.length !== f.length)
                    return p.recycle(u), p.recycle(f), !1;
                  for (x = 0; x < u.length; ++x)
                    if (T = c[u[x]], b = g[u[x]], typeof T == "object" || typeof b == "object" || Array.isArray(T) && Array.isArray(b)) {
                      if (T === b)
                        continue;
                      if (!d(T, b))
                        return p.recycle(u), p.recycle(f), !1;
                    } else if (T !== b)
                      return p.recycle(u), p.recycle(f), !1;
                  return p.recycle(u), p.recycle(f), !0;
                };
              }();
              j.exports.deepEqual = d, j.exports.diff = /* @__PURE__ */ function() {
                var p = [];
                return function(c, g, A) {
                  var u, f, x, T, b, D, S;
                  T = A || {}, p.length = 0;
                  for (b in c)
                    p.push(b);
                  if (!g)
                    return T;
                  for (x in g)
                    p.indexOf(x) === -1 && p.push(x);
                  for (D = 0; D < p.length; D++)
                    b = p[D], u = c[b], f = g[b], S = u && f && u.constructor === Object && f.constructor === Object, (S && !d(u, f) || !S && u !== f) && (T[b] = f);
                  return T;
                };
              }(), j.exports.shouldCaptureKeyEvent = function(p) {
                return p.metaKey ? !1 : document.activeElement === document.body;
              }, j.exports.splitString = function(p, c) {
                typeof c > "u" && (c = " ");
                var g = new RegExp(c, "g");
                return p = (p || "").replace(g, c), p.split(c);
              }, j.exports.getElData = function(p, c) {
                c = c || {};
                var g = {};
                Object.keys(c).forEach(A);
                function A(u) {
                  p.hasAttribute(u) && (g[u] = p.getAttribute(u));
                }
                return g;
              }, j.exports.getUrlParameter = function(p) {
                p = p.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                var c = new RegExp("[\\?&]" + p + "=([^&#]*)"), g = c.exec(location.search);
                return g === null ? "" : decodeURIComponent(g[1].replace(/\+/g, " "));
              }, j.exports.isIframed = function() {
                return window.top !== window.self;
              }, j.exports.findAllScenes = function(p) {
                for (var c = [], g = p.getElementsByTagName("*"), A = 0, u = g.length; A < u; A++)
                  g[A].isScene && c.push(g[A]);
                return c;
              }, j.exports.srcLoader = v(
                /*! ./src-loader */
                "./src/utils/src-loader.js"
              );
            }
          ),
          /***/
          "./src/utils/ios-orientationchange-blank-bug.js": (
            /*!******************************************************!*\
              !*** ./src/utils/ios-orientationchange-blank-bug.js ***!
              \******************************************************/
            /***/
            () => {
              window.addEventListener("orientationchange", function() {
                document.documentElement.style.height = "initial", setTimeout(function() {
                  document.documentElement.style.height = "100%", setTimeout(function() {
                    window.scrollTo(0, 1);
                  }, 500);
                }, 500);
              });
            }
          ),
          /***/
          "./src/utils/isIOSOlderThan10.js": (
            /*!***************************************!*\
              !*** ./src/utils/isIOSOlderThan10.js ***!
              \***************************************/
            /***/
            (j) => {
              j.exports = function(v) {
                return /(iphone|ipod|ipad).*os.(7_|8_|9_)/i.test(v);
              };
            }
          ),
          /***/
          "./src/utils/material.js": (
            /*!*******************************!*\
              !*** ./src/utils/material.js ***!
              \*******************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../lib/three */
                "./src/lib/three.js"
              ), w = v(
                /*! ./src-loader */
                "./src/utils/src-loader.js"
              ), E = v(
                /*! ./debug */
                "./src/utils/debug.js"
              ), y = E("utils:material:warn"), l = /* @__PURE__ */ new Set(["emissiveMap", "envMap", "map", "specularMap"]);
              function d(u, f) {
                var x = f.offset || {
                  x: 0,
                  y: 0
                }, T = f.repeat || {
                  x: 1,
                  y: 1
                }, b = f.npot || !1, D = f.anisotropy || C.Texture.DEFAULT_ANISOTROPY, S = u.wrapS, U = u.wrapT, G = u.magFilter, Z = u.minFilter;
                b && (S = C.ClampToEdgeWrapping, U = C.ClampToEdgeWrapping, G = C.LinearFilter, Z = C.LinearFilter), (T.x !== 1 || T.y !== 1) && (S = C.RepeatWrapping, U = C.RepeatWrapping), u.offset.set(x.x, x.y), u.repeat.set(T.x, T.y), (u.wrapS !== S || u.wrapT !== U || u.magFilter !== G || u.minFilter !== Z || u.anisotropy !== D) && (u.wrapS = S, u.wrapT = U, u.magFilter = G, u.minFilter = Z, u.anisotropy = D, u.needsUpdate = !0);
              }
              j.exports.setTextureProperties = d, j.exports.updateMapMaterialFromData = function(u, f, x, T) {
                var b = x.el, D = x.material, S = b.sceneEl.systems.renderer, U = T[f];
                if (x.materialSrcs || (x.materialSrcs = {}), !U) {
                  delete x.materialSrcs[u], Z(null);
                  return;
                }
                if (U === x.materialSrcs[u] && D[u]) {
                  d(D[u], T);
                  return;
                }
                x.materialSrcs[u] = U, U instanceof C.Texture ? Z(U) : b.sceneEl.systems.material.loadTextureSource(U, G);
                function G(W) {
                  if (x.materialSrcs[u] === U) {
                    var ie = D[u];
                    ie && (W === null || !g(ie, W)) && (ie = null), !ie && W && (ie = A(W)), ie && (ie.source !== W && (ie.source = W, ie.needsUpdate = !0), l.has(u) && S.applyColorCorrection(ie), d(ie, T)), Z(ie);
                  }
                }
                function Z(W) {
                  D[u] !== W && (D[u] && D[u].dispose(), D[u] = W, D.needsUpdate = !0, c(b, W));
                }
              }, j.exports.updateMap = function(u, f) {
                return j.exports.updateMapMaterialFromData("map", "src", u, f);
              }, j.exports.updateDistortionMap = function(u, f, x) {
                var T = u;
                u === "ambientOcclusion" && (T = "ao");
                var b = {};
                return b.src = x[u + "Map"], b.offset = x[u + "TextureOffset"], b.repeat = x[u + "TextureRepeat"], b.wrap = x[u + "TextureWrap"], j.exports.updateMapMaterialFromData(T + "Map", "src", f, b);
              };
              var p = {};
              j.exports.updateEnvMap = function(u, f) {
                var x = u.material, T = u.el, b = "envMap", D = f.envMap, S = f.sphericalEnvMap, U = f.refract;
                if (S && (D = S, y("`sphericalEnvMap` property is deprecated, using spherical map as equirectangular map instead. Use `envMap` property with a CubeMap or Equirectangular image instead.")), u.materialSrcs || (u.materialSrcs = {}), !D) {
                  delete u.materialSrcs[b], x.envMap = null, x.needsUpdate = !0;
                  return;
                }
                if (u.materialSrcs[b] = D, p[D]) {
                  p[D].then(G);
                  return;
                }
                p[D] = new Promise(function(Z) {
                  w.validateEnvMapSrc(D, function(ie) {
                    T.sceneEl.systems.material.loadCubeMapTexture(ie, function(te) {
                      te.mapping = U ? C.CubeRefractionMapping : C.CubeReflectionMapping, G(te), Z(te);
                    });
                  }, function(ie) {
                    T.sceneEl.systems.material.loadTexture(ie, {
                      src: ie
                    }, function(te) {
                      te.mapping = U ? C.EquirectangularRefractionMapping : C.EquirectangularReflectionMapping, G(te), Z(te);
                    });
                  });
                });
                function G(Z) {
                  u.materialSrcs[b] === D && (x.envMap = Z, x.needsUpdate = !0, c(T, Z));
                }
              };
              function c(u, f) {
                if (!f || (u.emit("materialtextureloaded", {
                  src: f.image,
                  texture: f
                }), !f.image || f.image.tagName !== "VIDEO"))
                  return;
                f.image.addEventListener("loadeddata", x), f.image.addEventListener("ended", T);
                function x() {
                  u.emit("materialvideoloadeddata", {
                    src: f.image,
                    texture: f
                  });
                }
                function T() {
                  u.emit("materialvideoended", {
                    src: f.image,
                    texture: f
                  });
                }
                f.addEventListener("dispose", function() {
                  f.image.removeEventListener("loadeddata", x), f.image.removeEventListener("ended", T);
                });
              }
              j.exports.handleTextureEvents = c;
              function g(u, f) {
                return f.data instanceof HTMLCanvasElement ? u.isCanvasTexture : f.data instanceof HTMLVideoElement ? u.isVideoTexture && u.source === f : u.isTexture && !u.isCanvasTexture && !u.isVideoTexture;
              }
              j.exports.isCompatibleTexture = g;
              function A(u) {
                var f;
                return u.data instanceof HTMLCanvasElement ? f = new C.CanvasTexture() : u.data instanceof HTMLVideoElement ? f = new C.VideoTexture(u.data) : f = new C.Texture(), f.source = u, f.needsUpdate = !0, f;
              }
              j.exports.createCompatibleTexture = A;
            }
          ),
          /***/
          "./src/utils/math.js": (
            /*!***************************!*\
              !*** ./src/utils/math.js ***!
              \***************************/
            /***/
            (j) => {
              function re(C, w, E) {
                var y = w.dot(C);
                return (y - w.dot(E)) / w.length();
              }
              function v(C, w, E, y) {
                var l = re(C, w, E);
                return y.copy(w), y.multiplyScalar(l), y.add(E), y;
              }
              j.exports.distanceOfPointFromPlane = re, j.exports.nearestPointInPlane = v;
            }
          ),
          /***/
          "./src/utils/object-pool.js": (
            /*!**********************************!*\
              !*** ./src/utils/object-pool.js ***!
              \**********************************/
            /***/
            (j) => {
              var re = Object.freeze(/* @__PURE__ */ Object.create(null));
              function v() {
                return {};
              }
              j.exports.createPool = function(y) {
                var l = [], d = null;
                y = y || v;
                function p() {
                  var u;
                  return (d === null || d === l.length) && g(l.length || 5), u = l[d], l[d++] = re, C(u), u;
                }
                function c(u) {
                  if (u instanceof Object) {
                    if (d === null || d === -1) {
                      l[l.length] = u;
                      return;
                    }
                    l[--d] = u;
                  }
                }
                function g(u) {
                  var f, x;
                  if (u = u === void 0 ? l.length : u, u > 0 && d == null && (d = 0), u > 0)
                    for (f = l.length, l.length += Number(u), x = f; x < l.length; x++)
                      l[x] = y();
                  return l.length;
                }
                function A() {
                  return l.length;
                }
                return {
                  grow: g,
                  pool: l,
                  recycle: c,
                  size: A,
                  use: p
                };
              };
              function C(E) {
                var y;
                if (!(!E || E.constructor !== Object))
                  for (y in E)
                    E[y] = void 0;
              }
              j.exports.clearObject = C;
              function w(E, y) {
                var l;
                if (!(!E || E.constructor !== Object))
                  for (l in E)
                    l in y || delete E[l];
              }
              j.exports.removeUnusedKeys = w;
            }
          ),
          /***/
          "./src/utils/split.js": (
            /*!****************************!*\
              !*** ./src/utils/split.js ***!
              \****************************/
            /***/
            (j) => {
              j.exports.split = /* @__PURE__ */ function() {
                var re = {};
                return function(v, C) {
                  return C in re || (re[C] = {}), v in re[C] || (re[C][v] = v.split(C)), re[C][v];
                };
              }();
            }
          ),
          /***/
          "./src/utils/src-loader.js": (
            /*!*********************************!*\
              !*** ./src/utils/src-loader.js ***!
              \*********************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./debug */
                "./src/utils/debug.js"
              ), w = C("utils:src-loader:warn");
              function E(A, u, f) {
                p(A, function(T) {
                  if (T) {
                    u(A);
                    return;
                  }
                  f(A);
                });
              }
              function y(A, u, f) {
                var x, T = "", b, D, S = [];
                if (typeof A == "string") {
                  let G = function(Z) {
                    S.push(Z), S.length === 6 && u(S);
                  };
                  for (b = 0; b < 5; b++)
                    T += "(url\\((?:[^\\)]+)\\),\\s*)";
                  if (T += "(url\\((?:[^\\)]+)\\)\\s*)", D = A.match(new RegExp(T)), D) {
                    for (b = 1; b < 7; b++)
                      E(d(D[b]), G);
                    return;
                  }
                  if (!A.startsWith("#")) {
                    var U = d(A);
                    E(U || A, f);
                    return;
                  }
                }
                if (A.tagName ? x = A : x = g(A), !!x) {
                  if (x.tagName === "A-CUBEMAP" && x.srcs)
                    return u(x.srcs);
                  if (x.tagName === "IMG")
                    return f(x);
                  w('Selector "%s" does not point to <a-cubemap> or <img>', A);
                }
              }
              function l(A, u) {
                return y(A, u, function() {
                  w("Expected cubemap but got image");
                });
              }
              function d(A) {
                var u = A.match(/url\((.+)\)/);
                if (u)
                  return u[1];
              }
              function p(A, u) {
                var f;
                if (A.tagName) {
                  u(A.tagName === "IMG");
                  return;
                }
                f = new XMLHttpRequest(), f.open("HEAD", A), f.addEventListener("load", function(x) {
                  var T;
                  f.status >= 200 && f.status < 300 ? (T = f.getResponseHeader("Content-Type"), T == null ? c(A, u) : T.startsWith("image") ? u(!0) : u(!1)) : c(A, u), f.abort();
                }), f.send();
              }
              function c(A, u) {
                var f = new Image();
                f.addEventListener("load", x);
                function x() {
                  u(!0);
                }
                f.addEventListener("error", T);
                function T() {
                  u(!1);
                }
                f.src = A;
              }
              function g(A) {
                try {
                  var u = document.querySelector(A);
                  return u || w('No element was found matching the selector: "%s"', A), u;
                } catch {
                  w('"%s" is not a valid selector', A);
                  return;
                }
              }
              j.exports = {
                parseUrl: d,
                validateSrc: E,
                validateCubemapSrc: l,
                validateEnvMapSrc: y
              };
            }
          ),
          /***/
          "./src/utils/styleParser.js": (
            /*!**********************************!*\
              !*** ./src/utils/styleParser.js ***!
              \**********************************/
            /***/
            (j) => {
              var re = /-([a-z])/g;
              j.exports.parse = function(l, d) {
                var p;
                return typeof l != "string" || (p = w(l, d), p[""]) ? l : p;
              }, j.exports.stringify = function(l) {
                return typeof l == "string" ? l : E(l);
              };
              function v(l) {
                return l.replace(re, y);
              }
              j.exports.toCamelCase = v;
              var C = /* @__PURE__ */ function() {
                var l = [], d = /url\([^)]+$/;
                return function(c) {
                  var g = "", A, u = 0, f = ";";
                  for (l.length = 0; u < c.length; ) {
                    if (A = c.indexOf(f, u), A === -1 && (A = c.length), g += c.substring(u, A), d.test(g)) {
                      g += ";", u = A + 1;
                      continue;
                    }
                    l.push(g.trim()), g = "", u = A + 1;
                  }
                  return l;
                };
              }();
              function w(l, d) {
                var p, c, g, A, u, f;
                for (d = d || {}, p = C(l), c = 0; c < p.length; c++)
                  g = p[c], g && (A = g.indexOf(":"), u = g.substr(0, A).trim(), f = g.substr(A + 1).trim(), d[v(u)] = f);
                return d;
              }
              function E(l) {
                var d, p = 0, c = 0, g = "";
                for (d in l)
                  p++;
                for (d in l)
                  g += d + ": " + l[d], c < p - 1 && (g += "; "), c++;
                return g;
              }
              function y(l) {
                return l[1].toUpperCase();
              }
            }
          ),
          /***/
          "./src/utils/tracked-controls.js": (
            /*!***************************************!*\
              !*** ./src/utils/tracked-controls.js ***!
              \***************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ../constants */
                "./src/constants/index.js"
              ).DEFAULT_HANDEDNESS, w = ["x", "y", "z", "w"], E = 2;
              j.exports.checkControllerPresentAndSetup = function(c, g, A) {
                var u = c.el, f, x = u.sceneEl.hasWebXR, T = x ? l : y, b;
                if (f = T(c, g, A), b = !!f, c.controllerPresent && !c.controllerEventsActive && !x && c.addEventListeners(), b === c.controllerPresent)
                  return b;
                c.controllerPresent = b, b ? (c.addEventListeners(), c.injectTrackedControls(f), u.emit("controllerconnected", {
                  name: c.name,
                  component: c
                })) : (c.removeEventListeners(), u.emit("controllerdisconnected", {
                  name: c.name,
                  component: c
                }));
              };
              function y(c, g, A) {
                var u, f = c.el.sceneEl, x, T = A.index || 0;
                return !g || (x = f && f.systems["tracked-controls-webvr"], !x) || (u = x.controllers, !u.length) ? !1 : !!d(u, null, g, A.hand, T);
              }
              function l(c, g, A) {
                var u, f = c.el.sceneEl, x = f && f.systems["tracked-controls-webxr"];
                return !x || (u = x.controllers, !u || !u.length) ? !1 : p(u, g, A.hand, A.index, A.iterateControllerProfiles, A.handTracking);
              }
              j.exports.isControllerPresentWebVR = y, j.exports.isControllerPresentWebXR = l;
              function d(c, g, A, u, f) {
                var x, T, b = 0, D = f >= 0 ? f : 0;
                for (T = 0; T < c.length; T++)
                  if (x = c[T], !(A && !x.id.startsWith(A)) && !(!A && x.id !== g) && !(u && x.hand && u !== x.hand)) {
                    if (u && !x.hand)
                      D = E * f + (u === C ? 0 : 1);
                    else
                      return x;
                    if (b === D)
                      return x;
                    ++b;
                  }
              }
              function p(c, g, A, u, f, x) {
                var T, b, D, S = !1, U, G;
                for (T = 0; T < c.length; T++) {
                  if (D = c[T], G = D.profiles, x)
                    S = D.hand;
                  else if (f)
                    for (b = 0; b < G.length && (S = G[b].startsWith(g), !S); b++)
                      ;
                  else
                    S = G.length > 0 && G[0].startsWith(g);
                  if (S) {
                    if (U = D.handedness === "right" || D.handedness === "left", U) {
                      if (D.handedness === A)
                        return c[T];
                    } else if (T === u)
                      return c[T];
                  }
                }
              }
              j.exports.findMatchingControllerWebVR = d, j.exports.findMatchingControllerWebXR = p, j.exports.emitIfAxesChanged = function(c, g, A) {
                var u, f, x, T, b;
                for (f in g) {
                  for (u = g[f], x = !1, b = 0; b < u.length; b++)
                    A.detail.changed[u[b]] && (x = !0);
                  if (x) {
                    for (T = {}, b = 0; b < u.length; b++)
                      T[w[b]] = A.detail.axis[u[b]];
                    c.el.emit(f + "moved", T);
                  }
                }
              }, j.exports.onButtonEvent = function(c, g, A, u) {
                var f = u ? A.mapping[u] : A.mapping, x = f.buttons[c];
                A.el.emit(x + g), A.updateModel && A.updateModel(x, g);
              };
            }
          ),
          /***/
          "./vendor/DeviceOrientationControls.js": (
            /*!*********************************************!*\
              !*** ./vendor/DeviceOrientationControls.js ***!
              \*********************************************/
            /***/
            () => {
              THREE.DeviceOrientationControls = function(j) {
                var re = this;
                this.object = j, this.object.rotation.reorder("YXZ"), this.enabled = !0, this.deviceOrientation = {}, this.screenOrientation = 0, this.alphaOffset = 0;
                var v = function(E) {
                  re.deviceOrientation = E;
                }, C = function() {
                  re.screenOrientation = window.orientation || 0;
                }, w = function() {
                  var E = new THREE.Vector3(0, 0, 1), y = new THREE.Euler(), l = new THREE.Quaternion(), d = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
                  return function(p, c, g, A, u) {
                    y.set(g, c, -A, "YXZ"), p.setFromEuler(y), p.multiply(d), p.multiply(l.setFromAxisAngle(E, -u));
                  };
                }();
                this.connect = function() {
                  C(), window.addEventListener("orientationchange", C, !1), window.addEventListener("deviceorientation", v, !1), re.enabled = !0;
                }, this.disconnect = function() {
                  window.removeEventListener("orientationchange", C, !1), window.removeEventListener("deviceorientation", v, !1), re.enabled = !1;
                }, this.update = function() {
                  if (re.enabled !== !1) {
                    var E = re.deviceOrientation;
                    if (E) {
                      var y = E.alpha ? THREE.MathUtils.degToRad(E.alpha) + re.alphaOffset : 0, l = E.beta ? THREE.MathUtils.degToRad(E.beta) : 0, d = E.gamma ? THREE.MathUtils.degToRad(E.gamma) : 0, p = re.screenOrientation ? THREE.MathUtils.degToRad(re.screenOrientation) : 0;
                      w(re.object.quaternion, y, l, d, p);
                    }
                  }
                }, this.dispose = function() {
                  re.disconnect();
                }, this.connect();
              };
            }
          ),
          /***/
          "./vendor/rStats.extras.js": (
            /*!*********************************!*\
              !*** ./vendor/rStats.extras.js ***!
              \*********************************/
            /***/
            (j) => {
              window.glStats = function() {
                var re = null, v = 0, C = 0, w = 0, E = 0, y = 0, l = 0, d = 0;
                function p(b, D) {
                  return function() {
                    D.apply(this, arguments), b.apply(this, arguments);
                  };
                }
                WebGLRenderingContext.prototype.drawArrays = p(WebGLRenderingContext.prototype.drawArrays, function() {
                  v++, arguments[0] == this.POINTS ? l += arguments[2] : y += arguments[2];
                }), WebGLRenderingContext.prototype.drawElements = p(WebGLRenderingContext.prototype.drawElements, function() {
                  C++, E += arguments[1] / 3, y += arguments[1];
                }), WebGLRenderingContext.prototype.useProgram = p(WebGLRenderingContext.prototype.useProgram, function() {
                  w++;
                }), WebGLRenderingContext.prototype.bindTexture = p(WebGLRenderingContext.prototype.bindTexture, function() {
                  d++;
                });
                var c = {
                  allcalls: {
                    over: 3e3,
                    caption: "Calls (hook)"
                  },
                  drawelements: {
                    caption: "drawElements (hook)"
                  },
                  drawarrays: {
                    caption: "drawArrays (hook)"
                  }
                }, g = [{
                  caption: "WebGL",
                  values: ["allcalls", "drawelements", "drawarrays", "useprogram", "bindtexture", "glfaces", "glvertices", "glpoints"]
                }], A = [{
                  base: "allcalls",
                  steps: ["drawelements", "drawarrays"]
                }];
                function u() {
                  re("allcalls").set(v + C), re("drawElements").set(C), re("drawArrays").set(v), re("bindTexture").set(d), re("useProgram").set(w), re("glfaces").set(E), re("glvertices").set(y), re("glpoints").set(l);
                }
                function f() {
                  v = 0, C = 0, w = 0, E = 0, y = 0, l = 0, d = 0;
                }
                function x() {
                }
                function T(b) {
                  re = b;
                }
                return {
                  update: u,
                  start: f,
                  end: x,
                  attach: T,
                  values: c,
                  groups: g,
                  fractions: A
                };
              }, window.threeStats = function(re) {
                var v = null, C = {
                  "renderer.info.memory.geometries": {
                    caption: "Geometries"
                  },
                  "renderer.info.memory.textures": {
                    caption: "Textures"
                  },
                  "renderer.info.programs": {
                    caption: "Programs"
                  },
                  "renderer.info.render.calls": {
                    caption: "Calls"
                  },
                  "renderer.info.render.triangles": {
                    caption: "Triangles",
                    over: 1e3
                  },
                  "renderer.info.render.points": {
                    caption: "Points"
                  }
                }, w = [{
                  caption: "Three.js - Memory",
                  values: ["renderer.info.memory.geometries", "renderer.info.programs", "renderer.info.memory.textures"]
                }, {
                  caption: "Three.js - Render",
                  values: ["renderer.info.render.calls", "renderer.info.render.triangles", "renderer.info.render.points"]
                }], E = [];
                function y() {
                  v("renderer.info.memory.geometries").set(re.info.memory.geometries), v("renderer.info.programs").set(re.info.programs.length), v("renderer.info.memory.textures").set(re.info.memory.textures), v("renderer.info.render.calls").set(re.info.render.calls), v("renderer.info.render.triangles").set(re.info.render.triangles), v("renderer.info.render.points").set(re.info.render.points);
                }
                function l() {
                }
                function d() {
                }
                function p(c) {
                  v = c;
                }
                return {
                  update: y,
                  start: l,
                  end: d,
                  attach: p,
                  values: C,
                  groups: w,
                  fractions: E
                };
              }, window.BrowserStats = function() {
                var re = null, v = 0, C = 0;
                window.performance && !performance.memory && (performance.memory = {
                  usedJSHeapSize: 0,
                  totalJSHeapSize: 0
                }), performance.memory.totalJSHeapSize === 0 && console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");
                var w = {
                  memory: {
                    caption: "Used Memory",
                    average: !0,
                    avgMs: 1e3,
                    over: 22
                  },
                  total: {
                    caption: "Total Memory"
                  }
                }, E = [{
                  caption: "Browser",
                  values: ["memory", "total"]
                }], y = [{
                  base: "total",
                  steps: ["memory"]
                }], l = Math.log(1024);
                function d(u) {
                  var f = 100, x = Math.floor(Math.log(u) / l);
                  return Math.round(u * f / Math.pow(1024, x)) / f;
                }
                function p() {
                  v = d(performance.memory.usedJSHeapSize), C = d(performance.memory.totalJSHeapSize), re("memory").set(v), re("total").set(C);
                }
                function c() {
                  v = 0;
                }
                function g() {
                }
                function A(u) {
                  re = u;
                }
                return {
                  update: p,
                  start: c,
                  end: g,
                  attach: A,
                  values: w,
                  groups: E,
                  fractions: y
                };
              }, j.exports = {
                glStats: window.glStats,
                threeStats: window.threeStats,
                BrowserStats: window.BrowserStats
              };
            }
          ),
          /***/
          "./vendor/rStats.js": (
            /*!**************************!*\
              !*** ./vendor/rStats.js ***!
              \**************************/
            /***/
            (j) => {
              (function() {
                "performance" in window || (window.performance = {});
                var re = window.performance;
                if (!("now" in re)) {
                  var v = Date.now();
                  re.timing && re.timing.navigationStart && (v = re.timing.navigationStart), re.now = function() {
                    return Date.now() - v;
                  };
                }
                re.mark || (re.mark = function() {
                }), re.measure || (re.measure = function() {
                });
              })(), window.rStats = function(v) {
                function C(G, Z) {
                  for (var W = Object.keys(G), ie = 0, te = W.length; ie < te; ie++)
                    Z(W[ie]);
                }
                function w(G) {
                  var Z = document.createElement("link");
                  Z.href = G, Z.rel = "stylesheet", Z.type = "text/css", document.getElementsByTagName("head")[0].appendChild(Z);
                }
                var E = v || {}, y = E.colours || ["#850700", "#c74900", "#fcb300", "#284280", "#4c7c0c"], l = "https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300", d = (E.CSSPath ? E.CSSPath : "") + "rStats.css", p = E.css || [l, d];
                p.forEach(function(G) {
                  w(G);
                }), E.values || (E.values = {});
                var c, g, A = 10, u = 200, f = {};
                function x(G, Z, W) {
                  var ie = W || {}, te = document.createElement("canvas"), X = te.getContext("2d"), Q = 0, O = 0, K = ie.color ? ie.color : "#666666", ne = document.createElement("canvas"), pe = ne.getContext("2d");
                  ne.width = 1, ne.height = 2 * A, pe.fillStyle = "#444444", pe.fillRect(0, 0, 1, 2 * A), pe.fillStyle = K, pe.fillRect(0, A, 1, A), pe.fillStyle = "#ffffff", pe.globalAlpha = 0.5, pe.fillRect(0, A, 1, 1), pe.globalAlpha = 1;
                  var be = document.createElement("canvas"), Te = be.getContext("2d");
                  be.width = 1, be.height = 2 * A, Te.fillStyle = "#444444", Te.fillRect(0, 0, 1, 2 * A), Te.fillStyle = "#b70000", Te.fillRect(0, A, 1, A), Te.globalAlpha = 0.5, Te.fillStyle = "#ffffff", Te.fillRect(0, A, 1, 1), Te.globalAlpha = 1;
                  function ke() {
                    te.width = u, te.height = A, te.style.width = te.width + "px", te.style.height = te.height + "px", te.className = "rs-canvas", G.appendChild(te), X.fillStyle = "#444444", X.fillRect(0, 0, te.width, te.height);
                  }
                  function Ve(st, ut) {
                    O += (st - O) * 0.1, Q *= 0.99, O > Q && (Q = O), X.drawImage(te, 1, 0, te.width - 1, te.height, 0, 0, te.width - 1, te.height), ut ? X.drawImage(be, te.width - 1, te.height - O * te.height / Q - A) : X.drawImage(ne, te.width - 1, te.height - O * te.height / Q - A);
                  }
                  return ke(), {
                    draw: Ve
                  };
                }
                function T(G, Z) {
                  var W = document.createElement("canvas"), ie = W.getContext("2d");
                  function te() {
                    W.width = u, W.height = A * Z, W.style.width = W.width + "px", W.style.height = W.height + "px", W.className = "rs-canvas", G.appendChild(W), ie.fillStyle = "#444444", ie.fillRect(0, 0, W.width, W.height);
                  }
                  function X(Q) {
                    ie.drawImage(W, 1, 0, W.width - 1, W.height, 0, 0, W.width - 1, W.height);
                    var O = 0;
                    C(Q, function(K) {
                      var ne = Q[K] * W.height;
                      ie.fillStyle = y[K], ie.fillRect(W.width - 1, O, 1, ne), O += ne;
                    });
                  }
                  return te(), {
                    draw: X
                  };
                }
                function b(G, Z) {
                  var W = G, ie, te = 0, X = 0, Q = 0, O = 0, K = performance.now(), ne = 0, pe = document.createElement("div"), be = document.createElement("span"), Te = document.createElement("div"), ke = document.createTextNode(""), Ve = E.values[W.toLowerCase()], st = new x(pe, W, Ve), ut = !1;
                  be.className = "rs-counter-id", be.textContent = Ve && Ve.caption ? Ve.caption : W, Te.className = "rs-counter-value", Te.appendChild(ke), pe.appendChild(be), pe.appendChild(Te), Z ? Z.div.appendChild(pe) : g.appendChild(pe), ie = performance.now();
                  function It(wn) {
                    if (Ve && Ve.average) {
                      O += wn, ne++;
                      var rn = performance.now();
                      rn - K >= (Ve.avgMs || 1e3) && (Q = O / ne, O = 0, K = rn, ne = 0);
                    }
                  }
                  function ht() {
                    ie = performance.now(), E.userTimingAPI && performance.mark(W + "-start"), ut = !0;
                  }
                  function Rt() {
                    te = performance.now() - ie, E.userTimingAPI && (performance.mark(W + "-end"), ut && performance.measure(W, W + "-start", W + "-end")), It(te);
                  }
                  function Qt() {
                    Rt(), ht();
                  }
                  function cn() {
                    var wn = Ve && Ve.average ? Q : te;
                    ke.nodeValue = Math.round(wn * 100) / 100;
                    var rn = Ve && (Ve.below && te < Ve.below || Ve.over && te > Ve.over);
                    st.draw(te, rn), pe.className = rn ? "rs-counter-base alarm" : "rs-counter-base";
                  }
                  function Cn() {
                    var wn = performance.now(), rn = wn - ie;
                    X++, rn > 1e3 && (Ve && Ve.interpolate === !1 ? te = X : te = X * 1e3 / rn, X = 0, ie = wn, It(te));
                  }
                  function Tn(wn) {
                    te = wn, It(te);
                  }
                  return {
                    set: Tn,
                    start: ht,
                    tick: Qt,
                    end: Rt,
                    frame: Cn,
                    value: function() {
                      return te;
                    },
                    draw: cn
                  };
                }
                function D(G) {
                  var Z = G.toLowerCase();
                  if (Z === void 0 && (Z = "default"), f[Z]) return f[Z];
                  var W = null;
                  E.groups && C(E.groups, function(te) {
                    var X = E.groups[parseInt(te, 10)];
                    !W && X.values.indexOf(Z.toLowerCase()) !== -1 && (W = X);
                  });
                  var ie = new b(Z, W);
                  return f[Z] = ie, ie;
                }
                function S() {
                  if (E.plugins) {
                    E.values || (E.values = {}), E.groups || (E.groups = []), E.fractions || (E.fractions = []);
                    for (var G = 0; G < E.plugins.length; G++)
                      E.plugins[G].attach(D), C(E.plugins[G].values, function(Z) {
                        E.values[Z] = E.plugins[G].values[Z];
                      }), E.groups = E.groups.concat(E.plugins[G].groups), E.fractions = E.fractions.concat(E.plugins[G].fractions);
                  } else
                    E.plugins = {};
                  c = document.createElement("div"), c.className = "rs-base", g = document.createElement("div"), g.className = "rs-container", g.style.height = "auto", c.appendChild(g), document.body.appendChild(c), E && (E.groups && C(E.groups, function(Z) {
                    var W = E.groups[parseInt(Z, 10)], ie = document.createElement("div");
                    ie.className = "rs-group", W.div = ie;
                    var te = document.createElement("h1");
                    te.textContent = W.caption, te.addEventListener("click", function(X) {
                      this.classList.toggle("hidden"), X.preventDefault();
                    }.bind(ie)), g.appendChild(te), g.appendChild(ie);
                  }), E.fractions && C(E.fractions, function(Z) {
                    var W = E.fractions[parseInt(Z, 10)], ie = document.createElement("div");
                    ie.className = "rs-fraction";
                    var te = document.createElement("div");
                    te.className = "rs-legend";
                    var X = 0;
                    C(E.fractions[Z].steps, function(O) {
                      var K = document.createElement("p");
                      K.textContent = E.fractions[Z].steps[O], K.style.color = y[X], te.appendChild(K), X++;
                    }), ie.appendChild(te), ie.style.height = X * A + "px", W.div = ie;
                    var Q = new T(ie, X);
                    W.graph = Q, g.appendChild(ie);
                  }));
                }
                function U() {
                  C(E.plugins, function(G) {
                    E.plugins[G].update();
                  }), C(f, function(G) {
                    f[G].draw();
                  }), E.fractions && C(E.fractions, function(G) {
                    var Z = E.fractions[parseInt(G, 10)], W = [], ie = f[Z.base.toLowerCase()];
                    ie && (ie = ie.value(), C(E.fractions[G].steps, function(te) {
                      var X = E.fractions[G].steps[parseInt(te, 10)].toLowerCase(), Q = f[X];
                      Q && W.push(Q.value() / ie);
                    })), Z.graph.draw(W);
                  });
                }
                return S(), function(G) {
                  return G ? D(G) : {
                    element: c,
                    update: U
                  };
                };
              }, j.exports = window.rStats;
            }
          ),
          /***/
          "./vendor/wakelock/util.js": (
            /*!*********************************!*\
              !*** ./vendor/wakelock/util.js ***!
              \*********************************/
            /***/
            (j) => {
              var re = {};
              re.base64 = function(v, C) {
                return "data:" + v + ";base64," + C;
              }, re.isMobile = function() {
                var v = !1;
                return function(C) {
                  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(C) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(C.substr(0, 4))) && (v = !0);
                }(navigator.userAgent || navigator.vendor || window.opera), v;
              }, re.isIOS = function() {
                return /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
              }, re.isIFrame = function() {
                try {
                  return window.self !== window.top;
                } catch {
                  return !0;
                }
              }, re.appendQueryParameter = function(v, C, w) {
                var E = v.indexOf("?") < 0 ? "?" : "&";
                return v += E + C + "=" + w, v;
              }, re.getQueryParameter = function(v) {
                v = v.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                var C = new RegExp("[\\?&]" + v + "=([^&#]*)"), w = C.exec(location.search);
                return w === null ? "" : decodeURIComponent(w[1].replace(/\+/g, " "));
              }, re.isLandscapeMode = function() {
                return window.orientation == 90 || window.orientation == -90;
              }, j.exports = re;
            }
          ),
          /***/
          "./vendor/wakelock/wakelock.js": (
            /*!*************************************!*\
              !*** ./vendor/wakelock/wakelock.js ***!
              \*************************************/
            /***/
            (j, re, v) => {
              var C = v(
                /*! ./util.js */
                "./vendor/wakelock/util.js"
              );
              function w() {
                var l = document.createElement("video");
                l.addEventListener("ended", function() {
                  l.play();
                }), this.request = function() {
                  l.paused && (l.src = C.base64("video/webm", "GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="), l.play());
                }, this.release = function() {
                  l.pause(), l.src = "";
                };
              }
              function E() {
                var l = null;
                this.request = function() {
                  l || (l = setInterval(function() {
                    window.location.href = "/", setTimeout(window.stop, 0);
                  }, 15e3));
                }, this.release = function() {
                  l && (clearInterval(l), l = null);
                };
              }
              function y() {
                var l = navigator.userAgent || navigator.vendor || window.opera;
                return l.match(/iPhone/i) || l.match(/iPod/i) ? E : w;
              }
              j.exports = y();
            }
          ),
          /***/
          "./node_modules/css-loader/dist/cjs.js!./src/style/aframe.css": (
            /*!********************************************************************!*\
              !*** ./node_modules/css-loader/dist/cjs.js!./src/style/aframe.css ***!
              \********************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                default: () => U
                /* harmony export */
              });
              var C = v(
                /*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */
                "./node_modules/css-loader/dist/runtime/sourceMaps.js"
              ), w = /* @__PURE__ */ v.n(C), E = v(
                /*! ../../node_modules/css-loader/dist/runtime/api.js */
                "./node_modules/css-loader/dist/runtime/api.js"
              ), y = /* @__PURE__ */ v.n(E), l = v(
                /*! ../../node_modules/css-loader/dist/runtime/getUrl.js */
                "./node_modules/css-loader/dist/runtime/getUrl.js"
              ), d = /* @__PURE__ */ v.n(l), p = new URL(
                /* asset import */
                v(
                  /*! data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E */
                  "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"
                ),
                v.b
              ), c = new URL(
                /* asset import */
                v(
                  /*! data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E */
                  "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"
                ),
                v.b
              ), g = new URL(
                /* asset import */
                v(
                  /*! data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E */
                  "data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"
                ),
                v.b
              ), A = new URL(
                /* asset import */
                v(
                  /*! data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E */
                  "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"
                ),
                v.b
              ), u = new URL(
                /* asset import */
                v(
                  /*! data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E */
                  "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"
                ),
                v.b
              ), f = y()(w()), x = d()(p), T = d()(c), b = d()(g), D = d()(A), S = d()(u);
              f.push([j.id, `/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url(` + x + `) 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url(` + T + `) 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url(` + b + `);
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(` + D + `) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(` + S + `) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`, "", { version: 3, sources: ["webpack://./src/style/aframe.css"], names: [], mappings: "AAAA,sCAAsC;AACtC;EACE,SAAS;EACT,OAAO;EACP,eAAe;EACf,QAAQ;EACR,MAAM;AACR;;AAEA;EACE,YAAY;EACZ,SAAS;EACT,gBAAgB;EAChB,UAAU;EACV,WAAW;AACb;;AAEA,oDAAoD;AACpD;EACE,sBAAsB;EACtB,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;AAC5B;;AAEA;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,WAAW;AACb;;AAEA,gEAAgE;AAChE;EACE,6BAA6B;AAC/B;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,yBAAyB;EACzB,eAAe;EACf,SAAS;EACT,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,qBAAqB;EACrB,eAAe;EACf,8BAA8B;EAC9B,kBAAkB;EAClB,cAAc;EACd,YAAY;AACd;;AAEA,+BAA+B;AAC/B,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;;AAErE;EACE,sCAAsC;EACtC,8CAA8C;AAChD;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;AACb;;AAEA;;;;EAIE,aAAa;AACf;;AAEA;;EAEE,0DAA0D;AAC5D;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,qBAAqB;EACrB,6BAA6B;AAC/B;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE,kCAAkC;EAClC,eAAe;EACf,WAAW;EACX,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;AACb;;AAEA;;;EAGE,WAAW;EACX,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,yFAA4qB;AAC9qB;;AAEA;EACE,yFAAkzB;AACpzB;;AAEA;EACE,yDAA2qK;AAC7qK;;AAEA;;EAEE,wBAAwB;EACxB,SAAS;EACT,SAAS;EACT,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB;;;;GAIC;EACD,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,sCAAsC;EACtC,8CAA8C;EAC9C,aAAa;EACb,kBAAkB;EAClB,0BAA0B,EAAE,8CAA8C;AAC5E;;AAEA;EACE,yBAAyB;EACzB,kBAAkB;AACpB;;AAEA;;;;EAIE,yBAAyB;AAC3B;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,sBAAsB;EACtB,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,qCAAqC;EACrC,4BAA4B;EAC5B,kCAAkC;EAClC,qBAAqB;EACrB,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,QAAQ;EACR,SAAS;AACX;;AAEA;;EAEE,eAAe;AACjB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2FAAivF;EACjvF,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,8CAA8C;EAC9C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,6DAA25B;EAC35B,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,WAAW;AACb;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,SAAS;EACT,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,+BAA+B;EAC/B,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,eAAe;EACf,YAAY;EACZ,aAAa;EACb,wBAAwB;EACxB,uBAAuB;EACvB,kCAAkC;EAClC,eAAe;EACf,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,uBAAuB;EACvB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,eAAe;EACf,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,oBAAoB;EACpB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,UAAU;EACV,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,qBAAqB;EACrB,yCAAyC;EACzC,iCAAiC;EACjC,wEAAwE;EACxE,iBAAiB;AACnB;;AAEA;EACE,mEAAmE;AACrE;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,oBAAoB;EACpB,sBAAsB;EACtB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,YAAY;AACd;;AAEA;EACE,oBAAoB;AACtB", sourcesContent: [`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z' fill='%23fff'/%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z' fill='%23fff'/%3E%3Cpath d='M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z' fill='%23fff'/%3E%3Cpath d='M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg width='108' height='62' viewBox='0 0 108 62' version='1.1' id='svg320' sodipodi:docname='fullscreen-aframe.svg' xml:space='preserve' inkscape:version='1.2.1 (9c6d41e  2022-07-14)' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:cc='http://creativecommons.org/ns%23' xmlns:dc='http://purl.org/dc/elements/1.1/'%3E%3Cdefs id='defs324' /%3E%3Csodipodi:namedview id='namedview322' pagecolor='%23ffffff' bordercolor='%23000000' borderopacity='0.25' inkscape:showpageshadow='2' inkscape:pageopacity='0.0' inkscape:pagecheckerboard='0' inkscape:deskcolor='%23d1d1d1' showgrid='false' inkscape:zoom='3.8064516' inkscape:cx='91.423729' inkscape:cy='-1.4449153' inkscape:window-width='1440' inkscape:window-height='847' inkscape:window-x='32' inkscape:window-y='25' inkscape:window-maximized='0' inkscape:current-layer='svg320' /%3E%3Ctitle id='title312'%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z' fill='%23fff' id='path314' style='fill:%23ffffff' /%3E%3Cg id='g356' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g358' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g360' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g362' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g364' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g366' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g368' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g370' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g372' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g374' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g376' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g378' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g380' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g382' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g384' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cmetadata id='metadata561'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d='m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4' id='path596' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4' id='path598' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4' id='path600' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616' id='path602' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3C/svg%3E");
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`], sourceRoot: "" }]);
              const U = f;
            }
          ),
          /***/
          "./node_modules/css-loader/dist/cjs.js!./src/style/rStats.css": (
            /*!********************************************************************!*\
              !*** ./node_modules/css-loader/dist/cjs.js!./src/style/rStats.css ***!
              \********************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                default: () => d
                /* harmony export */
              });
              var C = v(
                /*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */
                "./node_modules/css-loader/dist/runtime/sourceMaps.js"
              ), w = /* @__PURE__ */ v.n(C), E = v(
                /*! ../../node_modules/css-loader/dist/runtime/api.js */
                "./node_modules/css-loader/dist/runtime/api.js"
              ), y = /* @__PURE__ */ v.n(E), l = y()(w());
              l.push([j.id, `.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`, "", { version: 3, sources: ["webpack://./src/style/rStats.css"], names: [], mappings: "AAAA;EACE,sBAAsB;EACtB,cAAc;EACd,gBAAgB;EAChB,oBAAoB;EACpB,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,eAAe;EACf,QAAQ;EACR,YAAY;EACZ,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,sCAAsC;EACtC,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,YAAY;EACZ,sCAAsC;EACtC,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,cAAc;EACd;;;;;;;;2BAQyB;AAC3B;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,iBAAiB;EACjB,WAAW;AACb;;AAEA;EACE,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;AACV;;AAEA;EACE;IACE,UAAU;IACV,SAAS;EACX;AACF", sourcesContent: [`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`], sourceRoot: "" }]);
              const d = l;
            }
          ),
          /***/
          "./src/style/aframe.css": (
            /*!******************************!*\
              !*** ./src/style/aframe.css ***!
              \******************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                default: () => b
                /* harmony export */
              });
              var C = v(
                /*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
                "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"
              ), w = /* @__PURE__ */ v.n(C), E = v(
                /*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */
                "./node_modules/style-loader/dist/runtime/styleDomAPI.js"
              ), y = /* @__PURE__ */ v.n(E), l = v(
                /*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */
                "./node_modules/style-loader/dist/runtime/insertBySelector.js"
              ), d = /* @__PURE__ */ v.n(l), p = v(
                /*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */
                "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"
              ), c = /* @__PURE__ */ v.n(p), g = v(
                /*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */
                "./node_modules/style-loader/dist/runtime/insertStyleElement.js"
              ), A = /* @__PURE__ */ v.n(g), u = v(
                /*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */
                "./node_modules/style-loader/dist/runtime/styleTagTransform.js"
              ), f = /* @__PURE__ */ v.n(u), x = v(
                /*! !!../../node_modules/css-loader/dist/cjs.js!./aframe.css */
                "./node_modules/css-loader/dist/cjs.js!./src/style/aframe.css"
              ), T = {};
              T.styleTagTransform = f(), T.setAttributes = c(), T.insert = d().bind(null, "head"), T.domAPI = y(), T.insertStyleElement = A(), w()(x.default, T);
              const b = x.default && x.default.locals ? x.default.locals : void 0;
            }
          ),
          /***/
          "./src/style/rStats.css": (
            /*!******************************!*\
              !*** ./src/style/rStats.css ***!
              \******************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                default: () => b
                /* harmony export */
              });
              var C = v(
                /*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
                "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"
              ), w = /* @__PURE__ */ v.n(C), E = v(
                /*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */
                "./node_modules/style-loader/dist/runtime/styleDomAPI.js"
              ), y = /* @__PURE__ */ v.n(E), l = v(
                /*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */
                "./node_modules/style-loader/dist/runtime/insertBySelector.js"
              ), d = /* @__PURE__ */ v.n(l), p = v(
                /*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */
                "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"
              ), c = /* @__PURE__ */ v.n(p), g = v(
                /*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */
                "./node_modules/style-loader/dist/runtime/insertStyleElement.js"
              ), A = /* @__PURE__ */ v.n(g), u = v(
                /*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */
                "./node_modules/style-loader/dist/runtime/styleTagTransform.js"
              ), f = /* @__PURE__ */ v.n(u), x = v(
                /*! !!../../node_modules/css-loader/dist/cjs.js!./rStats.css */
                "./node_modules/css-loader/dist/cjs.js!./src/style/rStats.css"
              ), T = {};
              T.styleTagTransform = f(), T.setAttributes = c(), T.insert = d().bind(null, "head"), T.domAPI = y(), T.insertStyleElement = A(), w()(x.default, T);
              const b = x.default && x.default.locals ? x.default.locals : void 0;
            }
          ),
          /***/
          "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js": (
            /*!****************************************************************************!*\
              !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
              \****************************************************************************/
            /***/
            (j) => {
              var re = [];
              function v(E) {
                for (var y = -1, l = 0; l < re.length; l++)
                  if (re[l].identifier === E) {
                    y = l;
                    break;
                  }
                return y;
              }
              function C(E, y) {
                for (var l = {}, d = [], p = 0; p < E.length; p++) {
                  var c = E[p], g = y.base ? c[0] + y.base : c[0], A = l[g] || 0, u = "".concat(g, " ").concat(A);
                  l[g] = A + 1;
                  var f = v(u), x = {
                    css: c[1],
                    media: c[2],
                    sourceMap: c[3],
                    supports: c[4],
                    layer: c[5]
                  };
                  if (f !== -1)
                    re[f].references++, re[f].updater(x);
                  else {
                    var T = w(x, y);
                    y.byIndex = p, re.splice(p, 0, {
                      identifier: u,
                      updater: T,
                      references: 1
                    });
                  }
                  d.push(u);
                }
                return d;
              }
              function w(E, y) {
                var l = y.domAPI(y);
                l.update(E);
                var d = function(c) {
                  if (c) {
                    if (c.css === E.css && c.media === E.media && c.sourceMap === E.sourceMap && c.supports === E.supports && c.layer === E.layer)
                      return;
                    l.update(E = c);
                  } else
                    l.remove();
                };
                return d;
              }
              j.exports = function(E, y) {
                y = y || {}, E = E || [];
                var l = C(E, y);
                return function(p) {
                  p = p || [];
                  for (var c = 0; c < l.length; c++) {
                    var g = l[c], A = v(g);
                    re[A].references--;
                  }
                  for (var u = C(p, y), f = 0; f < l.length; f++) {
                    var x = l[f], T = v(x);
                    re[T].references === 0 && (re[T].updater(), re.splice(T, 1));
                  }
                  l = u;
                };
              };
            }
          ),
          /***/
          "./node_modules/style-loader/dist/runtime/insertBySelector.js": (
            /*!********************************************************************!*\
              !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
              \********************************************************************/
            /***/
            (j) => {
              var re = {};
              function v(w) {
                if (typeof re[w] > "u") {
                  var E = document.querySelector(w);
                  if (window.HTMLIFrameElement && E instanceof window.HTMLIFrameElement)
                    try {
                      E = E.contentDocument.head;
                    } catch {
                      E = null;
                    }
                  re[w] = E;
                }
                return re[w];
              }
              function C(w, E) {
                var y = v(w);
                if (!y)
                  throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                y.appendChild(E);
              }
              j.exports = C;
            }
          ),
          /***/
          "./node_modules/style-loader/dist/runtime/insertStyleElement.js": (
            /*!**********************************************************************!*\
              !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
              \**********************************************************************/
            /***/
            (j) => {
              function re(v) {
                var C = document.createElement("style");
                return v.setAttributes(C, v.attributes), v.insert(C, v.options), C;
              }
              j.exports = re;
            }
          ),
          /***/
          "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js": (
            /*!**********************************************************************************!*\
              !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
              \**********************************************************************************/
            /***/
            (j, re, v) => {
              function C(w) {
                var E = v.nc;
                E && w.setAttribute("nonce", E);
              }
              j.exports = C;
            }
          ),
          /***/
          "./node_modules/style-loader/dist/runtime/styleDomAPI.js": (
            /*!***************************************************************!*\
              !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
              \***************************************************************/
            /***/
            (j) => {
              function re(w, E, y) {
                var l = "";
                y.supports && (l += "@supports (".concat(y.supports, ") {")), y.media && (l += "@media ".concat(y.media, " {"));
                var d = typeof y.layer < "u";
                d && (l += "@layer".concat(y.layer.length > 0 ? " ".concat(y.layer) : "", " {")), l += y.css, d && (l += "}"), y.media && (l += "}"), y.supports && (l += "}");
                var p = y.sourceMap;
                p && typeof btoa < "u" && (l += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(p)))), " */")), E.styleTagTransform(l, w, E.options);
              }
              function v(w) {
                if (w.parentNode === null)
                  return !1;
                w.parentNode.removeChild(w);
              }
              function C(w) {
                if (typeof document > "u")
                  return {
                    update: function() {
                    },
                    remove: function() {
                    }
                  };
                var E = w.insertStyleElement(w);
                return {
                  update: function(l) {
                    re(E, w, l);
                  },
                  remove: function() {
                    v(E);
                  }
                };
              }
              j.exports = C;
            }
          ),
          /***/
          "./node_modules/style-loader/dist/runtime/styleTagTransform.js": (
            /*!*********************************************************************!*\
              !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
              \*********************************************************************/
            /***/
            (j) => {
              function re(v, C) {
                if (C.styleSheet)
                  C.styleSheet.cssText = v;
                else {
                  for (; C.firstChild; )
                    C.removeChild(C.firstChild);
                  C.appendChild(document.createTextNode(v));
                }
              }
              j.exports = re;
            }
          ),
          /***/
          "data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E": (
            /*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
              !*** data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E ***!
              \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
            /***/
            (j) => {
              j.exports = "data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E";
            }
          ),
          /***/
          "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E": (
            /*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
              !*** data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E ***!
              \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
            /***/
            (j) => {
              j.exports = "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E";
            }
          ),
          /***/
          "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E": (
            /*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
              !*** data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E ***!
              \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
            /***/
            (j) => {
              j.exports = "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E";
            }
          ),
          /***/
          "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E": (
            /*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
              !*** data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E ***!
              \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
            /***/
            (j) => {
              j.exports = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E";
            }
          ),
          /***/
          "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E": (
            /*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
              !*** data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E ***!
              \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
            /***/
            (j) => {
              j.exports = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E";
            }
          ),
          /***/
          "./node_modules/three/build/three.module.js": (
            /*!**************************************************!*\
              !*** ./node_modules/three/build/three.module.js ***!
              \**************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                ACESFilmicToneMapping: () => (
                  /* binding */
                  Xe
                ),
                /* harmony export */
                AddEquation: () => (
                  /* binding */
                  W
                ),
                /* harmony export */
                AddOperation: () => (
                  /* binding */
                  Dt
                ),
                /* harmony export */
                AdditiveAnimationBlendMode: () => (
                  /* binding */
                  us
                ),
                /* harmony export */
                AdditiveBlending: () => (
                  /* binding */
                  S
                ),
                /* harmony export */
                AgXToneMapping: () => (
                  /* binding */
                  ae
                ),
                /* harmony export */
                AlphaFormat: () => (
                  /* binding */
                  jn
                ),
                /* harmony export */
                AlwaysCompare: () => (
                  /* binding */
                  ll
                ),
                /* harmony export */
                AlwaysDepth: () => (
                  /* binding */
                  Tn
                ),
                /* harmony export */
                AlwaysStencilFunc: () => (
                  /* binding */
                  ga
                ),
                /* harmony export */
                AmbientLight: () => (
                  /* binding */
                  qf
                ),
                /* harmony export */
                AnimationAction: () => (
                  /* binding */
                  dp
                ),
                /* harmony export */
                AnimationClip: () => (
                  /* binding */
                  qa
                ),
                /* harmony export */
                AnimationLoader: () => (
                  /* binding */
                  Zv
                ),
                /* harmony export */
                AnimationMixer: () => (
                  /* binding */
                  SE
                ),
                /* harmony export */
                AnimationObjectGroup: () => (
                  /* binding */
                  wE
                ),
                /* harmony export */
                AnimationUtils: () => (
                  /* binding */
                  Xv
                ),
                /* harmony export */
                ArcCurve: () => (
                  /* binding */
                  df
                ),
                /* harmony export */
                ArrayCamera: () => (
                  /* binding */
                  Wu
                ),
                /* harmony export */
                ArrowHelper: () => (
                  /* binding */
                  YE
                ),
                /* harmony export */
                AttachedBindMode: () => (
                  /* binding */
                  fe
                ),
                /* harmony export */
                Audio: () => (
                  /* binding */
                  cp
                ),
                /* harmony export */
                AudioAnalyser: () => (
                  /* binding */
                  AE
                ),
                /* harmony export */
                AudioContext: () => (
                  /* binding */
                  Mh
                ),
                /* harmony export */
                AudioListener: () => (
                  /* binding */
                  dE
                ),
                /* harmony export */
                AudioLoader: () => (
                  /* binding */
                  cE
                ),
                /* harmony export */
                AxesHelper: () => (
                  /* binding */
                  qE
                ),
                /* harmony export */
                BackSide: () => (
                  /* binding */
                  x
                ),
                /* harmony export */
                BasicDepthPacking: () => (
                  /* binding */
                  vs
                ),
                /* harmony export */
                BasicShadowMap: () => (
                  /* binding */
                  c
                ),
                /* harmony export */
                BatchedMesh: () => (
                  /* binding */
                  nf
                ),
                /* harmony export */
                Bone: () => (
                  /* binding */
                  Zu
                ),
                /* harmony export */
                BooleanKeyframeTrack: () => (
                  /* binding */
                  Io
                ),
                /* harmony export */
                Box2: () => (
                  /* binding */
                  OE
                ),
                /* harmony export */
                Box3: () => (
                  /* binding */
                  Zi
                ),
                /* harmony export */
                Box3Helper: () => (
                  /* binding */
                  KE
                ),
                /* harmony export */
                BoxGeometry: () => (
                  /* binding */
                  go
                ),
                /* harmony export */
                BoxHelper: () => (
                  /* binding */
                  WE
                ),
                /* harmony export */
                BufferAttribute: () => (
                  /* binding */
                  Pi
                ),
                /* harmony export */
                BufferGeometry: () => (
                  /* binding */
                  ti
                ),
                /* harmony export */
                BufferGeometryLoader: () => (
                  /* binding */
                  tp
                ),
                /* harmony export */
                ByteType: () => (
                  /* binding */
                  Sr
                ),
                /* harmony export */
                Cache: () => (
                  /* binding */
                  Ns
                ),
                /* harmony export */
                Camera: () => (
                  /* binding */
                  Rl
                ),
                /* harmony export */
                CameraHelper: () => (
                  /* binding */
                  jE
                ),
                /* harmony export */
                CanvasTexture: () => (
                  /* binding */
                  vv
                ),
                /* harmony export */
                CapsuleGeometry: () => (
                  /* binding */
                  oc
                ),
                /* harmony export */
                CatmullRomCurve3: () => (
                  /* binding */
                  ff
                ),
                /* harmony export */
                CineonToneMapping: () => (
                  /* binding */
                  Yt
                ),
                /* harmony export */
                CircleGeometry: () => (
                  /* binding */
                  ac
                ),
                /* harmony export */
                ClampToEdgeWrapping: () => (
                  /* binding */
                  Oe
                ),
                /* harmony export */
                Clock: () => (
                  /* binding */
                  op
                ),
                /* harmony export */
                Color: () => (
                  /* binding */
                  sn
                ),
                /* harmony export */
                ColorKeyframeTrack: () => (
                  /* binding */
                  yh
                ),
                /* harmony export */
                ColorManagement: () => (
                  /* binding */
                  Mi
                ),
                /* harmony export */
                CompressedArrayTexture: () => (
                  /* binding */
                  mv
                ),
                /* harmony export */
                CompressedCubeTexture: () => (
                  /* binding */
                  gv
                ),
                /* harmony export */
                CompressedTexture: () => (
                  /* binding */
                  nc
                ),
                /* harmony export */
                CompressedTextureLoader: () => (
                  /* binding */
                  $v
                ),
                /* harmony export */
                ConeGeometry: () => (
                  /* binding */
                  lc
                ),
                /* harmony export */
                ConstantAlphaFactor: () => (
                  /* binding */
                  Qt
                ),
                /* harmony export */
                ConstantColorFactor: () => (
                  /* binding */
                  ht
                ),
                /* harmony export */
                CubeCamera: () => (
                  /* binding */
                  rd
                ),
                /* harmony export */
                CubeReflectionMapping: () => (
                  /* binding */
                  H
                ),
                /* harmony export */
                CubeRefractionMapping: () => (
                  /* binding */
                  M
                ),
                /* harmony export */
                CubeTexture: () => (
                  /* binding */
                  Ta
                ),
                /* harmony export */
                CubeTextureLoader: () => (
                  /* binding */
                  eE
                ),
                /* harmony export */
                CubeUVReflectionMapping: () => (
                  /* binding */
                  he
                ),
                /* harmony export */
                CubicBezierCurve: () => (
                  /* binding */
                  lh
                ),
                /* harmony export */
                CubicBezierCurve3: () => (
                  /* binding */
                  Af
                ),
                /* harmony export */
                CubicInterpolant: () => (
                  /* binding */
                  kf
                ),
                /* harmony export */
                CullFaceBack: () => (
                  /* binding */
                  l
                ),
                /* harmony export */
                CullFaceFront: () => (
                  /* binding */
                  d
                ),
                /* harmony export */
                CullFaceFrontBack: () => (
                  /* binding */
                  p
                ),
                /* harmony export */
                CullFaceNone: () => (
                  /* binding */
                  y
                ),
                /* harmony export */
                Curve: () => (
                  /* binding */
                  As
                ),
                /* harmony export */
                CurvePath: () => (
                  /* binding */
                  gf
                ),
                /* harmony export */
                CustomBlending: () => (
                  /* binding */
                  Z
                ),
                /* harmony export */
                CustomToneMapping: () => (
                  /* binding */
                  le
                ),
                /* harmony export */
                CylinderGeometry: () => (
                  /* binding */
                  pa
                ),
                /* harmony export */
                Cylindrical: () => (
                  /* binding */
                  PE
                ),
                /* harmony export */
                Data3DTexture: () => (
                  /* binding */
                  Qn
                ),
                /* harmony export */
                DataArrayTexture: () => (
                  /* binding */
                  Qo
                ),
                /* harmony export */
                DataTexture: () => (
                  /* binding */
                  $s
                ),
                /* harmony export */
                DataTextureLoader: () => (
                  /* binding */
                  tE
                ),
                /* harmony export */
                DataUtils: () => (
                  /* binding */
                  jp
                ),
                /* harmony export */
                DecrementStencilOp: () => (
                  /* binding */
                  Uc
                ),
                /* harmony export */
                DecrementWrapStencilOp: () => (
                  /* binding */
                  kc
                ),
                /* harmony export */
                DefaultLoadingManager: () => (
                  /* binding */
                  Vf
                ),
                /* harmony export */
                DepthFormat: () => (
                  /* binding */
                  Ke
                ),
                /* harmony export */
                DepthStencilFormat: () => (
                  /* binding */
                  rt
                ),
                /* harmony export */
                DepthTexture: () => (
                  /* binding */
                  Qu
                ),
                /* harmony export */
                DetachedBindMode: () => (
                  /* binding */
                  ge
                ),
                /* harmony export */
                DirectionalLight: () => (
                  /* binding */
                  Yf
                ),
                /* harmony export */
                DirectionalLightHelper: () => (
                  /* binding */
                  zE
                ),
                /* harmony export */
                DiscreteInterpolant: () => (
                  /* binding */
                  Gf
                ),
                /* harmony export */
                DisplayP3ColorSpace: () => (
                  /* binding */
                  Uo
                ),
                /* harmony export */
                DodecahedronGeometry: () => (
                  /* binding */
                  cc
                ),
                /* harmony export */
                DoubleSide: () => (
                  /* binding */
                  T
                ),
                /* harmony export */
                DstAlphaFactor: () => (
                  /* binding */
                  ke
                ),
                /* harmony export */
                DstColorFactor: () => (
                  /* binding */
                  st
                ),
                /* harmony export */
                DynamicCopyUsage: () => (
                  /* binding */
                  eu
                ),
                /* harmony export */
                DynamicDrawUsage: () => (
                  /* binding */
                  Xc
                ),
                /* harmony export */
                DynamicReadUsage: () => (
                  /* binding */
                  Jc
                ),
                /* harmony export */
                EdgesGeometry: () => (
                  /* binding */
                  vf
                ),
                /* harmony export */
                EllipseCurve: () => (
                  /* binding */
                  ic
                ),
                /* harmony export */
                EqualCompare: () => (
                  /* binding */
                  rl
                ),
                /* harmony export */
                EqualDepth: () => (
                  /* binding */
                  Bn
                ),
                /* harmony export */
                EqualStencilFunc: () => (
                  /* binding */
                  Hc
                ),
                /* harmony export */
                EquirectangularReflectionMapping: () => (
                  /* binding */
                  R
                ),
                /* harmony export */
                EquirectangularRefractionMapping: () => (
                  /* binding */
                  ee
                ),
                /* harmony export */
                Euler: () => (
                  /* binding */
                  $r
                ),
                /* harmony export */
                EventDispatcher: () => (
                  /* binding */
                  Nr
                ),
                /* harmony export */
                ExtrudeGeometry: () => (
                  /* binding */
                  mc
                ),
                /* harmony export */
                FileLoader: () => (
                  /* binding */
                  Gs
                ),
                /* harmony export */
                Float16BufferAttribute: () => (
                  /* binding */
                  Jp
                ),
                /* harmony export */
                Float32BufferAttribute: () => (
                  /* binding */
                  gn
                ),
                /* harmony export */
                FloatType: () => (
                  /* binding */
                  tt
                ),
                /* harmony export */
                Fog: () => (
                  /* binding */
                  kl
                ),
                /* harmony export */
                FogExp2: () => (
                  /* binding */
                  Nl
                ),
                /* harmony export */
                FramebufferTexture: () => (
                  /* binding */
                  Av
                ),
                /* harmony export */
                FrontSide: () => (
                  /* binding */
                  f
                ),
                /* harmony export */
                Frustum: () => (
                  /* binding */
                  Ia
                ),
                /* harmony export */
                GLBufferAttribute: () => (
                  /* binding */
                  RE
                ),
                /* harmony export */
                GLSL1: () => (
                  /* binding */
                  nu
                ),
                /* harmony export */
                GLSL3: () => (
                  /* binding */
                  Ea
                ),
                /* harmony export */
                GreaterCompare: () => (
                  /* binding */
                  sl
                ),
                /* harmony export */
                GreaterDepth: () => (
                  /* binding */
                  ri
                ),
                /* harmony export */
                GreaterEqualCompare: () => (
                  /* binding */
                  al
                ),
                /* harmony export */
                GreaterEqualDepth: () => (
                  /* binding */
                  di
                ),
                /* harmony export */
                GreaterEqualStencilFunc: () => (
                  /* binding */
                  Kc
                ),
                /* harmony export */
                GreaterStencilFunc: () => (
                  /* binding */
                  jc
                ),
                /* harmony export */
                GridHelper: () => (
                  /* binding */
                  VE
                ),
                /* harmony export */
                Group: () => (
                  /* binding */
                  xo
                ),
                /* harmony export */
                HalfFloatType: () => (
                  /* binding */
                  lt
                ),
                /* harmony export */
                HemisphereLight: () => (
                  /* binding */
                  Hf
                ),
                /* harmony export */
                HemisphereLightHelper: () => (
                  /* binding */
                  QE
                ),
                /* harmony export */
                IcosahedronGeometry: () => (
                  /* binding */
                  gc
                ),
                /* harmony export */
                ImageBitmapLoader: () => (
                  /* binding */
                  lE
                ),
                /* harmony export */
                ImageLoader: () => (
                  /* binding */
                  Ja
                ),
                /* harmony export */
                ImageUtils: () => (
                  /* binding */
                  Ws
                ),
                /* harmony export */
                IncrementStencilOp: () => (
                  /* binding */
                  Fc
                ),
                /* harmony export */
                IncrementWrapStencilOp: () => (
                  /* binding */
                  Nc
                ),
                /* harmony export */
                InstancedBufferAttribute: () => (
                  /* binding */
                  ha
                ),
                /* harmony export */
                InstancedBufferGeometry: () => (
                  /* binding */
                  ep
                ),
                /* harmony export */
                InstancedInterleavedBuffer: () => (
                  /* binding */
                  BE
                ),
                /* harmony export */
                InstancedMesh: () => (
                  /* binding */
                  $d
                ),
                /* harmony export */
                Int16BufferAttribute: () => (
                  /* binding */
                  Yp
                ),
                /* harmony export */
                Int32BufferAttribute: () => (
                  /* binding */
                  qp
                ),
                /* harmony export */
                Int8BufferAttribute: () => (
                  /* binding */
                  Wp
                ),
                /* harmony export */
                IntType: () => (
                  /* binding */
                  Y
                ),
                /* harmony export */
                InterleavedBuffer: () => (
                  /* binding */
                  Gl
                ),
                /* harmony export */
                InterleavedBufferAttribute: () => (
                  /* binding */
                  _o
                ),
                /* harmony export */
                Interpolant: () => (
                  /* binding */
                  Ka
                ),
                /* harmony export */
                InterpolateDiscrete: () => (
                  /* binding */
                  or
                ),
                /* harmony export */
                InterpolateLinear: () => (
                  /* binding */
                  ar
                ),
                /* harmony export */
                InterpolateSmooth: () => (
                  /* binding */
                  cr
                ),
                /* harmony export */
                InvertStencilOp: () => (
                  /* binding */
                  Gc
                ),
                /* harmony export */
                KeepStencilOp: () => (
                  /* binding */
                  Is
                ),
                /* harmony export */
                KeyframeTrack: () => (
                  /* binding */
                  ms
                ),
                /* harmony export */
                LOD: () => (
                  /* binding */
                  Hd
                ),
                /* harmony export */
                LatheGeometry: () => (
                  /* binding */
                  Qa
                ),
                /* harmony export */
                Layers: () => (
                  /* binding */
                  El
                ),
                /* harmony export */
                LessCompare: () => (
                  /* binding */
                  il
                ),
                /* harmony export */
                LessDepth: () => (
                  /* binding */
                  wn
                ),
                /* harmony export */
                LessEqualCompare: () => (
                  /* binding */
                  va
                ),
                /* harmony export */
                LessEqualDepth: () => (
                  /* binding */
                  rn
                ),
                /* harmony export */
                LessEqualStencilFunc: () => (
                  /* binding */
                  zc
                ),
                /* harmony export */
                LessStencilFunc: () => (
                  /* binding */
                  Vc
                ),
                /* harmony export */
                Light: () => (
                  /* binding */
                  io
                ),
                /* harmony export */
                LightProbe: () => (
                  /* binding */
                  $f
                ),
                /* harmony export */
                Line: () => (
                  /* binding */
                  to
                ),
                /* harmony export */
                Line3: () => (
                  /* binding */
                  FE
                ),
                /* harmony export */
                LineBasicMaterial: () => (
                  /* binding */
                  Hr
                ),
                /* harmony export */
                LineCurve: () => (
                  /* binding */
                  ch
                ),
                /* harmony export */
                LineCurve3: () => (
                  /* binding */
                  mf
                ),
                /* harmony export */
                LineDashedMaterial: () => (
                  /* binding */
                  Ff
                ),
                /* harmony export */
                LineLoop: () => (
                  /* binding */
                  lf
                ),
                /* harmony export */
                LineSegments: () => (
                  /* binding */
                  bs
                ),
                /* harmony export */
                LinearDisplayP3ColorSpace: () => (
                  /* binding */
                  ao
                ),
                /* harmony export */
                LinearFilter: () => (
                  /* binding */
                  vn
                ),
                /* harmony export */
                LinearInterpolant: () => (
                  /* binding */
                  Eh
                ),
                /* harmony export */
                LinearMipMapLinearFilter: () => (
                  /* binding */
                  fr
                ),
                /* harmony export */
                LinearMipMapNearestFilter: () => (
                  /* binding */
                  ui
                ),
                /* harmony export */
                LinearMipmapLinearFilter: () => (
                  /* binding */
                  Ei
                ),
                /* harmony export */
                LinearMipmapNearestFilter: () => (
                  /* binding */
                  Oi
                ),
                /* harmony export */
                LinearSRGBColorSpace: () => (
                  /* binding */
                  hs
                ),
                /* harmony export */
                LinearToneMapping: () => (
                  /* binding */
                  ei
                ),
                /* harmony export */
                LinearTransfer: () => (
                  /* binding */
                  lo
                ),
                /* harmony export */
                Loader: () => (
                  /* binding */
                  Xr
                ),
                /* harmony export */
                LoaderUtils: () => (
                  /* binding */
                  wh
                ),
                /* harmony export */
                LoadingManager: () => (
                  /* binding */
                  Ch
                ),
                /* harmony export */
                LoopOnce: () => (
                  /* binding */
                  Wi
                ),
                /* harmony export */
                LoopPingPong: () => (
                  /* binding */
                  sr
                ),
                /* harmony export */
                LoopRepeat: () => (
                  /* binding */
                  Qi
                ),
                /* harmony export */
                LuminanceAlphaFormat: () => (
                  /* binding */
                  Ye
                ),
                /* harmony export */
                LuminanceFormat: () => (
                  /* binding */
                  Ne
                ),
                /* harmony export */
                MOUSE: () => (
                  /* binding */
                  w
                ),
                /* harmony export */
                Material: () => (
                  /* binding */
                  Pr
                ),
                /* harmony export */
                MaterialLoader: () => (
                  /* binding */
                  _c
                ),
                /* harmony export */
                MathUtils: () => (
                  /* binding */
                  Eu
                ),
                /* harmony export */
                Matrix3: () => (
                  /* binding */
                  Gn
                ),
                /* harmony export */
                Matrix4: () => (
                  /* binding */
                  pn
                ),
                /* harmony export */
                MaxEquation: () => (
                  /* binding */
                  Q
                ),
                /* harmony export */
                Mesh: () => (
                  /* binding */
                  hr
                ),
                /* harmony export */
                MeshBasicMaterial: () => (
                  /* binding */
                  qs
                ),
                /* harmony export */
                MeshDepthMaterial: () => (
                  /* binding */
                  zu
                ),
                /* harmony export */
                MeshDistanceMaterial: () => (
                  /* binding */
                  ju
                ),
                /* harmony export */
                MeshLambertMaterial: () => (
                  /* binding */
                  Pf
                ),
                /* harmony export */
                MeshMatcapMaterial: () => (
                  /* binding */
                  Of
                ),
                /* harmony export */
                MeshNormalMaterial: () => (
                  /* binding */
                  Df
                ),
                /* harmony export */
                MeshPhongMaterial: () => (
                  /* binding */
                  Rf
                ),
                /* harmony export */
                MeshPhysicalMaterial: () => (
                  /* binding */
                  Bf
                ),
                /* harmony export */
                MeshStandardMaterial: () => (
                  /* binding */
                  mh
                ),
                /* harmony export */
                MeshToonMaterial: () => (
                  /* binding */
                  Lf
                ),
                /* harmony export */
                MinEquation: () => (
                  /* binding */
                  X
                ),
                /* harmony export */
                MirroredRepeatWrapping: () => (
                  /* binding */
                  Ct
                ),
                /* harmony export */
                MixOperation: () => (
                  /* binding */
                  Et
                ),
                /* harmony export */
                MultiplyBlending: () => (
                  /* binding */
                  G
                ),
                /* harmony export */
                MultiplyOperation: () => (
                  /* binding */
                  Be
                ),
                /* harmony export */
                NearestFilter: () => (
                  /* binding */
                  Pt
                ),
                /* harmony export */
                NearestMipMapLinearFilter: () => (
                  /* binding */
                  ki
                ),
                /* harmony export */
                NearestMipMapNearestFilter: () => (
                  /* binding */
                  St
                ),
                /* harmony export */
                NearestMipmapLinearFilter: () => (
                  /* binding */
                  qt
                ),
                /* harmony export */
                NearestMipmapNearestFilter: () => (
                  /* binding */
                  _t
                ),
                /* harmony export */
                NeutralToneMapping: () => (
                  /* binding */
                  Ce
                ),
                /* harmony export */
                NeverCompare: () => (
                  /* binding */
                  nl
                ),
                /* harmony export */
                NeverDepth: () => (
                  /* binding */
                  Cn
                ),
                /* harmony export */
                NeverStencilFunc: () => (
                  /* binding */
                  Qc
                ),
                /* harmony export */
                NoBlending: () => (
                  /* binding */
                  b
                ),
                /* harmony export */
                NoColorSpace: () => (
                  /* binding */
                  Tr
                ),
                /* harmony export */
                NoToneMapping: () => (
                  /* binding */
                  $t
                ),
                /* harmony export */
                NormalAnimationBlendMode: () => (
                  /* binding */
                  rs
                ),
                /* harmony export */
                NormalBlending: () => (
                  /* binding */
                  D
                ),
                /* harmony export */
                NotEqualCompare: () => (
                  /* binding */
                  ol
                ),
                /* harmony export */
                NotEqualDepth: () => (
                  /* binding */
                  Ni
                ),
                /* harmony export */
                NotEqualStencilFunc: () => (
                  /* binding */
                  Wc
                ),
                /* harmony export */
                NumberKeyframeTrack: () => (
                  /* binding */
                  Xa
                ),
                /* harmony export */
                Object3D: () => (
                  /* binding */
                  bi
                ),
                /* harmony export */
                ObjectLoader: () => (
                  /* binding */
                  oE
                ),
                /* harmony export */
                ObjectSpaceNormalMap: () => (
                  /* binding */
                  ys
                ),
                /* harmony export */
                OctahedronGeometry: () => (
                  /* binding */
                  ja
                ),
                /* harmony export */
                OneFactor: () => (
                  /* binding */
                  K
                ),
                /* harmony export */
                OneMinusConstantAlphaFactor: () => (
                  /* binding */
                  cn
                ),
                /* harmony export */
                OneMinusConstantColorFactor: () => (
                  /* binding */
                  Rt
                ),
                /* harmony export */
                OneMinusDstAlphaFactor: () => (
                  /* binding */
                  Ve
                ),
                /* harmony export */
                OneMinusDstColorFactor: () => (
                  /* binding */
                  ut
                ),
                /* harmony export */
                OneMinusSrcAlphaFactor: () => (
                  /* binding */
                  Te
                ),
                /* harmony export */
                OneMinusSrcColorFactor: () => (
                  /* binding */
                  pe
                ),
                /* harmony export */
                OrthographicCamera: () => (
                  /* binding */
                  Pl
                ),
                /* harmony export */
                P3Primaries: () => (
                  /* binding */
                  uo
                ),
                /* harmony export */
                PCFShadowMap: () => (
                  /* binding */
                  g
                ),
                /* harmony export */
                PCFSoftShadowMap: () => (
                  /* binding */
                  A
                ),
                /* harmony export */
                PMREMGenerator: () => (
                  /* binding */
                  ku
                ),
                /* harmony export */
                Path: () => (
                  /* binding */
                  Ga
                ),
                /* harmony export */
                PerspectiveCamera: () => (
                  /* binding */
                  mr
                ),
                /* harmony export */
                Plane: () => (
                  /* binding */
                  Zs
                ),
                /* harmony export */
                PlaneGeometry: () => (
                  /* binding */
                  ia
                ),
                /* harmony export */
                PlaneHelper: () => (
                  /* binding */
                  XE
                ),
                /* harmony export */
                PointLight: () => (
                  /* binding */
                  Xf
                ),
                /* harmony export */
                PointLightHelper: () => (
                  /* binding */
                  kE
                ),
                /* harmony export */
                Points: () => (
                  /* binding */
                  uf
                ),
                /* harmony export */
                PointsMaterial: () => (
                  /* binding */
                  nh
                ),
                /* harmony export */
                PolarGridHelper: () => (
                  /* binding */
                  HE
                ),
                /* harmony export */
                PolyhedronGeometry: () => (
                  /* binding */
                  no
                ),
                /* harmony export */
                PositionalAudio: () => (
                  /* binding */
                  pE
                ),
                /* harmony export */
                PropertyBinding: () => (
                  /* binding */
                  Ci
                ),
                /* harmony export */
                PropertyMixer: () => (
                  /* binding */
                  hp
                ),
                /* harmony export */
                QuadraticBezierCurve: () => (
                  /* binding */
                  uh
                ),
                /* harmony export */
                QuadraticBezierCurve3: () => (
                  /* binding */
                  hh
                ),
                /* harmony export */
                Quaternion: () => (
                  /* binding */
                  xi
                ),
                /* harmony export */
                QuaternionKeyframeTrack: () => (
                  /* binding */
                  ma
                ),
                /* harmony export */
                QuaternionLinearInterpolant: () => (
                  /* binding */
                  Qf
                ),
                /* harmony export */
                RED_GREEN_RGTC2_Format: () => (
                  /* binding */
                  Ai
                ),
                /* harmony export */
                RED_RGTC1_Format: () => (
                  /* binding */
                  On
                ),
                /* harmony export */
                REVISION: () => (
                  /* binding */
                  C
                ),
                /* harmony export */
                RGBADepthPacking: () => (
                  /* binding */
                  Es
                ),
                /* harmony export */
                RGBAFormat: () => (
                  /* binding */
                  _e
                ),
                /* harmony export */
                RGBAIntegerFormat: () => (
                  /* binding */
                  mn
                ),
                /* harmony export */
                RGBA_ASTC_10x10_Format: () => (
                  /* binding */
                  nt
                ),
                /* harmony export */
                RGBA_ASTC_10x5_Format: () => (
                  /* binding */
                  ft
                ),
                /* harmony export */
                RGBA_ASTC_10x6_Format: () => (
                  /* binding */
                  ct
                ),
                /* harmony export */
                RGBA_ASTC_10x8_Format: () => (
                  /* binding */
                  je
                ),
                /* harmony export */
                RGBA_ASTC_12x10_Format: () => (
                  /* binding */
                  xt
                ),
                /* harmony export */
                RGBA_ASTC_12x12_Format: () => (
                  /* binding */
                  Jt
                ),
                /* harmony export */
                RGBA_ASTC_4x4_Format: () => (
                  /* binding */
                  fi
                ),
                /* harmony export */
                RGBA_ASTC_5x4_Format: () => (
                  /* binding */
                  F
                ),
                /* harmony export */
                RGBA_ASTC_5x5_Format: () => (
                  /* binding */
                  V
                ),
                /* harmony export */
                RGBA_ASTC_6x5_Format: () => (
                  /* binding */
                  q
                ),
                /* harmony export */
                RGBA_ASTC_6x6_Format: () => (
                  /* binding */
                  oe
                ),
                /* harmony export */
                RGBA_ASTC_8x5_Format: () => (
                  /* binding */
                  me
                ),
                /* harmony export */
                RGBA_ASTC_8x6_Format: () => (
                  /* binding */
                  De
                ),
                /* harmony export */
                RGBA_ASTC_8x8_Format: () => (
                  /* binding */
                  Ge
                ),
                /* harmony export */
                RGBA_BPTC_Format: () => (
                  /* binding */
                  dn
                ),
                /* harmony export */
                RGBA_ETC2_EAC_Format: () => (
                  /* binding */
                  qi
                ),
                /* harmony export */
                RGBA_PVRTC_2BPPV1_Format: () => (
                  /* binding */
                  rr
                ),
                /* harmony export */
                RGBA_PVRTC_4BPPV1_Format: () => (
                  /* binding */
                  Gi
                ),
                /* harmony export */
                RGBA_S3TC_DXT1_Format: () => (
                  /* binding */
                  Rn
                ),
                /* harmony export */
                RGBA_S3TC_DXT3_Format: () => (
                  /* binding */
                  Bi
                ),
                /* harmony export */
                RGBA_S3TC_DXT5_Format: () => (
                  /* binding */
                  Wn
                ),
                /* harmony export */
                RGBFormat: () => (
                  /* binding */
                  de
                ),
                /* harmony export */
                RGB_BPTC_SIGNED_Format: () => (
                  /* binding */
                  Mn
                ),
                /* harmony export */
                RGB_BPTC_UNSIGNED_Format: () => (
                  /* binding */
                  Vn
                ),
                /* harmony export */
                RGB_ETC1_Format: () => (
                  /* binding */
                  Wt
                ),
                /* harmony export */
                RGB_ETC2_Format: () => (
                  /* binding */
                  Kn
                ),
                /* harmony export */
                RGB_PVRTC_2BPPV1_Format: () => (
                  /* binding */
                  li
                ),
                /* harmony export */
                RGB_PVRTC_4BPPV1_Format: () => (
                  /* binding */
                  Nn
                ),
                /* harmony export */
                RGB_S3TC_DXT1_Format: () => (
                  /* binding */
                  _n
                ),
                /* harmony export */
                RGFormat: () => (
                  /* binding */
                  jt
                ),
                /* harmony export */
                RGIntegerFormat: () => (
                  /* binding */
                  at
                ),
                /* harmony export */
                RawShaderMaterial: () => (
                  /* binding */
                  If
                ),
                /* harmony export */
                Ray: () => (
                  /* binding */
                  Ar
                ),
                /* harmony export */
                Raycaster: () => (
                  /* binding */
                  LE
                ),
                /* harmony export */
                Rec709Primaries: () => (
                  /* binding */
                  co
                ),
                /* harmony export */
                RectAreaLight: () => (
                  /* binding */
                  Jf
                ),
                /* harmony export */
                RedFormat: () => (
                  /* binding */
                  bt
                ),
                /* harmony export */
                RedIntegerFormat: () => (
                  /* binding */
                  ln
                ),
                /* harmony export */
                ReinhardToneMapping: () => (
                  /* binding */
                  Dn
                ),
                /* harmony export */
                RenderTarget: () => (
                  /* binding */
                  Go
                ),
                /* harmony export */
                RepeatWrapping: () => (
                  /* binding */
                  we
                ),
                /* harmony export */
                ReplaceStencilOp: () => (
                  /* binding */
                  Oc
                ),
                /* harmony export */
                ReverseSubtractEquation: () => (
                  /* binding */
                  te
                ),
                /* harmony export */
                RingGeometry: () => (
                  /* binding */
                  vc
                ),
                /* harmony export */
                SIGNED_RED_GREEN_RGTC2_Format: () => (
                  /* binding */
                  Ri
                ),
                /* harmony export */
                SIGNED_RED_RGTC1_Format: () => (
                  /* binding */
                  In
                ),
                /* harmony export */
                SRGBColorSpace: () => (
                  /* binding */
                  mi
                ),
                /* harmony export */
                SRGBTransfer: () => (
                  /* binding */
                  Fi
                ),
                /* harmony export */
                Scene: () => (
                  /* binding */
                  Ud
                ),
                /* harmony export */
                ShaderChunk: () => (
                  /* binding */
                  Jn
                ),
                /* harmony export */
                ShaderLib: () => (
                  /* binding */
                  ps
                ),
                /* harmony export */
                ShaderMaterial: () => (
                  /* binding */
                  fs
                ),
                /* harmony export */
                ShadowMaterial: () => (
                  /* binding */
                  Tf
                ),
                /* harmony export */
                Shape: () => (
                  /* binding */
                  Mo
                ),
                /* harmony export */
                ShapeGeometry: () => (
                  /* binding */
                  Ec
                ),
                /* harmony export */
                ShapePath: () => (
                  /* binding */
                  JE
                ),
                /* harmony export */
                ShapeUtils: () => (
                  /* binding */
                  _s
                ),
                /* harmony export */
                ShortType: () => (
                  /* binding */
                  ji
                ),
                /* harmony export */
                Skeleton: () => (
                  /* binding */
                  Wl
                ),
                /* harmony export */
                SkeletonHelper: () => (
                  /* binding */
                  NE
                ),
                /* harmony export */
                SkinnedMesh: () => (
                  /* binding */
                  Yd
                ),
                /* harmony export */
                Source: () => (
                  /* binding */
                  Ki
                ),
                /* harmony export */
                Sphere: () => (
                  /* binding */
                  pr
                ),
                /* harmony export */
                SphereGeometry: () => (
                  /* binding */
                  Wa
                ),
                /* harmony export */
                Spherical: () => (
                  /* binding */
                  DE
                ),
                /* harmony export */
                SphericalHarmonics3: () => (
                  /* binding */
                  Zf
                ),
                /* harmony export */
                SplineCurve: () => (
                  /* binding */
                  dh
                ),
                /* harmony export */
                SpotLight: () => (
                  /* binding */
                  Wf
                ),
                /* harmony export */
                SpotLightHelper: () => (
                  /* binding */
                  UE
                ),
                /* harmony export */
                Sprite: () => (
                  /* binding */
                  Qd
                ),
                /* harmony export */
                SpriteMaterial: () => (
                  /* binding */
                  Xu
                ),
                /* harmony export */
                SrcAlphaFactor: () => (
                  /* binding */
                  be
                ),
                /* harmony export */
                SrcAlphaSaturateFactor: () => (
                  /* binding */
                  It
                ),
                /* harmony export */
                SrcColorFactor: () => (
                  /* binding */
                  ne
                ),
                /* harmony export */
                StaticCopyUsage: () => (
                  /* binding */
                  $c
                ),
                /* harmony export */
                StaticDrawUsage: () => (
                  /* binding */
                  ho
                ),
                /* harmony export */
                StaticReadUsage: () => (
                  /* binding */
                  qc
                ),
                /* harmony export */
                StereoCamera: () => (
                  /* binding */
                  uE
                ),
                /* harmony export */
                StreamCopyUsage: () => (
                  /* binding */
                  tu
                ),
                /* harmony export */
                StreamDrawUsage: () => (
                  /* binding */
                  Yc
                ),
                /* harmony export */
                StreamReadUsage: () => (
                  /* binding */
                  Zc
                ),
                /* harmony export */
                StringKeyframeTrack: () => (
                  /* binding */
                  Bo
                ),
                /* harmony export */
                SubtractEquation: () => (
                  /* binding */
                  ie
                ),
                /* harmony export */
                SubtractiveBlending: () => (
                  /* binding */
                  U
                ),
                /* harmony export */
                TOUCH: () => (
                  /* binding */
                  E
                ),
                /* harmony export */
                TangentSpaceNormalMap: () => (
                  /* binding */
                  Rr
                ),
                /* harmony export */
                TetrahedronGeometry: () => (
                  /* binding */
                  yc
                ),
                /* harmony export */
                Texture: () => (
                  /* binding */
                  Vi
                ),
                /* harmony export */
                TextureLoader: () => (
                  /* binding */
                  nE
                ),
                /* harmony export */
                TorusGeometry: () => (
                  /* binding */
                  Cc
                ),
                /* harmony export */
                TorusKnotGeometry: () => (
                  /* binding */
                  xc
                ),
                /* harmony export */
                Triangle: () => (
                  /* binding */
                  es
                ),
                /* harmony export */
                TriangleFanDrawMode: () => (
                  /* binding */
                  Ts
                ),
                /* harmony export */
                TriangleStripDrawMode: () => (
                  /* binding */
                  Ss
                ),
                /* harmony export */
                TrianglesDrawMode: () => (
                  /* binding */
                  Ms
                ),
                /* harmony export */
                TubeGeometry: () => (
                  /* binding */
                  bc
                ),
                /* harmony export */
                UVMapping: () => (
                  /* binding */
                  xe
                ),
                /* harmony export */
                Uint16BufferAttribute: () => (
                  /* binding */
                  Tu
                ),
                /* harmony export */
                Uint32BufferAttribute: () => (
                  /* binding */
                  Iu
                ),
                /* harmony export */
                Uint8BufferAttribute: () => (
                  /* binding */
                  Kp
                ),
                /* harmony export */
                Uint8ClampedBufferAttribute: () => (
                  /* binding */
                  Xp
                ),
                /* harmony export */
                Uniform: () => (
                  /* binding */
                  Ih
                ),
                /* harmony export */
                UniformsGroup: () => (
                  /* binding */
                  IE
                ),
                /* harmony export */
                UniformsLib: () => (
                  /* binding */
                  Vt
                ),
                /* harmony export */
                UniformsUtils: () => (
                  /* binding */
                  td
                ),
                /* harmony export */
                UnsignedByteType: () => (
                  /* binding */
                  Ii
                ),
                /* harmony export */
                UnsignedInt248Type: () => (
                  /* binding */
                  zt
                ),
                /* harmony export */
                UnsignedInt5999Type: () => (
                  /* binding */
                  ai
                ),
                /* harmony export */
                UnsignedIntType: () => (
                  /* binding */
                  Fe
                ),
                /* harmony export */
                UnsignedShort4444Type: () => (
                  /* binding */
                  Ut
                ),
                /* harmony export */
                UnsignedShort5551Type: () => (
                  /* binding */
                  hn
                ),
                /* harmony export */
                UnsignedShortType: () => (
                  /* binding */
                  Cr
                ),
                /* harmony export */
                VSMShadowMap: () => (
                  /* binding */
                  u
                ),
                /* harmony export */
                Vector2: () => (
                  /* binding */
                  pt
                ),
                /* harmony export */
                Vector3: () => (
                  /* binding */
                  ye
                ),
                /* harmony export */
                Vector4: () => (
                  /* binding */
                  yi
                ),
                /* harmony export */
                VectorKeyframeTrack: () => (
                  /* binding */
                  Ya
                ),
                /* harmony export */
                VideoTexture: () => (
                  /* binding */
                  pv
                ),
                /* harmony export */
                WebGL3DRenderTarget: () => (
                  /* binding */
                  pi
                ),
                /* harmony export */
                WebGLArrayRenderTarget: () => (
                  /* binding */
                  un
                ),
                /* harmony export */
                WebGLCoordinateSystem: () => (
                  /* binding */
                  ss
                ),
                /* harmony export */
                WebGLCubeRenderTarget: () => (
                  /* binding */
                  sd
                ),
                /* harmony export */
                WebGLMultipleRenderTargets: () => (
                  /* binding */
                  ZE
                ),
                /* harmony export */
                WebGLRenderTarget: () => (
                  /* binding */
                  zr
                ),
                /* harmony export */
                WebGLRenderer: () => (
                  /* binding */
                  sv
                ),
                /* harmony export */
                WebGLUtils: () => (
                  /* binding */
                  Ld
                ),
                /* harmony export */
                WebGPUCoordinateSystem: () => (
                  /* binding */
                  fo
                ),
                /* harmony export */
                WireframeGeometry: () => (
                  /* binding */
                  wf
                ),
                /* harmony export */
                WrapAroundEnding: () => (
                  /* binding */
                  Yr
                ),
                /* harmony export */
                ZeroCurvatureEnding: () => (
                  /* binding */
                  Ji
                ),
                /* harmony export */
                ZeroFactor: () => (
                  /* binding */
                  O
                ),
                /* harmony export */
                ZeroSlopeEnding: () => (
                  /* binding */
                  xr
                ),
                /* harmony export */
                ZeroStencilOp: () => (
                  /* binding */
                  Pc
                ),
                /* harmony export */
                createCanvasElement: () => (
                  /* binding */
                  hl
                )
                /* harmony export */
              });
              /**
               * @license
               * Copyright 2010-2024 Three.js Authors
               * SPDX-License-Identifier: MIT
               */
              const C = "164", w = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, E = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, y = 0, l = 1, d = 2, p = 3, c = 0, g = 1, A = 2, u = 3, f = 0, x = 1, T = 2, b = 0, D = 1, S = 2, U = 3, G = 4, Z = 5, W = 100, ie = 101, te = 102, X = 103, Q = 104, O = 200, K = 201, ne = 202, pe = 203, be = 204, Te = 205, ke = 206, Ve = 207, st = 208, ut = 209, It = 210, ht = 211, Rt = 212, Qt = 213, cn = 214, Cn = 0, Tn = 1, wn = 2, rn = 3, Bn = 4, di = 5, ri = 6, Ni = 7, Be = 0, Et = 1, Dt = 2, $t = 0, ei = 1, Dn = 2, Yt = 3, Xe = 4, le = 5, ae = 6, Ce = 7, fe = "attached", ge = "detached", xe = 300, H = 301, M = 302, R = 303, ee = 304, he = 306, we = 1e3, Oe = 1001, Ct = 1002, Pt = 1003, _t = 1004, St = 1004, qt = 1005, ki = 1005, vn = 1006, Oi = 1007, ui = 1007, Ei = 1008, fr = 1008, Ii = 1009, Sr = 1010, ji = 1011, Cr = 1012, Y = 1013, Fe = 1014, tt = 1015, lt = 1016, Ut = 1017, hn = 1018, zt = 1020, ai = 35902, jn = 1021, de = 1022, _e = 1023, Ne = 1024, Ye = 1025, Ke = 1026, rt = 1027, bt = 1028, ln = 1029, jt = 1030, at = 1031, mn = 1033, _n = 33776, Rn = 33777, Bi = 33778, Wn = 33779, Nn = 35840, li = 35841, Gi = 35842, rr = 35843, Wt = 36196, Kn = 37492, qi = 37496, fi = 37808, F = 37809, V = 37810, q = 37811, oe = 37812, me = 37813, De = 37814, Ge = 37815, ft = 37816, ct = 37817, je = 37818, nt = 37819, xt = 37820, Jt = 37821, dn = 36492, Mn = 36494, Vn = 36495, On = 36283, In = 36284, Ai = 36285, Ri = 36286, Wi = 2200, Qi = 2201, sr = 2202, or = 2300, ar = 2301, cr = 2302, Ji = 2400, xr = 2401, Yr = 2402, rs = 2500, us = 2501, Ms = 0, Ss = 1, Ts = 2, vs = 3200, Es = 3201, Rr = 0, ys = 1, Tr = "", mi = "srgb", hs = "srgb-linear", Uo = "display-p3", ao = "display-p3-linear", lo = "linear", Fi = "srgb", co = "rec709", uo = "p3", Pc = 0, Is = 7680, Oc = 7681, Fc = 7682, Uc = 7683, Nc = 34055, kc = 34056, Gc = 5386, Qc = 512, Vc = 513, Hc = 514, zc = 515, jc = 516, Wc = 517, Kc = 518, ga = 519, nl = 512, il = 513, rl = 514, va = 515, sl = 516, ol = 517, al = 518, ll = 519, ho = 35044, Xc = 35048, Yc = 35040, qc = 35045, Jc = 35049, Zc = 35041, $c = 35046, eu = 35050, tu = 35042, nu = "100", Ea = "300 es", ss = 2e3, fo = 2001;
              class Nr {
                addEventListener(e, t) {
                  this._listeners === void 0 && (this._listeners = {});
                  const n = this._listeners;
                  n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
                }
                hasEventListener(e, t) {
                  if (this._listeners === void 0) return !1;
                  const n = this._listeners;
                  return n[e] !== void 0 && n[e].indexOf(t) !== -1;
                }
                removeEventListener(e, t) {
                  if (this._listeners === void 0) return;
                  const i = this._listeners[e];
                  if (i !== void 0) {
                    const r = i.indexOf(t);
                    r !== -1 && i.splice(r, 1);
                  }
                }
                dispatchEvent(e) {
                  if (this._listeners === void 0) return;
                  const n = this._listeners[e.type];
                  if (n !== void 0) {
                    e.target = this;
                    const i = n.slice(0);
                    for (let r = 0, o = i.length; r < o; r++)
                      i[r].call(this, e);
                    e.target = null;
                  }
                }
              }
              const br = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
              let cl = 1234567;
              const Bs = Math.PI / 180, Hs = 180 / Math.PI;
              function kr() {
                const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
                return (br[s & 255] + br[s >> 8 & 255] + br[s >> 16 & 255] + br[s >> 24 & 255] + "-" + br[e & 255] + br[e >> 8 & 255] + "-" + br[e >> 16 & 15 | 64] + br[e >> 24 & 255] + "-" + br[t & 63 | 128] + br[t >> 8 & 255] + "-" + br[t >> 16 & 255] + br[t >> 24 & 255] + br[n & 255] + br[n >> 8 & 255] + br[n >> 16 & 255] + br[n >> 24 & 255]).toLowerCase();
              }
              function Yi(s, e, t) {
                return Math.max(e, Math.min(t, s));
              }
              function ya(s, e) {
                return (s % e + e) % e;
              }
              function iu(s, e, t, n, i) {
                return n + (s - e) * (i - n) / (t - e);
              }
              function ru(s, e, t) {
                return s !== e ? (t - s) / (e - s) : 0;
              }
              function po(s, e, t) {
                return (1 - t) * s + t * e;
              }
              function su(s, e, t, n) {
                return po(s, e, 1 - Math.exp(-t * n));
              }
              function ou(s, e = 1) {
                return e - Math.abs(ya(s, e * 2) - e);
              }
              function au(s, e, t) {
                return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
              }
              function lu(s, e, t) {
                return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
              }
              function cu(s, e) {
                return s + Math.floor(Math.random() * (e - s + 1));
              }
              function uu(s, e) {
                return s + Math.random() * (e - s);
              }
              function hu(s) {
                return s * (0.5 - Math.random());
              }
              function du(s) {
                s !== void 0 && (cl = s);
                let e = cl += 1831565813;
                return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
              }
              function fu(s) {
                return s * Bs;
              }
              function pu(s) {
                return s * Hs;
              }
              function Au(s) {
                return (s & s - 1) === 0 && s !== 0;
              }
              function mu(s) {
                return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
              }
              function gu(s) {
                return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
              }
              function vu(s, e, t, n, i) {
                const r = Math.cos, o = Math.sin, a = r(t / 2), h = o(t / 2), m = r((e + n) / 2), _ = o((e + n) / 2), I = r((e - n) / 2), B = o((e - n) / 2), L = r((n - e) / 2), N = o((n - e) / 2);
                switch (i) {
                  case "XYX":
                    s.set(a * _, h * I, h * B, a * m);
                    break;
                  case "YZY":
                    s.set(h * B, a * _, h * I, a * m);
                    break;
                  case "ZXZ":
                    s.set(h * I, h * B, a * _, a * m);
                    break;
                  case "XZX":
                    s.set(a * _, h * N, h * L, a * m);
                    break;
                  case "YXY":
                    s.set(h * L, a * _, h * N, a * m);
                    break;
                  case "ZYZ":
                    s.set(h * N, h * L, a * _, a * m);
                    break;
                  default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
                }
              }
              function Ir(s, e) {
                switch (e.constructor) {
                  case Float32Array:
                    return s;
                  case Uint32Array:
                    return s / 4294967295;
                  case Uint16Array:
                    return s / 65535;
                  case Uint8Array:
                    return s / 255;
                  case Int32Array:
                    return Math.max(s / 2147483647, -1);
                  case Int16Array:
                    return Math.max(s / 32767, -1);
                  case Int8Array:
                    return Math.max(s / 127, -1);
                  default:
                    throw new Error("Invalid component type.");
                }
              }
              function Hn(s, e) {
                switch (e.constructor) {
                  case Float32Array:
                    return s;
                  case Uint32Array:
                    return Math.round(s * 4294967295);
                  case Uint16Array:
                    return Math.round(s * 65535);
                  case Uint8Array:
                    return Math.round(s * 255);
                  case Int32Array:
                    return Math.round(s * 2147483647);
                  case Int16Array:
                    return Math.round(s * 32767);
                  case Int8Array:
                    return Math.round(s * 127);
                  default:
                    throw new Error("Invalid component type.");
                }
              }
              const Eu = { DEG2RAD: Bs, RAD2DEG: Hs, generateUUID: kr, clamp: Yi, euclideanModulo: ya, mapLinear: iu, inverseLerp: ru, lerp: po, damp: su, pingpong: ou, smoothstep: au, smootherstep: lu, randInt: cu, randFloat: uu, randFloatSpread: hu, seededRandom: du, degToRad: fu, radToDeg: pu, isPowerOfTwo: Au, ceilPowerOfTwo: mu, floorPowerOfTwo: gu, setQuaternionFromProperEuler: vu, normalize: Hn, denormalize: Ir };
              class pt {
                constructor(e = 0, t = 0) {
                  pt.prototype.isVector2 = !0, this.x = e, this.y = t;
                }
                get width() {
                  return this.x;
                }
                set width(e) {
                  this.x = e;
                }
                get height() {
                  return this.y;
                }
                set height(e) {
                  this.y = e;
                }
                set(e, t) {
                  return this.x = e, this.y = t, this;
                }
                setScalar(e) {
                  return this.x = e, this.y = e, this;
                }
                setX(e) {
                  return this.x = e, this;
                }
                setY(e) {
                  return this.y = e, this;
                }
                setComponent(e, t) {
                  switch (e) {
                    case 0:
                      this.x = t;
                      break;
                    case 1:
                      this.y = t;
                      break;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                  return this;
                }
                getComponent(e) {
                  switch (e) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                }
                clone() {
                  return new this.constructor(this.x, this.y);
                }
                copy(e) {
                  return this.x = e.x, this.y = e.y, this;
                }
                add(e) {
                  return this.x += e.x, this.y += e.y, this;
                }
                addScalar(e) {
                  return this.x += e, this.y += e, this;
                }
                addVectors(e, t) {
                  return this.x = e.x + t.x, this.y = e.y + t.y, this;
                }
                addScaledVector(e, t) {
                  return this.x += e.x * t, this.y += e.y * t, this;
                }
                sub(e) {
                  return this.x -= e.x, this.y -= e.y, this;
                }
                subScalar(e) {
                  return this.x -= e, this.y -= e, this;
                }
                subVectors(e, t) {
                  return this.x = e.x - t.x, this.y = e.y - t.y, this;
                }
                multiply(e) {
                  return this.x *= e.x, this.y *= e.y, this;
                }
                multiplyScalar(e) {
                  return this.x *= e, this.y *= e, this;
                }
                divide(e) {
                  return this.x /= e.x, this.y /= e.y, this;
                }
                divideScalar(e) {
                  return this.multiplyScalar(1 / e);
                }
                applyMatrix3(e) {
                  const t = this.x, n = this.y, i = e.elements;
                  return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
                }
                min(e) {
                  return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
                }
                max(e) {
                  return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
                }
                clamp(e, t) {
                  return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
                }
                clampScalar(e, t) {
                  return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
                }
                clampLength(e, t) {
                  const n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
                }
                floor() {
                  return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
                }
                ceil() {
                  return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
                }
                round() {
                  return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
                }
                roundToZero() {
                  return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
                }
                negate() {
                  return this.x = -this.x, this.y = -this.y, this;
                }
                dot(e) {
                  return this.x * e.x + this.y * e.y;
                }
                cross(e) {
                  return this.x * e.y - this.y * e.x;
                }
                lengthSq() {
                  return this.x * this.x + this.y * this.y;
                }
                length() {
                  return Math.sqrt(this.x * this.x + this.y * this.y);
                }
                manhattanLength() {
                  return Math.abs(this.x) + Math.abs(this.y);
                }
                normalize() {
                  return this.divideScalar(this.length() || 1);
                }
                angle() {
                  return Math.atan2(-this.y, -this.x) + Math.PI;
                }
                angleTo(e) {
                  const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                  if (t === 0) return Math.PI / 2;
                  const n = this.dot(e) / t;
                  return Math.acos(Yi(n, -1, 1));
                }
                distanceTo(e) {
                  return Math.sqrt(this.distanceToSquared(e));
                }
                distanceToSquared(e) {
                  const t = this.x - e.x, n = this.y - e.y;
                  return t * t + n * n;
                }
                manhattanDistanceTo(e) {
                  return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
                }
                setLength(e) {
                  return this.normalize().multiplyScalar(e);
                }
                lerp(e, t) {
                  return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
                }
                lerpVectors(e, t, n) {
                  return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
                }
                equals(e) {
                  return e.x === this.x && e.y === this.y;
                }
                fromArray(e, t = 0) {
                  return this.x = e[t], this.y = e[t + 1], this;
                }
                toArray(e = [], t = 0) {
                  return e[t] = this.x, e[t + 1] = this.y, e;
                }
                fromBufferAttribute(e, t) {
                  return this.x = e.getX(t), this.y = e.getY(t), this;
                }
                rotateAround(e, t) {
                  const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, o = this.y - e.y;
                  return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this;
                }
                random() {
                  return this.x = Math.random(), this.y = Math.random(), this;
                }
                *[Symbol.iterator]() {
                  yield this.x, yield this.y;
                }
              }
              class Gn {
                constructor(e, t, n, i, r, o, a, h, m) {
                  Gn.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, r, o, a, h, m);
                }
                set(e, t, n, i, r, o, a, h, m) {
                  const _ = this.elements;
                  return _[0] = e, _[1] = i, _[2] = a, _[3] = t, _[4] = r, _[5] = h, _[6] = n, _[7] = o, _[8] = m, this;
                }
                identity() {
                  return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                }
                copy(e) {
                  const t = this.elements, n = e.elements;
                  return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
                }
                extractBasis(e, t, n) {
                  return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
                }
                setFromMatrix4(e) {
                  const t = e.elements;
                  return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
                }
                multiply(e) {
                  return this.multiplyMatrices(this, e);
                }
                premultiply(e) {
                  return this.multiplyMatrices(e, this);
                }
                multiplyMatrices(e, t) {
                  const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[3], h = n[6], m = n[1], _ = n[4], I = n[7], B = n[2], L = n[5], N = n[8], z = i[0], k = i[3], P = i[6], se = i[1], $ = i[4], J = i[7], Le = i[2], Ee = i[5], Me = i[8];
                  return r[0] = o * z + a * se + h * Le, r[3] = o * k + a * $ + h * Ee, r[6] = o * P + a * J + h * Me, r[1] = m * z + _ * se + I * Le, r[4] = m * k + _ * $ + I * Ee, r[7] = m * P + _ * J + I * Me, r[2] = B * z + L * se + N * Le, r[5] = B * k + L * $ + N * Ee, r[8] = B * P + L * J + N * Me, this;
                }
                multiplyScalar(e) {
                  const t = this.elements;
                  return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
                }
                determinant() {
                  const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], h = e[6], m = e[7], _ = e[8];
                  return t * o * _ - t * a * m - n * r * _ + n * a * h + i * r * m - i * o * h;
                }
                invert() {
                  const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], h = e[6], m = e[7], _ = e[8], I = _ * o - a * m, B = a * h - _ * r, L = m * r - o * h, N = t * I + n * B + i * L;
                  if (N === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                  const z = 1 / N;
                  return e[0] = I * z, e[1] = (i * m - _ * n) * z, e[2] = (a * n - i * o) * z, e[3] = B * z, e[4] = (_ * t - i * h) * z, e[5] = (i * r - a * t) * z, e[6] = L * z, e[7] = (n * h - m * t) * z, e[8] = (o * t - n * r) * z, this;
                }
                transpose() {
                  let e;
                  const t = this.elements;
                  return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
                }
                getNormalMatrix(e) {
                  return this.setFromMatrix4(e).invert().transpose();
                }
                transposeIntoArray(e) {
                  const t = this.elements;
                  return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
                }
                setUvTransform(e, t, n, i, r, o, a) {
                  const h = Math.cos(r), m = Math.sin(r);
                  return this.set(n * h, n * m, -n * (h * o + m * a) + o + e, -i * m, i * h, -i * (-m * o + h * a) + a + t, 0, 0, 1), this;
                }
                //
                scale(e, t) {
                  return this.premultiply(Ca.makeScale(e, t)), this;
                }
                rotate(e) {
                  return this.premultiply(Ca.makeRotation(-e)), this;
                }
                translate(e, t) {
                  return this.premultiply(Ca.makeTranslation(e, t)), this;
                }
                // for 2D Transforms
                makeTranslation(e, t) {
                  return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
                }
                makeRotation(e) {
                  const t = Math.cos(e), n = Math.sin(e);
                  return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
                }
                makeScale(e, t) {
                  return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
                }
                //
                equals(e) {
                  const t = this.elements, n = e.elements;
                  for (let i = 0; i < 9; i++)
                    if (t[i] !== n[i]) return !1;
                  return !0;
                }
                fromArray(e, t = 0) {
                  for (let n = 0; n < 9; n++)
                    this.elements[n] = e[n + t];
                  return this;
                }
                toArray(e = [], t = 0) {
                  const n = this.elements;
                  return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
                }
                clone() {
                  return new this.constructor().fromArray(this.elements);
                }
              }
              const Ca = /* @__PURE__ */ new Gn();
              function ul(s) {
                for (let e = s.length - 1; e >= 0; --e)
                  if (s[e] >= 65535) return !0;
                return !1;
              }
              const yu = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
              function zs(s, e) {
                return new yu[s](e);
              }
              function Ao(s) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", s);
              }
              function hl() {
                const s = Ao("canvas");
                return s.style.display = "block", s;
              }
              const dl = {};
              function fl(s) {
                s in dl || (dl[s] = !0, console.warn(s));
              }
              const pl = /* @__PURE__ */ new Gn().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), Al = /* @__PURE__ */ new Gn().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), No = { [hs]: { transfer: lo, primaries: co, toReference: (s) => s, fromReference: (s) => s }, [mi]: { transfer: Fi, primaries: co, toReference: (s) => s.convertSRGBToLinear(), fromReference: (s) => s.convertLinearToSRGB() }, [ao]: { transfer: lo, primaries: uo, toReference: (s) => s.applyMatrix3(Al), fromReference: (s) => s.applyMatrix3(pl) }, [Uo]: { transfer: Fi, primaries: uo, toReference: (s) => s.convertSRGBToLinear().applyMatrix3(Al), fromReference: (s) => s.applyMatrix3(pl).convertLinearToSRGB() } }, Cu = /* @__PURE__ */ new Set([hs, ao]), Mi = { enabled: !0, _workingColorSpace: hs, get workingColorSpace() {
                return this._workingColorSpace;
              }, set workingColorSpace(s) {
                if (!Cu.has(s))
                  throw new Error(`Unsupported working color space, "${s}".`);
                this._workingColorSpace = s;
              }, convert: function(s, e, t) {
                if (this.enabled === !1 || e === t || !e || !t)
                  return s;
                const n = No[e].toReference, i = No[t].fromReference;
                return i(n(s));
              }, fromWorkingColorSpace: function(s, e) {
                return this.convert(s, this._workingColorSpace, e);
              }, toWorkingColorSpace: function(s, e) {
                return this.convert(s, e, this._workingColorSpace);
              }, getPrimaries: function(s) {
                return No[s].primaries;
              }, getTransfer: function(s) {
                return s === Tr ? lo : No[s].transfer;
              } };
              function js(s) {
                return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
              }
              function xa(s) {
                return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
              }
              let Rs;
              class Ws {
                static getDataURL(e) {
                  if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
                    return e.src;
                  let t;
                  if (e instanceof HTMLCanvasElement)
                    t = e;
                  else {
                    Rs === void 0 && (Rs = Ao("canvas")), Rs.width = e.width, Rs.height = e.height;
                    const n = Rs.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Rs;
                  }
                  return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
                }
                static sRGBToLinear(e) {
                  if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                    const t = Ao("canvas");
                    t.width = e.width, t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const i = n.getImageData(0, 0, e.width, e.height), r = i.data;
                    for (let o = 0; o < r.length; o++)
                      r[o] = js(r[o] / 255) * 255;
                    return n.putImageData(i, 0, 0), t;
                  } else if (e.data) {
                    const t = e.data.slice(0);
                    for (let n = 0; n < t.length; n++)
                      t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(js(t[n] / 255) * 255) : t[n] = js(t[n]);
                    return { data: t, width: e.width, height: e.height };
                  } else
                    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
                }
              }
              let ml = 0;
              class Ki {
                constructor(e = null) {
                  this.isSource = !0, Object.defineProperty(this, "id", { value: ml++ }), this.uuid = kr(), this.data = e, this.dataReady = !0, this.version = 0;
                }
                set needsUpdate(e) {
                  e === !0 && this.version++;
                }
                toJSON(e) {
                  const t = e === void 0 || typeof e == "string";
                  if (!t && e.images[this.uuid] !== void 0)
                    return e.images[this.uuid];
                  const n = { uuid: this.uuid, url: "" }, i = this.data;
                  if (i !== null) {
                    let r;
                    if (Array.isArray(i)) {
                      r = [];
                      for (let o = 0, a = i.length; o < a; o++)
                        i[o].isDataTexture ? r.push(ko(i[o].image)) : r.push(ko(i[o]));
                    } else
                      r = ko(i);
                    n.url = r;
                  }
                  return t || (e.images[this.uuid] = n), n;
                }
              }
              function ko(s) {
                return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Ws.getDataURL(s) : s.data ? { data: Array.from(s.data), width: s.width, height: s.height, type: s.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
              }
              let gl = 0;
              class Vi extends Nr {
                constructor(e = Vi.DEFAULT_IMAGE, t = Vi.DEFAULT_MAPPING, n = Oe, i = Oe, r = vn, o = Ei, a = _e, h = Ii, m = Vi.DEFAULT_ANISOTROPY, _ = Tr) {
                  super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: gl++ }), this.uuid = kr(), this.name = "", this.source = new Ki(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = m, this.format = a, this.internalFormat = null, this.type = h, this.offset = new pt(0, 0), this.repeat = new pt(1, 1), this.center = new pt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Gn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = _, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
                }
                get image() {
                  return this.source.data;
                }
                set image(e = null) {
                  this.source.data = e;
                }
                updateMatrix() {
                  this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
                }
                toJSON(e) {
                  const t = e === void 0 || typeof e == "string";
                  if (!t && e.textures[this.uuid] !== void 0)
                    return e.textures[this.uuid];
                  const n = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
                  return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
                }
                dispose() {
                  this.dispatchEvent({ type: "dispose" });
                }
                transformUv(e) {
                  if (this.mapping !== xe) return e;
                  if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
                    switch (this.wrapS) {
                      case we:
                        e.x = e.x - Math.floor(e.x);
                        break;
                      case Oe:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                      case Ct:
                        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                        break;
                    }
                  if (e.y < 0 || e.y > 1)
                    switch (this.wrapT) {
                      case we:
                        e.y = e.y - Math.floor(e.y);
                        break;
                      case Oe:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                      case Ct:
                        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                        break;
                    }
                  return this.flipY && (e.y = 1 - e.y), e;
                }
                set needsUpdate(e) {
                  e === !0 && (this.version++, this.source.needsUpdate = !0);
                }
                set needsPMREMUpdate(e) {
                  e === !0 && this.pmremVersion++;
                }
              }
              Vi.DEFAULT_IMAGE = null, Vi.DEFAULT_MAPPING = xe, Vi.DEFAULT_ANISOTROPY = 1;
              class yi {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                  yi.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
                }
                get width() {
                  return this.z;
                }
                set width(e) {
                  this.z = e;
                }
                get height() {
                  return this.w;
                }
                set height(e) {
                  this.w = e;
                }
                set(e, t, n, i) {
                  return this.x = e, this.y = t, this.z = n, this.w = i, this;
                }
                setScalar(e) {
                  return this.x = e, this.y = e, this.z = e, this.w = e, this;
                }
                setX(e) {
                  return this.x = e, this;
                }
                setY(e) {
                  return this.y = e, this;
                }
                setZ(e) {
                  return this.z = e, this;
                }
                setW(e) {
                  return this.w = e, this;
                }
                setComponent(e, t) {
                  switch (e) {
                    case 0:
                      this.x = t;
                      break;
                    case 1:
                      this.y = t;
                      break;
                    case 2:
                      this.z = t;
                      break;
                    case 3:
                      this.w = t;
                      break;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                  return this;
                }
                getComponent(e) {
                  switch (e) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    case 2:
                      return this.z;
                    case 3:
                      return this.w;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                }
                clone() {
                  return new this.constructor(this.x, this.y, this.z, this.w);
                }
                copy(e) {
                  return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
                }
                add(e) {
                  return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
                }
                addScalar(e) {
                  return this.x += e, this.y += e, this.z += e, this.w += e, this;
                }
                addVectors(e, t) {
                  return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
                }
                addScaledVector(e, t) {
                  return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
                }
                sub(e) {
                  return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
                }
                subScalar(e) {
                  return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
                }
                subVectors(e, t) {
                  return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
                }
                multiply(e) {
                  return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
                }
                multiplyScalar(e) {
                  return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
                }
                applyMatrix4(e) {
                  const t = this.x, n = this.y, i = this.z, r = this.w, o = e.elements;
                  return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this;
                }
                divideScalar(e) {
                  return this.multiplyScalar(1 / e);
                }
                setAxisAngleFromQuaternion(e) {
                  this.w = 2 * Math.acos(e.w);
                  const t = Math.sqrt(1 - e.w * e.w);
                  return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
                }
                setAxisAngleFromRotationMatrix(e) {
                  let t, n, i, r;
                  const h = e.elements, m = h[0], _ = h[4], I = h[8], B = h[1], L = h[5], N = h[9], z = h[2], k = h[6], P = h[10];
                  if (Math.abs(_ - B) < 0.01 && Math.abs(I - z) < 0.01 && Math.abs(N - k) < 0.01) {
                    if (Math.abs(_ + B) < 0.1 && Math.abs(I + z) < 0.1 && Math.abs(N + k) < 0.1 && Math.abs(m + L + P - 3) < 0.1)
                      return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    const $ = (m + 1) / 2, J = (L + 1) / 2, Le = (P + 1) / 2, Ee = (_ + B) / 4, Me = (I + z) / 4, Re = (N + k) / 4;
                    return $ > J && $ > Le ? $ < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt($), i = Ee / n, r = Me / n) : J > Le ? J < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(J), n = Ee / i, r = Re / i) : Le < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(Le), n = Me / r, i = Re / r), this.set(n, i, r, t), this;
                  }
                  let se = Math.sqrt((k - N) * (k - N) + (I - z) * (I - z) + (B - _) * (B - _));
                  return Math.abs(se) < 1e-3 && (se = 1), this.x = (k - N) / se, this.y = (I - z) / se, this.z = (B - _) / se, this.w = Math.acos((m + L + P - 1) / 2), this;
                }
                min(e) {
                  return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
                }
                max(e) {
                  return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
                }
                clamp(e, t) {
                  return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
                }
                clampScalar(e, t) {
                  return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
                }
                clampLength(e, t) {
                  const n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
                }
                floor() {
                  return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
                }
                ceil() {
                  return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
                }
                round() {
                  return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
                }
                roundToZero() {
                  return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
                }
                negate() {
                  return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
                }
                dot(e) {
                  return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
                }
                lengthSq() {
                  return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                }
                length() {
                  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                }
                manhattanLength() {
                  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
                }
                normalize() {
                  return this.divideScalar(this.length() || 1);
                }
                setLength(e) {
                  return this.normalize().multiplyScalar(e);
                }
                lerp(e, t) {
                  return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
                }
                lerpVectors(e, t, n) {
                  return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
                }
                equals(e) {
                  return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
                }
                fromArray(e, t = 0) {
                  return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
                }
                toArray(e = [], t = 0) {
                  return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
                }
                fromBufferAttribute(e, t) {
                  return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
                }
                random() {
                  return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
                }
                *[Symbol.iterator]() {
                  yield this.x, yield this.y, yield this.z, yield this.w;
                }
              }
              class Go extends Nr {
                constructor(e = 1, t = 1, n = {}) {
                  super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new yi(0, 0, e, t), this.scissorTest = !1, this.viewport = new yi(0, 0, e, t);
                  const i = { width: e, height: t, depth: 1 };
                  n = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: vn, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, n);
                  const r = new Vi(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
                  r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
                  const o = n.count;
                  for (let a = 0; a < o; a++)
                    this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = !0;
                  this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
                }
                get texture() {
                  return this.textures[0];
                }
                set texture(e) {
                  this.textures[0] = e;
                }
                setSize(e, t, n = 1) {
                  if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e, this.height = t, this.depth = n;
                    for (let i = 0, r = this.textures.length; i < r; i++)
                      this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
                    this.dispose();
                  }
                  this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
                  for (let n = 0, i = e.textures.length; n < i; n++)
                    this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
                  const t = Object.assign({}, e.texture.image);
                  return this.texture.source = new Ki(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
                }
                dispose() {
                  this.dispatchEvent({ type: "dispose" });
                }
              }
              class zr extends Go {
                constructor(e = 1, t = 1, n = {}) {
                  super(e, t, n), this.isWebGLRenderTarget = !0;
                }
              }
              class Qo extends Vi {
                constructor(e = null, t = 1, n = 1, i = 1) {
                  super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Pt, this.minFilter = Pt, this.wrapR = Oe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
                }
              }
              class un extends zr {
                constructor(e = 1, t = 1, n = 1, i = {}) {
                  super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new Qo(null, e, t, n), this.texture.isRenderTargetTexture = !0;
                }
              }
              class Qn extends Vi {
                constructor(e = null, t = 1, n = 1, i = 1) {
                  super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Pt, this.minFilter = Pt, this.wrapR = Oe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
                }
              }
              class pi extends zr {
                constructor(e = 1, t = 1, n = 1, i = {}) {
                  super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Qn(null, e, t, n), this.texture.isRenderTargetTexture = !0;
                }
              }
              class xi {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                  this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
                }
                static slerpFlat(e, t, n, i, r, o, a) {
                  let h = n[i + 0], m = n[i + 1], _ = n[i + 2], I = n[i + 3];
                  const B = r[o + 0], L = r[o + 1], N = r[o + 2], z = r[o + 3];
                  if (a === 0) {
                    e[t + 0] = h, e[t + 1] = m, e[t + 2] = _, e[t + 3] = I;
                    return;
                  }
                  if (a === 1) {
                    e[t + 0] = B, e[t + 1] = L, e[t + 2] = N, e[t + 3] = z;
                    return;
                  }
                  if (I !== z || h !== B || m !== L || _ !== N) {
                    let k = 1 - a;
                    const P = h * B + m * L + _ * N + I * z, se = P >= 0 ? 1 : -1, $ = 1 - P * P;
                    if ($ > Number.EPSILON) {
                      const Le = Math.sqrt($), Ee = Math.atan2(Le, P * se);
                      k = Math.sin(k * Ee) / Le, a = Math.sin(a * Ee) / Le;
                    }
                    const J = a * se;
                    if (h = h * k + B * J, m = m * k + L * J, _ = _ * k + N * J, I = I * k + z * J, k === 1 - a) {
                      const Le = 1 / Math.sqrt(h * h + m * m + _ * _ + I * I);
                      h *= Le, m *= Le, _ *= Le, I *= Le;
                    }
                  }
                  e[t] = h, e[t + 1] = m, e[t + 2] = _, e[t + 3] = I;
                }
                static multiplyQuaternionsFlat(e, t, n, i, r, o) {
                  const a = n[i], h = n[i + 1], m = n[i + 2], _ = n[i + 3], I = r[o], B = r[o + 1], L = r[o + 2], N = r[o + 3];
                  return e[t] = a * N + _ * I + h * L - m * B, e[t + 1] = h * N + _ * B + m * I - a * L, e[t + 2] = m * N + _ * L + a * B - h * I, e[t + 3] = _ * N - a * I - h * B - m * L, e;
                }
                get x() {
                  return this._x;
                }
                set x(e) {
                  this._x = e, this._onChangeCallback();
                }
                get y() {
                  return this._y;
                }
                set y(e) {
                  this._y = e, this._onChangeCallback();
                }
                get z() {
                  return this._z;
                }
                set z(e) {
                  this._z = e, this._onChangeCallback();
                }
                get w() {
                  return this._w;
                }
                set w(e) {
                  this._w = e, this._onChangeCallback();
                }
                set(e, t, n, i) {
                  return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
                }
                clone() {
                  return new this.constructor(this._x, this._y, this._z, this._w);
                }
                copy(e) {
                  return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
                }
                setFromEuler(e, t = !0) {
                  const n = e._x, i = e._y, r = e._z, o = e._order, a = Math.cos, h = Math.sin, m = a(n / 2), _ = a(i / 2), I = a(r / 2), B = h(n / 2), L = h(i / 2), N = h(r / 2);
                  switch (o) {
                    case "XYZ":
                      this._x = B * _ * I + m * L * N, this._y = m * L * I - B * _ * N, this._z = m * _ * N + B * L * I, this._w = m * _ * I - B * L * N;
                      break;
                    case "YXZ":
                      this._x = B * _ * I + m * L * N, this._y = m * L * I - B * _ * N, this._z = m * _ * N - B * L * I, this._w = m * _ * I + B * L * N;
                      break;
                    case "ZXY":
                      this._x = B * _ * I - m * L * N, this._y = m * L * I + B * _ * N, this._z = m * _ * N + B * L * I, this._w = m * _ * I - B * L * N;
                      break;
                    case "ZYX":
                      this._x = B * _ * I - m * L * N, this._y = m * L * I + B * _ * N, this._z = m * _ * N - B * L * I, this._w = m * _ * I + B * L * N;
                      break;
                    case "YZX":
                      this._x = B * _ * I + m * L * N, this._y = m * L * I + B * _ * N, this._z = m * _ * N - B * L * I, this._w = m * _ * I - B * L * N;
                      break;
                    case "XZY":
                      this._x = B * _ * I - m * L * N, this._y = m * L * I - B * _ * N, this._z = m * _ * N + B * L * I, this._w = m * _ * I + B * L * N;
                      break;
                    default:
                      console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
                  }
                  return t === !0 && this._onChangeCallback(), this;
                }
                setFromAxisAngle(e, t) {
                  const n = t / 2, i = Math.sin(n);
                  return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
                }
                setFromRotationMatrix(e) {
                  const t = e.elements, n = t[0], i = t[4], r = t[8], o = t[1], a = t[5], h = t[9], m = t[2], _ = t[6], I = t[10], B = n + a + I;
                  if (B > 0) {
                    const L = 0.5 / Math.sqrt(B + 1);
                    this._w = 0.25 / L, this._x = (_ - h) * L, this._y = (r - m) * L, this._z = (o - i) * L;
                  } else if (n > a && n > I) {
                    const L = 2 * Math.sqrt(1 + n - a - I);
                    this._w = (_ - h) / L, this._x = 0.25 * L, this._y = (i + o) / L, this._z = (r + m) / L;
                  } else if (a > I) {
                    const L = 2 * Math.sqrt(1 + a - n - I);
                    this._w = (r - m) / L, this._x = (i + o) / L, this._y = 0.25 * L, this._z = (h + _) / L;
                  } else {
                    const L = 2 * Math.sqrt(1 + I - n - a);
                    this._w = (o - i) / L, this._x = (r + m) / L, this._y = (h + _) / L, this._z = 0.25 * L;
                  }
                  return this._onChangeCallback(), this;
                }
                setFromUnitVectors(e, t) {
                  let n = e.dot(t) + 1;
                  return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
                }
                angleTo(e) {
                  return 2 * Math.acos(Math.abs(Yi(this.dot(e), -1, 1)));
                }
                rotateTowards(e, t) {
                  const n = this.angleTo(e);
                  if (n === 0) return this;
                  const i = Math.min(1, t / n);
                  return this.slerp(e, i), this;
                }
                identity() {
                  return this.set(0, 0, 0, 1);
                }
                invert() {
                  return this.conjugate();
                }
                conjugate() {
                  return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
                }
                dot(e) {
                  return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
                }
                lengthSq() {
                  return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
                }
                length() {
                  return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
                }
                normalize() {
                  let e = this.length();
                  return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
                }
                multiply(e) {
                  return this.multiplyQuaternions(this, e);
                }
                premultiply(e) {
                  return this.multiplyQuaternions(e, this);
                }
                multiplyQuaternions(e, t) {
                  const n = e._x, i = e._y, r = e._z, o = e._w, a = t._x, h = t._y, m = t._z, _ = t._w;
                  return this._x = n * _ + o * a + i * m - r * h, this._y = i * _ + o * h + r * a - n * m, this._z = r * _ + o * m + n * h - i * a, this._w = o * _ - n * a - i * h - r * m, this._onChangeCallback(), this;
                }
                slerp(e, t) {
                  if (t === 0) return this;
                  if (t === 1) return this.copy(e);
                  const n = this._x, i = this._y, r = this._z, o = this._w;
                  let a = o * e._w + n * e._x + i * e._y + r * e._z;
                  if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
                    return this._w = o, this._x = n, this._y = i, this._z = r, this;
                  const h = 1 - a * a;
                  if (h <= Number.EPSILON) {
                    const L = 1 - t;
                    return this._w = L * o + t * this._w, this._x = L * n + t * this._x, this._y = L * i + t * this._y, this._z = L * r + t * this._z, this.normalize(), this;
                  }
                  const m = Math.sqrt(h), _ = Math.atan2(m, a), I = Math.sin((1 - t) * _) / m, B = Math.sin(t * _) / m;
                  return this._w = o * I + this._w * B, this._x = n * I + this._x * B, this._y = i * I + this._y * B, this._z = r * I + this._z * B, this._onChangeCallback(), this;
                }
                slerpQuaternions(e, t, n) {
                  return this.copy(e).slerp(t, n);
                }
                random() {
                  const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), r = Math.sqrt(n);
                  return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
                }
                equals(e) {
                  return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
                }
                fromArray(e, t = 0) {
                  return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
                }
                toArray(e = [], t = 0) {
                  return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
                }
                fromBufferAttribute(e, t) {
                  return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
                }
                toJSON() {
                  return this.toArray();
                }
                _onChange(e) {
                  return this._onChangeCallback = e, this;
                }
                _onChangeCallback() {
                }
                *[Symbol.iterator]() {
                  yield this._x, yield this._y, yield this._z, yield this._w;
                }
              }
              class ye {
                constructor(e = 0, t = 0, n = 0) {
                  ye.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
                }
                set(e, t, n) {
                  return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
                }
                setScalar(e) {
                  return this.x = e, this.y = e, this.z = e, this;
                }
                setX(e) {
                  return this.x = e, this;
                }
                setY(e) {
                  return this.y = e, this;
                }
                setZ(e) {
                  return this.z = e, this;
                }
                setComponent(e, t) {
                  switch (e) {
                    case 0:
                      this.x = t;
                      break;
                    case 1:
                      this.y = t;
                      break;
                    case 2:
                      this.z = t;
                      break;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                  return this;
                }
                getComponent(e) {
                  switch (e) {
                    case 0:
                      return this.x;
                    case 1:
                      return this.y;
                    case 2:
                      return this.z;
                    default:
                      throw new Error("index is out of range: " + e);
                  }
                }
                clone() {
                  return new this.constructor(this.x, this.y, this.z);
                }
                copy(e) {
                  return this.x = e.x, this.y = e.y, this.z = e.z, this;
                }
                add(e) {
                  return this.x += e.x, this.y += e.y, this.z += e.z, this;
                }
                addScalar(e) {
                  return this.x += e, this.y += e, this.z += e, this;
                }
                addVectors(e, t) {
                  return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
                }
                addScaledVector(e, t) {
                  return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
                }
                sub(e) {
                  return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
                }
                subScalar(e) {
                  return this.x -= e, this.y -= e, this.z -= e, this;
                }
                subVectors(e, t) {
                  return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
                }
                multiply(e) {
                  return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
                }
                multiplyScalar(e) {
                  return this.x *= e, this.y *= e, this.z *= e, this;
                }
                multiplyVectors(e, t) {
                  return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
                }
                applyEuler(e) {
                  return this.applyQuaternion(tr.setFromEuler(e));
                }
                applyAxisAngle(e, t) {
                  return this.applyQuaternion(tr.setFromAxisAngle(e, t));
                }
                applyMatrix3(e) {
                  const t = this.x, n = this.y, i = this.z, r = e.elements;
                  return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
                }
                applyNormalMatrix(e) {
                  return this.applyMatrix3(e).normalize();
                }
                applyMatrix4(e) {
                  const t = this.x, n = this.y, i = this.z, r = e.elements, o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                  return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this;
                }
                applyQuaternion(e) {
                  const t = this.x, n = this.y, i = this.z, r = e.x, o = e.y, a = e.z, h = e.w, m = 2 * (o * i - a * n), _ = 2 * (a * t - r * i), I = 2 * (r * n - o * t);
                  return this.x = t + h * m + o * I - a * _, this.y = n + h * _ + a * m - r * I, this.z = i + h * I + r * _ - o * m, this;
                }
                project(e) {
                  return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
                }
                unproject(e) {
                  return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
                }
                transformDirection(e) {
                  const t = this.x, n = this.y, i = this.z, r = e.elements;
                  return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
                }
                divide(e) {
                  return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
                }
                divideScalar(e) {
                  return this.multiplyScalar(1 / e);
                }
                min(e) {
                  return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
                }
                max(e) {
                  return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
                }
                clamp(e, t) {
                  return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
                }
                clampScalar(e, t) {
                  return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
                }
                clampLength(e, t) {
                  const n = this.length();
                  return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
                }
                floor() {
                  return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
                }
                ceil() {
                  return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
                }
                round() {
                  return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
                }
                roundToZero() {
                  return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
                }
                negate() {
                  return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
                }
                dot(e) {
                  return this.x * e.x + this.y * e.y + this.z * e.z;
                }
                // TODO lengthSquared?
                lengthSq() {
                  return this.x * this.x + this.y * this.y + this.z * this.z;
                }
                length() {
                  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                manhattanLength() {
                  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                }
                normalize() {
                  return this.divideScalar(this.length() || 1);
                }
                setLength(e) {
                  return this.normalize().multiplyScalar(e);
                }
                lerp(e, t) {
                  return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
                }
                lerpVectors(e, t, n) {
                  return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
                }
                cross(e) {
                  return this.crossVectors(this, e);
                }
                crossVectors(e, t) {
                  const n = e.x, i = e.y, r = e.z, o = t.x, a = t.y, h = t.z;
                  return this.x = i * h - r * a, this.y = r * o - n * h, this.z = n * a - i * o, this;
                }
                projectOnVector(e) {
                  const t = e.lengthSq();
                  if (t === 0) return this.set(0, 0, 0);
                  const n = e.dot(this) / t;
                  return this.copy(e).multiplyScalar(n);
                }
                projectOnPlane(e) {
                  return qr.copy(this).projectOnVector(e), this.sub(qr);
                }
                reflect(e) {
                  return this.sub(qr.copy(e).multiplyScalar(2 * this.dot(e)));
                }
                angleTo(e) {
                  const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                  if (t === 0) return Math.PI / 2;
                  const n = this.dot(e) / t;
                  return Math.acos(Yi(n, -1, 1));
                }
                distanceTo(e) {
                  return Math.sqrt(this.distanceToSquared(e));
                }
                distanceToSquared(e) {
                  const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
                  return t * t + n * n + i * i;
                }
                manhattanDistanceTo(e) {
                  return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
                }
                setFromSpherical(e) {
                  return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
                }
                setFromSphericalCoords(e, t, n) {
                  const i = Math.sin(t) * e;
                  return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
                }
                setFromCylindrical(e) {
                  return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
                }
                setFromCylindricalCoords(e, t, n) {
                  return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
                }
                setFromMatrixPosition(e) {
                  const t = e.elements;
                  return this.x = t[12], this.y = t[13], this.z = t[14], this;
                }
                setFromMatrixScale(e) {
                  const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
                  return this.x = t, this.y = n, this.z = i, this;
                }
                setFromMatrixColumn(e, t) {
                  return this.fromArray(e.elements, t * 4);
                }
                setFromMatrix3Column(e, t) {
                  return this.fromArray(e.elements, t * 3);
                }
                setFromEuler(e) {
                  return this.x = e._x, this.y = e._y, this.z = e._z, this;
                }
                setFromColor(e) {
                  return this.x = e.r, this.y = e.g, this.z = e.b, this;
                }
                equals(e) {
                  return e.x === this.x && e.y === this.y && e.z === this.z;
                }
                fromArray(e, t = 0) {
                  return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
                }
                toArray(e = [], t = 0) {
                  return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
                }
                fromBufferAttribute(e, t) {
                  return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
                }
                random() {
                  return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
                }
                randomDirection() {
                  const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
                  return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
                }
                *[Symbol.iterator]() {
                  yield this.x, yield this.y, yield this.z;
                }
              }
              const qr = /* @__PURE__ */ new ye(), tr = /* @__PURE__ */ new xi();
              class Zi {
                constructor(e = new ye(1 / 0, 1 / 0, 1 / 0), t = new ye(-1 / 0, -1 / 0, -1 / 0)) {
                  this.isBox3 = !0, this.min = e, this.max = t;
                }
                set(e, t) {
                  return this.min.copy(e), this.max.copy(t), this;
                }
                setFromArray(e) {
                  this.makeEmpty();
                  for (let t = 0, n = e.length; t < n; t += 3)
                    this.expandByPoint(Lr.fromArray(e, t));
                  return this;
                }
                setFromBufferAttribute(e) {
                  this.makeEmpty();
                  for (let t = 0, n = e.count; t < n; t++)
                    this.expandByPoint(Lr.fromBufferAttribute(e, t));
                  return this;
                }
                setFromPoints(e) {
                  this.makeEmpty();
                  for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                  return this;
                }
                setFromCenterAndSize(e, t) {
                  const n = Lr.copy(t).multiplyScalar(0.5);
                  return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
                }
                setFromObject(e, t = !1) {
                  return this.makeEmpty(), this.expandByObject(e, t);
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  return this.min.copy(e.min), this.max.copy(e.max), this;
                }
                makeEmpty() {
                  return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
                }
                isEmpty() {
                  return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
                }
                getCenter(e) {
                  return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
                }
                getSize(e) {
                  return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
                }
                expandByPoint(e) {
                  return this.min.min(e), this.max.max(e), this;
                }
                expandByVector(e) {
                  return this.min.sub(e), this.max.add(e), this;
                }
                expandByScalar(e) {
                  return this.min.addScalar(-e), this.max.addScalar(e), this;
                }
                expandByObject(e, t = !1) {
                  e.updateWorldMatrix(!1, !1);
                  const n = e.geometry;
                  if (n !== void 0) {
                    const r = n.getAttribute("position");
                    if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
                      for (let o = 0, a = r.count; o < a; o++)
                        e.isMesh === !0 ? e.getVertexPosition(o, Lr) : Lr.fromBufferAttribute(r, o), Lr.applyMatrix4(e.matrixWorld), this.expandByPoint(Lr);
                    else
                      e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Cs.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Cs.copy(n.boundingBox)), Cs.applyMatrix4(e.matrixWorld), this.union(Cs);
                  }
                  const i = e.children;
                  for (let r = 0, o = i.length; r < o; r++)
                    this.expandByObject(i[r], t);
                  return this;
                }
                containsPoint(e) {
                  return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
                }
                containsBox(e) {
                  return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
                }
                getParameter(e, t) {
                  return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
                }
                intersectsBox(e) {
                  return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
                }
                intersectsSphere(e) {
                  return this.clampPoint(e.center, Lr), Lr.distanceToSquared(e.center) <= e.radius * e.radius;
                }
                intersectsPlane(e) {
                  let t, n;
                  return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
                }
                intersectsTriangle(e) {
                  if (this.isEmpty())
                    return !1;
                  this.getCenter(gi), Di.subVectors(this.max, gi), jr.subVectors(e.a, gi), _r.subVectors(e.b, gi), Yn.subVectors(e.c, gi), Br.subVectors(_r, jr), Jr.subVectors(Yn, _r), wr.subVectors(jr, Yn);
                  let t = [0, -Br.z, Br.y, 0, -Jr.z, Jr.y, 0, -wr.z, wr.y, Br.z, 0, -Br.x, Jr.z, 0, -Jr.x, wr.z, 0, -wr.x, -Br.y, Br.x, 0, -Jr.y, Jr.x, 0, -wr.y, wr.x, 0];
                  return !Gr(t, jr, _r, Yn, Di) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Gr(t, jr, _r, Yn, Di)) ? !1 : (qn.crossVectors(Br, Jr), t = [qn.x, qn.y, qn.z], Gr(t, jr, _r, Yn, Di));
                }
                clampPoint(e, t) {
                  return t.copy(e).clamp(this.min, this.max);
                }
                distanceToPoint(e) {
                  return this.clampPoint(e, Lr).distanceTo(e);
                }
                getBoundingSphere(e) {
                  return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Lr).length() * 0.5), e;
                }
                intersect(e) {
                  return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
                }
                union(e) {
                  return this.min.min(e.min), this.max.max(e.max), this;
                }
                applyMatrix4(e) {
                  return this.isEmpty() ? this : (hi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), hi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), hi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), hi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), hi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), hi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), hi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), hi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(hi), this);
                }
                translate(e) {
                  return this.min.add(e), this.max.add(e), this;
                }
                equals(e) {
                  return e.min.equals(this.min) && e.max.equals(this.max);
                }
              }
              const hi = [/* @__PURE__ */ new ye(), /* @__PURE__ */ new ye(), /* @__PURE__ */ new ye(), /* @__PURE__ */ new ye(), /* @__PURE__ */ new ye(), /* @__PURE__ */ new ye(), /* @__PURE__ */ new ye(), /* @__PURE__ */ new ye()], Lr = /* @__PURE__ */ new ye(), Cs = /* @__PURE__ */ new Zi(), jr = /* @__PURE__ */ new ye(), _r = /* @__PURE__ */ new ye(), Yn = /* @__PURE__ */ new ye(), Br = /* @__PURE__ */ new ye(), Jr = /* @__PURE__ */ new ye(), wr = /* @__PURE__ */ new ye(), gi = /* @__PURE__ */ new ye(), Di = /* @__PURE__ */ new ye(), qn = /* @__PURE__ */ new ye(), vi = /* @__PURE__ */ new ye();
              function Gr(s, e, t, n, i) {
                for (let r = 0, o = s.length - 3; r <= o; r += 3) {
                  vi.fromArray(s, r);
                  const a = i.x * Math.abs(vi.x) + i.y * Math.abs(vi.y) + i.z * Math.abs(vi.z), h = e.dot(vi), m = t.dot(vi), _ = n.dot(vi);
                  if (Math.max(-Math.max(h, m, _), Math.min(h, m, _)) > a)
                    return !1;
                }
                return !0;
              }
              const Ks = /* @__PURE__ */ new Zi(), Ls = /* @__PURE__ */ new ye(), Vo = /* @__PURE__ */ new ye();
              class pr {
                constructor(e = new ye(), t = -1) {
                  this.isSphere = !0, this.center = e, this.radius = t;
                }
                set(e, t) {
                  return this.center.copy(e), this.radius = t, this;
                }
                setFromPoints(e, t) {
                  const n = this.center;
                  t !== void 0 ? n.copy(t) : Ks.setFromPoints(e).getCenter(n);
                  let i = 0;
                  for (let r = 0, o = e.length; r < o; r++)
                    i = Math.max(i, n.distanceToSquared(e[r]));
                  return this.radius = Math.sqrt(i), this;
                }
                copy(e) {
                  return this.center.copy(e.center), this.radius = e.radius, this;
                }
                isEmpty() {
                  return this.radius < 0;
                }
                makeEmpty() {
                  return this.center.set(0, 0, 0), this.radius = -1, this;
                }
                containsPoint(e) {
                  return e.distanceToSquared(this.center) <= this.radius * this.radius;
                }
                distanceToPoint(e) {
                  return e.distanceTo(this.center) - this.radius;
                }
                intersectsSphere(e) {
                  const t = this.radius + e.radius;
                  return e.center.distanceToSquared(this.center) <= t * t;
                }
                intersectsBox(e) {
                  return e.intersectsSphere(this);
                }
                intersectsPlane(e) {
                  return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
                }
                clampPoint(e, t) {
                  const n = this.center.distanceToSquared(e);
                  return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
                }
                getBoundingBox(e) {
                  return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
                }
                applyMatrix4(e) {
                  return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
                }
                translate(e) {
                  return this.center.add(e), this;
                }
                expandByPoint(e) {
                  if (this.isEmpty())
                    return this.center.copy(e), this.radius = 0, this;
                  Ls.subVectors(e, this.center);
                  const t = Ls.lengthSq();
                  if (t > this.radius * this.radius) {
                    const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
                    this.center.addScaledVector(Ls, i / n), this.radius += i;
                  }
                  return this;
                }
                union(e) {
                  return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Vo.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Ls.copy(e.center).add(Vo)), this.expandByPoint(Ls.copy(e.center).sub(Vo))), this);
                }
                equals(e) {
                  return e.center.equals(this.center) && e.radius === this.radius;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              const os = /* @__PURE__ */ new ye(), Ho = /* @__PURE__ */ new ye(), zo = /* @__PURE__ */ new ye(), xs = /* @__PURE__ */ new ye(), ba = /* @__PURE__ */ new ye(), jo = /* @__PURE__ */ new ye(), _a = /* @__PURE__ */ new ye();
              class Ar {
                constructor(e = new ye(), t = new ye(0, 0, -1)) {
                  this.origin = e, this.direction = t;
                }
                set(e, t) {
                  return this.origin.copy(e), this.direction.copy(t), this;
                }
                copy(e) {
                  return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
                }
                at(e, t) {
                  return t.copy(this.origin).addScaledVector(this.direction, e);
                }
                lookAt(e) {
                  return this.direction.copy(e).sub(this.origin).normalize(), this;
                }
                recast(e) {
                  return this.origin.copy(this.at(e, os)), this;
                }
                closestPointToPoint(e, t) {
                  t.subVectors(e, this.origin);
                  const n = t.dot(this.direction);
                  return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
                }
                distanceToPoint(e) {
                  return Math.sqrt(this.distanceSqToPoint(e));
                }
                distanceSqToPoint(e) {
                  const t = os.subVectors(e, this.origin).dot(this.direction);
                  return t < 0 ? this.origin.distanceToSquared(e) : (os.copy(this.origin).addScaledVector(this.direction, t), os.distanceToSquared(e));
                }
                distanceSqToSegment(e, t, n, i) {
                  Ho.copy(e).add(t).multiplyScalar(0.5), zo.copy(t).sub(e).normalize(), xs.copy(this.origin).sub(Ho);
                  const r = e.distanceTo(t) * 0.5, o = -this.direction.dot(zo), a = xs.dot(this.direction), h = -xs.dot(zo), m = xs.lengthSq(), _ = Math.abs(1 - o * o);
                  let I, B, L, N;
                  if (_ > 0)
                    if (I = o * h - a, B = o * a - h, N = r * _, I >= 0)
                      if (B >= -N)
                        if (B <= N) {
                          const z = 1 / _;
                          I *= z, B *= z, L = I * (I + o * B + 2 * a) + B * (o * I + B + 2 * h) + m;
                        } else
                          B = r, I = Math.max(0, -(o * B + a)), L = -I * I + B * (B + 2 * h) + m;
                      else
                        B = -r, I = Math.max(0, -(o * B + a)), L = -I * I + B * (B + 2 * h) + m;
                    else
                      B <= -N ? (I = Math.max(0, -(-o * r + a)), B = I > 0 ? -r : Math.min(Math.max(-r, -h), r), L = -I * I + B * (B + 2 * h) + m) : B <= N ? (I = 0, B = Math.min(Math.max(-r, -h), r), L = B * (B + 2 * h) + m) : (I = Math.max(0, -(o * r + a)), B = I > 0 ? r : Math.min(Math.max(-r, -h), r), L = -I * I + B * (B + 2 * h) + m);
                  else
                    B = o > 0 ? -r : r, I = Math.max(0, -(o * B + a)), L = -I * I + B * (B + 2 * h) + m;
                  return n && n.copy(this.origin).addScaledVector(this.direction, I), i && i.copy(Ho).addScaledVector(zo, B), L;
                }
                intersectSphere(e, t) {
                  os.subVectors(e.center, this.origin);
                  const n = os.dot(this.direction), i = os.dot(os) - n * n, r = e.radius * e.radius;
                  if (i > r) return null;
                  const o = Math.sqrt(r - i), a = n - o, h = n + o;
                  return h < 0 ? null : a < 0 ? this.at(h, t) : this.at(a, t);
                }
                intersectsSphere(e) {
                  return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
                }
                distanceToPlane(e) {
                  const t = e.normal.dot(this.direction);
                  if (t === 0)
                    return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                  const n = -(this.origin.dot(e.normal) + e.constant) / t;
                  return n >= 0 ? n : null;
                }
                intersectPlane(e, t) {
                  const n = this.distanceToPlane(e);
                  return n === null ? null : this.at(n, t);
                }
                intersectsPlane(e) {
                  const t = e.distanceToPoint(this.origin);
                  return t === 0 || e.normal.dot(this.direction) * t < 0;
                }
                intersectBox(e, t) {
                  let n, i, r, o, a, h;
                  const m = 1 / this.direction.x, _ = 1 / this.direction.y, I = 1 / this.direction.z, B = this.origin;
                  return m >= 0 ? (n = (e.min.x - B.x) * m, i = (e.max.x - B.x) * m) : (n = (e.max.x - B.x) * m, i = (e.min.x - B.x) * m), _ >= 0 ? (r = (e.min.y - B.y) * _, o = (e.max.y - B.y) * _) : (r = (e.max.y - B.y) * _, o = (e.min.y - B.y) * _), n > o || r > i || ((r > n || isNaN(n)) && (n = r), (o < i || isNaN(i)) && (i = o), I >= 0 ? (a = (e.min.z - B.z) * I, h = (e.max.z - B.z) * I) : (a = (e.max.z - B.z) * I, h = (e.min.z - B.z) * I), n > h || a > i) || ((a > n || n !== n) && (n = a), (h < i || i !== i) && (i = h), i < 0) ? null : this.at(n >= 0 ? n : i, t);
                }
                intersectsBox(e) {
                  return this.intersectBox(e, os) !== null;
                }
                intersectTriangle(e, t, n, i, r) {
                  ba.subVectors(t, e), jo.subVectors(n, e), _a.crossVectors(ba, jo);
                  let o = this.direction.dot(_a), a;
                  if (o > 0) {
                    if (i) return null;
                    a = 1;
                  } else if (o < 0)
                    a = -1, o = -o;
                  else
                    return null;
                  xs.subVectors(this.origin, e);
                  const h = a * this.direction.dot(jo.crossVectors(xs, jo));
                  if (h < 0)
                    return null;
                  const m = a * this.direction.dot(ba.cross(xs));
                  if (m < 0 || h + m > o)
                    return null;
                  const _ = -a * xs.dot(_a);
                  return _ < 0 ? null : this.at(_ / o, r);
                }
                applyMatrix4(e) {
                  return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
                }
                equals(e) {
                  return e.origin.equals(this.origin) && e.direction.equals(this.direction);
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              class pn {
                constructor(e, t, n, i, r, o, a, h, m, _, I, B, L, N, z, k) {
                  pn.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, r, o, a, h, m, _, I, B, L, N, z, k);
                }
                set(e, t, n, i, r, o, a, h, m, _, I, B, L, N, z, k) {
                  const P = this.elements;
                  return P[0] = e, P[4] = t, P[8] = n, P[12] = i, P[1] = r, P[5] = o, P[9] = a, P[13] = h, P[2] = m, P[6] = _, P[10] = I, P[14] = B, P[3] = L, P[7] = N, P[11] = z, P[15] = k, this;
                }
                identity() {
                  return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                }
                clone() {
                  return new pn().fromArray(this.elements);
                }
                copy(e) {
                  const t = this.elements, n = e.elements;
                  return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
                }
                copyPosition(e) {
                  const t = this.elements, n = e.elements;
                  return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
                }
                setFromMatrix3(e) {
                  const t = e.elements;
                  return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
                }
                extractBasis(e, t, n) {
                  return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
                }
                makeBasis(e, t, n) {
                  return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
                }
                extractRotation(e) {
                  const t = this.elements, n = e.elements, i = 1 / Ds.setFromMatrixColumn(e, 0).length(), r = 1 / Ds.setFromMatrixColumn(e, 1).length(), o = 1 / Ds.setFromMatrixColumn(e, 2).length();
                  return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
                }
                makeRotationFromEuler(e) {
                  const t = this.elements, n = e.x, i = e.y, r = e.z, o = Math.cos(n), a = Math.sin(n), h = Math.cos(i), m = Math.sin(i), _ = Math.cos(r), I = Math.sin(r);
                  if (e.order === "XYZ") {
                    const B = o * _, L = o * I, N = a * _, z = a * I;
                    t[0] = h * _, t[4] = -h * I, t[8] = m, t[1] = L + N * m, t[5] = B - z * m, t[9] = -a * h, t[2] = z - B * m, t[6] = N + L * m, t[10] = o * h;
                  } else if (e.order === "YXZ") {
                    const B = h * _, L = h * I, N = m * _, z = m * I;
                    t[0] = B + z * a, t[4] = N * a - L, t[8] = o * m, t[1] = o * I, t[5] = o * _, t[9] = -a, t[2] = L * a - N, t[6] = z + B * a, t[10] = o * h;
                  } else if (e.order === "ZXY") {
                    const B = h * _, L = h * I, N = m * _, z = m * I;
                    t[0] = B - z * a, t[4] = -o * I, t[8] = N + L * a, t[1] = L + N * a, t[5] = o * _, t[9] = z - B * a, t[2] = -o * m, t[6] = a, t[10] = o * h;
                  } else if (e.order === "ZYX") {
                    const B = o * _, L = o * I, N = a * _, z = a * I;
                    t[0] = h * _, t[4] = N * m - L, t[8] = B * m + z, t[1] = h * I, t[5] = z * m + B, t[9] = L * m - N, t[2] = -m, t[6] = a * h, t[10] = o * h;
                  } else if (e.order === "YZX") {
                    const B = o * h, L = o * m, N = a * h, z = a * m;
                    t[0] = h * _, t[4] = z - B * I, t[8] = N * I + L, t[1] = I, t[5] = o * _, t[9] = -a * _, t[2] = -m * _, t[6] = L * I + N, t[10] = B - z * I;
                  } else if (e.order === "XZY") {
                    const B = o * h, L = o * m, N = a * h, z = a * m;
                    t[0] = h * _, t[4] = -I, t[8] = m * _, t[1] = B * I + z, t[5] = o * _, t[9] = L * I - N, t[2] = N * I - L, t[6] = a * _, t[10] = z * I + B;
                  }
                  return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
                }
                makeRotationFromQuaternion(e) {
                  return this.compose(Up, e, Np);
                }
                lookAt(e, t, n) {
                  const i = this.elements;
                  return Zr.subVectors(e, t), Zr.lengthSq() === 0 && (Zr.z = 1), Zr.normalize(), Xs.crossVectors(n, Zr), Xs.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Zr.x += 1e-4 : Zr.z += 1e-4, Zr.normalize(), Xs.crossVectors(n, Zr)), Xs.normalize(), vl.crossVectors(Zr, Xs), i[0] = Xs.x, i[4] = vl.x, i[8] = Zr.x, i[1] = Xs.y, i[5] = vl.y, i[9] = Zr.y, i[2] = Xs.z, i[6] = vl.z, i[10] = Zr.z, this;
                }
                multiply(e) {
                  return this.multiplyMatrices(this, e);
                }
                premultiply(e) {
                  return this.multiplyMatrices(e, this);
                }
                multiplyMatrices(e, t) {
                  const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[4], h = n[8], m = n[12], _ = n[1], I = n[5], B = n[9], L = n[13], N = n[2], z = n[6], k = n[10], P = n[14], se = n[3], $ = n[7], J = n[11], Le = n[15], Ee = i[0], Me = i[4], Re = i[8], Ae = i[12], ce = i[1], Ie = i[5], Qe = i[9], Ue = i[13], He = i[2], Ze = i[6], dt = i[10], Nt = i[14], et = i[3], Lt = i[7], Ot = i[11], fn = i[15];
                  return r[0] = o * Ee + a * ce + h * He + m * et, r[4] = o * Me + a * Ie + h * Ze + m * Lt, r[8] = o * Re + a * Qe + h * dt + m * Ot, r[12] = o * Ae + a * Ue + h * Nt + m * fn, r[1] = _ * Ee + I * ce + B * He + L * et, r[5] = _ * Me + I * Ie + B * Ze + L * Lt, r[9] = _ * Re + I * Qe + B * dt + L * Ot, r[13] = _ * Ae + I * Ue + B * Nt + L * fn, r[2] = N * Ee + z * ce + k * He + P * et, r[6] = N * Me + z * Ie + k * Ze + P * Lt, r[10] = N * Re + z * Qe + k * dt + P * Ot, r[14] = N * Ae + z * Ue + k * Nt + P * fn, r[3] = se * Ee + $ * ce + J * He + Le * et, r[7] = se * Me + $ * Ie + J * Ze + Le * Lt, r[11] = se * Re + $ * Qe + J * dt + Le * Ot, r[15] = se * Ae + $ * Ue + J * Nt + Le * fn, this;
                }
                multiplyScalar(e) {
                  const t = this.elements;
                  return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
                }
                determinant() {
                  const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], o = e[1], a = e[5], h = e[9], m = e[13], _ = e[2], I = e[6], B = e[10], L = e[14], N = e[3], z = e[7], k = e[11], P = e[15];
                  return N * (+r * h * I - i * m * I - r * a * B + n * m * B + i * a * L - n * h * L) + z * (+t * h * L - t * m * B + r * o * B - i * o * L + i * m * _ - r * h * _) + k * (+t * m * I - t * a * L - r * o * I + n * o * L + r * a * _ - n * m * _) + P * (-i * a * _ - t * h * I + t * a * B + i * o * I - n * o * B + n * h * _);
                }
                transpose() {
                  const e = this.elements;
                  let t;
                  return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
                }
                setPosition(e, t, n) {
                  const i = this.elements;
                  return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
                }
                invert() {
                  const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], h = e[6], m = e[7], _ = e[8], I = e[9], B = e[10], L = e[11], N = e[12], z = e[13], k = e[14], P = e[15], se = I * k * m - z * B * m + z * h * L - a * k * L - I * h * P + a * B * P, $ = N * B * m - _ * k * m - N * h * L + o * k * L + _ * h * P - o * B * P, J = _ * z * m - N * I * m + N * a * L - o * z * L - _ * a * P + o * I * P, Le = N * I * h - _ * z * h - N * a * B + o * z * B + _ * a * k - o * I * k, Ee = t * se + n * $ + i * J + r * Le;
                  if (Ee === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                  const Me = 1 / Ee;
                  return e[0] = se * Me, e[1] = (z * B * r - I * k * r - z * i * L + n * k * L + I * i * P - n * B * P) * Me, e[2] = (a * k * r - z * h * r + z * i * m - n * k * m - a * i * P + n * h * P) * Me, e[3] = (I * h * r - a * B * r - I * i * m + n * B * m + a * i * L - n * h * L) * Me, e[4] = $ * Me, e[5] = (_ * k * r - N * B * r + N * i * L - t * k * L - _ * i * P + t * B * P) * Me, e[6] = (N * h * r - o * k * r - N * i * m + t * k * m + o * i * P - t * h * P) * Me, e[7] = (o * B * r - _ * h * r + _ * i * m - t * B * m - o * i * L + t * h * L) * Me, e[8] = J * Me, e[9] = (N * I * r - _ * z * r - N * n * L + t * z * L + _ * n * P - t * I * P) * Me, e[10] = (o * z * r - N * a * r + N * n * m - t * z * m - o * n * P + t * a * P) * Me, e[11] = (_ * a * r - o * I * r - _ * n * m + t * I * m + o * n * L - t * a * L) * Me, e[12] = Le * Me, e[13] = (_ * z * i - N * I * i + N * n * B - t * z * B - _ * n * k + t * I * k) * Me, e[14] = (N * a * i - o * z * i - N * n * h + t * z * h + o * n * k - t * a * k) * Me, e[15] = (o * I * i - _ * a * i + _ * n * h - t * I * h - o * n * B + t * a * B) * Me, this;
                }
                scale(e) {
                  const t = this.elements, n = e.x, i = e.y, r = e.z;
                  return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
                }
                getMaxScaleOnAxis() {
                  const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                  return Math.sqrt(Math.max(t, n, i));
                }
                makeTranslation(e, t, n) {
                  return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
                }
                makeRotationX(e) {
                  const t = Math.cos(e), n = Math.sin(e);
                  return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
                }
                makeRotationY(e) {
                  const t = Math.cos(e), n = Math.sin(e);
                  return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
                }
                makeRotationZ(e) {
                  const t = Math.cos(e), n = Math.sin(e);
                  return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                }
                makeRotationAxis(e, t) {
                  const n = Math.cos(t), i = Math.sin(t), r = 1 - n, o = e.x, a = e.y, h = e.z, m = r * o, _ = r * a;
                  return this.set(m * o + n, m * a - i * h, m * h + i * a, 0, m * a + i * h, _ * a + n, _ * h - i * o, 0, m * h - i * a, _ * h + i * o, r * h * h + n, 0, 0, 0, 0, 1), this;
                }
                makeScale(e, t, n) {
                  return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
                }
                makeShear(e, t, n, i, r, o) {
                  return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
                }
                compose(e, t, n) {
                  const i = this.elements, r = t._x, o = t._y, a = t._z, h = t._w, m = r + r, _ = o + o, I = a + a, B = r * m, L = r * _, N = r * I, z = o * _, k = o * I, P = a * I, se = h * m, $ = h * _, J = h * I, Le = n.x, Ee = n.y, Me = n.z;
                  return i[0] = (1 - (z + P)) * Le, i[1] = (L + J) * Le, i[2] = (N - $) * Le, i[3] = 0, i[4] = (L - J) * Ee, i[5] = (1 - (B + P)) * Ee, i[6] = (k + se) * Ee, i[7] = 0, i[8] = (N + $) * Me, i[9] = (k - se) * Me, i[10] = (1 - (B + z)) * Me, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
                }
                decompose(e, t, n) {
                  const i = this.elements;
                  let r = Ds.set(i[0], i[1], i[2]).length();
                  const o = Ds.set(i[4], i[5], i[6]).length(), a = Ds.set(i[8], i[9], i[10]).length();
                  this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Wr.copy(this);
                  const m = 1 / r, _ = 1 / o, I = 1 / a;
                  return Wr.elements[0] *= m, Wr.elements[1] *= m, Wr.elements[2] *= m, Wr.elements[4] *= _, Wr.elements[5] *= _, Wr.elements[6] *= _, Wr.elements[8] *= I, Wr.elements[9] *= I, Wr.elements[10] *= I, t.setFromRotationMatrix(Wr), n.x = r, n.y = o, n.z = a, this;
                }
                makePerspective(e, t, n, i, r, o, a = ss) {
                  const h = this.elements, m = 2 * r / (t - e), _ = 2 * r / (n - i), I = (t + e) / (t - e), B = (n + i) / (n - i);
                  let L, N;
                  if (a === ss)
                    L = -(o + r) / (o - r), N = -2 * o * r / (o - r);
                  else if (a === fo)
                    L = -o / (o - r), N = -o * r / (o - r);
                  else
                    throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                  return h[0] = m, h[4] = 0, h[8] = I, h[12] = 0, h[1] = 0, h[5] = _, h[9] = B, h[13] = 0, h[2] = 0, h[6] = 0, h[10] = L, h[14] = N, h[3] = 0, h[7] = 0, h[11] = -1, h[15] = 0, this;
                }
                makeOrthographic(e, t, n, i, r, o, a = ss) {
                  const h = this.elements, m = 1 / (t - e), _ = 1 / (n - i), I = 1 / (o - r), B = (t + e) * m, L = (n + i) * _;
                  let N, z;
                  if (a === ss)
                    N = (o + r) * I, z = -2 * I;
                  else if (a === fo)
                    N = r * I, z = -1 * I;
                  else
                    throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                  return h[0] = 2 * m, h[4] = 0, h[8] = 0, h[12] = -B, h[1] = 0, h[5] = 2 * _, h[9] = 0, h[13] = -L, h[2] = 0, h[6] = 0, h[10] = z, h[14] = -N, h[3] = 0, h[7] = 0, h[11] = 0, h[15] = 1, this;
                }
                equals(e) {
                  const t = this.elements, n = e.elements;
                  for (let i = 0; i < 16; i++)
                    if (t[i] !== n[i]) return !1;
                  return !0;
                }
                fromArray(e, t = 0) {
                  for (let n = 0; n < 16; n++)
                    this.elements[n] = e[n + t];
                  return this;
                }
                toArray(e = [], t = 0) {
                  const n = this.elements;
                  return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
                }
              }
              const Ds = /* @__PURE__ */ new ye(), Wr = /* @__PURE__ */ new pn(), Up = /* @__PURE__ */ new ye(0, 0, 0), Np = /* @__PURE__ */ new ye(1, 1, 1), Xs = /* @__PURE__ */ new ye(), vl = /* @__PURE__ */ new ye(), Zr = /* @__PURE__ */ new ye(), Gh = /* @__PURE__ */ new pn(), Qh = /* @__PURE__ */ new xi();
              class $r {
                constructor(e = 0, t = 0, n = 0, i = $r.DEFAULT_ORDER) {
                  this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
                }
                get x() {
                  return this._x;
                }
                set x(e) {
                  this._x = e, this._onChangeCallback();
                }
                get y() {
                  return this._y;
                }
                set y(e) {
                  this._y = e, this._onChangeCallback();
                }
                get z() {
                  return this._z;
                }
                set z(e) {
                  this._z = e, this._onChangeCallback();
                }
                get order() {
                  return this._order;
                }
                set order(e) {
                  this._order = e, this._onChangeCallback();
                }
                set(e, t, n, i = this._order) {
                  return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
                }
                clone() {
                  return new this.constructor(this._x, this._y, this._z, this._order);
                }
                copy(e) {
                  return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
                }
                setFromRotationMatrix(e, t = this._order, n = !0) {
                  const i = e.elements, r = i[0], o = i[4], a = i[8], h = i[1], m = i[5], _ = i[9], I = i[2], B = i[6], L = i[10];
                  switch (t) {
                    case "XYZ":
                      this._y = Math.asin(Yi(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-_, L), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(B, m), this._z = 0);
                      break;
                    case "YXZ":
                      this._x = Math.asin(-Yi(_, -1, 1)), Math.abs(_) < 0.9999999 ? (this._y = Math.atan2(a, L), this._z = Math.atan2(h, m)) : (this._y = Math.atan2(-I, r), this._z = 0);
                      break;
                    case "ZXY":
                      this._x = Math.asin(Yi(B, -1, 1)), Math.abs(B) < 0.9999999 ? (this._y = Math.atan2(-I, L), this._z = Math.atan2(-o, m)) : (this._y = 0, this._z = Math.atan2(h, r));
                      break;
                    case "ZYX":
                      this._y = Math.asin(-Yi(I, -1, 1)), Math.abs(I) < 0.9999999 ? (this._x = Math.atan2(B, L), this._z = Math.atan2(h, r)) : (this._x = 0, this._z = Math.atan2(-o, m));
                      break;
                    case "YZX":
                      this._z = Math.asin(Yi(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-_, m), this._y = Math.atan2(-I, r)) : (this._x = 0, this._y = Math.atan2(a, L));
                      break;
                    case "XZY":
                      this._z = Math.asin(-Yi(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(B, m), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-_, L), this._y = 0);
                      break;
                    default:
                      console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
                  }
                  return this._order = t, n === !0 && this._onChangeCallback(), this;
                }
                setFromQuaternion(e, t, n) {
                  return Gh.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Gh, t, n);
                }
                setFromVector3(e, t = this._order) {
                  return this.set(e.x, e.y, e.z, t);
                }
                reorder(e) {
                  return Qh.setFromEuler(this), this.setFromQuaternion(Qh, e);
                }
                equals(e) {
                  return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
                }
                fromArray(e) {
                  return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
                }
                toArray(e = [], t = 0) {
                  return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
                }
                _onChange(e) {
                  return this._onChangeCallback = e, this;
                }
                _onChangeCallback() {
                }
                *[Symbol.iterator]() {
                  yield this._x, yield this._y, yield this._z, yield this._order;
                }
              }
              $r.DEFAULT_ORDER = "XYZ";
              class El {
                constructor() {
                  this.mask = 1;
                }
                set(e) {
                  this.mask = (1 << e | 0) >>> 0;
                }
                enable(e) {
                  this.mask |= 1 << e | 0;
                }
                enableAll() {
                  this.mask = -1;
                }
                toggle(e) {
                  this.mask ^= 1 << e | 0;
                }
                disable(e) {
                  this.mask &= ~(1 << e | 0);
                }
                disableAll() {
                  this.mask = 0;
                }
                test(e) {
                  return (this.mask & e.mask) !== 0;
                }
                isEnabled(e) {
                  return (this.mask & (1 << e | 0)) !== 0;
                }
              }
              let kp = 0;
              const Vh = /* @__PURE__ */ new ye(), Wo = /* @__PURE__ */ new xi(), Ps = /* @__PURE__ */ new pn(), yl = /* @__PURE__ */ new ye(), wa = /* @__PURE__ */ new ye(), Gp = /* @__PURE__ */ new ye(), Qp = /* @__PURE__ */ new xi(), Hh = /* @__PURE__ */ new ye(1, 0, 0), zh = /* @__PURE__ */ new ye(0, 1, 0), jh = /* @__PURE__ */ new ye(0, 0, 1), Wh = { type: "added" }, Vp = { type: "removed" }, Ko = { type: "childadded", child: null }, xu = { type: "childremoved", child: null };
              class bi extends Nr {
                constructor() {
                  super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: kp++ }), this.uuid = kr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = bi.DEFAULT_UP.clone();
                  const e = new ye(), t = new $r(), n = new xi(), i = new ye(1, 1, 1);
                  function r() {
                    n.setFromEuler(t, !1);
                  }
                  function o() {
                    t.setFromQuaternion(n, void 0, !1);
                  }
                  t._onChange(r), n._onChange(o), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new pn() }, normalMatrix: { value: new Gn() } }), this.matrix = new pn(), this.matrixWorld = new pn(), this.matrixAutoUpdate = bi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = bi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new El(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
                }
                onBeforeShadow() {
                }
                onAfterShadow() {
                }
                onBeforeRender() {
                }
                onAfterRender() {
                }
                applyMatrix4(e) {
                  this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
                }
                applyQuaternion(e) {
                  return this.quaternion.premultiply(e), this;
                }
                setRotationFromAxisAngle(e, t) {
                  this.quaternion.setFromAxisAngle(e, t);
                }
                setRotationFromEuler(e) {
                  this.quaternion.setFromEuler(e, !0);
                }
                setRotationFromMatrix(e) {
                  this.quaternion.setFromRotationMatrix(e);
                }
                setRotationFromQuaternion(e) {
                  this.quaternion.copy(e);
                }
                rotateOnAxis(e, t) {
                  return Wo.setFromAxisAngle(e, t), this.quaternion.multiply(Wo), this;
                }
                rotateOnWorldAxis(e, t) {
                  return Wo.setFromAxisAngle(e, t), this.quaternion.premultiply(Wo), this;
                }
                rotateX(e) {
                  return this.rotateOnAxis(Hh, e);
                }
                rotateY(e) {
                  return this.rotateOnAxis(zh, e);
                }
                rotateZ(e) {
                  return this.rotateOnAxis(jh, e);
                }
                translateOnAxis(e, t) {
                  return Vh.copy(e).applyQuaternion(this.quaternion), this.position.add(Vh.multiplyScalar(t)), this;
                }
                translateX(e) {
                  return this.translateOnAxis(Hh, e);
                }
                translateY(e) {
                  return this.translateOnAxis(zh, e);
                }
                translateZ(e) {
                  return this.translateOnAxis(jh, e);
                }
                localToWorld(e) {
                  return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
                }
                worldToLocal(e) {
                  return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ps.copy(this.matrixWorld).invert());
                }
                lookAt(e, t, n) {
                  e.isVector3 ? yl.copy(e) : yl.set(e, t, n);
                  const i = this.parent;
                  this.updateWorldMatrix(!0, !1), wa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ps.lookAt(wa, yl, this.up) : Ps.lookAt(yl, wa, this.up), this.quaternion.setFromRotationMatrix(Ps), i && (Ps.extractRotation(i.matrixWorld), Wo.setFromRotationMatrix(Ps), this.quaternion.premultiply(Wo.invert()));
                }
                add(e) {
                  if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                      this.add(arguments[t]);
                    return this;
                  }
                  return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Wh), Ko.child = e, this.dispatchEvent(Ko), Ko.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
                }
                remove(e) {
                  if (arguments.length > 1) {
                    for (let n = 0; n < arguments.length; n++)
                      this.remove(arguments[n]);
                    return this;
                  }
                  const t = this.children.indexOf(e);
                  return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Vp), xu.child = e, this.dispatchEvent(xu), xu.child = null), this;
                }
                removeFromParent() {
                  const e = this.parent;
                  return e !== null && e.remove(this), this;
                }
                clear() {
                  return this.remove(...this.children);
                }
                attach(e) {
                  return this.updateWorldMatrix(!0, !1), Ps.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ps.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ps), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Wh), Ko.child = e, this.dispatchEvent(Ko), Ko.child = null, this;
                }
                getObjectById(e) {
                  return this.getObjectByProperty("id", e);
                }
                getObjectByName(e) {
                  return this.getObjectByProperty("name", e);
                }
                getObjectByProperty(e, t) {
                  if (this[e] === t) return this;
                  for (let n = 0, i = this.children.length; n < i; n++) {
                    const o = this.children[n].getObjectByProperty(e, t);
                    if (o !== void 0)
                      return o;
                  }
                }
                getObjectsByProperty(e, t, n = []) {
                  this[e] === t && n.push(this);
                  const i = this.children;
                  for (let r = 0, o = i.length; r < o; r++)
                    i[r].getObjectsByProperty(e, t, n);
                  return n;
                }
                getWorldPosition(e) {
                  return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
                }
                getWorldQuaternion(e) {
                  return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wa, e, Gp), e;
                }
                getWorldScale(e) {
                  return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wa, Qp, e), e;
                }
                getWorldDirection(e) {
                  this.updateWorldMatrix(!0, !1);
                  const t = this.matrixWorld.elements;
                  return e.set(t[8], t[9], t[10]).normalize();
                }
                raycast() {
                }
                traverse(e) {
                  e(this);
                  const t = this.children;
                  for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverse(e);
                }
                traverseVisible(e) {
                  if (this.visible === !1) return;
                  e(this);
                  const t = this.children;
                  for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverseVisible(e);
                }
                traverseAncestors(e) {
                  const t = this.parent;
                  t !== null && (e(t), t.traverseAncestors(e));
                }
                updateMatrix() {
                  this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
                }
                updateMatrixWorld(e) {
                  this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                  const t = this.children;
                  for (let n = 0, i = t.length; n < i; n++) {
                    const r = t[n];
                    (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
                  }
                }
                updateWorldMatrix(e, t) {
                  const n = this.parent;
                  if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
                    const i = this.children;
                    for (let r = 0, o = i.length; r < o; r++) {
                      const a = i[r];
                      a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
                    }
                  }
                }
                toJSON(e) {
                  const t = e === void 0 || typeof e == "string", n = {};
                  t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
                  const i = {};
                  i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((a) => ({ boxInitialized: a.boxInitialized, boxMin: a.box.min.toArray(), boxMax: a.box.max.toArray(), sphereInitialized: a.sphereInitialized, sphereRadius: a.sphere.radius, sphereCenter: a.sphere.center.toArray() })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (i.boundingSphere = { center: i.boundingSphere.center.toArray(), radius: i.boundingSphere.radius }), this.boundingBox !== null && (i.boundingBox = { min: i.boundingBox.min.toArray(), max: i.boundingBox.max.toArray() }));
                  function r(a, h) {
                    return a[h.uuid] === void 0 && (a[h.uuid] = h.toJSON(e)), h.uuid;
                  }
                  if (this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
                  else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    const a = this.geometry.parameters;
                    if (a !== void 0 && a.shapes !== void 0) {
                      const h = a.shapes;
                      if (Array.isArray(h))
                        for (let m = 0, _ = h.length; m < _; m++) {
                          const I = h[m];
                          r(e.shapes, I);
                        }
                      else
                        r(e.shapes, h);
                    }
                  }
                  if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
                    if (Array.isArray(this.material)) {
                      const a = [];
                      for (let h = 0, m = this.material.length; h < m; h++)
                        a.push(r(e.materials, this.material[h]));
                      i.material = a;
                    } else
                      i.material = r(e.materials, this.material);
                  if (this.children.length > 0) {
                    i.children = [];
                    for (let a = 0; a < this.children.length; a++)
                      i.children.push(this.children[a].toJSON(e).object);
                  }
                  if (this.animations.length > 0) {
                    i.animations = [];
                    for (let a = 0; a < this.animations.length; a++) {
                      const h = this.animations[a];
                      i.animations.push(r(e.animations, h));
                    }
                  }
                  if (t) {
                    const a = o(e.geometries), h = o(e.materials), m = o(e.textures), _ = o(e.images), I = o(e.shapes), B = o(e.skeletons), L = o(e.animations), N = o(e.nodes);
                    a.length > 0 && (n.geometries = a), h.length > 0 && (n.materials = h), m.length > 0 && (n.textures = m), _.length > 0 && (n.images = _), I.length > 0 && (n.shapes = I), B.length > 0 && (n.skeletons = B), L.length > 0 && (n.animations = L), N.length > 0 && (n.nodes = N);
                  }
                  return n.object = i, n;
                  function o(a) {
                    const h = [];
                    for (const m in a) {
                      const _ = a[m];
                      delete _.metadata, h.push(_);
                    }
                    return h;
                  }
                }
                clone(e) {
                  return new this.constructor().copy(this, e);
                }
                copy(e, t = !0) {
                  if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
                    for (let n = 0; n < e.children.length; n++) {
                      const i = e.children[n];
                      this.add(i.clone());
                    }
                  return this;
                }
              }
              bi.DEFAULT_UP = /* @__PURE__ */ new ye(0, 1, 0), bi.DEFAULT_MATRIX_AUTO_UPDATE = !0, bi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
              const ds = /* @__PURE__ */ new ye(), Os = /* @__PURE__ */ new ye(), bu = /* @__PURE__ */ new ye(), Fs = /* @__PURE__ */ new ye(), Xo = /* @__PURE__ */ new ye(), Yo = /* @__PURE__ */ new ye(), Kh = /* @__PURE__ */ new ye(), _u = /* @__PURE__ */ new ye(), wu = /* @__PURE__ */ new ye(), Mu = /* @__PURE__ */ new ye();
              class es {
                constructor(e = new ye(), t = new ye(), n = new ye()) {
                  this.a = e, this.b = t, this.c = n;
                }
                static getNormal(e, t, n, i) {
                  i.subVectors(n, t), ds.subVectors(e, t), i.cross(ds);
                  const r = i.lengthSq();
                  return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
                }
                // static/instance method to calculate barycentric coordinates
                // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
                static getBarycoord(e, t, n, i, r) {
                  ds.subVectors(i, t), Os.subVectors(n, t), bu.subVectors(e, t);
                  const o = ds.dot(ds), a = ds.dot(Os), h = ds.dot(bu), m = Os.dot(Os), _ = Os.dot(bu), I = o * m - a * a;
                  if (I === 0)
                    return r.set(0, 0, 0), null;
                  const B = 1 / I, L = (m * h - a * _) * B, N = (o * _ - a * h) * B;
                  return r.set(1 - L - N, N, L);
                }
                static containsPoint(e, t, n, i) {
                  return this.getBarycoord(e, t, n, i, Fs) === null ? !1 : Fs.x >= 0 && Fs.y >= 0 && Fs.x + Fs.y <= 1;
                }
                static getInterpolation(e, t, n, i, r, o, a, h) {
                  return this.getBarycoord(e, t, n, i, Fs) === null ? (h.x = 0, h.y = 0, "z" in h && (h.z = 0), "w" in h && (h.w = 0), null) : (h.setScalar(0), h.addScaledVector(r, Fs.x), h.addScaledVector(o, Fs.y), h.addScaledVector(a, Fs.z), h);
                }
                static isFrontFacing(e, t, n, i) {
                  return ds.subVectors(n, t), Os.subVectors(e, t), ds.cross(Os).dot(i) < 0;
                }
                set(e, t, n) {
                  return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
                }
                setFromPointsAndIndices(e, t, n, i) {
                  return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
                }
                setFromAttributeAndIndices(e, t, n, i) {
                  return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
                }
                getArea() {
                  return ds.subVectors(this.c, this.b), Os.subVectors(this.a, this.b), ds.cross(Os).length() * 0.5;
                }
                getMidpoint(e) {
                  return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(0.3333333333333333);
                }
                getNormal(e) {
                  return es.getNormal(this.a, this.b, this.c, e);
                }
                getPlane(e) {
                  return e.setFromCoplanarPoints(this.a, this.b, this.c);
                }
                getBarycoord(e, t) {
                  return es.getBarycoord(e, this.a, this.b, this.c, t);
                }
                getInterpolation(e, t, n, i, r) {
                  return es.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
                }
                containsPoint(e) {
                  return es.containsPoint(e, this.a, this.b, this.c);
                }
                isFrontFacing(e) {
                  return es.isFrontFacing(this.a, this.b, this.c, e);
                }
                intersectsBox(e) {
                  return e.intersectsTriangle(this);
                }
                closestPointToPoint(e, t) {
                  const n = this.a, i = this.b, r = this.c;
                  let o, a;
                  Xo.subVectors(i, n), Yo.subVectors(r, n), _u.subVectors(e, n);
                  const h = Xo.dot(_u), m = Yo.dot(_u);
                  if (h <= 0 && m <= 0)
                    return t.copy(n);
                  wu.subVectors(e, i);
                  const _ = Xo.dot(wu), I = Yo.dot(wu);
                  if (_ >= 0 && I <= _)
                    return t.copy(i);
                  const B = h * I - _ * m;
                  if (B <= 0 && h >= 0 && _ <= 0)
                    return o = h / (h - _), t.copy(n).addScaledVector(Xo, o);
                  Mu.subVectors(e, r);
                  const L = Xo.dot(Mu), N = Yo.dot(Mu);
                  if (N >= 0 && L <= N)
                    return t.copy(r);
                  const z = L * m - h * N;
                  if (z <= 0 && m >= 0 && N <= 0)
                    return a = m / (m - N), t.copy(n).addScaledVector(Yo, a);
                  const k = _ * N - L * I;
                  if (k <= 0 && I - _ >= 0 && L - N >= 0)
                    return Kh.subVectors(r, i), a = (I - _) / (I - _ + (L - N)), t.copy(i).addScaledVector(Kh, a);
                  const P = 1 / (k + z + B);
                  return o = z * P, a = B * P, t.copy(n).addScaledVector(Xo, o).addScaledVector(Yo, a);
                }
                equals(e) {
                  return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
                }
              }
              const Xh = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Ys = { h: 0, s: 0, l: 0 }, Cl = { h: 0, s: 0, l: 0 };
              function Su(s, e, t) {
                return t < 0 && (t += 1), t > 1 && (t -= 1), t < 0.16666666666666666 ? s + (e - s) * 6 * t : t < 0.5 ? e : t < 0.6666666666666666 ? s + (e - s) * 6 * (0.6666666666666666 - t) : s;
              }
              class sn {
                constructor(e, t, n) {
                  return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
                }
                set(e, t, n) {
                  if (t === void 0 && n === void 0) {
                    const i = e;
                    i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
                  } else
                    this.setRGB(e, t, n);
                  return this;
                }
                setScalar(e) {
                  return this.r = e, this.g = e, this.b = e, this;
                }
                setHex(e, t = mi) {
                  return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Mi.toWorkingColorSpace(this, t), this;
                }
                setRGB(e, t, n, i = Mi.workingColorSpace) {
                  return this.r = e, this.g = t, this.b = n, Mi.toWorkingColorSpace(this, i), this;
                }
                setHSL(e, t, n, i = Mi.workingColorSpace) {
                  if (e = ya(e, 1), t = Yi(t, 0, 1), n = Yi(n, 0, 1), t === 0)
                    this.r = this.g = this.b = n;
                  else {
                    const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, o = 2 * n - r;
                    this.r = Su(o, r, e + 0.3333333333333333), this.g = Su(o, r, e), this.b = Su(o, r, e - 0.3333333333333333);
                  }
                  return Mi.toWorkingColorSpace(this, i), this;
                }
                setStyle(e, t = mi) {
                  function n(r) {
                    r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
                  }
                  let i;
                  if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let r;
                    const o = i[1], a = i[2];
                    switch (o) {
                      case "rgb":
                      case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                          return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                          return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                        break;
                      case "hsl":
                      case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                          return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                        break;
                      default:
                        console.warn("THREE.Color: Unknown color model " + e);
                    }
                  } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const r = i[1], o = r.length;
                    if (o === 3)
                      return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
                    if (o === 6)
                      return this.setHex(parseInt(r, 16), t);
                    console.warn("THREE.Color: Invalid hex color " + e);
                  } else if (e && e.length > 0)
                    return this.setColorName(e, t);
                  return this;
                }
                setColorName(e, t = mi) {
                  const n = Xh[e.toLowerCase()];
                  return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
                }
                clone() {
                  return new this.constructor(this.r, this.g, this.b);
                }
                copy(e) {
                  return this.r = e.r, this.g = e.g, this.b = e.b, this;
                }
                copySRGBToLinear(e) {
                  return this.r = js(e.r), this.g = js(e.g), this.b = js(e.b), this;
                }
                copyLinearToSRGB(e) {
                  return this.r = xa(e.r), this.g = xa(e.g), this.b = xa(e.b), this;
                }
                convertSRGBToLinear() {
                  return this.copySRGBToLinear(this), this;
                }
                convertLinearToSRGB() {
                  return this.copyLinearToSRGB(this), this;
                }
                getHex(e = mi) {
                  return Mi.fromWorkingColorSpace(Dr.copy(this), e), Math.round(Yi(Dr.r * 255, 0, 255)) * 65536 + Math.round(Yi(Dr.g * 255, 0, 255)) * 256 + Math.round(Yi(Dr.b * 255, 0, 255));
                }
                getHexString(e = mi) {
                  return ("000000" + this.getHex(e).toString(16)).slice(-6);
                }
                getHSL(e, t = Mi.workingColorSpace) {
                  Mi.fromWorkingColorSpace(Dr.copy(this), t);
                  const n = Dr.r, i = Dr.g, r = Dr.b, o = Math.max(n, i, r), a = Math.min(n, i, r);
                  let h, m;
                  const _ = (a + o) / 2;
                  if (a === o)
                    h = 0, m = 0;
                  else {
                    const I = o - a;
                    switch (m = _ <= 0.5 ? I / (o + a) : I / (2 - o - a), o) {
                      case n:
                        h = (i - r) / I + (i < r ? 6 : 0);
                        break;
                      case i:
                        h = (r - n) / I + 2;
                        break;
                      case r:
                        h = (n - i) / I + 4;
                        break;
                    }
                    h /= 6;
                  }
                  return e.h = h, e.s = m, e.l = _, e;
                }
                getRGB(e, t = Mi.workingColorSpace) {
                  return Mi.fromWorkingColorSpace(Dr.copy(this), t), e.r = Dr.r, e.g = Dr.g, e.b = Dr.b, e;
                }
                getStyle(e = mi) {
                  Mi.fromWorkingColorSpace(Dr.copy(this), e);
                  const t = Dr.r, n = Dr.g, i = Dr.b;
                  return e !== mi ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
                }
                offsetHSL(e, t, n) {
                  return this.getHSL(Ys), this.setHSL(Ys.h + e, Ys.s + t, Ys.l + n);
                }
                add(e) {
                  return this.r += e.r, this.g += e.g, this.b += e.b, this;
                }
                addColors(e, t) {
                  return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
                }
                addScalar(e) {
                  return this.r += e, this.g += e, this.b += e, this;
                }
                sub(e) {
                  return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
                }
                multiply(e) {
                  return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
                }
                multiplyScalar(e) {
                  return this.r *= e, this.g *= e, this.b *= e, this;
                }
                lerp(e, t) {
                  return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
                }
                lerpColors(e, t, n) {
                  return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
                }
                lerpHSL(e, t) {
                  this.getHSL(Ys), e.getHSL(Cl);
                  const n = po(Ys.h, Cl.h, t), i = po(Ys.s, Cl.s, t), r = po(Ys.l, Cl.l, t);
                  return this.setHSL(n, i, r), this;
                }
                setFromVector3(e) {
                  return this.r = e.x, this.g = e.y, this.b = e.z, this;
                }
                applyMatrix3(e) {
                  const t = this.r, n = this.g, i = this.b, r = e.elements;
                  return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
                }
                equals(e) {
                  return e.r === this.r && e.g === this.g && e.b === this.b;
                }
                fromArray(e, t = 0) {
                  return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
                }
                toArray(e = [], t = 0) {
                  return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
                }
                fromBufferAttribute(e, t) {
                  return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
                }
                toJSON() {
                  return this.getHex();
                }
                *[Symbol.iterator]() {
                  yield this.r, yield this.g, yield this.b;
                }
              }
              const Dr = /* @__PURE__ */ new sn();
              sn.NAMES = Xh;
              let Hp = 0;
              class Pr extends Nr {
                constructor() {
                  super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Hp++ }), this.uuid = kr(), this.name = "", this.type = "Material", this.blending = D, this.side = f, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = be, this.blendDst = Te, this.blendEquation = W, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new sn(0, 0, 0), this.blendAlpha = 0, this.depthFunc = rn, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = ga, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Is, this.stencilZFail = Is, this.stencilZPass = Is, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
                }
                get alphaTest() {
                  return this._alphaTest;
                }
                set alphaTest(e) {
                  this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
                }
                onBuild() {
                }
                onBeforeRender() {
                }
                onBeforeCompile() {
                }
                customProgramCacheKey() {
                  return this.onBeforeCompile.toString();
                }
                setValues(e) {
                  if (e !== void 0)
                    for (const t in e) {
                      const n = e[t];
                      if (n === void 0) {
                        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                        continue;
                      }
                      const i = this[t];
                      if (i === void 0) {
                        console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                        continue;
                      }
                      i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
                    }
                }
                toJSON(e) {
                  const t = e === void 0 || typeof e == "string";
                  t && (e = { textures: {}, images: {} });
                  const n = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
                  n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== D && (n.blending = this.blending), this.side !== f && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== be && (n.blendSrc = this.blendSrc), this.blendDst !== Te && (n.blendDst = this.blendDst), this.blendEquation !== W && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== rn && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== ga && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Is && (n.stencilFail = this.stencilFail), this.stencilZFail !== Is && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Is && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
                  function i(r) {
                    const o = [];
                    for (const a in r) {
                      const h = r[a];
                      delete h.metadata, o.push(h);
                    }
                    return o;
                  }
                  if (t) {
                    const r = i(e.textures), o = i(e.images);
                    r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
                  }
                  return n;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                  const t = e.clippingPlanes;
                  let n = null;
                  if (t !== null) {
                    const i = t.length;
                    n = new Array(i);
                    for (let r = 0; r !== i; ++r)
                      n[r] = t[r].clone();
                  }
                  return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
                }
                dispose() {
                  this.dispatchEvent({ type: "dispose" });
                }
                set needsUpdate(e) {
                  e === !0 && this.version++;
                }
              }
              class qs extends Pr {
                constructor(e) {
                  super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new sn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $r(), this.combine = Be, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
                }
              }
              const Us = /* @__PURE__ */ zp();
              function zp() {
                const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), n = new Uint32Array(512), i = new Uint32Array(512);
                for (let h = 0; h < 256; ++h) {
                  const m = h - 127;
                  m < -27 ? (n[h] = 0, n[h | 256] = 32768, i[h] = 24, i[h | 256] = 24) : m < -14 ? (n[h] = 1024 >> -m - 14, n[h | 256] = 1024 >> -m - 14 | 32768, i[h] = -m - 1, i[h | 256] = -m - 1) : m <= 15 ? (n[h] = m + 15 << 10, n[h | 256] = m + 15 << 10 | 32768, i[h] = 13, i[h | 256] = 13) : m < 128 ? (n[h] = 31744, n[h | 256] = 64512, i[h] = 24, i[h | 256] = 24) : (n[h] = 31744, n[h | 256] = 64512, i[h] = 13, i[h | 256] = 13);
                }
                const r = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
                for (let h = 1; h < 1024; ++h) {
                  let m = h << 13, _ = 0;
                  for (; !(m & 8388608); )
                    m <<= 1, _ -= 8388608;
                  m &= -8388609, _ += 947912704, r[h] = m | _;
                }
                for (let h = 1024; h < 2048; ++h)
                  r[h] = 939524096 + (h - 1024 << 13);
                for (let h = 1; h < 31; ++h)
                  o[h] = h << 23;
                o[31] = 1199570944, o[32] = 2147483648;
                for (let h = 33; h < 63; ++h)
                  o[h] = 2147483648 + (h - 32 << 23);
                o[63] = 3347054592;
                for (let h = 1; h < 64; ++h)
                  h !== 32 && (a[h] = 1024);
                return { floatView: e, uint32View: t, baseTable: n, shiftTable: i, mantissaTable: r, exponentTable: o, offsetTable: a };
              }
              function Kr(s) {
                Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = Yi(s, -65504, 65504), Us.floatView[0] = s;
                const e = Us.uint32View[0], t = e >> 23 & 511;
                return Us.baseTable[t] + ((e & 8388607) >> Us.shiftTable[t]);
              }
              function Ma(s) {
                const e = s >> 10;
                return Us.uint32View[0] = Us.mantissaTable[Us.offsetTable[e] + (s & 1023)] + Us.exponentTable[e], Us.floatView[0];
              }
              const jp = { toHalfFloat: Kr, fromHalfFloat: Ma }, ur = /* @__PURE__ */ new ye(), xl = /* @__PURE__ */ new pt();
              class Pi {
                constructor(e, t, n = !1) {
                  if (Array.isArray(e))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                  this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = ho, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = tt, this.version = 0;
                }
                onUploadCallback() {
                }
                set needsUpdate(e) {
                  e === !0 && this.version++;
                }
                get updateRange() {
                  return fl("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
                }
                setUsage(e) {
                  return this.usage = e, this;
                }
                addUpdateRange(e, t) {
                  this.updateRanges.push({ start: e, count: t });
                }
                clearUpdateRanges() {
                  this.updateRanges.length = 0;
                }
                copy(e) {
                  return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
                }
                copyAt(e, t, n) {
                  e *= this.itemSize, n *= t.itemSize;
                  for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                  return this;
                }
                copyArray(e) {
                  return this.array.set(e), this;
                }
                applyMatrix3(e) {
                  if (this.itemSize === 2)
                    for (let t = 0, n = this.count; t < n; t++)
                      xl.fromBufferAttribute(this, t), xl.applyMatrix3(e), this.setXY(t, xl.x, xl.y);
                  else if (this.itemSize === 3)
                    for (let t = 0, n = this.count; t < n; t++)
                      ur.fromBufferAttribute(this, t), ur.applyMatrix3(e), this.setXYZ(t, ur.x, ur.y, ur.z);
                  return this;
                }
                applyMatrix4(e) {
                  for (let t = 0, n = this.count; t < n; t++)
                    ur.fromBufferAttribute(this, t), ur.applyMatrix4(e), this.setXYZ(t, ur.x, ur.y, ur.z);
                  return this;
                }
                applyNormalMatrix(e) {
                  for (let t = 0, n = this.count; t < n; t++)
                    ur.fromBufferAttribute(this, t), ur.applyNormalMatrix(e), this.setXYZ(t, ur.x, ur.y, ur.z);
                  return this;
                }
                transformDirection(e) {
                  for (let t = 0, n = this.count; t < n; t++)
                    ur.fromBufferAttribute(this, t), ur.transformDirection(e), this.setXYZ(t, ur.x, ur.y, ur.z);
                  return this;
                }
                set(e, t = 0) {
                  return this.array.set(e, t), this;
                }
                getComponent(e, t) {
                  let n = this.array[e * this.itemSize + t];
                  return this.normalized && (n = Ir(n, this.array)), n;
                }
                setComponent(e, t, n) {
                  return this.normalized && (n = Hn(n, this.array)), this.array[e * this.itemSize + t] = n, this;
                }
                getX(e) {
                  let t = this.array[e * this.itemSize];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setX(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize] = t, this;
                }
                getY(e) {
                  let t = this.array[e * this.itemSize + 1];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setY(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
                }
                getZ(e) {
                  let t = this.array[e * this.itemSize + 2];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setZ(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
                }
                getW(e) {
                  let t = this.array[e * this.itemSize + 3];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setW(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
                }
                setXY(e, t, n) {
                  return e *= this.itemSize, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
                }
                setXYZ(e, t, n, i) {
                  return e *= this.itemSize, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array), i = Hn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
                }
                setXYZW(e, t, n, i, r) {
                  return e *= this.itemSize, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array), i = Hn(i, this.array), r = Hn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
                }
                onUpload(e) {
                  return this.onUploadCallback = e, this;
                }
                clone() {
                  return new this.constructor(this.array, this.itemSize).copy(this);
                }
                toJSON() {
                  const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
                  return this.name !== "" && (e.name = this.name), this.usage !== ho && (e.usage = this.usage), e;
                }
              }
              class Wp extends Pi {
                constructor(e, t, n) {
                  super(new Int8Array(e), t, n);
                }
              }
              class Kp extends Pi {
                constructor(e, t, n) {
                  super(new Uint8Array(e), t, n);
                }
              }
              class Xp extends Pi {
                constructor(e, t, n) {
                  super(new Uint8ClampedArray(e), t, n);
                }
              }
              class Yp extends Pi {
                constructor(e, t, n) {
                  super(new Int16Array(e), t, n);
                }
              }
              class Tu extends Pi {
                constructor(e, t, n) {
                  super(new Uint16Array(e), t, n);
                }
              }
              class qp extends Pi {
                constructor(e, t, n) {
                  super(new Int32Array(e), t, n);
                }
              }
              class Iu extends Pi {
                constructor(e, t, n) {
                  super(new Uint32Array(e), t, n);
                }
              }
              class Jp extends Pi {
                constructor(e, t, n) {
                  super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
                }
                getX(e) {
                  let t = Ma(this.array[e * this.itemSize]);
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setX(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize] = Kr(t), this;
                }
                getY(e) {
                  let t = Ma(this.array[e * this.itemSize + 1]);
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setY(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize + 1] = Kr(t), this;
                }
                getZ(e) {
                  let t = Ma(this.array[e * this.itemSize + 2]);
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setZ(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize + 2] = Kr(t), this;
                }
                getW(e) {
                  let t = Ma(this.array[e * this.itemSize + 3]);
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setW(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.array[e * this.itemSize + 3] = Kr(t), this;
                }
                setXY(e, t, n) {
                  return e *= this.itemSize, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array)), this.array[e + 0] = Kr(t), this.array[e + 1] = Kr(n), this;
                }
                setXYZ(e, t, n, i) {
                  return e *= this.itemSize, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array), i = Hn(i, this.array)), this.array[e + 0] = Kr(t), this.array[e + 1] = Kr(n), this.array[e + 2] = Kr(i), this;
                }
                setXYZW(e, t, n, i, r) {
                  return e *= this.itemSize, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array), i = Hn(i, this.array), r = Hn(r, this.array)), this.array[e + 0] = Kr(t), this.array[e + 1] = Kr(n), this.array[e + 2] = Kr(i), this.array[e + 3] = Kr(r), this;
                }
              }
              class gn extends Pi {
                constructor(e, t, n) {
                  super(new Float32Array(e), t, n);
                }
              }
              let Zp = 0;
              const as = /* @__PURE__ */ new pn(), Bu = /* @__PURE__ */ new bi(), qo = /* @__PURE__ */ new ye(), ts = /* @__PURE__ */ new Zi(), Sa = /* @__PURE__ */ new Zi(), Mr = /* @__PURE__ */ new ye();
              class ti extends Nr {
                constructor() {
                  super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Zp++ }), this.uuid = kr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
                }
                getIndex() {
                  return this.index;
                }
                setIndex(e) {
                  return Array.isArray(e) ? this.index = new (ul(e) ? Iu : Tu)(e, 1) : this.index = e, this;
                }
                getAttribute(e) {
                  return this.attributes[e];
                }
                setAttribute(e, t) {
                  return this.attributes[e] = t, this;
                }
                deleteAttribute(e) {
                  return delete this.attributes[e], this;
                }
                hasAttribute(e) {
                  return this.attributes[e] !== void 0;
                }
                addGroup(e, t, n = 0) {
                  this.groups.push({ start: e, count: t, materialIndex: n });
                }
                clearGroups() {
                  this.groups = [];
                }
                setDrawRange(e, t) {
                  this.drawRange.start = e, this.drawRange.count = t;
                }
                applyMatrix4(e) {
                  const t = this.attributes.position;
                  t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
                  const n = this.attributes.normal;
                  if (n !== void 0) {
                    const r = new Gn().getNormalMatrix(e);
                    n.applyNormalMatrix(r), n.needsUpdate = !0;
                  }
                  const i = this.attributes.tangent;
                  return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
                }
                applyQuaternion(e) {
                  return as.makeRotationFromQuaternion(e), this.applyMatrix4(as), this;
                }
                rotateX(e) {
                  return as.makeRotationX(e), this.applyMatrix4(as), this;
                }
                rotateY(e) {
                  return as.makeRotationY(e), this.applyMatrix4(as), this;
                }
                rotateZ(e) {
                  return as.makeRotationZ(e), this.applyMatrix4(as), this;
                }
                translate(e, t, n) {
                  return as.makeTranslation(e, t, n), this.applyMatrix4(as), this;
                }
                scale(e, t, n) {
                  return as.makeScale(e, t, n), this.applyMatrix4(as), this;
                }
                lookAt(e) {
                  return Bu.lookAt(e), Bu.updateMatrix(), this.applyMatrix4(Bu.matrix), this;
                }
                center() {
                  return this.computeBoundingBox(), this.boundingBox.getCenter(qo).negate(), this.translate(qo.x, qo.y, qo.z), this;
                }
                setFromPoints(e) {
                  const t = [];
                  for (let n = 0, i = e.length; n < i; n++) {
                    const r = e[n];
                    t.push(r.x, r.y, r.z || 0);
                  }
                  return this.setAttribute("position", new gn(t, 3)), this;
                }
                computeBoundingBox() {
                  this.boundingBox === null && (this.boundingBox = new Zi());
                  const e = this.attributes.position, t = this.morphAttributes.position;
                  if (e && e.isGLBufferAttribute) {
                    console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new ye(-1 / 0, -1 / 0, -1 / 0), new ye(1 / 0, 1 / 0, 1 / 0));
                    return;
                  }
                  if (e !== void 0) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                      for (let n = 0, i = t.length; n < i; n++) {
                        const r = t[n];
                        ts.setFromBufferAttribute(r), this.morphTargetsRelative ? (Mr.addVectors(this.boundingBox.min, ts.min), this.boundingBox.expandByPoint(Mr), Mr.addVectors(this.boundingBox.max, ts.max), this.boundingBox.expandByPoint(Mr)) : (this.boundingBox.expandByPoint(ts.min), this.boundingBox.expandByPoint(ts.max));
                      }
                  } else
                    this.boundingBox.makeEmpty();
                  (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
                }
                computeBoundingSphere() {
                  this.boundingSphere === null && (this.boundingSphere = new pr());
                  const e = this.attributes.position, t = this.morphAttributes.position;
                  if (e && e.isGLBufferAttribute) {
                    console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new ye(), 1 / 0);
                    return;
                  }
                  if (e) {
                    const n = this.boundingSphere.center;
                    if (ts.setFromBufferAttribute(e), t)
                      for (let r = 0, o = t.length; r < o; r++) {
                        const a = t[r];
                        Sa.setFromBufferAttribute(a), this.morphTargetsRelative ? (Mr.addVectors(ts.min, Sa.min), ts.expandByPoint(Mr), Mr.addVectors(ts.max, Sa.max), ts.expandByPoint(Mr)) : (ts.expandByPoint(Sa.min), ts.expandByPoint(Sa.max));
                      }
                    ts.getCenter(n);
                    let i = 0;
                    for (let r = 0, o = e.count; r < o; r++)
                      Mr.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(Mr));
                    if (t)
                      for (let r = 0, o = t.length; r < o; r++) {
                        const a = t[r], h = this.morphTargetsRelative;
                        for (let m = 0, _ = a.count; m < _; m++)
                          Mr.fromBufferAttribute(a, m), h && (qo.fromBufferAttribute(e, m), Mr.add(qo)), i = Math.max(i, n.distanceToSquared(Mr));
                      }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                  }
                }
                computeTangents() {
                  const e = this.index, t = this.attributes;
                  if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                    console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    return;
                  }
                  const n = t.position, i = t.normal, r = t.uv;
                  this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Pi(new Float32Array(4 * n.count), 4));
                  const o = this.getAttribute("tangent"), a = [], h = [];
                  for (let Re = 0; Re < n.count; Re++)
                    a[Re] = new ye(), h[Re] = new ye();
                  const m = new ye(), _ = new ye(), I = new ye(), B = new pt(), L = new pt(), N = new pt(), z = new ye(), k = new ye();
                  function P(Re, Ae, ce) {
                    m.fromBufferAttribute(n, Re), _.fromBufferAttribute(n, Ae), I.fromBufferAttribute(n, ce), B.fromBufferAttribute(r, Re), L.fromBufferAttribute(r, Ae), N.fromBufferAttribute(r, ce), _.sub(m), I.sub(m), L.sub(B), N.sub(B);
                    const Ie = 1 / (L.x * N.y - N.x * L.y);
                    isFinite(Ie) && (z.copy(_).multiplyScalar(N.y).addScaledVector(I, -L.y).multiplyScalar(Ie), k.copy(I).multiplyScalar(L.x).addScaledVector(_, -N.x).multiplyScalar(Ie), a[Re].add(z), a[Ae].add(z), a[ce].add(z), h[Re].add(k), h[Ae].add(k), h[ce].add(k));
                  }
                  let se = this.groups;
                  se.length === 0 && (se = [{ start: 0, count: e.count }]);
                  for (let Re = 0, Ae = se.length; Re < Ae; ++Re) {
                    const ce = se[Re], Ie = ce.start, Qe = ce.count;
                    for (let Ue = Ie, He = Ie + Qe; Ue < He; Ue += 3)
                      P(e.getX(Ue + 0), e.getX(Ue + 1), e.getX(Ue + 2));
                  }
                  const $ = new ye(), J = new ye(), Le = new ye(), Ee = new ye();
                  function Me(Re) {
                    Le.fromBufferAttribute(i, Re), Ee.copy(Le);
                    const Ae = a[Re];
                    $.copy(Ae), $.sub(Le.multiplyScalar(Le.dot(Ae))).normalize(), J.crossVectors(Ee, Ae);
                    const Ie = J.dot(h[Re]) < 0 ? -1 : 1;
                    o.setXYZW(Re, $.x, $.y, $.z, Ie);
                  }
                  for (let Re = 0, Ae = se.length; Re < Ae; ++Re) {
                    const ce = se[Re], Ie = ce.start, Qe = ce.count;
                    for (let Ue = Ie, He = Ie + Qe; Ue < He; Ue += 3)
                      Me(e.getX(Ue + 0)), Me(e.getX(Ue + 1)), Me(e.getX(Ue + 2));
                  }
                }
                computeVertexNormals() {
                  const e = this.index, t = this.getAttribute("position");
                  if (t !== void 0) {
                    let n = this.getAttribute("normal");
                    if (n === void 0)
                      n = new Pi(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
                    else
                      for (let B = 0, L = n.count; B < L; B++)
                        n.setXYZ(B, 0, 0, 0);
                    const i = new ye(), r = new ye(), o = new ye(), a = new ye(), h = new ye(), m = new ye(), _ = new ye(), I = new ye();
                    if (e)
                      for (let B = 0, L = e.count; B < L; B += 3) {
                        const N = e.getX(B + 0), z = e.getX(B + 1), k = e.getX(B + 2);
                        i.fromBufferAttribute(t, N), r.fromBufferAttribute(t, z), o.fromBufferAttribute(t, k), _.subVectors(o, r), I.subVectors(i, r), _.cross(I), a.fromBufferAttribute(n, N), h.fromBufferAttribute(n, z), m.fromBufferAttribute(n, k), a.add(_), h.add(_), m.add(_), n.setXYZ(N, a.x, a.y, a.z), n.setXYZ(z, h.x, h.y, h.z), n.setXYZ(k, m.x, m.y, m.z);
                      }
                    else
                      for (let B = 0, L = t.count; B < L; B += 3)
                        i.fromBufferAttribute(t, B + 0), r.fromBufferAttribute(t, B + 1), o.fromBufferAttribute(t, B + 2), _.subVectors(o, r), I.subVectors(i, r), _.cross(I), n.setXYZ(B + 0, _.x, _.y, _.z), n.setXYZ(B + 1, _.x, _.y, _.z), n.setXYZ(B + 2, _.x, _.y, _.z);
                    this.normalizeNormals(), n.needsUpdate = !0;
                  }
                }
                normalizeNormals() {
                  const e = this.attributes.normal;
                  for (let t = 0, n = e.count; t < n; t++)
                    Mr.fromBufferAttribute(e, t), Mr.normalize(), e.setXYZ(t, Mr.x, Mr.y, Mr.z);
                }
                toNonIndexed() {
                  function e(a, h) {
                    const m = a.array, _ = a.itemSize, I = a.normalized, B = new m.constructor(h.length * _);
                    let L = 0, N = 0;
                    for (let z = 0, k = h.length; z < k; z++) {
                      a.isInterleavedBufferAttribute ? L = h[z] * a.data.stride + a.offset : L = h[z] * _;
                      for (let P = 0; P < _; P++)
                        B[N++] = m[L++];
                    }
                    return new Pi(B, _, I);
                  }
                  if (this.index === null)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                  const t = new ti(), n = this.index.array, i = this.attributes;
                  for (const a in i) {
                    const h = i[a], m = e(h, n);
                    t.setAttribute(a, m);
                  }
                  const r = this.morphAttributes;
                  for (const a in r) {
                    const h = [], m = r[a];
                    for (let _ = 0, I = m.length; _ < I; _++) {
                      const B = m[_], L = e(B, n);
                      h.push(L);
                    }
                    t.morphAttributes[a] = h;
                  }
                  t.morphTargetsRelative = this.morphTargetsRelative;
                  const o = this.groups;
                  for (let a = 0, h = o.length; a < h; a++) {
                    const m = o[a];
                    t.addGroup(m.start, m.count, m.materialIndex);
                  }
                  return t;
                }
                toJSON() {
                  const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                  if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                    const h = this.parameters;
                    for (const m in h)
                      h[m] !== void 0 && (e[m] = h[m]);
                    return e;
                  }
                  e.data = { attributes: {} };
                  const t = this.index;
                  t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
                  const n = this.attributes;
                  for (const h in n) {
                    const m = n[h];
                    e.data.attributes[h] = m.toJSON(e.data);
                  }
                  const i = {};
                  let r = !1;
                  for (const h in this.morphAttributes) {
                    const m = this.morphAttributes[h], _ = [];
                    for (let I = 0, B = m.length; I < B; I++) {
                      const L = m[I];
                      _.push(L.toJSON(e.data));
                    }
                    _.length > 0 && (i[h] = _, r = !0);
                  }
                  r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
                  const o = this.groups;
                  o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
                  const a = this.boundingSphere;
                  return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                  const t = {};
                  this.name = e.name;
                  const n = e.index;
                  n !== null && this.setIndex(n.clone(t));
                  const i = e.attributes;
                  for (const m in i) {
                    const _ = i[m];
                    this.setAttribute(m, _.clone(t));
                  }
                  const r = e.morphAttributes;
                  for (const m in r) {
                    const _ = [], I = r[m];
                    for (let B = 0, L = I.length; B < L; B++)
                      _.push(I[B].clone(t));
                    this.morphAttributes[m] = _;
                  }
                  this.morphTargetsRelative = e.morphTargetsRelative;
                  const o = e.groups;
                  for (let m = 0, _ = o.length; m < _; m++) {
                    const I = o[m];
                    this.addGroup(I.start, I.count, I.materialIndex);
                  }
                  const a = e.boundingBox;
                  a !== null && (this.boundingBox = a.clone());
                  const h = e.boundingSphere;
                  return h !== null && (this.boundingSphere = h.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
                }
                dispose() {
                  this.dispatchEvent({ type: "dispose" });
                }
              }
              const Yh = /* @__PURE__ */ new pn(), mo = /* @__PURE__ */ new Ar(), bl = /* @__PURE__ */ new pr(), qh = /* @__PURE__ */ new ye(), Jo = /* @__PURE__ */ new ye(), Zo = /* @__PURE__ */ new ye(), $o = /* @__PURE__ */ new ye(), Ru = /* @__PURE__ */ new ye(), _l = /* @__PURE__ */ new ye(), wl = /* @__PURE__ */ new pt(), Ml = /* @__PURE__ */ new pt(), Sl = /* @__PURE__ */ new pt(), Jh = /* @__PURE__ */ new ye(), Zh = /* @__PURE__ */ new ye(), $h = /* @__PURE__ */ new ye(), Tl = /* @__PURE__ */ new ye(), Il = /* @__PURE__ */ new ye();
              class hr extends bi {
                constructor(e = new ti(), t = new qs()) {
                  super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
                }
                copy(e, t) {
                  return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
                }
                updateMorphTargets() {
                  const t = this.geometry.morphAttributes, n = Object.keys(t);
                  if (n.length > 0) {
                    const i = t[n[0]];
                    if (i !== void 0) {
                      this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                      for (let r = 0, o = i.length; r < o; r++) {
                        const a = i[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
                      }
                    }
                  }
                }
                getVertexPosition(e, t) {
                  const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, o = n.morphTargetsRelative;
                  t.fromBufferAttribute(i, e);
                  const a = this.morphTargetInfluences;
                  if (r && a) {
                    _l.set(0, 0, 0);
                    for (let h = 0, m = r.length; h < m; h++) {
                      const _ = a[h], I = r[h];
                      _ !== 0 && (Ru.fromBufferAttribute(I, e), o ? _l.addScaledVector(Ru, _) : _l.addScaledVector(Ru.sub(t), _));
                    }
                    t.add(_l);
                  }
                  return t;
                }
                raycast(e, t) {
                  const n = this.geometry, i = this.material, r = this.matrixWorld;
                  i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), bl.copy(n.boundingSphere), bl.applyMatrix4(r), mo.copy(e.ray).recast(e.near), !(bl.containsPoint(mo.origin) === !1 && (mo.intersectSphere(bl, qh) === null || mo.origin.distanceToSquared(qh) > (e.far - e.near) ** 2)) && (Yh.copy(r).invert(), mo.copy(e.ray).applyMatrix4(Yh), !(n.boundingBox !== null && mo.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, mo)));
                }
                _computeIntersections(e, t, n) {
                  let i;
                  const r = this.geometry, o = this.material, a = r.index, h = r.attributes.position, m = r.attributes.uv, _ = r.attributes.uv1, I = r.attributes.normal, B = r.groups, L = r.drawRange;
                  if (a !== null)
                    if (Array.isArray(o))
                      for (let N = 0, z = B.length; N < z; N++) {
                        const k = B[N], P = o[k.materialIndex], se = Math.max(k.start, L.start), $ = Math.min(a.count, Math.min(k.start + k.count, L.start + L.count));
                        for (let J = se, Le = $; J < Le; J += 3) {
                          const Ee = a.getX(J), Me = a.getX(J + 1), Re = a.getX(J + 2);
                          i = Bl(this, P, e, n, m, _, I, Ee, Me, Re), i && (i.faceIndex = Math.floor(J / 3), i.face.materialIndex = k.materialIndex, t.push(i));
                        }
                      }
                    else {
                      const N = Math.max(0, L.start), z = Math.min(a.count, L.start + L.count);
                      for (let k = N, P = z; k < P; k += 3) {
                        const se = a.getX(k), $ = a.getX(k + 1), J = a.getX(k + 2);
                        i = Bl(this, o, e, n, m, _, I, se, $, J), i && (i.faceIndex = Math.floor(k / 3), t.push(i));
                      }
                    }
                  else if (h !== void 0)
                    if (Array.isArray(o))
                      for (let N = 0, z = B.length; N < z; N++) {
                        const k = B[N], P = o[k.materialIndex], se = Math.max(k.start, L.start), $ = Math.min(h.count, Math.min(k.start + k.count, L.start + L.count));
                        for (let J = se, Le = $; J < Le; J += 3) {
                          const Ee = J, Me = J + 1, Re = J + 2;
                          i = Bl(this, P, e, n, m, _, I, Ee, Me, Re), i && (i.faceIndex = Math.floor(J / 3), i.face.materialIndex = k.materialIndex, t.push(i));
                        }
                      }
                    else {
                      const N = Math.max(0, L.start), z = Math.min(h.count, L.start + L.count);
                      for (let k = N, P = z; k < P; k += 3) {
                        const se = k, $ = k + 1, J = k + 2;
                        i = Bl(this, o, e, n, m, _, I, se, $, J), i && (i.faceIndex = Math.floor(k / 3), t.push(i));
                      }
                    }
                }
              }
              function $p(s, e, t, n, i, r, o, a) {
                let h;
                if (e.side === x ? h = n.intersectTriangle(o, r, i, !0, a) : h = n.intersectTriangle(i, r, o, e.side === f, a), h === null) return null;
                Il.copy(a), Il.applyMatrix4(s.matrixWorld);
                const m = t.ray.origin.distanceTo(Il);
                return m < t.near || m > t.far ? null : { distance: m, point: Il.clone(), object: s };
              }
              function Bl(s, e, t, n, i, r, o, a, h, m) {
                s.getVertexPosition(a, Jo), s.getVertexPosition(h, Zo), s.getVertexPosition(m, $o);
                const _ = $p(s, e, t, n, Jo, Zo, $o, Tl);
                if (_) {
                  i && (wl.fromBufferAttribute(i, a), Ml.fromBufferAttribute(i, h), Sl.fromBufferAttribute(i, m), _.uv = es.getInterpolation(Tl, Jo, Zo, $o, wl, Ml, Sl, new pt())), r && (wl.fromBufferAttribute(r, a), Ml.fromBufferAttribute(r, h), Sl.fromBufferAttribute(r, m), _.uv1 = es.getInterpolation(Tl, Jo, Zo, $o, wl, Ml, Sl, new pt())), o && (Jh.fromBufferAttribute(o, a), Zh.fromBufferAttribute(o, h), $h.fromBufferAttribute(o, m), _.normal = es.getInterpolation(Tl, Jo, Zo, $o, Jh, Zh, $h, new ye()), _.normal.dot(n.direction) > 0 && _.normal.multiplyScalar(-1));
                  const I = { a, b: h, c: m, normal: new ye(), materialIndex: 0 };
                  es.getNormal(Jo, Zo, $o, I.normal), _.face = I;
                }
                return _;
              }
              class go extends ti {
                constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
                  super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: i, heightSegments: r, depthSegments: o };
                  const a = this;
                  i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
                  const h = [], m = [], _ = [], I = [];
                  let B = 0, L = 0;
                  N("z", "y", "x", -1, -1, n, t, e, o, r, 0), N("z", "y", "x", 1, -1, n, t, -e, o, r, 1), N("x", "z", "y", 1, 1, e, n, t, i, o, 2), N("x", "z", "y", 1, -1, e, n, -t, i, o, 3), N("x", "y", "z", 1, -1, e, t, n, i, r, 4), N("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(h), this.setAttribute("position", new gn(m, 3)), this.setAttribute("normal", new gn(_, 3)), this.setAttribute("uv", new gn(I, 2));
                  function N(z, k, P, se, $, J, Le, Ee, Me, Re, Ae) {
                    const ce = J / Me, Ie = Le / Re, Qe = J / 2, Ue = Le / 2, He = Ee / 2, Ze = Me + 1, dt = Re + 1;
                    let Nt = 0, et = 0;
                    const Lt = new ye();
                    for (let Ot = 0; Ot < dt; Ot++) {
                      const fn = Ot * Ie - Ue;
                      for (let ni = 0; ni < Ze; ni++) {
                        const Si = ni * ce - Qe;
                        Lt[z] = Si * se, Lt[k] = fn * $, Lt[P] = He, m.push(Lt.x, Lt.y, Lt.z), Lt[z] = 0, Lt[k] = 0, Lt[P] = Ee > 0 ? 1 : -1, _.push(Lt.x, Lt.y, Lt.z), I.push(ni / Me), I.push(1 - Ot / Re), Nt += 1;
                      }
                    }
                    for (let Ot = 0; Ot < Re; Ot++)
                      for (let fn = 0; fn < Me; fn++) {
                        const ni = B + fn + Ze * Ot, Si = B + fn + Ze * (Ot + 1), Hi = B + (fn + 1) + Ze * (Ot + 1), _i = B + (fn + 1) + Ze * Ot;
                        h.push(ni, Si, _i), h.push(Si, Hi, _i), et += 6;
                      }
                    a.addGroup(L, et, Ae), L += et, B += Nt;
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new go(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
                }
              }
              function ea(s) {
                const e = {};
                for (const t in s) {
                  e[t] = {};
                  for (const n in s[t]) {
                    const i = s[t][n];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
                  }
                }
                return e;
              }
              function Qr(s) {
                const e = {};
                for (let t = 0; t < s.length; t++) {
                  const n = ea(s[t]);
                  for (const i in n)
                    e[i] = n[i];
                }
                return e;
              }
              function eA(s) {
                const e = [];
                for (let t = 0; t < s.length; t++)
                  e.push(s[t].clone());
                return e;
              }
              function ed(s) {
                const e = s.getRenderTarget();
                return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Mi.workingColorSpace;
              }
              const td = { clone: ea, merge: Qr };
              var tA = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, nA = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
              class fs extends Pr {
                constructor(e) {
                  super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = tA, this.fragmentShader = nA, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    clipCullDistance: !1,
                    // set to use vertex shader clipping
                    multiDraw: !1
                    // set to use vertex shader multi_draw / enable gl_DrawID
                  }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ea(e.uniforms), this.uniformsGroups = eA(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  t.glslVersion = this.glslVersion, t.uniforms = {};
                  for (const i in this.uniforms) {
                    const o = this.uniforms[i].value;
                    o && o.isTexture ? t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid } : o && o.isColor ? t.uniforms[i] = { type: "c", value: o.getHex() } : o && o.isVector2 ? t.uniforms[i] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? t.uniforms[i] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? t.uniforms[i] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? t.uniforms[i] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? t.uniforms[i] = { type: "m4", value: o.toArray() } : t.uniforms[i] = { value: o };
                  }
                  Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
                  const n = {};
                  for (const i in this.extensions)
                    this.extensions[i] === !0 && (n[i] = !0);
                  return Object.keys(n).length > 0 && (t.extensions = n), t;
                }
              }
              class Rl extends bi {
                constructor() {
                  super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new pn(), this.projectionMatrix = new pn(), this.projectionMatrixInverse = new pn(), this.coordinateSystem = ss;
                }
                copy(e, t) {
                  return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
                }
                getWorldDirection(e) {
                  return super.getWorldDirection(e).negate();
                }
                updateMatrixWorld(e) {
                  super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
                updateWorldMatrix(e, t) {
                  super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              const Js = /* @__PURE__ */ new ye(), nd = /* @__PURE__ */ new pt(), id = /* @__PURE__ */ new pt();
              class mr extends Rl {
                constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
                  super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
                }
                copy(e, t) {
                  return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
                }
                /**
                * Sets the FOV by focal length in respect to the current .filmGauge.
                *
                * The default film gauge is 35, so that the focal length can be specified for
                * a 35mm (full frame) camera.
                *
                * Values for focal length and film gauge must have the same unit.
                */
                setFocalLength(e) {
                  const t = 0.5 * this.getFilmHeight() / e;
                  this.fov = Hs * 2 * Math.atan(t), this.updateProjectionMatrix();
                }
                /**
                * Calculates the focal length from the current .fov and .filmGauge.
                */
                getFocalLength() {
                  const e = Math.tan(Bs * 0.5 * this.fov);
                  return 0.5 * this.getFilmHeight() / e;
                }
                getEffectiveFOV() {
                  return Hs * 2 * Math.atan(Math.tan(Bs * 0.5 * this.fov) / this.zoom);
                }
                getFilmWidth() {
                  return this.filmGauge * Math.min(this.aspect, 1);
                }
                getFilmHeight() {
                  return this.filmGauge / Math.max(this.aspect, 1);
                }
                /**
                * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
                * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
                */
                getViewBounds(e, t, n) {
                  Js.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Js.x, Js.y).multiplyScalar(-e / Js.z), Js.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Js.x, Js.y).multiplyScalar(-e / Js.z);
                }
                /**
                * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
                * Copies the result into the target Vector2, where x is width and y is height.
                */
                getViewSize(e, t) {
                  return this.getViewBounds(e, nd, id), t.subVectors(id, nd);
                }
                /**
                * Sets an offset in a larger frustum. This is useful for multi-window or
                * multi-monitor/multi-machine setups.
                *
                * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
                * the monitors are in grid like this
                *
                *   +---+---+---+
                *   | A | B | C |
                *   +---+---+---+
                *   | D | E | F |
                *   +---+---+---+
                *
                * then for each monitor you would call it like this
                *
                *   const w = 1920;
                *   const h = 1080;
                *   const fullWidth = w * 3;
                *   const fullHeight = h * 2;
                *
                *   --A--
                *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
                *   --B--
                *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
                *   --C--
                *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
                *   --D--
                *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
                *   --E--
                *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
                *   --F--
                *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
                *
                *   Note there is no reason monitors have to be the same size or in a grid.
                */
                setViewOffset(e, t, n, i, r, o) {
                  this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
                }
                clearViewOffset() {
                  this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
                }
                updateProjectionMatrix() {
                  const e = this.near;
                  let t = e * Math.tan(Bs * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
                  const o = this.view;
                  if (this.view !== null && this.view.enabled) {
                    const h = o.fullWidth, m = o.fullHeight;
                    r += o.offsetX * i / h, t -= o.offsetY * n / m, i *= o.width / h, n *= o.height / m;
                  }
                  const a = this.filmOffset;
                  a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
                }
              }
              const ta = -90, na = 1;
              class rd extends bi {
                constructor(e, t, n) {
                  super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                  const i = new mr(ta, na, e, t);
                  i.layers = this.layers, this.add(i);
                  const r = new mr(ta, na, e, t);
                  r.layers = this.layers, this.add(r);
                  const o = new mr(ta, na, e, t);
                  o.layers = this.layers, this.add(o);
                  const a = new mr(ta, na, e, t);
                  a.layers = this.layers, this.add(a);
                  const h = new mr(ta, na, e, t);
                  h.layers = this.layers, this.add(h);
                  const m = new mr(ta, na, e, t);
                  m.layers = this.layers, this.add(m);
                }
                updateCoordinateSystem() {
                  const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, o, a, h] = t;
                  for (const m of t) this.remove(m);
                  if (e === ss)
                    n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), h.up.set(0, 1, 0), h.lookAt(0, 0, -1);
                  else if (e === fo)
                    n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), h.up.set(0, -1, 0), h.lookAt(0, 0, -1);
                  else
                    throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                  for (const m of t)
                    this.add(m), m.updateMatrixWorld();
                }
                update(e, t) {
                  this.parent === null && this.updateMatrixWorld();
                  const { renderTarget: n, activeMipmapLevel: i } = this;
                  this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
                  const [r, o, a, h, m, _] = this.children, I = e.getRenderTarget(), B = e.getActiveCubeFace(), L = e.getActiveMipmapLevel(), N = e.xr.enabled;
                  e.xr.enabled = !1;
                  const z = n.texture.generateMipmaps;
                  n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, a), e.setRenderTarget(n, 3, i), e.render(t, h), e.setRenderTarget(n, 4, i), e.render(t, m), n.texture.generateMipmaps = z, e.setRenderTarget(n, 5, i), e.render(t, _), e.setRenderTarget(I, B, L), e.xr.enabled = N, n.texture.needsPMREMUpdate = !0;
                }
              }
              class Ta extends Vi {
                constructor(e, t, n, i, r, o, a, h, m, _) {
                  e = e !== void 0 ? e : [], t = t !== void 0 ? t : H, super(e, t, n, i, r, o, a, h, m, _), this.isCubeTexture = !0, this.flipY = !1;
                }
                get images() {
                  return this.image;
                }
                set images(e) {
                  this.image = e;
                }
              }
              class sd extends zr {
                constructor(e = 1, t = {}) {
                  super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                  const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
                  this.texture = new Ta(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : vn;
                }
                fromEquirectangularTexture(e, t) {
                  this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                  const n = { uniforms: { tEquirect: { value: null } }, vertexShader: (
                    /* glsl */
                    `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
                  ), fragmentShader: (
                    /* glsl */
                    `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                  ) }, i = new go(5, 5, 5), r = new fs({ name: "CubemapFromEquirect", uniforms: ea(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: x, blending: b });
                  r.uniforms.tEquirect.value = t;
                  const o = new hr(i, r), a = t.minFilter;
                  return t.minFilter === Ei && (t.minFilter = vn), new rd(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
                }
                clear(e, t, n, i) {
                  const r = e.getRenderTarget();
                  for (let o = 0; o < 6; o++)
                    e.setRenderTarget(this, o), e.clear(t, n, i);
                  e.setRenderTarget(r);
                }
              }
              const Lu = /* @__PURE__ */ new ye(), iA = /* @__PURE__ */ new ye(), rA = /* @__PURE__ */ new Gn();
              class Zs {
                constructor(e = new ye(1, 0, 0), t = 0) {
                  this.isPlane = !0, this.normal = e, this.constant = t;
                }
                set(e, t) {
                  return this.normal.copy(e), this.constant = t, this;
                }
                setComponents(e, t, n, i) {
                  return this.normal.set(e, t, n), this.constant = i, this;
                }
                setFromNormalAndCoplanarPoint(e, t) {
                  return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
                }
                setFromCoplanarPoints(e, t, n) {
                  const i = Lu.subVectors(n, t).cross(iA.subVectors(e, t)).normalize();
                  return this.setFromNormalAndCoplanarPoint(i, e), this;
                }
                copy(e) {
                  return this.normal.copy(e.normal), this.constant = e.constant, this;
                }
                normalize() {
                  const e = 1 / this.normal.length();
                  return this.normal.multiplyScalar(e), this.constant *= e, this;
                }
                negate() {
                  return this.constant *= -1, this.normal.negate(), this;
                }
                distanceToPoint(e) {
                  return this.normal.dot(e) + this.constant;
                }
                distanceToSphere(e) {
                  return this.distanceToPoint(e.center) - e.radius;
                }
                projectPoint(e, t) {
                  return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
                }
                intersectLine(e, t) {
                  const n = e.delta(Lu), i = this.normal.dot(n);
                  if (i === 0)
                    return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
                  const r = -(e.start.dot(this.normal) + this.constant) / i;
                  return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
                }
                intersectsLine(e) {
                  const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
                  return t < 0 && n > 0 || n < 0 && t > 0;
                }
                intersectsBox(e) {
                  return e.intersectsPlane(this);
                }
                intersectsSphere(e) {
                  return e.intersectsPlane(this);
                }
                coplanarPoint(e) {
                  return e.copy(this.normal).multiplyScalar(-this.constant);
                }
                applyMatrix4(e, t) {
                  const n = t || rA.getNormalMatrix(e), i = this.coplanarPoint(Lu).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
                  return this.constant = -i.dot(r), this;
                }
                translate(e) {
                  return this.constant -= e.dot(this.normal), this;
                }
                equals(e) {
                  return e.normal.equals(this.normal) && e.constant === this.constant;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              const vo = /* @__PURE__ */ new pr(), Ll = /* @__PURE__ */ new ye();
              class Ia {
                constructor(e = new Zs(), t = new Zs(), n = new Zs(), i = new Zs(), r = new Zs(), o = new Zs()) {
                  this.planes = [e, t, n, i, r, o];
                }
                set(e, t, n, i, r, o) {
                  const a = this.planes;
                  return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this;
                }
                copy(e) {
                  const t = this.planes;
                  for (let n = 0; n < 6; n++)
                    t[n].copy(e.planes[n]);
                  return this;
                }
                setFromProjectionMatrix(e, t = ss) {
                  const n = this.planes, i = e.elements, r = i[0], o = i[1], a = i[2], h = i[3], m = i[4], _ = i[5], I = i[6], B = i[7], L = i[8], N = i[9], z = i[10], k = i[11], P = i[12], se = i[13], $ = i[14], J = i[15];
                  if (n[0].setComponents(h - r, B - m, k - L, J - P).normalize(), n[1].setComponents(h + r, B + m, k + L, J + P).normalize(), n[2].setComponents(h + o, B + _, k + N, J + se).normalize(), n[3].setComponents(h - o, B - _, k - N, J - se).normalize(), n[4].setComponents(h - a, B - I, k - z, J - $).normalize(), t === ss)
                    n[5].setComponents(h + a, B + I, k + z, J + $).normalize();
                  else if (t === fo)
                    n[5].setComponents(a, I, z, $).normalize();
                  else
                    throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                  return this;
                }
                intersectsObject(e) {
                  if (e.boundingSphere !== void 0)
                    e.boundingSphere === null && e.computeBoundingSphere(), vo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                  else {
                    const t = e.geometry;
                    t.boundingSphere === null && t.computeBoundingSphere(), vo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
                  }
                  return this.intersectsSphere(vo);
                }
                intersectsSprite(e) {
                  return vo.center.set(0, 0, 0), vo.radius = 0.7071067811865476, vo.applyMatrix4(e.matrixWorld), this.intersectsSphere(vo);
                }
                intersectsSphere(e) {
                  const t = this.planes, n = e.center, i = -e.radius;
                  for (let r = 0; r < 6; r++)
                    if (t[r].distanceToPoint(n) < i)
                      return !1;
                  return !0;
                }
                intersectsBox(e) {
                  const t = this.planes;
                  for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (Ll.x = i.normal.x > 0 ? e.max.x : e.min.x, Ll.y = i.normal.y > 0 ? e.max.y : e.min.y, Ll.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Ll) < 0)
                      return !1;
                  }
                  return !0;
                }
                containsPoint(e) {
                  const t = this.planes;
                  for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0)
                      return !1;
                  return !0;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              function Du() {
                let s = null, e = !1, t = null, n = null;
                function i(r, o) {
                  t(r, o), n = s.requestAnimationFrame(i);
                }
                return { start: function() {
                  e !== !0 && t !== null && (n = s.requestAnimationFrame(i), e = !0);
                }, stop: function() {
                  s.cancelAnimationFrame(n), e = !1;
                }, setAnimationLoop: function(r) {
                  t = r;
                }, setContext: function(r) {
                  s = r;
                } };
              }
              function sA(s) {
                const e = /* @__PURE__ */ new WeakMap();
                function t(a, h) {
                  const m = a.array, _ = a.usage, I = m.byteLength, B = s.createBuffer();
                  s.bindBuffer(h, B), s.bufferData(h, m, _), a.onUploadCallback();
                  let L;
                  if (m instanceof Float32Array)
                    L = s.FLOAT;
                  else if (m instanceof Uint16Array)
                    a.isFloat16BufferAttribute ? L = s.HALF_FLOAT : L = s.UNSIGNED_SHORT;
                  else if (m instanceof Int16Array)
                    L = s.SHORT;
                  else if (m instanceof Uint32Array)
                    L = s.UNSIGNED_INT;
                  else if (m instanceof Int32Array)
                    L = s.INT;
                  else if (m instanceof Int8Array)
                    L = s.BYTE;
                  else if (m instanceof Uint8Array)
                    L = s.UNSIGNED_BYTE;
                  else if (m instanceof Uint8ClampedArray)
                    L = s.UNSIGNED_BYTE;
                  else
                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + m);
                  return { buffer: B, type: L, bytesPerElement: m.BYTES_PER_ELEMENT, version: a.version, size: I };
                }
                function n(a, h, m) {
                  const _ = h.array, I = h._updateRange, B = h.updateRanges;
                  if (s.bindBuffer(m, a), I.count === -1 && B.length === 0 && s.bufferSubData(m, 0, _), B.length !== 0) {
                    for (let L = 0, N = B.length; L < N; L++) {
                      const z = B[L];
                      s.bufferSubData(m, z.start * _.BYTES_PER_ELEMENT, _, z.start, z.count);
                    }
                    h.clearUpdateRanges();
                  }
                  I.count !== -1 && (s.bufferSubData(m, I.offset * _.BYTES_PER_ELEMENT, _, I.offset, I.count), I.count = -1), h.onUploadCallback();
                }
                function i(a) {
                  return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
                }
                function r(a) {
                  a.isInterleavedBufferAttribute && (a = a.data);
                  const h = e.get(a);
                  h && (s.deleteBuffer(h.buffer), e.delete(a));
                }
                function o(a, h) {
                  if (a.isGLBufferAttribute) {
                    const _ = e.get(a);
                    (!_ || _.version < a.version) && e.set(a, { buffer: a.buffer, type: a.type, bytesPerElement: a.elementSize, version: a.version });
                    return;
                  }
                  a.isInterleavedBufferAttribute && (a = a.data);
                  const m = e.get(a);
                  if (m === void 0)
                    e.set(a, t(a, h));
                  else if (m.version < a.version) {
                    if (m.size !== a.array.byteLength)
                      throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                    n(m.buffer, a, h), m.version = a.version;
                  }
                }
                return { get: i, remove: r, update: o };
              }
              class ia extends ti {
                constructor(e = 1, t = 1, n = 1, i = 1) {
                  super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i };
                  const r = e / 2, o = t / 2, a = Math.floor(n), h = Math.floor(i), m = a + 1, _ = h + 1, I = e / a, B = t / h, L = [], N = [], z = [], k = [];
                  for (let P = 0; P < _; P++) {
                    const se = P * B - o;
                    for (let $ = 0; $ < m; $++) {
                      const J = $ * I - r;
                      N.push(J, -se, 0), z.push(0, 0, 1), k.push($ / a), k.push(1 - P / h);
                    }
                  }
                  for (let P = 0; P < h; P++)
                    for (let se = 0; se < a; se++) {
                      const $ = se + m * P, J = se + m * (P + 1), Le = se + 1 + m * (P + 1), Ee = se + 1 + m * P;
                      L.push($, J, Ee), L.push(J, Le, Ee);
                    }
                  this.setIndex(L), this.setAttribute("position", new gn(N, 3)), this.setAttribute("normal", new gn(z, 3)), this.setAttribute("uv", new gn(k, 2));
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new ia(e.width, e.height, e.widthSegments, e.heightSegments);
                }
              }
              var oA = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, aA = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, lA = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, cA = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, uA = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, hA = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, dA = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, fA = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, pA = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, AA = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, mA = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, gA = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, vA = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, EA = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, yA = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, CA = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, xA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, bA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, _A = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, wA = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, MA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, SA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, TA = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, IA = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, BA = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, RA = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, LA = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, DA = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, PA = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, OA = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, FA = "gl_FragColor = linearToOutputTexel( gl_FragColor );", UA = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, NA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, kA = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, GA = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, QA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, VA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, HA = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, zA = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, jA = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, WA = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, KA = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, XA = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, YA = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, qA = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, JA = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, ZA = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, $A = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, em = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, tm = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, nm = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, im = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, rm = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, sm = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, om = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, am = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, lm = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, cm = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, um = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, hm = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, dm = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, fm = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, pm = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Am = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, mm = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, gm = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, vm = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, Em = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, ym = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Cm = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, xm = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, bm = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, _m = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, wm = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Mm = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Sm = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Tm = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Im = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Bm = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Rm = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Lm = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Dm = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Pm = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Om = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Fm = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Um = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Nm = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, km = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Gm = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Qm = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, Vm = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Hm = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, zm = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, jm = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Wm = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Km = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Xm = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Ym = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, qm = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Jm = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Zm = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, $m = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, e0 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, t0 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, n0 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, i0 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, r0 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
              const Jn = { alphahash_fragment: oA, alphahash_pars_fragment: aA, alphamap_fragment: lA, alphamap_pars_fragment: cA, alphatest_fragment: uA, alphatest_pars_fragment: hA, aomap_fragment: dA, aomap_pars_fragment: fA, batching_pars_vertex: pA, batching_vertex: AA, begin_vertex: mA, beginnormal_vertex: gA, bsdfs: vA, iridescence_fragment: EA, bumpmap_pars_fragment: yA, clipping_planes_fragment: CA, clipping_planes_pars_fragment: xA, clipping_planes_pars_vertex: bA, clipping_planes_vertex: _A, color_fragment: wA, color_pars_fragment: MA, color_pars_vertex: SA, color_vertex: TA, common: IA, cube_uv_reflection_fragment: BA, defaultnormal_vertex: RA, displacementmap_pars_vertex: LA, displacementmap_vertex: DA, emissivemap_fragment: PA, emissivemap_pars_fragment: OA, colorspace_fragment: FA, colorspace_pars_fragment: UA, envmap_fragment: NA, envmap_common_pars_fragment: kA, envmap_pars_fragment: GA, envmap_pars_vertex: QA, envmap_physical_pars_fragment: ZA, envmap_vertex: VA, fog_vertex: HA, fog_pars_vertex: zA, fog_fragment: jA, fog_pars_fragment: WA, gradientmap_pars_fragment: KA, lightmap_pars_fragment: XA, lights_lambert_fragment: YA, lights_lambert_pars_fragment: qA, lights_pars_begin: JA, lights_toon_fragment: $A, lights_toon_pars_fragment: em, lights_phong_fragment: tm, lights_phong_pars_fragment: nm, lights_physical_fragment: im, lights_physical_pars_fragment: rm, lights_fragment_begin: sm, lights_fragment_maps: om, lights_fragment_end: am, logdepthbuf_fragment: lm, logdepthbuf_pars_fragment: cm, logdepthbuf_pars_vertex: um, logdepthbuf_vertex: hm, map_fragment: dm, map_pars_fragment: fm, map_particle_fragment: pm, map_particle_pars_fragment: Am, metalnessmap_fragment: mm, metalnessmap_pars_fragment: gm, morphinstance_vertex: vm, morphcolor_vertex: Em, morphnormal_vertex: ym, morphtarget_pars_vertex: Cm, morphtarget_vertex: xm, normal_fragment_begin: bm, normal_fragment_maps: _m, normal_pars_fragment: wm, normal_pars_vertex: Mm, normal_vertex: Sm, normalmap_pars_fragment: Tm, clearcoat_normal_fragment_begin: Im, clearcoat_normal_fragment_maps: Bm, clearcoat_pars_fragment: Rm, iridescence_pars_fragment: Lm, opaque_fragment: Dm, packing: Pm, premultiplied_alpha_fragment: Om, project_vertex: Fm, dithering_fragment: Um, dithering_pars_fragment: Nm, roughnessmap_fragment: km, roughnessmap_pars_fragment: Gm, shadowmap_pars_fragment: Qm, shadowmap_pars_vertex: Vm, shadowmap_vertex: Hm, shadowmask_pars_fragment: zm, skinbase_vertex: jm, skinning_pars_vertex: Wm, skinning_vertex: Km, skinnormal_vertex: Xm, specularmap_fragment: Ym, specularmap_pars_fragment: qm, tonemapping_fragment: Jm, tonemapping_pars_fragment: Zm, transmission_fragment: $m, transmission_pars_fragment: e0, uv_pars_fragment: t0, uv_pars_vertex: n0, uv_vertex: i0, worldpos_vertex: r0, background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}` }, Vt = { common: { diffuse: { value: /* @__PURE__ */ new sn(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: /* @__PURE__ */ new Gn() }, alphaMap: { value: null }, alphaMapTransform: { value: /* @__PURE__ */ new Gn() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: /* @__PURE__ */ new Gn() } }, envmap: {
                envMap: { value: null },
                envMapRotation: { value: /* @__PURE__ */ new Gn() },
                flipEnvMap: { value: -1 },
                reflectivity: { value: 1 },
                // basic, lambert, phong
                ior: { value: 1.5 },
                // physical
                refractionRatio: { value: 0.98 }
                // basic, lambert, phong
              }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: /* @__PURE__ */ new Gn() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: /* @__PURE__ */ new Gn() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: /* @__PURE__ */ new Gn() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: /* @__PURE__ */ new Gn() }, normalScale: { value: /* @__PURE__ */ new pt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: /* @__PURE__ */ new Gn() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: /* @__PURE__ */ new Gn() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: /* @__PURE__ */ new Gn() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: /* @__PURE__ */ new Gn() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: /* @__PURE__ */ new sn(16777215) } }, lights: {
                ambientLightColor: { value: [] },
                lightProbe: { value: [] },
                directionalLights: { value: [], properties: { direction: {}, color: {} } },
                directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
                directionalShadowMap: { value: [] },
                directionalShadowMatrix: { value: [] },
                spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } },
                spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
                spotLightMap: { value: [] },
                spotShadowMap: { value: [] },
                spotLightMatrix: { value: [] },
                pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
                pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
                pointShadowMap: { value: [] },
                pointShadowMatrix: { value: [] },
                hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
                // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
                rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
                ltc_1: { value: null },
                ltc_2: { value: null }
              }, points: { diffuse: { value: /* @__PURE__ */ new sn(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: /* @__PURE__ */ new Gn() }, alphaTest: { value: 0 }, uvTransform: { value: /* @__PURE__ */ new Gn() } }, sprite: { diffuse: { value: /* @__PURE__ */ new sn(16777215) }, opacity: { value: 1 }, center: { value: /* @__PURE__ */ new pt(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: /* @__PURE__ */ new Gn() }, alphaMap: { value: null }, alphaMapTransform: { value: /* @__PURE__ */ new Gn() }, alphaTest: { value: 0 } } }, ps = { basic: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.specularmap, Vt.envmap, Vt.aomap, Vt.lightmap, Vt.fog]), vertexShader: Jn.meshbasic_vert, fragmentShader: Jn.meshbasic_frag }, lambert: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.specularmap, Vt.envmap, Vt.aomap, Vt.lightmap, Vt.emissivemap, Vt.bumpmap, Vt.normalmap, Vt.displacementmap, Vt.fog, Vt.lights, { emissive: { value: /* @__PURE__ */ new sn(0) } }]), vertexShader: Jn.meshlambert_vert, fragmentShader: Jn.meshlambert_frag }, phong: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.specularmap, Vt.envmap, Vt.aomap, Vt.lightmap, Vt.emissivemap, Vt.bumpmap, Vt.normalmap, Vt.displacementmap, Vt.fog, Vt.lights, { emissive: { value: /* @__PURE__ */ new sn(0) }, specular: { value: /* @__PURE__ */ new sn(1118481) }, shininess: { value: 30 } }]), vertexShader: Jn.meshphong_vert, fragmentShader: Jn.meshphong_frag }, standard: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.envmap, Vt.aomap, Vt.lightmap, Vt.emissivemap, Vt.bumpmap, Vt.normalmap, Vt.displacementmap, Vt.roughnessmap, Vt.metalnessmap, Vt.fog, Vt.lights, { emissive: { value: /* @__PURE__ */ new sn(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Jn.meshphysical_vert, fragmentShader: Jn.meshphysical_frag }, toon: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.aomap, Vt.lightmap, Vt.emissivemap, Vt.bumpmap, Vt.normalmap, Vt.displacementmap, Vt.gradientmap, Vt.fog, Vt.lights, { emissive: { value: /* @__PURE__ */ new sn(0) } }]), vertexShader: Jn.meshtoon_vert, fragmentShader: Jn.meshtoon_frag }, matcap: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.bumpmap, Vt.normalmap, Vt.displacementmap, Vt.fog, { matcap: { value: null } }]), vertexShader: Jn.meshmatcap_vert, fragmentShader: Jn.meshmatcap_frag }, points: { uniforms: /* @__PURE__ */ Qr([Vt.points, Vt.fog]), vertexShader: Jn.points_vert, fragmentShader: Jn.points_frag }, dashed: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Jn.linedashed_vert, fragmentShader: Jn.linedashed_frag }, depth: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.displacementmap]), vertexShader: Jn.depth_vert, fragmentShader: Jn.depth_frag }, normal: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.bumpmap, Vt.normalmap, Vt.displacementmap, { opacity: { value: 1 } }]), vertexShader: Jn.meshnormal_vert, fragmentShader: Jn.meshnormal_frag }, sprite: { uniforms: /* @__PURE__ */ Qr([Vt.sprite, Vt.fog]), vertexShader: Jn.sprite_vert, fragmentShader: Jn.sprite_frag }, background: { uniforms: { uvTransform: { value: /* @__PURE__ */ new Gn() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Jn.background_vert, fragmentShader: Jn.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: /* @__PURE__ */ new Gn() } }, vertexShader: Jn.backgroundCube_vert, fragmentShader: Jn.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Jn.cube_vert, fragmentShader: Jn.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Jn.equirect_vert, fragmentShader: Jn.equirect_frag }, distanceRGBA: { uniforms: /* @__PURE__ */ Qr([Vt.common, Vt.displacementmap, { referencePosition: { value: /* @__PURE__ */ new ye() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Jn.distanceRGBA_vert, fragmentShader: Jn.distanceRGBA_frag }, shadow: { uniforms: /* @__PURE__ */ Qr([Vt.lights, Vt.fog, { color: { value: /* @__PURE__ */ new sn(0) }, opacity: { value: 1 } }]), vertexShader: Jn.shadow_vert, fragmentShader: Jn.shadow_frag } };
              ps.physical = { uniforms: /* @__PURE__ */ Qr([ps.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: /* @__PURE__ */ new Gn() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Gn() }, clearcoatNormalScale: { value: /* @__PURE__ */ new pt(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Gn() }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: /* @__PURE__ */ new Gn() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Gn() }, sheen: { value: 0 }, sheenColor: { value: /* @__PURE__ */ new sn(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: /* @__PURE__ */ new Gn() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Gn() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: /* @__PURE__ */ new Gn() }, transmissionSamplerSize: { value: /* @__PURE__ */ new pt() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: /* @__PURE__ */ new Gn() }, attenuationDistance: { value: 0 }, attenuationColor: { value: /* @__PURE__ */ new sn(0) }, specularColor: { value: /* @__PURE__ */ new sn(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: /* @__PURE__ */ new Gn() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: /* @__PURE__ */ new Gn() }, anisotropyVector: { value: /* @__PURE__ */ new pt() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: /* @__PURE__ */ new Gn() } }]), vertexShader: Jn.meshphysical_vert, fragmentShader: Jn.meshphysical_frag };
              const Dl = { r: 0, b: 0, g: 0 }, Eo = /* @__PURE__ */ new $r(), s0 = /* @__PURE__ */ new pn();
              function o0(s, e, t, n, i, r, o) {
                const a = new sn(0);
                let h = r === !0 ? 0 : 1, m, _, I = null, B = 0, L = null;
                function N(se) {
                  let $ = se.isScene === !0 ? se.background : null;
                  return $ && $.isTexture && ($ = (se.backgroundBlurriness > 0 ? t : e).get($)), $;
                }
                function z(se) {
                  let $ = !1;
                  const J = N(se);
                  J === null ? P(a, h) : J && J.isColor && (P(J, 1), $ = !0);
                  const Le = s.xr.getEnvironmentBlendMode();
                  Le === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : Le === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || $) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil);
                }
                function k(se, $) {
                  const J = N($);
                  J && (J.isCubeTexture || J.mapping === he) ? (_ === void 0 && (_ = new hr(new go(1e4, 1e4, 1e4), new fs({ name: "BackgroundCubeMaterial", uniforms: ea(ps.backgroundCube.uniforms), vertexShader: ps.backgroundCube.vertexShader, fragmentShader: ps.backgroundCube.fragmentShader, side: x, depthTest: !1, depthWrite: !1, fog: !1 })), _.geometry.deleteAttribute("normal"), _.geometry.deleteAttribute("uv"), _.onBeforeRender = function(Le, Ee, Me) {
                    this.matrixWorld.copyPosition(Me.matrixWorld);
                  }, Object.defineProperty(_.material, "envMap", { get: function() {
                    return this.uniforms.envMap.value;
                  } }), i.update(_)), Eo.copy($.backgroundRotation), Eo.x *= -1, Eo.y *= -1, Eo.z *= -1, J.isCubeTexture && J.isRenderTargetTexture === !1 && (Eo.y *= -1, Eo.z *= -1), _.material.uniforms.envMap.value = J, _.material.uniforms.flipEnvMap.value = J.isCubeTexture && J.isRenderTargetTexture === !1 ? -1 : 1, _.material.uniforms.backgroundBlurriness.value = $.backgroundBlurriness, _.material.uniforms.backgroundIntensity.value = $.backgroundIntensity, _.material.uniforms.backgroundRotation.value.setFromMatrix4(s0.makeRotationFromEuler(Eo)), _.material.toneMapped = Mi.getTransfer(J.colorSpace) !== Fi, (I !== J || B !== J.version || L !== s.toneMapping) && (_.material.needsUpdate = !0, I = J, B = J.version, L = s.toneMapping), _.layers.enableAll(), se.unshift(_, _.geometry, _.material, 0, 0, null)) : J && J.isTexture && (m === void 0 && (m = new hr(new ia(2, 2), new fs({ name: "BackgroundMaterial", uniforms: ea(ps.background.uniforms), vertexShader: ps.background.vertexShader, fragmentShader: ps.background.fragmentShader, side: f, depthTest: !1, depthWrite: !1, fog: !1 })), m.geometry.deleteAttribute("normal"), Object.defineProperty(m.material, "map", { get: function() {
                    return this.uniforms.t2D.value;
                  } }), i.update(m)), m.material.uniforms.t2D.value = J, m.material.uniforms.backgroundIntensity.value = $.backgroundIntensity, m.material.toneMapped = Mi.getTransfer(J.colorSpace) !== Fi, J.matrixAutoUpdate === !0 && J.updateMatrix(), m.material.uniforms.uvTransform.value.copy(J.matrix), (I !== J || B !== J.version || L !== s.toneMapping) && (m.material.needsUpdate = !0, I = J, B = J.version, L = s.toneMapping), m.layers.enableAll(), se.unshift(m, m.geometry, m.material, 0, 0, null));
                }
                function P(se, $) {
                  se.getRGB(Dl, ed(s)), n.buffers.color.setClear(Dl.r, Dl.g, Dl.b, $, o);
                }
                return { getClearColor: function() {
                  return a;
                }, setClearColor: function(se, $ = 1) {
                  a.set(se), h = $, P(a, h);
                }, getClearAlpha: function() {
                  return h;
                }, setClearAlpha: function(se) {
                  h = se, P(a, h);
                }, render: z, addToRenderList: k };
              }
              function a0(s, e) {
                const t = s.getParameter(s.MAX_VERTEX_ATTRIBS), n = {}, i = B(null);
                let r = i, o = !1;
                function a(ce, Ie, Qe, Ue, He) {
                  let Ze = !1;
                  const dt = I(Ue, Qe, Ie);
                  r !== dt && (r = dt, m(r.object)), Ze = L(ce, Ue, Qe, He), Ze && N(ce, Ue, Qe, He), He !== null && e.update(He, s.ELEMENT_ARRAY_BUFFER), (Ze || o) && (o = !1, J(ce, Ie, Qe, Ue), He !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(He).buffer));
                }
                function h() {
                  return s.createVertexArray();
                }
                function m(ce) {
                  return s.bindVertexArray(ce);
                }
                function _(ce) {
                  return s.deleteVertexArray(ce);
                }
                function I(ce, Ie, Qe) {
                  const Ue = Qe.wireframe === !0;
                  let He = n[ce.id];
                  He === void 0 && (He = {}, n[ce.id] = He);
                  let Ze = He[Ie.id];
                  Ze === void 0 && (Ze = {}, He[Ie.id] = Ze);
                  let dt = Ze[Ue];
                  return dt === void 0 && (dt = B(h()), Ze[Ue] = dt), dt;
                }
                function B(ce) {
                  const Ie = [], Qe = [], Ue = [];
                  for (let He = 0; He < t; He++)
                    Ie[He] = 0, Qe[He] = 0, Ue[He] = 0;
                  return {
                    // for backward compatibility on non-VAO support browser
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: Ie,
                    enabledAttributes: Qe,
                    attributeDivisors: Ue,
                    object: ce,
                    attributes: {},
                    index: null
                  };
                }
                function L(ce, Ie, Qe, Ue) {
                  const He = r.attributes, Ze = Ie.attributes;
                  let dt = 0;
                  const Nt = Qe.getAttributes();
                  for (const et in Nt)
                    if (Nt[et].location >= 0) {
                      const Ot = He[et];
                      let fn = Ze[et];
                      if (fn === void 0 && (et === "instanceMatrix" && ce.instanceMatrix && (fn = ce.instanceMatrix), et === "instanceColor" && ce.instanceColor && (fn = ce.instanceColor)), Ot === void 0 || Ot.attribute !== fn || fn && Ot.data !== fn.data) return !0;
                      dt++;
                    }
                  return r.attributesNum !== dt || r.index !== Ue;
                }
                function N(ce, Ie, Qe, Ue) {
                  const He = {}, Ze = Ie.attributes;
                  let dt = 0;
                  const Nt = Qe.getAttributes();
                  for (const et in Nt)
                    if (Nt[et].location >= 0) {
                      let Ot = Ze[et];
                      Ot === void 0 && (et === "instanceMatrix" && ce.instanceMatrix && (Ot = ce.instanceMatrix), et === "instanceColor" && ce.instanceColor && (Ot = ce.instanceColor));
                      const fn = {};
                      fn.attribute = Ot, Ot && Ot.data && (fn.data = Ot.data), He[et] = fn, dt++;
                    }
                  r.attributes = He, r.attributesNum = dt, r.index = Ue;
                }
                function z() {
                  const ce = r.newAttributes;
                  for (let Ie = 0, Qe = ce.length; Ie < Qe; Ie++)
                    ce[Ie] = 0;
                }
                function k(ce) {
                  P(ce, 0);
                }
                function P(ce, Ie) {
                  const Qe = r.newAttributes, Ue = r.enabledAttributes, He = r.attributeDivisors;
                  Qe[ce] = 1, Ue[ce] === 0 && (s.enableVertexAttribArray(ce), Ue[ce] = 1), He[ce] !== Ie && (s.vertexAttribDivisor(ce, Ie), He[ce] = Ie);
                }
                function se() {
                  const ce = r.newAttributes, Ie = r.enabledAttributes;
                  for (let Qe = 0, Ue = Ie.length; Qe < Ue; Qe++)
                    Ie[Qe] !== ce[Qe] && (s.disableVertexAttribArray(Qe), Ie[Qe] = 0);
                }
                function $(ce, Ie, Qe, Ue, He, Ze, dt) {
                  dt === !0 ? s.vertexAttribIPointer(ce, Ie, Qe, He, Ze) : s.vertexAttribPointer(ce, Ie, Qe, Ue, He, Ze);
                }
                function J(ce, Ie, Qe, Ue) {
                  z();
                  const He = Ue.attributes, Ze = Qe.getAttributes(), dt = Ie.defaultAttributeValues;
                  for (const Nt in Ze) {
                    const et = Ze[Nt];
                    if (et.location >= 0) {
                      let Lt = He[Nt];
                      if (Lt === void 0 && (Nt === "instanceMatrix" && ce.instanceMatrix && (Lt = ce.instanceMatrix), Nt === "instanceColor" && ce.instanceColor && (Lt = ce.instanceColor)), Lt !== void 0) {
                        const Ot = Lt.normalized, fn = Lt.itemSize, ni = e.get(Lt);
                        if (ni === void 0) continue;
                        const Si = ni.buffer, Hi = ni.type, _i = ni.bytesPerElement, Ui = Hi === s.INT || Hi === s.UNSIGNED_INT || Lt.gpuType === Y;
                        if (Lt.isInterleavedBufferAttribute) {
                          const An = Lt.data, mt = An.stride, Gt = Lt.offset;
                          if (An.isInstancedInterleavedBuffer) {
                            for (let Ht = 0; Ht < et.locationSize; Ht++)
                              P(et.location + Ht, An.meshPerAttribute);
                            ce.isInstancedMesh !== !0 && Ue._maxInstanceCount === void 0 && (Ue._maxInstanceCount = An.meshPerAttribute * An.count);
                          } else
                            for (let Ht = 0; Ht < et.locationSize; Ht++)
                              k(et.location + Ht);
                          s.bindBuffer(s.ARRAY_BUFFER, Si);
                          for (let Ht = 0; Ht < et.locationSize; Ht++)
                            $(et.location + Ht, fn / et.locationSize, Hi, Ot, mt * _i, (Gt + fn / et.locationSize * Ht) * _i, Ui);
                        } else {
                          if (Lt.isInstancedBufferAttribute) {
                            for (let An = 0; An < et.locationSize; An++)
                              P(et.location + An, Lt.meshPerAttribute);
                            ce.isInstancedMesh !== !0 && Ue._maxInstanceCount === void 0 && (Ue._maxInstanceCount = Lt.meshPerAttribute * Lt.count);
                          } else
                            for (let An = 0; An < et.locationSize; An++)
                              k(et.location + An);
                          s.bindBuffer(s.ARRAY_BUFFER, Si);
                          for (let An = 0; An < et.locationSize; An++)
                            $(et.location + An, fn / et.locationSize, Hi, Ot, fn * _i, fn / et.locationSize * An * _i, Ui);
                        }
                      } else if (dt !== void 0) {
                        const Ot = dt[Nt];
                        if (Ot !== void 0)
                          switch (Ot.length) {
                            case 2:
                              s.vertexAttrib2fv(et.location, Ot);
                              break;
                            case 3:
                              s.vertexAttrib3fv(et.location, Ot);
                              break;
                            case 4:
                              s.vertexAttrib4fv(et.location, Ot);
                              break;
                            default:
                              s.vertexAttrib1fv(et.location, Ot);
                          }
                      }
                    }
                  }
                  se();
                }
                function Le() {
                  Re();
                  for (const ce in n) {
                    const Ie = n[ce];
                    for (const Qe in Ie) {
                      const Ue = Ie[Qe];
                      for (const He in Ue)
                        _(Ue[He].object), delete Ue[He];
                      delete Ie[Qe];
                    }
                    delete n[ce];
                  }
                }
                function Ee(ce) {
                  if (n[ce.id] === void 0) return;
                  const Ie = n[ce.id];
                  for (const Qe in Ie) {
                    const Ue = Ie[Qe];
                    for (const He in Ue)
                      _(Ue[He].object), delete Ue[He];
                    delete Ie[Qe];
                  }
                  delete n[ce.id];
                }
                function Me(ce) {
                  for (const Ie in n) {
                    const Qe = n[Ie];
                    if (Qe[ce.id] === void 0) continue;
                    const Ue = Qe[ce.id];
                    for (const He in Ue)
                      _(Ue[He].object), delete Ue[He];
                    delete Qe[ce.id];
                  }
                }
                function Re() {
                  Ae(), o = !0, r !== i && (r = i, m(r.object));
                }
                function Ae() {
                  i.geometry = null, i.program = null, i.wireframe = !1;
                }
                return { setup: a, reset: Re, resetDefaultState: Ae, dispose: Le, releaseStatesOfGeometry: Ee, releaseStatesOfProgram: Me, initAttributes: z, enableAttribute: k, disableUnusedAttributes: se };
              }
              function l0(s, e, t) {
                let n;
                function i(m) {
                  n = m;
                }
                function r(m, _) {
                  s.drawArrays(n, m, _), t.update(_, n, 1);
                }
                function o(m, _, I) {
                  I !== 0 && (s.drawArraysInstanced(n, m, _, I), t.update(_, n, I));
                }
                function a(m, _, I) {
                  if (I === 0) return;
                  const B = e.get("WEBGL_multi_draw");
                  if (B === null)
                    for (let L = 0; L < I; L++)
                      this.render(m[L], _[L]);
                  else {
                    B.multiDrawArraysWEBGL(n, m, 0, _, 0, I);
                    let L = 0;
                    for (let N = 0; N < I; N++)
                      L += _[N];
                    t.update(L, n, 1);
                  }
                }
                function h(m, _, I, B) {
                  if (I === 0) return;
                  const L = e.get("WEBGL_multi_draw");
                  if (L === null)
                    for (let N = 0; N < m.length; N++)
                      o(m[N], _[N], B[N]);
                  else {
                    L.multiDrawArraysInstancedWEBGL(n, m, 0, _, 0, B, 0, I);
                    let N = 0;
                    for (let z = 0; z < I; z++)
                      N += _[z];
                    for (let z = 0; z < B.length; z++)
                      t.update(N, n, B[z]);
                  }
                }
                this.setMode = i, this.render = r, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = h;
              }
              function c0(s, e, t, n) {
                let i;
                function r() {
                  if (i !== void 0) return i;
                  if (e.has("EXT_texture_filter_anisotropic") === !0) {
                    const Ee = e.get("EXT_texture_filter_anisotropic");
                    i = s.getParameter(Ee.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                  } else
                    i = 0;
                  return i;
                }
                function o(Ee) {
                  return !(Ee !== _e && n.convert(Ee) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
                }
                function a(Ee) {
                  const Me = Ee === lt && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
                  return !(Ee !== Ii && n.convert(Ee) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
                  Ee !== tt && !Me);
                }
                function h(Ee) {
                  if (Ee === "highp") {
                    if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
                      return "highp";
                    Ee = "mediump";
                  }
                  return Ee === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
                }
                let m = t.precision !== void 0 ? t.precision : "highp";
                const _ = h(m);
                _ !== m && (console.warn("THREE.WebGLRenderer:", m, "not supported, using", _, "instead."), m = _);
                const I = t.logarithmicDepthBuffer === !0, B = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), L = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), N = s.getParameter(s.MAX_TEXTURE_SIZE), z = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), k = s.getParameter(s.MAX_VERTEX_ATTRIBS), P = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), se = s.getParameter(s.MAX_VARYING_VECTORS), $ = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), J = L > 0, Le = s.getParameter(s.MAX_SAMPLES);
                return {
                  isWebGL2: !0,
                  // keeping this for backwards compatibility
                  getMaxAnisotropy: r,
                  getMaxPrecision: h,
                  textureFormatReadable: o,
                  textureTypeReadable: a,
                  precision: m,
                  logarithmicDepthBuffer: I,
                  maxTextures: B,
                  maxVertexTextures: L,
                  maxTextureSize: N,
                  maxCubemapSize: z,
                  maxAttributes: k,
                  maxVertexUniforms: P,
                  maxVaryings: se,
                  maxFragmentUniforms: $,
                  vertexTextures: J,
                  maxSamples: Le
                };
              }
              function u0(s) {
                const e = this;
                let t = null, n = 0, i = !1, r = !1;
                const o = new Zs(), a = new Gn(), h = { value: null, needsUpdate: !1 };
                this.uniform = h, this.numPlanes = 0, this.numIntersection = 0, this.init = function(I, B) {
                  const L = I.length !== 0 || B || // enable state of previous frame - the clipping code has to
                  // run another frame in order to reset the state:
                  n !== 0 || i;
                  return i = B, n = I.length, L;
                }, this.beginShadows = function() {
                  r = !0, _(null);
                }, this.endShadows = function() {
                  r = !1;
                }, this.setGlobalState = function(I, B) {
                  t = _(I, B, 0);
                }, this.setState = function(I, B, L) {
                  const N = I.clippingPlanes, z = I.clipIntersection, k = I.clipShadows, P = s.get(I);
                  if (!i || N === null || N.length === 0 || r && !k)
                    r ? _(null) : m();
                  else {
                    const se = r ? 0 : n, $ = se * 4;
                    let J = P.clippingState || null;
                    h.value = J, J = _(N, B, $, L);
                    for (let Le = 0; Le !== $; ++Le)
                      J[Le] = t[Le];
                    P.clippingState = J, this.numIntersection = z ? this.numPlanes : 0, this.numPlanes += se;
                  }
                };
                function m() {
                  h.value !== t && (h.value = t, h.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
                }
                function _(I, B, L, N) {
                  const z = I !== null ? I.length : 0;
                  let k = null;
                  if (z !== 0) {
                    if (k = h.value, N !== !0 || k === null) {
                      const P = L + z * 4, se = B.matrixWorldInverse;
                      a.getNormalMatrix(se), (k === null || k.length < P) && (k = new Float32Array(P));
                      for (let $ = 0, J = L; $ !== z; ++$, J += 4)
                        o.copy(I[$]).applyMatrix4(se, a), o.normal.toArray(k, J), k[J + 3] = o.constant;
                    }
                    h.value = k, h.needsUpdate = !0;
                  }
                  return e.numPlanes = z, e.numIntersection = 0, k;
                }
              }
              function h0(s) {
                let e = /* @__PURE__ */ new WeakMap();
                function t(o, a) {
                  return a === R ? o.mapping = H : a === ee && (o.mapping = M), o;
                }
                function n(o) {
                  if (o && o.isTexture) {
                    const a = o.mapping;
                    if (a === R || a === ee)
                      if (e.has(o)) {
                        const h = e.get(o).texture;
                        return t(h, o.mapping);
                      } else {
                        const h = o.image;
                        if (h && h.height > 0) {
                          const m = new sd(h.height);
                          return m.fromEquirectangularTexture(s, o), e.set(o, m), o.addEventListener("dispose", i), t(m.texture, o.mapping);
                        } else
                          return null;
                      }
                  }
                  return o;
                }
                function i(o) {
                  const a = o.target;
                  a.removeEventListener("dispose", i);
                  const h = e.get(a);
                  h !== void 0 && (e.delete(a), h.dispose());
                }
                function r() {
                  e = /* @__PURE__ */ new WeakMap();
                }
                return { get: n, dispose: r };
              }
              class Pl extends Rl {
                constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
                  super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix();
                }
                copy(e, t) {
                  return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
                }
                setViewOffset(e, t, n, i, r, o) {
                  this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
                }
                clearViewOffset() {
                  this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
                }
                updateProjectionMatrix() {
                  const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
                  let r = n - e, o = n + e, a = i + t, h = i - t;
                  if (this.view !== null && this.view.enabled) {
                    const m = (this.right - this.left) / this.view.fullWidth / this.zoom, _ = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += m * this.view.offsetX, o = r + m * this.view.width, a -= _ * this.view.offsetY, h = a - _ * this.view.height;
                  }
                  this.projectionMatrix.makeOrthographic(r, o, a, h, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
                }
              }
              const ra = 4, od = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], yo = 20, Pu = /* @__PURE__ */ new Pl(), ad = /* @__PURE__ */ new sn();
              let Ou = null, Fu = 0, Uu = 0, Nu = !1;
              const Co = (1 + Math.sqrt(5)) / 2, sa = 1 / Co, ld = [/* @__PURE__ */ new ye(-Co, sa, 0), /* @__PURE__ */ new ye(Co, sa, 0), /* @__PURE__ */ new ye(-sa, 0, Co), /* @__PURE__ */ new ye(sa, 0, Co), /* @__PURE__ */ new ye(0, Co, -sa), /* @__PURE__ */ new ye(0, Co, sa), /* @__PURE__ */ new ye(-1, 1, -1), /* @__PURE__ */ new ye(1, 1, -1), /* @__PURE__ */ new ye(-1, 1, 1), /* @__PURE__ */ new ye(1, 1, 1)];
              class ku {
                constructor(e) {
                  this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
                }
                /**
                * Generates a PMREM from a supplied Scene, which can be faster than using an
                * image if networking bandwidth is low. Optional sigma specifies a blur radius
                * in radians to be applied to the scene before PMREM generation. Optional near
                * and far planes ensure the scene is rendered in its entirety (the cubeCamera
                * is placed at the origin).
                */
                fromScene(e, t = 0, n = 0.1, i = 100) {
                  Ou = this._renderer.getRenderTarget(), Fu = this._renderer.getActiveCubeFace(), Uu = this._renderer.getActiveMipmapLevel(), Nu = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
                  const r = this._allocateTargets();
                  return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
                }
                /**
                * Generates a PMREM from an equirectangular texture, which can be either LDR
                * or HDR. The ideal input image size is 1k (1024 x 512),
                * as this matches best with the 256 x 256 cubemap output.
                * The smallest supported equirectangular image size is 64 x 32.
                */
                fromEquirectangular(e, t = null) {
                  return this._fromTexture(e, t);
                }
                /**
                * Generates a PMREM from an cubemap texture, which can be either LDR
                * or HDR. The ideal input cube size is 256 x 256,
                * as this matches best with the 256 x 256 cubemap output.
                * The smallest supported cube size is 16 x 16.
                */
                fromCubemap(e, t = null) {
                  return this._fromTexture(e, t);
                }
                /**
                * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
                * your texture's network fetch for increased concurrency.
                */
                compileCubemapShader() {
                  this._cubemapMaterial === null && (this._cubemapMaterial = hd(), this._compileMaterial(this._cubemapMaterial));
                }
                /**
                * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
                * your texture's network fetch for increased concurrency.
                */
                compileEquirectangularShader() {
                  this._equirectMaterial === null && (this._equirectMaterial = ud(), this._compileMaterial(this._equirectMaterial));
                }
                /**
                * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
                * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
                * one of them will cause any others to also become unusable.
                */
                dispose() {
                  this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
                }
                // private interface
                _setSize(e) {
                  this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
                }
                _dispose() {
                  this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                  for (let e = 0; e < this._lodPlanes.length; e++)
                    this._lodPlanes[e].dispose();
                }
                _cleanup(e) {
                  this._renderer.setRenderTarget(Ou, Fu, Uu), this._renderer.xr.enabled = Nu, e.scissorTest = !1, Ol(e, 0, 0, e.width, e.height);
                }
                _fromTexture(e, t) {
                  e.mapping === H || e.mapping === M ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Ou = this._renderer.getRenderTarget(), Fu = this._renderer.getActiveCubeFace(), Uu = this._renderer.getActiveMipmapLevel(), Nu = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
                  const n = t || this._allocateTargets();
                  return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
                }
                _allocateTargets() {
                  const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = { magFilter: vn, minFilter: vn, generateMipmaps: !1, type: lt, format: _e, colorSpace: hs, depthBuffer: !1 }, i = cd(e, t, n);
                  if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                    this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = cd(e, t, n);
                    const { _lodMax: r } = this;
                    ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = d0(r)), this._blurMaterial = f0(r, e, t);
                  }
                  return i;
                }
                _compileMaterial(e) {
                  const t = new hr(this._lodPlanes[0], e);
                  this._renderer.compile(t, Pu);
                }
                _sceneToCubeUV(e, t, n, i) {
                  const a = new mr(90, 1, t, n), h = [1, -1, 1, 1, 1, 1], m = [1, 1, 1, -1, -1, -1], _ = this._renderer, I = _.autoClear, B = _.toneMapping;
                  _.getClearColor(ad), _.toneMapping = $t, _.autoClear = !1;
                  const L = new qs({ name: "PMREM.Background", side: x, depthWrite: !1, depthTest: !1 }), N = new hr(new go(), L);
                  let z = !1;
                  const k = e.background;
                  k ? k.isColor && (L.color.copy(k), e.background = null, z = !0) : (L.color.copy(ad), z = !0);
                  for (let P = 0; P < 6; P++) {
                    const se = P % 3;
                    se === 0 ? (a.up.set(0, h[P], 0), a.lookAt(m[P], 0, 0)) : se === 1 ? (a.up.set(0, 0, h[P]), a.lookAt(0, m[P], 0)) : (a.up.set(0, h[P], 0), a.lookAt(0, 0, m[P]));
                    const $ = this._cubeSize;
                    Ol(i, se * $, P > 2 ? $ : 0, $, $), _.setRenderTarget(i), z && _.render(N, a), _.render(e, a);
                  }
                  N.geometry.dispose(), N.material.dispose(), _.toneMapping = B, _.autoClear = I, e.background = k;
                }
                _textureToCubeUV(e, t) {
                  const n = this._renderer, i = e.mapping === H || e.mapping === M;
                  i ? (this._cubemapMaterial === null && (this._cubemapMaterial = hd()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = ud());
                  const r = i ? this._cubemapMaterial : this._equirectMaterial, o = new hr(this._lodPlanes[0], r), a = r.uniforms;
                  a.envMap.value = e;
                  const h = this._cubeSize;
                  Ol(t, 0, 0, 3 * h, 2 * h), n.setRenderTarget(t), n.render(o, Pu);
                }
                _applyPMREM(e) {
                  const t = this._renderer, n = t.autoClear;
                  t.autoClear = !1;
                  const i = this._lodPlanes.length;
                  for (let r = 1; r < i; r++) {
                    const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = ld[(i - r - 1) % ld.length];
                    this._blur(e, r - 1, r, o, a);
                  }
                  t.autoClear = n;
                }
                /**
                * This is a two-pass Gaussian blur for a cubemap. Normally this is done
                * vertically and horizontally, but this breaks down on a cube. Here we apply
                * the blur latitudinally (around the poles), and then longitudinally (towards
                * the poles) to approximate the orthogonally-separable blur. It is least
                * accurate at the poles, but still does a decent job.
                */
                _blur(e, t, n, i, r) {
                  const o = this._pingPongRenderTarget;
                  this._halfBlur(e, o, t, n, i, "latitudinal", r), this._halfBlur(o, e, n, n, i, "longitudinal", r);
                }
                _halfBlur(e, t, n, i, r, o, a) {
                  const h = this._renderer, m = this._blurMaterial;
                  o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                  const _ = 3, I = new hr(this._lodPlanes[i], m), B = m.uniforms, L = this._sizeLods[n] - 1, N = isFinite(r) ? Math.PI / (2 * L) : 2 * Math.PI / (2 * yo - 1), z = r / N, k = isFinite(r) ? 1 + Math.floor(_ * z) : yo;
                  k > yo && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${k} samples when the maximum is set to ${yo}`);
                  const P = [];
                  let se = 0;
                  for (let Me = 0; Me < yo; ++Me) {
                    const Re = Me / z, Ae = Math.exp(-Re * Re / 2);
                    P.push(Ae), Me === 0 ? se += Ae : Me < k && (se += 2 * Ae);
                  }
                  for (let Me = 0; Me < P.length; Me++)
                    P[Me] = P[Me] / se;
                  B.envMap.value = e.texture, B.samples.value = k, B.weights.value = P, B.latitudinal.value = o === "latitudinal", a && (B.poleAxis.value = a);
                  const { _lodMax: $ } = this;
                  B.dTheta.value = N, B.mipInt.value = $ - n;
                  const J = this._sizeLods[i], Le = 3 * J * (i > $ - ra ? i - $ + ra : 0), Ee = 4 * (this._cubeSize - J);
                  Ol(t, Le, Ee, 3 * J, 2 * J), h.setRenderTarget(t), h.render(I, Pu);
                }
              }
              function d0(s) {
                const e = [], t = [], n = [];
                let i = s;
                const r = s - ra + 1 + od.length;
                for (let o = 0; o < r; o++) {
                  const a = Math.pow(2, i);
                  t.push(a);
                  let h = 1 / a;
                  o > s - ra ? h = od[o - s + ra - 1] : o === 0 && (h = 0), n.push(h);
                  const m = 1 / (a - 2), _ = -m, I = 1 + m, B = [_, _, I, _, I, I, _, _, I, I, _, I], L = 6, N = 6, z = 3, k = 2, P = 1, se = new Float32Array(z * N * L), $ = new Float32Array(k * N * L), J = new Float32Array(P * N * L);
                  for (let Ee = 0; Ee < L; Ee++) {
                    const Me = Ee % 3 * 2 / 3 - 1, Re = Ee > 2 ? 0 : -1, Ae = [Me, Re, 0, Me + 2 / 3, Re, 0, Me + 2 / 3, Re + 1, 0, Me, Re, 0, Me + 2 / 3, Re + 1, 0, Me, Re + 1, 0];
                    se.set(Ae, z * N * Ee), $.set(B, k * N * Ee);
                    const ce = [Ee, Ee, Ee, Ee, Ee, Ee];
                    J.set(ce, P * N * Ee);
                  }
                  const Le = new ti();
                  Le.setAttribute("position", new Pi(se, z)), Le.setAttribute("uv", new Pi($, k)), Le.setAttribute("faceIndex", new Pi(J, P)), e.push(Le), i > ra && i--;
                }
                return { lodPlanes: e, sizeLods: t, sigmas: n };
              }
              function cd(s, e, t) {
                const n = new zr(s, e, t);
                return n.texture.mapping = he, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
              }
              function Ol(s, e, t, n, i) {
                s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
              }
              function f0(s, e, t) {
                const n = new Float32Array(yo), i = new ye(0, 1, 0);
                return new fs({ name: "SphericalGaussianBlur", defines: { n: yo, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${s}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i } }, vertexShader: Gu(), fragmentShader: (
                  /* glsl */
                  `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
                ), blending: b, depthTest: !1, depthWrite: !1 });
              }
              function ud() {
                return new fs({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: Gu(), fragmentShader: (
                  /* glsl */
                  `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
                ), blending: b, depthTest: !1, depthWrite: !1 });
              }
              function hd() {
                return new fs({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: Gu(), fragmentShader: (
                  /* glsl */
                  `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
                ), blending: b, depthTest: !1, depthWrite: !1 });
              }
              function Gu() {
                return (
                  /* glsl */
                  `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
                );
              }
              function p0(s) {
                let e = /* @__PURE__ */ new WeakMap(), t = null;
                function n(a) {
                  if (a && a.isTexture) {
                    const h = a.mapping, m = h === R || h === ee, _ = h === H || h === M;
                    if (m || _) {
                      let I = e.get(a);
                      const B = I !== void 0 ? I.texture.pmremVersion : 0;
                      if (a.isRenderTargetTexture && a.pmremVersion !== B)
                        return t === null && (t = new ku(s)), I = m ? t.fromEquirectangular(a, I) : t.fromCubemap(a, I), I.texture.pmremVersion = a.pmremVersion, e.set(a, I), I.texture;
                      if (I !== void 0)
                        return I.texture;
                      {
                        const L = a.image;
                        return m && L && L.height > 0 || _ && L && i(L) ? (t === null && (t = new ku(s)), I = m ? t.fromEquirectangular(a) : t.fromCubemap(a), I.texture.pmremVersion = a.pmremVersion, e.set(a, I), a.addEventListener("dispose", r), I.texture) : null;
                      }
                    }
                  }
                  return a;
                }
                function i(a) {
                  let h = 0;
                  const m = 6;
                  for (let _ = 0; _ < m; _++)
                    a[_] !== void 0 && h++;
                  return h === m;
                }
                function r(a) {
                  const h = a.target;
                  h.removeEventListener("dispose", r);
                  const m = e.get(h);
                  m !== void 0 && (e.delete(h), m.dispose());
                }
                function o() {
                  e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
                }
                return { get: n, dispose: o };
              }
              function A0(s) {
                const e = {};
                function t(n) {
                  if (e[n] !== void 0)
                    return e[n];
                  let i;
                  switch (n) {
                    case "WEBGL_depth_texture":
                      i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
                      break;
                    case "EXT_texture_filter_anisotropic":
                      i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                      break;
                    case "WEBGL_compressed_texture_s3tc":
                      i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                      break;
                    case "WEBGL_compressed_texture_pvrtc":
                      i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                      break;
                    default:
                      i = s.getExtension(n);
                  }
                  return e[n] = i, i;
                }
                return { has: function(n) {
                  return t(n) !== null;
                }, init: function() {
                  t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
                }, get: function(n) {
                  const i = t(n);
                  return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
                } };
              }
              function m0(s, e, t, n) {
                const i = {}, r = /* @__PURE__ */ new WeakMap();
                function o(I) {
                  const B = I.target;
                  B.index !== null && e.remove(B.index);
                  for (const N in B.attributes)
                    e.remove(B.attributes[N]);
                  for (const N in B.morphAttributes) {
                    const z = B.morphAttributes[N];
                    for (let k = 0, P = z.length; k < P; k++)
                      e.remove(z[k]);
                  }
                  B.removeEventListener("dispose", o), delete i[B.id];
                  const L = r.get(B);
                  L && (e.remove(L), r.delete(B)), n.releaseStatesOfGeometry(B), B.isInstancedBufferGeometry === !0 && delete B._maxInstanceCount, t.memory.geometries--;
                }
                function a(I, B) {
                  return i[B.id] === !0 || (B.addEventListener("dispose", o), i[B.id] = !0, t.memory.geometries++), B;
                }
                function h(I) {
                  const B = I.attributes;
                  for (const N in B)
                    e.update(B[N], s.ARRAY_BUFFER);
                  const L = I.morphAttributes;
                  for (const N in L) {
                    const z = L[N];
                    for (let k = 0, P = z.length; k < P; k++)
                      e.update(z[k], s.ARRAY_BUFFER);
                  }
                }
                function m(I) {
                  const B = [], L = I.index, N = I.attributes.position;
                  let z = 0;
                  if (L !== null) {
                    const se = L.array;
                    z = L.version;
                    for (let $ = 0, J = se.length; $ < J; $ += 3) {
                      const Le = se[$ + 0], Ee = se[$ + 1], Me = se[$ + 2];
                      B.push(Le, Ee, Ee, Me, Me, Le);
                    }
                  } else if (N !== void 0) {
                    const se = N.array;
                    z = N.version;
                    for (let $ = 0, J = se.length / 3 - 1; $ < J; $ += 3) {
                      const Le = $ + 0, Ee = $ + 1, Me = $ + 2;
                      B.push(Le, Ee, Ee, Me, Me, Le);
                    }
                  } else
                    return;
                  const k = new (ul(B) ? Iu : Tu)(B, 1);
                  k.version = z;
                  const P = r.get(I);
                  P && e.remove(P), r.set(I, k);
                }
                function _(I) {
                  const B = r.get(I);
                  if (B) {
                    const L = I.index;
                    L !== null && B.version < L.version && m(I);
                  } else
                    m(I);
                  return r.get(I);
                }
                return { get: a, update: h, getWireframeAttribute: _ };
              }
              function g0(s, e, t) {
                let n;
                function i(B) {
                  n = B;
                }
                let r, o;
                function a(B) {
                  r = B.type, o = B.bytesPerElement;
                }
                function h(B, L) {
                  s.drawElements(n, L, r, B * o), t.update(L, n, 1);
                }
                function m(B, L, N) {
                  N !== 0 && (s.drawElementsInstanced(n, L, r, B * o, N), t.update(L, n, N));
                }
                function _(B, L, N) {
                  if (N === 0) return;
                  const z = e.get("WEBGL_multi_draw");
                  if (z === null)
                    for (let k = 0; k < N; k++)
                      this.render(B[k] / o, L[k]);
                  else {
                    z.multiDrawElementsWEBGL(n, L, 0, r, B, 0, N);
                    let k = 0;
                    for (let P = 0; P < N; P++)
                      k += L[P];
                    t.update(k, n, 1);
                  }
                }
                function I(B, L, N, z) {
                  if (N === 0) return;
                  const k = e.get("WEBGL_multi_draw");
                  if (k === null)
                    for (let P = 0; P < B.length; P++)
                      m(B[P] / o, L[P], z[P]);
                  else {
                    k.multiDrawElementsInstancedWEBGL(n, L, 0, r, B, 0, z, 0, N);
                    let P = 0;
                    for (let se = 0; se < N; se++)
                      P += L[se];
                    for (let se = 0; se < z.length; se++)
                      t.update(P, n, z[se]);
                  }
                }
                this.setMode = i, this.setIndex = a, this.render = h, this.renderInstances = m, this.renderMultiDraw = _, this.renderMultiDrawInstances = I;
              }
              function v0(s) {
                const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
                function n(r, o, a) {
                  switch (t.calls++, o) {
                    case s.TRIANGLES:
                      t.triangles += a * (r / 3);
                      break;
                    case s.LINES:
                      t.lines += a * (r / 2);
                      break;
                    case s.LINE_STRIP:
                      t.lines += a * (r - 1);
                      break;
                    case s.LINE_LOOP:
                      t.lines += a * r;
                      break;
                    case s.POINTS:
                      t.points += a * r;
                      break;
                    default:
                      console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                      break;
                  }
                }
                function i() {
                  t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
                }
                return { memory: e, render: t, programs: null, autoReset: !0, reset: i, update: n };
              }
              function E0(s, e, t) {
                const n = /* @__PURE__ */ new WeakMap(), i = new yi();
                function r(o, a, h) {
                  const m = o.morphTargetInfluences, _ = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, I = _ !== void 0 ? _.length : 0;
                  let B = n.get(a);
                  if (B === void 0 || B.count !== I) {
                    let Ae = function() {
                      Me.dispose(), n.delete(a), a.removeEventListener("dispose", Ae);
                    };
                    B !== void 0 && B.texture.dispose();
                    const L = a.morphAttributes.position !== void 0, N = a.morphAttributes.normal !== void 0, z = a.morphAttributes.color !== void 0, k = a.morphAttributes.position || [], P = a.morphAttributes.normal || [], se = a.morphAttributes.color || [];
                    let $ = 0;
                    L === !0 && ($ = 1), N === !0 && ($ = 2), z === !0 && ($ = 3);
                    let J = a.attributes.position.count * $, Le = 1;
                    J > e.maxTextureSize && (Le = Math.ceil(J / e.maxTextureSize), J = e.maxTextureSize);
                    const Ee = new Float32Array(J * Le * 4 * I), Me = new Qo(Ee, J, Le, I);
                    Me.type = tt, Me.needsUpdate = !0;
                    const Re = $ * 4;
                    for (let ce = 0; ce < I; ce++) {
                      const Ie = k[ce], Qe = P[ce], Ue = se[ce], He = J * Le * 4 * ce;
                      for (let Ze = 0; Ze < Ie.count; Ze++) {
                        const dt = Ze * Re;
                        L === !0 && (i.fromBufferAttribute(Ie, Ze), Ee[He + dt + 0] = i.x, Ee[He + dt + 1] = i.y, Ee[He + dt + 2] = i.z, Ee[He + dt + 3] = 0), N === !0 && (i.fromBufferAttribute(Qe, Ze), Ee[He + dt + 4] = i.x, Ee[He + dt + 5] = i.y, Ee[He + dt + 6] = i.z, Ee[He + dt + 7] = 0), z === !0 && (i.fromBufferAttribute(Ue, Ze), Ee[He + dt + 8] = i.x, Ee[He + dt + 9] = i.y, Ee[He + dt + 10] = i.z, Ee[He + dt + 11] = Ue.itemSize === 4 ? i.w : 1);
                      }
                    }
                    B = { count: I, texture: Me, size: new pt(J, Le) }, n.set(a, B), a.addEventListener("dispose", Ae);
                  }
                  if (o.isInstancedMesh === !0 && o.morphTexture !== null)
                    h.getUniforms().setValue(s, "morphTexture", o.morphTexture, t);
                  else {
                    let L = 0;
                    for (let z = 0; z < m.length; z++)
                      L += m[z];
                    const N = a.morphTargetsRelative ? 1 : 1 - L;
                    h.getUniforms().setValue(s, "morphTargetBaseInfluence", N), h.getUniforms().setValue(s, "morphTargetInfluences", m);
                  }
                  h.getUniforms().setValue(s, "morphTargetsTexture", B.texture, t), h.getUniforms().setValue(s, "morphTargetsTextureSize", B.size);
                }
                return { update: r };
              }
              class y0 {
                constructor(e, t, n) {
                  if (this.renderer = e, this.DEFAULT_NUMVIEWS = 2, this.maxNumViews = 0, this.gl = n, this.extensions = t, this.available = this.extensions.has("OCULUS_multiview"), this.available) {
                    const r = this.extensions.get("OCULUS_multiview");
                    this.maxNumViews = this.gl.getParameter(r.MAX_VIEWS_OVR), this.mat4 = [], this.mat3 = [], this.cameraArray = [];
                    for (var i = 0; i < this.maxNumViews; i++)
                      this.mat4[i] = new pn(), this.mat3[i] = new Gn();
                  }
                }
                //
                getCameraArray(e) {
                  return e.isArrayCamera ? e.cameras : (this.cameraArray[0] = e, this.cameraArray);
                }
                updateCameraProjectionMatricesUniform(e, t) {
                  for (var n = this.getCameraArray(e), i = 0; i < n.length; i++)
                    this.mat4[i].copy(n[i].projectionMatrix);
                  t.setValue(this.gl, "projectionMatrices", this.mat4);
                }
                updateCameraViewMatricesUniform(e, t) {
                  for (var n = this.getCameraArray(e), i = 0; i < n.length; i++)
                    this.mat4[i].copy(n[i].matrixWorldInverse);
                  t.setValue(this.gl, "viewMatrices", this.mat4);
                }
                updateObjectMatricesUniforms(e, t, n) {
                  for (var i = this.getCameraArray(t), r = 0; r < i.length; r++)
                    this.mat4[r].multiplyMatrices(i[r].matrixWorldInverse, e.matrixWorld), this.mat3[r].getNormalMatrix(this.mat4[r]);
                  n.setValue(this.gl, "modelViewMatrices", this.mat4), n.setValue(this.gl, "normalMatrices", this.mat3);
                }
              }
              function C0(s, e, t, n) {
                let i = /* @__PURE__ */ new WeakMap();
                function r(h) {
                  const m = n.render.frame, _ = h.geometry, I = e.get(h, _);
                  if (i.get(I) !== m && (e.update(I), i.set(I, m)), h.isInstancedMesh && (h.hasEventListener("dispose", a) === !1 && h.addEventListener("dispose", a), i.get(h) !== m && (t.update(h.instanceMatrix, s.ARRAY_BUFFER), h.instanceColor !== null && t.update(h.instanceColor, s.ARRAY_BUFFER), i.set(h, m))), h.isSkinnedMesh) {
                    const B = h.skeleton;
                    i.get(B) !== m && (B.update(), i.set(B, m));
                  }
                  return I;
                }
                function o() {
                  i = /* @__PURE__ */ new WeakMap();
                }
                function a(h) {
                  const m = h.target;
                  m.removeEventListener("dispose", a), t.remove(m.instanceMatrix), m.instanceColor !== null && t.remove(m.instanceColor);
                }
                return { update: r, dispose: o };
              }
              class Qu extends Vi {
                constructor(e, t, n, i, r, o, a, h, m, _) {
                  if (_ = _ !== void 0 ? _ : Ke, _ !== Ke && _ !== rt)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                  n === void 0 && _ === Ke && (n = Fe), n === void 0 && _ === rt && (n = zt), super(null, i, r, o, a, h, _, n, m), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : Pt, this.minFilter = h !== void 0 ? h : Pt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
                }
                copy(e) {
                  return super.copy(e), this.compareFunction = e.compareFunction, this;
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
                }
              }
              const dd = /* @__PURE__ */ new Vi(), fd = /* @__PURE__ */ new Qu(1, 1);
              fd.compareFunction = va;
              const pd = /* @__PURE__ */ new Qo(), Ad = /* @__PURE__ */ new Qn(), md = /* @__PURE__ */ new Ta(), gd = [], vd = [], Ed = new Float32Array(16), yd = new Float32Array(9), Cd = new Float32Array(4);
              function oa(s, e, t) {
                const n = s[0];
                if (n <= 0 || n > 0) return s;
                const i = e * t;
                let r = gd[i];
                if (r === void 0 && (r = new Float32Array(i), gd[i] = r), e !== 0) {
                  n.toArray(r, 0);
                  for (let o = 1, a = 0; o !== e; ++o)
                    a += t, s[o].toArray(r, a);
                }
                return r;
              }
              function gr(s, e) {
                if (s.length !== e.length) return !1;
                for (let t = 0, n = s.length; t < n; t++)
                  if (s[t] !== e[t]) return !1;
                return !0;
              }
              function vr(s, e) {
                for (let t = 0, n = e.length; t < n; t++)
                  s[t] = e[t];
              }
              function Fl(s, e) {
                let t = vd[e];
                t === void 0 && (t = new Int32Array(e), vd[e] = t);
                for (let n = 0; n !== e; ++n)
                  t[n] = s.allocateTextureUnit();
                return t;
              }
              function x0(s, e) {
                const t = this.cache;
                t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
              }
              function b0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
                else {
                  if (gr(t, e)) return;
                  s.uniform2fv(this.addr, e), vr(t, e);
                }
              }
              function _0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
                else if (e.r !== void 0)
                  (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
                else {
                  if (gr(t, e)) return;
                  s.uniform3fv(this.addr, e), vr(t, e);
                }
              }
              function w0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
                else {
                  if (gr(t, e)) return;
                  s.uniform4fv(this.addr, e), vr(t, e);
                }
              }
              function M0(s, e) {
                const t = this.cache, n = e.elements;
                if (n === void 0) {
                  if (gr(t, e)) return;
                  s.uniformMatrix2fv(this.addr, !1, e), vr(t, e);
                } else {
                  if (gr(t, n)) return;
                  Cd.set(n), s.uniformMatrix2fv(this.addr, !1, Cd), vr(t, n);
                }
              }
              function S0(s, e) {
                const t = this.cache, n = e.elements;
                if (n === void 0) {
                  if (gr(t, e)) return;
                  s.uniformMatrix3fv(this.addr, !1, e), vr(t, e);
                } else {
                  if (gr(t, n)) return;
                  yd.set(n), s.uniformMatrix3fv(this.addr, !1, yd), vr(t, n);
                }
              }
              function T0(s, e) {
                const t = this.cache, n = e.elements;
                if (n === void 0) {
                  if (gr(t, e)) return;
                  s.uniformMatrix4fv(this.addr, !1, e), vr(t, e);
                } else {
                  if (gr(t, n)) return;
                  Ed.set(n), s.uniformMatrix4fv(this.addr, !1, Ed), vr(t, n);
                }
              }
              function I0(s, e) {
                const t = this.cache;
                t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
              }
              function B0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
                else {
                  if (gr(t, e)) return;
                  s.uniform2iv(this.addr, e), vr(t, e);
                }
              }
              function R0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
                else {
                  if (gr(t, e)) return;
                  s.uniform3iv(this.addr, e), vr(t, e);
                }
              }
              function L0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
                else {
                  if (gr(t, e)) return;
                  s.uniform4iv(this.addr, e), vr(t, e);
                }
              }
              function D0(s, e) {
                const t = this.cache;
                t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
              }
              function P0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
                else {
                  if (gr(t, e)) return;
                  s.uniform2uiv(this.addr, e), vr(t, e);
                }
              }
              function O0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
                else {
                  if (gr(t, e)) return;
                  s.uniform3uiv(this.addr, e), vr(t, e);
                }
              }
              function F0(s, e) {
                const t = this.cache;
                if (e.x !== void 0)
                  (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
                else {
                  if (gr(t, e)) return;
                  s.uniform4uiv(this.addr, e), vr(t, e);
                }
              }
              function U0(s, e, t) {
                const n = this.cache, i = t.allocateTextureUnit();
                n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
                const r = this.type === s.SAMPLER_2D_SHADOW ? fd : dd;
                t.setTexture2D(e || r, i);
              }
              function N0(s, e, t) {
                const n = this.cache, i = t.allocateTextureUnit();
                n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || Ad, i);
              }
              function k0(s, e, t) {
                const n = this.cache, i = t.allocateTextureUnit();
                n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || md, i);
              }
              function G0(s, e, t) {
                const n = this.cache, i = t.allocateTextureUnit();
                n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || pd, i);
              }
              function Q0(s) {
                switch (s) {
                  case 5126:
                    return x0;
                  // FLOAT
                  case 35664:
                    return b0;
                  // _VEC2
                  case 35665:
                    return _0;
                  // _VEC3
                  case 35666:
                    return w0;
                  // _VEC4
                  case 35674:
                    return M0;
                  // _MAT2
                  case 35675:
                    return S0;
                  // _MAT3
                  case 35676:
                    return T0;
                  // _MAT4
                  case 5124:
                  case 35670:
                    return I0;
                  // INT, BOOL
                  case 35667:
                  case 35671:
                    return B0;
                  // _VEC2
                  case 35668:
                  case 35672:
                    return R0;
                  // _VEC3
                  case 35669:
                  case 35673:
                    return L0;
                  // _VEC4
                  case 5125:
                    return D0;
                  // UINT
                  case 36294:
                    return P0;
                  // _VEC2
                  case 36295:
                    return O0;
                  // _VEC3
                  case 36296:
                    return F0;
                  // _VEC4
                  case 35678:
                  // SAMPLER_2D
                  case 36198:
                  // SAMPLER_EXTERNAL_OES
                  case 36298:
                  // INT_SAMPLER_2D
                  case 36306:
                  // UNSIGNED_INT_SAMPLER_2D
                  case 35682:
                    return U0;
                  case 35679:
                  // SAMPLER_3D
                  case 36299:
                  // INT_SAMPLER_3D
                  case 36307:
                    return N0;
                  case 35680:
                  // SAMPLER_CUBE
                  case 36300:
                  // INT_SAMPLER_CUBE
                  case 36308:
                  // UNSIGNED_INT_SAMPLER_CUBE
                  case 36293:
                    return k0;
                  case 36289:
                  // SAMPLER_2D_ARRAY
                  case 36303:
                  // INT_SAMPLER_2D_ARRAY
                  case 36311:
                  // UNSIGNED_INT_SAMPLER_2D_ARRAY
                  case 36292:
                    return G0;
                }
              }
              function V0(s, e) {
                s.uniform1fv(this.addr, e);
              }
              function H0(s, e) {
                const t = oa(e, this.size, 2);
                s.uniform2fv(this.addr, t);
              }
              function z0(s, e) {
                const t = oa(e, this.size, 3);
                s.uniform3fv(this.addr, t);
              }
              function j0(s, e) {
                const t = oa(e, this.size, 4);
                s.uniform4fv(this.addr, t);
              }
              function W0(s, e) {
                const t = oa(e, this.size, 4);
                s.uniformMatrix2fv(this.addr, !1, t);
              }
              function K0(s, e) {
                const t = oa(e, this.size, 9);
                s.uniformMatrix3fv(this.addr, !1, t);
              }
              function X0(s, e) {
                const t = oa(e, this.size, 16);
                s.uniformMatrix4fv(this.addr, !1, t);
              }
              function Y0(s, e) {
                s.uniform1iv(this.addr, e);
              }
              function q0(s, e) {
                s.uniform2iv(this.addr, e);
              }
              function J0(s, e) {
                s.uniform3iv(this.addr, e);
              }
              function Z0(s, e) {
                s.uniform4iv(this.addr, e);
              }
              function $0(s, e) {
                s.uniform1uiv(this.addr, e);
              }
              function eg(s, e) {
                s.uniform2uiv(this.addr, e);
              }
              function tg(s, e) {
                s.uniform3uiv(this.addr, e);
              }
              function ng(s, e) {
                s.uniform4uiv(this.addr, e);
              }
              function ig(s, e, t) {
                const n = this.cache, i = e.length, r = Fl(t, i);
                gr(n, r) || (s.uniform1iv(this.addr, r), vr(n, r));
                for (let o = 0; o !== i; ++o)
                  t.setTexture2D(e[o] || dd, r[o]);
              }
              function rg(s, e, t) {
                const n = this.cache, i = e.length, r = Fl(t, i);
                gr(n, r) || (s.uniform1iv(this.addr, r), vr(n, r));
                for (let o = 0; o !== i; ++o)
                  t.setTexture3D(e[o] || Ad, r[o]);
              }
              function sg(s, e, t) {
                const n = this.cache, i = e.length, r = Fl(t, i);
                gr(n, r) || (s.uniform1iv(this.addr, r), vr(n, r));
                for (let o = 0; o !== i; ++o)
                  t.setTextureCube(e[o] || md, r[o]);
              }
              function og(s, e, t) {
                const n = this.cache, i = e.length, r = Fl(t, i);
                gr(n, r) || (s.uniform1iv(this.addr, r), vr(n, r));
                for (let o = 0; o !== i; ++o)
                  t.setTexture2DArray(e[o] || pd, r[o]);
              }
              function ag(s) {
                switch (s) {
                  case 5126:
                    return V0;
                  // FLOAT
                  case 35664:
                    return H0;
                  // _VEC2
                  case 35665:
                    return z0;
                  // _VEC3
                  case 35666:
                    return j0;
                  // _VEC4
                  case 35674:
                    return W0;
                  // _MAT2
                  case 35675:
                    return K0;
                  // _MAT3
                  case 35676:
                    return X0;
                  // _MAT4
                  case 5124:
                  case 35670:
                    return Y0;
                  // INT, BOOL
                  case 35667:
                  case 35671:
                    return q0;
                  // _VEC2
                  case 35668:
                  case 35672:
                    return J0;
                  // _VEC3
                  case 35669:
                  case 35673:
                    return Z0;
                  // _VEC4
                  case 5125:
                    return $0;
                  // UINT
                  case 36294:
                    return eg;
                  // _VEC2
                  case 36295:
                    return tg;
                  // _VEC3
                  case 36296:
                    return ng;
                  // _VEC4
                  case 35678:
                  // SAMPLER_2D
                  case 36198:
                  // SAMPLER_EXTERNAL_OES
                  case 36298:
                  // INT_SAMPLER_2D
                  case 36306:
                  // UNSIGNED_INT_SAMPLER_2D
                  case 35682:
                    return ig;
                  case 35679:
                  // SAMPLER_3D
                  case 36299:
                  // INT_SAMPLER_3D
                  case 36307:
                    return rg;
                  case 35680:
                  // SAMPLER_CUBE
                  case 36300:
                  // INT_SAMPLER_CUBE
                  case 36308:
                  // UNSIGNED_INT_SAMPLER_CUBE
                  case 36293:
                    return sg;
                  case 36289:
                  // SAMPLER_2D_ARRAY
                  case 36303:
                  // INT_SAMPLER_2D_ARRAY
                  case 36311:
                  // UNSIGNED_INT_SAMPLER_2D_ARRAY
                  case 36292:
                    return og;
                }
              }
              class lg {
                constructor(e, t, n) {
                  this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = Q0(t.type);
                }
              }
              class cg {
                constructor(e, t, n) {
                  this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = ag(t.type);
                }
              }
              class ug {
                constructor(e) {
                  this.id = e, this.seq = [], this.map = {};
                }
                setValue(e, t, n) {
                  const i = this.seq;
                  for (let r = 0, o = i.length; r !== o; ++r) {
                    const a = i[r];
                    a.setValue(e, t[a.id], n);
                  }
                }
              }
              const Vu = /(\w+)(\])?(\[|\.)?/g;
              function xd(s, e) {
                s.seq.push(e), s.map[e.id] = e;
              }
              function hg(s, e, t) {
                const n = s.name, i = n.length;
                for (Vu.lastIndex = 0; ; ) {
                  const r = Vu.exec(n), o = Vu.lastIndex;
                  let a = r[1];
                  const h = r[2] === "]", m = r[3];
                  if (h && (a = a | 0), m === void 0 || m === "[" && o + 2 === i) {
                    xd(t, m === void 0 ? new lg(a, s, e) : new cg(a, s, e));
                    break;
                  } else {
                    let I = t.map[a];
                    I === void 0 && (I = new ug(a), xd(t, I)), t = I;
                  }
                }
              }
              class Ul {
                constructor(e, t) {
                  this.seq = [], this.map = {};
                  const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                  for (let i = 0; i < n; ++i) {
                    const r = e.getActiveUniform(t, i), o = e.getUniformLocation(t, r.name);
                    hg(r, o, this);
                  }
                }
                setValue(e, t, n, i) {
                  const r = this.map[t];
                  r !== void 0 && r.setValue(e, n, i);
                }
                setOptional(e, t, n) {
                  const i = t[n];
                  i !== void 0 && this.setValue(e, n, i);
                }
                static upload(e, t, n, i) {
                  for (let r = 0, o = t.length; r !== o; ++r) {
                    const a = t[r], h = n[a.id];
                    h.needsUpdate !== !1 && a.setValue(e, h.value, i);
                  }
                }
                static seqWithValue(e, t) {
                  const n = [];
                  for (let i = 0, r = e.length; i !== r; ++i) {
                    const o = e[i];
                    o.id in t && n.push(o);
                  }
                  return n;
                }
              }
              function bd(s, e, t) {
                const n = s.createShader(e);
                return s.shaderSource(n, t), s.compileShader(n), n;
              }
              const dg = 37297;
              let fg = 0;
              function pg(s, e) {
                const t = s.split(`
`), n = [], i = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
                for (let o = i; o < r; o++) {
                  const a = o + 1;
                  n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
                }
                return n.join(`
`);
              }
              function Ag(s) {
                const e = Mi.getPrimaries(Mi.workingColorSpace), t = Mi.getPrimaries(s);
                let n;
                switch (e === t ? n = "" : e === uo && t === co ? n = "LinearDisplayP3ToLinearSRGB" : e === co && t === uo && (n = "LinearSRGBToLinearDisplayP3"), s) {
                  case hs:
                  case ao:
                    return [n, "LinearTransferOETF"];
                  case mi:
                  case Uo:
                    return [n, "sRGBTransferOETF"];
                  default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [n, "LinearTransferOETF"];
                }
              }
              function _d(s, e, t) {
                const n = s.getShaderParameter(e, s.COMPILE_STATUS), i = s.getShaderInfoLog(e).trim();
                if (n && i === "") return "";
                const r = /ERROR: 0:(\d+)/.exec(i);
                if (r) {
                  const o = parseInt(r[1]);
                  return t.toUpperCase() + `

` + i + `

` + pg(s.getShaderSource(e), o);
                } else
                  return i;
              }
              function mg(s, e) {
                const t = Ag(e);
                return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
              }
              function gg(s, e) {
                let t;
                switch (e) {
                  case ei:
                    t = "Linear";
                    break;
                  case Dn:
                    t = "Reinhard";
                    break;
                  case Yt:
                    t = "OptimizedCineon";
                    break;
                  case Xe:
                    t = "ACESFilmic";
                    break;
                  case ae:
                    t = "AgX";
                    break;
                  case Ce:
                    t = "Neutral";
                    break;
                  case le:
                    t = "Custom";
                    break;
                  default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
                }
                return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
              }
              function vg(s) {
                return [s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Ba).join(`
`);
              }
              function Eg(s) {
                const e = [];
                for (const t in s) {
                  const n = s[t];
                  n !== !1 && e.push("#define " + t + " " + n);
                }
                return e.join(`
`);
              }
              function yg(s, e) {
                const t = {}, n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < n; i++) {
                  const r = s.getActiveAttrib(e, i), o = r.name;
                  let a = 1;
                  r.type === s.FLOAT_MAT2 && (a = 2), r.type === s.FLOAT_MAT3 && (a = 3), r.type === s.FLOAT_MAT4 && (a = 4), t[o] = { type: r.type, location: s.getAttribLocation(e, o), locationSize: a };
                }
                return t;
              }
              function Ba(s) {
                return s !== "";
              }
              function wd(s, e) {
                const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
                return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
              }
              function Md(s, e) {
                return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
              }
              const Cg = /^[ \t]*#include +<([\w\d./]+)>/gm;
              function Hu(s) {
                return s.replace(Cg, bg);
              }
              const xg = /* @__PURE__ */ new Map();
              function bg(s, e) {
                let t = Jn[e];
                if (t === void 0) {
                  const n = xg.get(e);
                  if (n !== void 0)
                    t = Jn[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
                  else
                    throw new Error("Can not resolve #include <" + e + ">");
                }
                return Hu(t);
              }
              const _g = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
              function Sd(s) {
                return s.replace(_g, wg);
              }
              function wg(s, e, t, n) {
                let i = "";
                for (let r = parseInt(e); r < parseInt(t); r++)
                  i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
                return i;
              }
              function Td(s) {
                let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
                return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
              }
              function Mg(s) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return s.shadowMapType === g ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === A ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === u && (e = "SHADOWMAP_TYPE_VSM"), e;
              }
              function Sg(s) {
                let e = "ENVMAP_TYPE_CUBE";
                if (s.envMap)
                  switch (s.envMapMode) {
                    case H:
                    case M:
                      e = "ENVMAP_TYPE_CUBE";
                      break;
                    case he:
                      e = "ENVMAP_TYPE_CUBE_UV";
                      break;
                  }
                return e;
              }
              function Tg(s) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (s.envMap)
                  switch (s.envMapMode) {
                    case M:
                      e = "ENVMAP_MODE_REFRACTION";
                      break;
                  }
                return e;
              }
              function Ig(s) {
                let e = "ENVMAP_BLENDING_NONE";
                if (s.envMap)
                  switch (s.combine) {
                    case Be:
                      e = "ENVMAP_BLENDING_MULTIPLY";
                      break;
                    case Et:
                      e = "ENVMAP_BLENDING_MIX";
                      break;
                    case Dt:
                      e = "ENVMAP_BLENDING_ADD";
                      break;
                  }
                return e;
              }
              function Bg(s) {
                const e = s.envMapCubeUVHeight;
                if (e === null) return null;
                const t = Math.log2(e) - 2, n = 1 / e;
                return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
              }
              function Rg(s, e, t, n) {
                const i = s.getContext(), r = t.defines;
                let o = t.vertexShader, a = t.fragmentShader;
                const h = Mg(t), m = Sg(t), _ = Tg(t), I = Ig(t), B = Bg(t), L = vg(t), N = Eg(r), z = i.createProgram();
                let k, P, se = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
                const $ = t.numMultiviewViews;
                t.isRawShaderMaterial ? (k = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, N].filter(Ba).join(`
`), k.length > 0 && (k += `
`), P = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, N].filter(Ba).join(`
`), P.length > 0 && (P += `
`)) : (k = [
                  Td(t),
                  "#define SHADER_TYPE " + t.shaderType,
                  "#define SHADER_NAME " + t.shaderName,
                  N,
                  t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
                  t.batching ? "#define USE_BATCHING" : "",
                  t.instancing ? "#define USE_INSTANCING" : "",
                  t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                  t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
                  t.useFog && t.fog ? "#define USE_FOG" : "",
                  t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
                  t.map ? "#define USE_MAP" : "",
                  t.envMap ? "#define USE_ENVMAP" : "",
                  t.envMap ? "#define " + _ : "",
                  t.lightMap ? "#define USE_LIGHTMAP" : "",
                  t.aoMap ? "#define USE_AOMAP" : "",
                  t.bumpMap ? "#define USE_BUMPMAP" : "",
                  t.normalMap ? "#define USE_NORMALMAP" : "",
                  t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
                  t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
                  t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
                  t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                  t.anisotropy ? "#define USE_ANISOTROPY" : "",
                  t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                  t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                  t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                  t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                  t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                  t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
                  t.specularMap ? "#define USE_SPECULARMAP" : "",
                  t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                  t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
                  t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                  t.metalnessMap ? "#define USE_METALNESSMAP" : "",
                  t.alphaMap ? "#define USE_ALPHAMAP" : "",
                  t.alphaHash ? "#define USE_ALPHAHASH" : "",
                  t.transmission ? "#define USE_TRANSMISSION" : "",
                  t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                  t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                  t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                  t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                  //
                  t.mapUv ? "#define MAP_UV " + t.mapUv : "",
                  t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
                  t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
                  t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
                  t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
                  t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
                  t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
                  t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
                  t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
                  t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
                  t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
                  t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
                  t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
                  t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
                  t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
                  t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
                  t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
                  t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
                  t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
                  t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
                  t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
                  t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
                  t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
                  //
                  t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
                  t.vertexColors ? "#define USE_COLOR" : "",
                  t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                  t.vertexUv1s ? "#define USE_UV1" : "",
                  t.vertexUv2s ? "#define USE_UV2" : "",
                  t.vertexUv3s ? "#define USE_UV3" : "",
                  t.pointsUvs ? "#define USE_POINTS_UV" : "",
                  t.flatShading ? "#define FLAT_SHADED" : "",
                  t.skinning ? "#define USE_SKINNING" : "",
                  t.morphTargets ? "#define USE_MORPHTARGETS" : "",
                  t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
                  t.morphColors ? "#define USE_MORPHCOLORS" : "",
                  t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
                  t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
                  t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
                  t.doubleSided ? "#define DOUBLE_SIDED" : "",
                  t.flipSided ? "#define FLIP_SIDED" : "",
                  t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                  t.shadowMapEnabled ? "#define " + h : "",
                  t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                  t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
                  t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                  t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                  "uniform mat4 modelMatrix;",
                  "uniform mat4 modelViewMatrix;",
                  "uniform mat4 projectionMatrix;",
                  "uniform mat4 viewMatrix;",
                  "uniform mat3 normalMatrix;",
                  "uniform vec3 cameraPosition;",
                  "uniform bool isOrthographic;",
                  "#ifdef USE_INSTANCING",
                  "	attribute mat4 instanceMatrix;",
                  "#endif",
                  "#ifdef USE_INSTANCING_COLOR",
                  "	attribute vec3 instanceColor;",
                  "#endif",
                  "#ifdef USE_INSTANCING_MORPH",
                  "	uniform sampler2D morphTexture;",
                  "#endif",
                  "attribute vec3 position;",
                  "attribute vec3 normal;",
                  "attribute vec2 uv;",
                  "#ifdef USE_UV1",
                  "	attribute vec2 uv1;",
                  "#endif",
                  "#ifdef USE_UV2",
                  "	attribute vec2 uv2;",
                  "#endif",
                  "#ifdef USE_UV3",
                  "	attribute vec2 uv3;",
                  "#endif",
                  "#ifdef USE_TANGENT",
                  "	attribute vec4 tangent;",
                  "#endif",
                  "#if defined( USE_COLOR_ALPHA )",
                  "	attribute vec4 color;",
                  "#elif defined( USE_COLOR )",
                  "	attribute vec3 color;",
                  "#endif",
                  "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                  "	attribute vec3 morphTarget0;",
                  "	attribute vec3 morphTarget1;",
                  "	attribute vec3 morphTarget2;",
                  "	attribute vec3 morphTarget3;",
                  "	#ifdef USE_MORPHNORMALS",
                  "		attribute vec3 morphNormal0;",
                  "		attribute vec3 morphNormal1;",
                  "		attribute vec3 morphNormal2;",
                  "		attribute vec3 morphNormal3;",
                  "	#else",
                  "		attribute vec3 morphTarget4;",
                  "		attribute vec3 morphTarget5;",
                  "		attribute vec3 morphTarget6;",
                  "		attribute vec3 morphTarget7;",
                  "	#endif",
                  "#endif",
                  "#ifdef USE_SKINNING",
                  "	attribute vec4 skinIndex;",
                  "	attribute vec4 skinWeight;",
                  "#endif",
                  `
`
                ].filter(Ba).join(`
`), P = [
                  Td(t),
                  "#define SHADER_TYPE " + t.shaderType,
                  "#define SHADER_NAME " + t.shaderName,
                  N,
                  t.useFog && t.fog ? "#define USE_FOG" : "",
                  t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
                  t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
                  t.map ? "#define USE_MAP" : "",
                  t.matcap ? "#define USE_MATCAP" : "",
                  t.envMap ? "#define USE_ENVMAP" : "",
                  t.envMap ? "#define " + m : "",
                  t.envMap ? "#define " + _ : "",
                  t.envMap ? "#define " + I : "",
                  B ? "#define CUBEUV_TEXEL_WIDTH " + B.texelWidth : "",
                  B ? "#define CUBEUV_TEXEL_HEIGHT " + B.texelHeight : "",
                  B ? "#define CUBEUV_MAX_MIP " + B.maxMip + ".0" : "",
                  t.lightMap ? "#define USE_LIGHTMAP" : "",
                  t.aoMap ? "#define USE_AOMAP" : "",
                  t.bumpMap ? "#define USE_BUMPMAP" : "",
                  t.normalMap ? "#define USE_NORMALMAP" : "",
                  t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
                  t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
                  t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                  t.anisotropy ? "#define USE_ANISOTROPY" : "",
                  t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
                  t.clearcoat ? "#define USE_CLEARCOAT" : "",
                  t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                  t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                  t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                  t.dispersion ? "#define USE_DISPERSION" : "",
                  t.iridescence ? "#define USE_IRIDESCENCE" : "",
                  t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
                  t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
                  t.specularMap ? "#define USE_SPECULARMAP" : "",
                  t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
                  t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
                  t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                  t.metalnessMap ? "#define USE_METALNESSMAP" : "",
                  t.alphaMap ? "#define USE_ALPHAMAP" : "",
                  t.alphaTest ? "#define USE_ALPHATEST" : "",
                  t.alphaHash ? "#define USE_ALPHAHASH" : "",
                  t.sheen ? "#define USE_SHEEN" : "",
                  t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
                  t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
                  t.transmission ? "#define USE_TRANSMISSION" : "",
                  t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                  t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                  t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
                  t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
                  t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                  t.vertexUv1s ? "#define USE_UV1" : "",
                  t.vertexUv2s ? "#define USE_UV2" : "",
                  t.vertexUv3s ? "#define USE_UV3" : "",
                  t.pointsUvs ? "#define USE_POINTS_UV" : "",
                  t.gradientMap ? "#define USE_GRADIENTMAP" : "",
                  t.flatShading ? "#define FLAT_SHADED" : "",
                  t.doubleSided ? "#define DOUBLE_SIDED" : "",
                  t.flipSided ? "#define FLIP_SIDED" : "",
                  t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                  t.shadowMapEnabled ? "#define " + h : "",
                  t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                  t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
                  t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
                  t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
                  t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                  "uniform mat4 viewMatrix;",
                  "uniform vec3 cameraPosition;",
                  "uniform bool isOrthographic;",
                  t.toneMapping !== $t ? "#define TONE_MAPPING" : "",
                  t.toneMapping !== $t ? Jn.tonemapping_pars_fragment : "",
                  // this code is required here because it is used by the toneMapping() function defined below
                  t.toneMapping !== $t ? gg("toneMapping", t.toneMapping) : "",
                  t.dithering ? "#define DITHERING" : "",
                  t.opaque ? "#define OPAQUE" : "",
                  Jn.colorspace_pars_fragment,
                  // this code is required here because it is used by the various encoding/decoding function defined below
                  mg("linearToOutputTexel", t.outputColorSpace),
                  t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
                  `
`
                ].filter(Ba).join(`
`)), o = Hu(o), o = wd(o, t), o = Md(o, t), a = Hu(a), a = wd(a, t), a = Md(a, t), o = Sd(o), a = Sd(a), t.isRawShaderMaterial !== !0 && (se = `#version 300 es
`, k = [L, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + k, P = ["#define varying in", t.glslVersion === Ea ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Ea ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + P, $ > 0 && (k = ["#extension GL_OVR_multiview : require", "layout(num_views = " + $ + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join(`
`) + `
` + k, k = k.replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join(`
`), ["uniform mat4 modelViewMatrices[" + $ + "];", "uniform mat4 projectionMatrices[" + $ + "];", "uniform mat4 viewMatrices[" + $ + "];", "uniform mat3 normalMatrices[" + $ + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join(`
`)), P = ["#extension GL_OVR_multiview : require", "#define VIEW_ID gl_ViewID_OVR"].join(`
`) + `
` + P, P = P.replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + $ + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join(`
`))));
                const J = se + k + o, Le = se + P + a, Ee = bd(i, i.VERTEX_SHADER, J), Me = bd(i, i.FRAGMENT_SHADER, Le);
                i.attachShader(z, Ee), i.attachShader(z, Me), t.index0AttributeName !== void 0 ? i.bindAttribLocation(z, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(z, 0, "position"), i.linkProgram(z);
                function Re(Qe) {
                  if (s.debug.checkShaderErrors) {
                    const Ue = i.getProgramInfoLog(z).trim(), He = i.getShaderInfoLog(Ee).trim(), Ze = i.getShaderInfoLog(Me).trim();
                    let dt = !0, Nt = !0;
                    if (i.getProgramParameter(z, i.LINK_STATUS) === !1)
                      if (dt = !1, typeof s.debug.onShaderError == "function")
                        s.debug.onShaderError(i, z, Ee, Me);
                      else {
                        const et = _d(i, Ee, "vertex"), Lt = _d(i, Me, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(z, i.VALIDATE_STATUS) + `

Material Name: ` + Qe.name + `
Material Type: ` + Qe.type + `

Program Info Log: ` + Ue + `
` + et + `
` + Lt);
                      }
                    else Ue !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Ue) : (He === "" || Ze === "") && (Nt = !1);
                    Nt && (Qe.diagnostics = { runnable: dt, programLog: Ue, vertexShader: { log: He, prefix: k }, fragmentShader: { log: Ze, prefix: P } });
                  }
                  i.deleteShader(Ee), i.deleteShader(Me), Ae = new Ul(i, z), ce = yg(i, z);
                }
                let Ae;
                this.getUniforms = function() {
                  return Ae === void 0 && Re(this), Ae;
                };
                let ce;
                this.getAttributes = function() {
                  return ce === void 0 && Re(this), ce;
                };
                let Ie = t.rendererExtensionParallelShaderCompile === !1;
                return this.isReady = function() {
                  return Ie === !1 && (Ie = i.getProgramParameter(z, dg)), Ie;
                }, this.destroy = function() {
                  n.releaseStatesOfProgram(this), i.deleteProgram(z), this.program = void 0;
                }, this.type = t.shaderType, this.name = t.shaderName, this.id = fg++, this.cacheKey = e, this.usedTimes = 1, this.program = z, this.vertexShader = Ee, this.fragmentShader = Me, this.numMultiviewViews = $, this;
              }
              let Lg = 0;
              class Dg {
                constructor() {
                  this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
                }
                update(e) {
                  const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
                  return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this;
                }
                remove(e) {
                  const t = this.materialCache.get(e);
                  for (const n of t)
                    n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
                  return this.materialCache.delete(e), this;
                }
                getVertexShaderID(e) {
                  return this._getShaderStage(e.vertexShader).id;
                }
                getFragmentShaderID(e) {
                  return this._getShaderStage(e.fragmentShader).id;
                }
                dispose() {
                  this.shaderCache.clear(), this.materialCache.clear();
                }
                _getShaderCacheForMaterial(e) {
                  const t = this.materialCache;
                  let n = t.get(e);
                  return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
                }
                _getShaderStage(e) {
                  const t = this.shaderCache;
                  let n = t.get(e);
                  return n === void 0 && (n = new Pg(e), t.set(e, n)), n;
                }
              }
              class Pg {
                constructor(e) {
                  this.id = Lg++, this.code = e, this.usedTimes = 0;
                }
              }
              function Og(s, e, t, n, i, r, o) {
                const a = new El(), h = new Dg(), m = /* @__PURE__ */ new Set(), _ = [], I = i.logarithmicDepthBuffer, B = i.vertexTextures;
                let L = i.precision;
                const N = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
                function z(Ae) {
                  return m.add(Ae), Ae === 0 ? "uv" : `uv${Ae}`;
                }
                function k(Ae, ce, Ie, Qe, Ue) {
                  const He = Qe.fog, Ze = Ue.geometry, dt = Ae.isMeshStandardMaterial ? Qe.environment : null, Nt = (Ae.isMeshStandardMaterial ? t : e).get(Ae.envMap || dt), et = Nt && Nt.mapping === he ? Nt.image.height : null, Lt = N[Ae.type];
                  Ae.precision !== null && (L = i.getMaxPrecision(Ae.precision), L !== Ae.precision && console.warn("THREE.WebGLProgram.getParameters:", Ae.precision, "not supported, using", L, "instead."));
                  const Ot = Ze.morphAttributes.position || Ze.morphAttributes.normal || Ze.morphAttributes.color, fn = Ot !== void 0 ? Ot.length : 0;
                  let ni = 0;
                  Ze.morphAttributes.position !== void 0 && (ni = 1), Ze.morphAttributes.normal !== void 0 && (ni = 2), Ze.morphAttributes.color !== void 0 && (ni = 3);
                  let Si, Hi, _i, Ui;
                  if (Lt) {
                    const Er = ps[Lt];
                    Si = Er.vertexShader, Hi = Er.fragmentShader;
                  } else
                    Si = Ae.vertexShader, Hi = Ae.fragmentShader, h.update(Ae), _i = h.getVertexShaderID(Ae), Ui = h.getFragmentShaderID(Ae);
                  const An = s.getRenderTarget(), mt = An && An.isWebGLMultiviewRenderTarget ? An.numViews : 0, Gt = Ue.isInstancedMesh === !0, Ht = Ue.isBatchedMesh === !0, ze = !!Ae.map, gt = !!Ae.matcap, ot = !!Nt, Bt = !!Ae.aoMap, Tt = !!Ae.lightMap, wt = !!Ae.bumpMap, Kt = !!Ae.normalMap, nn = !!Ae.displacementMap, kn = !!Ae.emissiveMap, zn = !!Ae.metalnessMap, wi = !!Ae.roughnessMap, er = Ae.anisotropy > 0, zi = Ae.clearcoat > 0, Se = Ae.dispersion > 0, ue = Ae.iridescence > 0, it = Ae.sheen > 0, At = Ae.transmission > 0, yt = er && !!Ae.anisotropyMap, vt = zi && !!Ae.clearcoatMap, En = zi && !!Ae.clearcoatNormalMap, kt = zi && !!Ae.clearcoatRoughnessMap, on = ue && !!Ae.iridescenceMap, Li = ue && !!Ae.iridescenceThicknessMap, an = it && !!Ae.sheenColorMap, xn = it && !!Ae.sheenRoughnessMap, Zn = !!Ae.specularMap, Pn = !!Ae.specularColorMap, Pe = !!Ae.specularIntensityMap, Mt = At && !!Ae.transmissionMap, Ft = At && !!Ae.thicknessMap, yn = !!Ae.gradientMap, en = !!Ae.alphaMap, $n = Ae.alphaTest > 0, tn = !!Ae.alphaHash, Xt = !!Ae.extensions;
                  let si = $t;
                  Ae.toneMapped && (An === null || An.isXRRenderTarget === !0) && (si = s.toneMapping);
                  const Fn = {
                    shaderID: Lt,
                    shaderType: Ae.type,
                    shaderName: Ae.name,
                    vertexShader: Si,
                    fragmentShader: Hi,
                    defines: Ae.defines,
                    customVertexShaderID: _i,
                    customFragmentShaderID: Ui,
                    isRawShaderMaterial: Ae.isRawShaderMaterial === !0,
                    glslVersion: Ae.glslVersion,
                    precision: L,
                    batching: Ht,
                    instancing: Gt,
                    instancingColor: Gt && Ue.instanceColor !== null,
                    instancingMorph: Gt && Ue.morphTexture !== null,
                    supportsVertexTextures: B,
                    numMultiviewViews: mt,
                    outputColorSpace: An === null ? s.outputColorSpace : An.isXRRenderTarget === !0 ? An.texture.colorSpace : hs,
                    alphaToCoverage: !!Ae.alphaToCoverage,
                    map: ze,
                    matcap: gt,
                    envMap: ot,
                    envMapMode: ot && Nt.mapping,
                    envMapCubeUVHeight: et,
                    aoMap: Bt,
                    lightMap: Tt,
                    bumpMap: wt,
                    normalMap: Kt,
                    displacementMap: B && nn,
                    emissiveMap: kn,
                    normalMapObjectSpace: Kt && Ae.normalMapType === ys,
                    normalMapTangentSpace: Kt && Ae.normalMapType === Rr,
                    metalnessMap: zn,
                    roughnessMap: wi,
                    anisotropy: er,
                    anisotropyMap: yt,
                    clearcoat: zi,
                    clearcoatMap: vt,
                    clearcoatNormalMap: En,
                    clearcoatRoughnessMap: kt,
                    dispersion: Se,
                    iridescence: ue,
                    iridescenceMap: on,
                    iridescenceThicknessMap: Li,
                    sheen: it,
                    sheenColorMap: an,
                    sheenRoughnessMap: xn,
                    specularMap: Zn,
                    specularColorMap: Pn,
                    specularIntensityMap: Pe,
                    transmission: At,
                    transmissionMap: Mt,
                    thicknessMap: Ft,
                    gradientMap: yn,
                    opaque: Ae.transparent === !1 && Ae.blending === D && Ae.alphaToCoverage === !1,
                    alphaMap: en,
                    alphaTest: $n,
                    alphaHash: tn,
                    combine: Ae.combine,
                    //
                    mapUv: ze && z(Ae.map.channel),
                    aoMapUv: Bt && z(Ae.aoMap.channel),
                    lightMapUv: Tt && z(Ae.lightMap.channel),
                    bumpMapUv: wt && z(Ae.bumpMap.channel),
                    normalMapUv: Kt && z(Ae.normalMap.channel),
                    displacementMapUv: nn && z(Ae.displacementMap.channel),
                    emissiveMapUv: kn && z(Ae.emissiveMap.channel),
                    metalnessMapUv: zn && z(Ae.metalnessMap.channel),
                    roughnessMapUv: wi && z(Ae.roughnessMap.channel),
                    anisotropyMapUv: yt && z(Ae.anisotropyMap.channel),
                    clearcoatMapUv: vt && z(Ae.clearcoatMap.channel),
                    clearcoatNormalMapUv: En && z(Ae.clearcoatNormalMap.channel),
                    clearcoatRoughnessMapUv: kt && z(Ae.clearcoatRoughnessMap.channel),
                    iridescenceMapUv: on && z(Ae.iridescenceMap.channel),
                    iridescenceThicknessMapUv: Li && z(Ae.iridescenceThicknessMap.channel),
                    sheenColorMapUv: an && z(Ae.sheenColorMap.channel),
                    sheenRoughnessMapUv: xn && z(Ae.sheenRoughnessMap.channel),
                    specularMapUv: Zn && z(Ae.specularMap.channel),
                    specularColorMapUv: Pn && z(Ae.specularColorMap.channel),
                    specularIntensityMapUv: Pe && z(Ae.specularIntensityMap.channel),
                    transmissionMapUv: Mt && z(Ae.transmissionMap.channel),
                    thicknessMapUv: Ft && z(Ae.thicknessMap.channel),
                    alphaMapUv: en && z(Ae.alphaMap.channel),
                    //
                    vertexTangents: !!Ze.attributes.tangent && (Kt || er),
                    vertexColors: Ae.vertexColors,
                    vertexAlphas: Ae.vertexColors === !0 && !!Ze.attributes.color && Ze.attributes.color.itemSize === 4,
                    pointsUvs: Ue.isPoints === !0 && !!Ze.attributes.uv && (ze || en),
                    fog: !!He,
                    useFog: Ae.fog === !0,
                    fogExp2: !!He && He.isFogExp2,
                    flatShading: Ae.flatShading === !0,
                    sizeAttenuation: Ae.sizeAttenuation === !0,
                    logarithmicDepthBuffer: I,
                    skinning: Ue.isSkinnedMesh === !0,
                    morphTargets: Ze.morphAttributes.position !== void 0,
                    morphNormals: Ze.morphAttributes.normal !== void 0,
                    morphColors: Ze.morphAttributes.color !== void 0,
                    morphTargetsCount: fn,
                    morphTextureStride: ni,
                    numDirLights: ce.directional.length,
                    numPointLights: ce.point.length,
                    numSpotLights: ce.spot.length,
                    numSpotLightMaps: ce.spotLightMap.length,
                    numRectAreaLights: ce.rectArea.length,
                    numHemiLights: ce.hemi.length,
                    numDirLightShadows: ce.directionalShadowMap.length,
                    numPointLightShadows: ce.pointShadowMap.length,
                    numSpotLightShadows: ce.spotShadowMap.length,
                    numSpotLightShadowsWithMaps: ce.numSpotLightShadowsWithMaps,
                    numLightProbes: ce.numLightProbes,
                    numClippingPlanes: o.numPlanes,
                    numClipIntersection: o.numIntersection,
                    dithering: Ae.dithering,
                    shadowMapEnabled: s.shadowMap.enabled && Ie.length > 0,
                    shadowMapType: s.shadowMap.type,
                    toneMapping: si,
                    useLegacyLights: s._useLegacyLights,
                    decodeVideoTexture: ze && Ae.map.isVideoTexture === !0 && Mi.getTransfer(Ae.map.colorSpace) === Fi,
                    premultipliedAlpha: Ae.premultipliedAlpha,
                    doubleSided: Ae.side === T,
                    flipSided: Ae.side === x,
                    useDepthPacking: Ae.depthPacking >= 0,
                    depthPacking: Ae.depthPacking || 0,
                    index0AttributeName: Ae.index0AttributeName,
                    extensionClipCullDistance: Xt && Ae.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
                    extensionMultiDraw: Xt && Ae.extensions.multiDraw === !0 && n.has("WEBGL_multi_draw"),
                    rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                    customProgramCacheKey: Ae.customProgramCacheKey()
                  };
                  return Fn.vertexUv1s = m.has(1), Fn.vertexUv2s = m.has(2), Fn.vertexUv3s = m.has(3), m.clear(), Fn;
                }
                function P(Ae) {
                  const ce = [];
                  if (Ae.shaderID ? ce.push(Ae.shaderID) : (ce.push(Ae.customVertexShaderID), ce.push(Ae.customFragmentShaderID)), Ae.defines !== void 0)
                    for (const Ie in Ae.defines)
                      ce.push(Ie), ce.push(Ae.defines[Ie]);
                  return Ae.isRawShaderMaterial === !1 && (se(ce, Ae), $(ce, Ae), ce.push(s.outputColorSpace)), ce.push(Ae.customProgramCacheKey), ce.join();
                }
                function se(Ae, ce) {
                  Ae.push(ce.precision), Ae.push(ce.outputColorSpace), Ae.push(ce.envMapMode), Ae.push(ce.envMapCubeUVHeight), Ae.push(ce.mapUv), Ae.push(ce.alphaMapUv), Ae.push(ce.lightMapUv), Ae.push(ce.aoMapUv), Ae.push(ce.bumpMapUv), Ae.push(ce.normalMapUv), Ae.push(ce.displacementMapUv), Ae.push(ce.emissiveMapUv), Ae.push(ce.metalnessMapUv), Ae.push(ce.roughnessMapUv), Ae.push(ce.anisotropyMapUv), Ae.push(ce.clearcoatMapUv), Ae.push(ce.clearcoatNormalMapUv), Ae.push(ce.clearcoatRoughnessMapUv), Ae.push(ce.iridescenceMapUv), Ae.push(ce.iridescenceThicknessMapUv), Ae.push(ce.sheenColorMapUv), Ae.push(ce.sheenRoughnessMapUv), Ae.push(ce.specularMapUv), Ae.push(ce.specularColorMapUv), Ae.push(ce.specularIntensityMapUv), Ae.push(ce.transmissionMapUv), Ae.push(ce.thicknessMapUv), Ae.push(ce.combine), Ae.push(ce.fogExp2), Ae.push(ce.sizeAttenuation), Ae.push(ce.morphTargetsCount), Ae.push(ce.morphAttributeCount), Ae.push(ce.numDirLights), Ae.push(ce.numPointLights), Ae.push(ce.numSpotLights), Ae.push(ce.numSpotLightMaps), Ae.push(ce.numHemiLights), Ae.push(ce.numRectAreaLights), Ae.push(ce.numDirLightShadows), Ae.push(ce.numPointLightShadows), Ae.push(ce.numSpotLightShadows), Ae.push(ce.numSpotLightShadowsWithMaps), Ae.push(ce.numLightProbes), Ae.push(ce.shadowMapType), Ae.push(ce.toneMapping), Ae.push(ce.numClippingPlanes), Ae.push(ce.numClipIntersection), Ae.push(ce.depthPacking);
                }
                function $(Ae, ce) {
                  a.disableAll(), ce.supportsVertexTextures && a.enable(0), ce.instancing && a.enable(1), ce.instancingColor && a.enable(2), ce.instancingMorph && a.enable(3), ce.matcap && a.enable(4), ce.envMap && a.enable(5), ce.normalMapObjectSpace && a.enable(6), ce.normalMapTangentSpace && a.enable(7), ce.clearcoat && a.enable(8), ce.iridescence && a.enable(9), ce.alphaTest && a.enable(10), ce.vertexColors && a.enable(11), ce.vertexAlphas && a.enable(12), ce.vertexUv1s && a.enable(13), ce.vertexUv2s && a.enable(14), ce.vertexUv3s && a.enable(15), ce.vertexTangents && a.enable(16), ce.anisotropy && a.enable(17), ce.alphaHash && a.enable(18), ce.batching && a.enable(19), ce.dispersion && a.enable(20), Ae.push(a.mask), a.disableAll(), ce.fog && a.enable(0), ce.useFog && a.enable(1), ce.flatShading && a.enable(2), ce.logarithmicDepthBuffer && a.enable(3), ce.skinning && a.enable(4), ce.morphTargets && a.enable(5), ce.morphNormals && a.enable(6), ce.morphColors && a.enable(7), ce.premultipliedAlpha && a.enable(8), ce.shadowMapEnabled && a.enable(9), ce.useLegacyLights && a.enable(10), ce.doubleSided && a.enable(11), ce.flipSided && a.enable(12), ce.useDepthPacking && a.enable(13), ce.dithering && a.enable(14), ce.transmission && a.enable(15), ce.sheen && a.enable(16), ce.opaque && a.enable(17), ce.pointsUvs && a.enable(18), ce.decodeVideoTexture && a.enable(19), ce.alphaToCoverage && a.enable(20), ce.numMultiviewViews && a.enable(21), Ae.push(a.mask);
                }
                function J(Ae) {
                  const ce = N[Ae.type];
                  let Ie;
                  if (ce) {
                    const Qe = ps[ce];
                    Ie = td.clone(Qe.uniforms);
                  } else
                    Ie = Ae.uniforms;
                  return Ie;
                }
                function Le(Ae, ce) {
                  let Ie;
                  for (let Qe = 0, Ue = _.length; Qe < Ue; Qe++) {
                    const He = _[Qe];
                    if (He.cacheKey === ce) {
                      Ie = He, ++Ie.usedTimes;
                      break;
                    }
                  }
                  return Ie === void 0 && (Ie = new Rg(s, ce, Ae, r), _.push(Ie)), Ie;
                }
                function Ee(Ae) {
                  if (--Ae.usedTimes === 0) {
                    const ce = _.indexOf(Ae);
                    _[ce] = _[_.length - 1], _.pop(), Ae.destroy();
                  }
                }
                function Me(Ae) {
                  h.remove(Ae);
                }
                function Re() {
                  h.dispose();
                }
                return {
                  getParameters: k,
                  getProgramCacheKey: P,
                  getUniforms: J,
                  acquireProgram: Le,
                  releaseProgram: Ee,
                  releaseShaderCache: Me,
                  // Exposed for resource monitoring & error feedback via renderer.info:
                  programs: _,
                  dispose: Re
                };
              }
              function Fg() {
                let s = /* @__PURE__ */ new WeakMap();
                function e(r) {
                  let o = s.get(r);
                  return o === void 0 && (o = {}, s.set(r, o)), o;
                }
                function t(r) {
                  s.delete(r);
                }
                function n(r, o, a) {
                  s.get(r)[o] = a;
                }
                function i() {
                  s = /* @__PURE__ */ new WeakMap();
                }
                return { get: e, remove: t, update: n, dispose: i };
              }
              function Ug(s, e) {
                return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
              }
              function Id(s, e) {
                return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
              }
              function Bd() {
                const s = [];
                let e = 0;
                const t = [], n = [], i = [];
                function r() {
                  e = 0, t.length = 0, n.length = 0, i.length = 0;
                }
                function o(I, B, L, N, z, k) {
                  let P = s[e];
                  return P === void 0 ? (P = { id: I.id, object: I, geometry: B, material: L, groupOrder: N, renderOrder: I.renderOrder, z, group: k }, s[e] = P) : (P.id = I.id, P.object = I, P.geometry = B, P.material = L, P.groupOrder = N, P.renderOrder = I.renderOrder, P.z = z, P.group = k), e++, P;
                }
                function a(I, B, L, N, z, k) {
                  const P = o(I, B, L, N, z, k);
                  L.transmission > 0 ? n.push(P) : L.transparent === !0 ? i.push(P) : t.push(P);
                }
                function h(I, B, L, N, z, k) {
                  const P = o(I, B, L, N, z, k);
                  L.transmission > 0 ? n.unshift(P) : L.transparent === !0 ? i.unshift(P) : t.unshift(P);
                }
                function m(I, B) {
                  t.length > 1 && t.sort(I || Ug), n.length > 1 && n.sort(B || Id), i.length > 1 && i.sort(B || Id);
                }
                function _() {
                  for (let I = e, B = s.length; I < B; I++) {
                    const L = s[I];
                    if (L.id === null) break;
                    L.id = null, L.object = null, L.geometry = null, L.material = null, L.group = null;
                  }
                }
                return { opaque: t, transmissive: n, transparent: i, init: r, push: a, unshift: h, finish: _, sort: m };
              }
              function Ng() {
                let s = /* @__PURE__ */ new WeakMap();
                function e(n, i) {
                  const r = s.get(n);
                  let o;
                  return r === void 0 ? (o = new Bd(), s.set(n, [o])) : i >= r.length ? (o = new Bd(), r.push(o)) : o = r[i], o;
                }
                function t() {
                  s = /* @__PURE__ */ new WeakMap();
                }
                return { get: e, dispose: t };
              }
              function kg() {
                const s = {};
                return { get: function(e) {
                  if (s[e.id] !== void 0)
                    return s[e.id];
                  let t;
                  switch (e.type) {
                    case "DirectionalLight":
                      t = { direction: new ye(), color: new sn() };
                      break;
                    case "SpotLight":
                      t = { position: new ye(), direction: new ye(), color: new sn(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                      break;
                    case "PointLight":
                      t = { position: new ye(), color: new sn(), distance: 0, decay: 0 };
                      break;
                    case "HemisphereLight":
                      t = { direction: new ye(), skyColor: new sn(), groundColor: new sn() };
                      break;
                    case "RectAreaLight":
                      t = { color: new sn(), position: new ye(), halfWidth: new ye(), halfHeight: new ye() };
                      break;
                  }
                  return s[e.id] = t, t;
                } };
              }
              function Gg() {
                const s = {};
                return { get: function(e) {
                  if (s[e.id] !== void 0)
                    return s[e.id];
                  let t;
                  switch (e.type) {
                    case "DirectionalLight":
                      t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pt() };
                      break;
                    case "SpotLight":
                      t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pt() };
                      break;
                    case "PointLight":
                      t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pt(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
                      break;
                  }
                  return s[e.id] = t, t;
                } };
              }
              let Qg = 0;
              function Vg(s, e) {
                return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
              }
              function Hg(s) {
                const e = new kg(), t = Gg(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
                for (let m = 0; m < 9; m++) n.probe.push(new ye());
                const i = new ye(), r = new pn(), o = new pn();
                function a(m, _) {
                  let I = 0, B = 0, L = 0;
                  for (let Ie = 0; Ie < 9; Ie++) n.probe[Ie].set(0, 0, 0);
                  let N = 0, z = 0, k = 0, P = 0, se = 0, $ = 0, J = 0, Le = 0, Ee = 0, Me = 0, Re = 0;
                  m.sort(Vg);
                  const Ae = _ === !0 ? Math.PI : 1;
                  for (let Ie = 0, Qe = m.length; Ie < Qe; Ie++) {
                    const Ue = m[Ie], He = Ue.color, Ze = Ue.intensity, dt = Ue.distance, Nt = Ue.shadow && Ue.shadow.map ? Ue.shadow.map.texture : null;
                    if (Ue.isAmbientLight)
                      I += He.r * Ze * Ae, B += He.g * Ze * Ae, L += He.b * Ze * Ae;
                    else if (Ue.isLightProbe) {
                      for (let et = 0; et < 9; et++)
                        n.probe[et].addScaledVector(Ue.sh.coefficients[et], Ze);
                      Re++;
                    } else if (Ue.isDirectionalLight) {
                      const et = e.get(Ue);
                      if (et.color.copy(Ue.color).multiplyScalar(Ue.intensity * Ae), Ue.castShadow) {
                        const Lt = Ue.shadow, Ot = t.get(Ue);
                        Ot.shadowBias = Lt.bias, Ot.shadowNormalBias = Lt.normalBias, Ot.shadowRadius = Lt.radius, Ot.shadowMapSize = Lt.mapSize, n.directionalShadow[N] = Ot, n.directionalShadowMap[N] = Nt, n.directionalShadowMatrix[N] = Ue.shadow.matrix, $++;
                      }
                      n.directional[N] = et, N++;
                    } else if (Ue.isSpotLight) {
                      const et = e.get(Ue);
                      et.position.setFromMatrixPosition(Ue.matrixWorld), et.color.copy(He).multiplyScalar(Ze * Ae), et.distance = dt, et.coneCos = Math.cos(Ue.angle), et.penumbraCos = Math.cos(Ue.angle * (1 - Ue.penumbra)), et.decay = Ue.decay, n.spot[k] = et;
                      const Lt = Ue.shadow;
                      if (Ue.map && (n.spotLightMap[Ee] = Ue.map, Ee++, Lt.updateMatrices(Ue), Ue.castShadow && Me++), n.spotLightMatrix[k] = Lt.matrix, Ue.castShadow) {
                        const Ot = t.get(Ue);
                        Ot.shadowBias = Lt.bias, Ot.shadowNormalBias = Lt.normalBias, Ot.shadowRadius = Lt.radius, Ot.shadowMapSize = Lt.mapSize, n.spotShadow[k] = Ot, n.spotShadowMap[k] = Nt, Le++;
                      }
                      k++;
                    } else if (Ue.isRectAreaLight) {
                      const et = e.get(Ue);
                      et.color.copy(He).multiplyScalar(Ze), et.halfWidth.set(Ue.width * 0.5, 0, 0), et.halfHeight.set(0, Ue.height * 0.5, 0), n.rectArea[P] = et, P++;
                    } else if (Ue.isPointLight) {
                      const et = e.get(Ue);
                      if (et.color.copy(Ue.color).multiplyScalar(Ue.intensity * Ae), et.distance = Ue.distance, et.decay = Ue.decay, Ue.castShadow) {
                        const Lt = Ue.shadow, Ot = t.get(Ue);
                        Ot.shadowBias = Lt.bias, Ot.shadowNormalBias = Lt.normalBias, Ot.shadowRadius = Lt.radius, Ot.shadowMapSize = Lt.mapSize, Ot.shadowCameraNear = Lt.camera.near, Ot.shadowCameraFar = Lt.camera.far, n.pointShadow[z] = Ot, n.pointShadowMap[z] = Nt, n.pointShadowMatrix[z] = Ue.shadow.matrix, J++;
                      }
                      n.point[z] = et, z++;
                    } else if (Ue.isHemisphereLight) {
                      const et = e.get(Ue);
                      et.skyColor.copy(Ue.color).multiplyScalar(Ze * Ae), et.groundColor.copy(Ue.groundColor).multiplyScalar(Ze * Ae), n.hemi[se] = et, se++;
                    }
                  }
                  P > 0 && (s.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Vt.LTC_FLOAT_1, n.rectAreaLTC2 = Vt.LTC_FLOAT_2) : (n.rectAreaLTC1 = Vt.LTC_HALF_1, n.rectAreaLTC2 = Vt.LTC_HALF_2)), n.ambient[0] = I, n.ambient[1] = B, n.ambient[2] = L;
                  const ce = n.hash;
                  (ce.directionalLength !== N || ce.pointLength !== z || ce.spotLength !== k || ce.rectAreaLength !== P || ce.hemiLength !== se || ce.numDirectionalShadows !== $ || ce.numPointShadows !== J || ce.numSpotShadows !== Le || ce.numSpotMaps !== Ee || ce.numLightProbes !== Re) && (n.directional.length = N, n.spot.length = k, n.rectArea.length = P, n.point.length = z, n.hemi.length = se, n.directionalShadow.length = $, n.directionalShadowMap.length = $, n.pointShadow.length = J, n.pointShadowMap.length = J, n.spotShadow.length = Le, n.spotShadowMap.length = Le, n.directionalShadowMatrix.length = $, n.pointShadowMatrix.length = J, n.spotLightMatrix.length = Le + Ee - Me, n.spotLightMap.length = Ee, n.numSpotLightShadowsWithMaps = Me, n.numLightProbes = Re, ce.directionalLength = N, ce.pointLength = z, ce.spotLength = k, ce.rectAreaLength = P, ce.hemiLength = se, ce.numDirectionalShadows = $, ce.numPointShadows = J, ce.numSpotShadows = Le, ce.numSpotMaps = Ee, ce.numLightProbes = Re, n.version = Qg++);
                }
                function h(m, _) {
                  let I = 0, B = 0, L = 0, N = 0, z = 0;
                  const k = _.matrixWorldInverse;
                  for (let P = 0, se = m.length; P < se; P++) {
                    const $ = m[P];
                    if ($.isDirectionalLight) {
                      const J = n.directional[I];
                      J.direction.setFromMatrixPosition($.matrixWorld), i.setFromMatrixPosition($.target.matrixWorld), J.direction.sub(i), J.direction.transformDirection(k), I++;
                    } else if ($.isSpotLight) {
                      const J = n.spot[L];
                      J.position.setFromMatrixPosition($.matrixWorld), J.position.applyMatrix4(k), J.direction.setFromMatrixPosition($.matrixWorld), i.setFromMatrixPosition($.target.matrixWorld), J.direction.sub(i), J.direction.transformDirection(k), L++;
                    } else if ($.isRectAreaLight) {
                      const J = n.rectArea[N];
                      J.position.setFromMatrixPosition($.matrixWorld), J.position.applyMatrix4(k), o.identity(), r.copy($.matrixWorld), r.premultiply(k), o.extractRotation(r), J.halfWidth.set($.width * 0.5, 0, 0), J.halfHeight.set(0, $.height * 0.5, 0), J.halfWidth.applyMatrix4(o), J.halfHeight.applyMatrix4(o), N++;
                    } else if ($.isPointLight) {
                      const J = n.point[B];
                      J.position.setFromMatrixPosition($.matrixWorld), J.position.applyMatrix4(k), B++;
                    } else if ($.isHemisphereLight) {
                      const J = n.hemi[z];
                      J.direction.setFromMatrixPosition($.matrixWorld), J.direction.transformDirection(k), z++;
                    }
                  }
                }
                return { setup: a, setupView: h, state: n };
              }
              function Rd(s) {
                const e = new Hg(s), t = [], n = [];
                function i(_) {
                  m.camera = _, t.length = 0, n.length = 0;
                }
                function r(_) {
                  t.push(_);
                }
                function o(_) {
                  n.push(_);
                }
                function a(_) {
                  e.setup(t, _);
                }
                function h(_) {
                  e.setupView(t, _);
                }
                const m = { lightsArray: t, shadowsArray: n, camera: null, lights: e, transmissionRenderTarget: {} };
                return { init: i, state: m, setupLights: a, setupLightsView: h, pushLight: r, pushShadow: o };
              }
              function zg(s) {
                let e = /* @__PURE__ */ new WeakMap();
                function t(i, r = 0) {
                  const o = e.get(i);
                  let a;
                  return o === void 0 ? (a = new Rd(s), e.set(i, [a])) : r >= o.length ? (a = new Rd(s), o.push(a)) : a = o[r], a;
                }
                function n() {
                  e = /* @__PURE__ */ new WeakMap();
                }
                return { get: t, dispose: n };
              }
              class zu extends Pr {
                constructor(e) {
                  super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = vs, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
                }
              }
              class ju extends Pr {
                constructor(e) {
                  super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
                }
              }
              const jg = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Wg = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
              function Kg(s, e, t) {
                let n = new Ia();
                const i = new pt(), r = new pt(), o = new yi(), a = new zu({ depthPacking: Es }), h = new ju(), m = {}, _ = t.maxTextureSize, I = { [f]: x, [x]: f, [T]: T }, B = new fs({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new pt() }, radius: { value: 4 } }, vertexShader: jg, fragmentShader: Wg }), L = B.clone();
                L.defines.HORIZONTAL_PASS = 1;
                const N = new ti();
                N.setAttribute("position", new Pi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
                const z = new hr(N, B), k = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = g;
                let P = this.type;
                this.render = function(Ee, Me, Re) {
                  if (k.enabled === !1 || k.autoUpdate === !1 && k.needsUpdate === !1 || Ee.length === 0) return;
                  const Ae = s.getRenderTarget(), ce = s.getActiveCubeFace(), Ie = s.getActiveMipmapLevel(), Qe = s.state;
                  Qe.setBlending(b), Qe.buffers.color.setClear(1, 1, 1, 1), Qe.buffers.depth.setTest(!0), Qe.setScissorTest(!1);
                  const Ue = P !== u && this.type === u, He = P === u && this.type !== u;
                  for (let Ze = 0, dt = Ee.length; Ze < dt; Ze++) {
                    const Nt = Ee[Ze], et = Nt.shadow;
                    if (et === void 0) {
                      console.warn("THREE.WebGLShadowMap:", Nt, "has no shadow.");
                      continue;
                    }
                    if (et.autoUpdate === !1 && et.needsUpdate === !1) continue;
                    i.copy(et.mapSize);
                    const Lt = et.getFrameExtents();
                    if (i.multiply(Lt), r.copy(et.mapSize), (i.x > _ || i.y > _) && (i.x > _ && (r.x = Math.floor(_ / Lt.x), i.x = r.x * Lt.x, et.mapSize.x = r.x), i.y > _ && (r.y = Math.floor(_ / Lt.y), i.y = r.y * Lt.y, et.mapSize.y = r.y)), et.map === null || Ue === !0 || He === !0) {
                      const fn = this.type !== u ? { minFilter: Pt, magFilter: Pt } : {};
                      et.map !== null && et.map.dispose(), et.map = new zr(i.x, i.y, fn), et.map.texture.name = Nt.name + ".shadowMap", et.camera.updateProjectionMatrix();
                    }
                    s.setRenderTarget(et.map), s.clear();
                    const Ot = et.getViewportCount();
                    for (let fn = 0; fn < Ot; fn++) {
                      const ni = et.getViewport(fn);
                      o.set(r.x * ni.x, r.y * ni.y, r.x * ni.z, r.y * ni.w), Qe.viewport(o), et.updateMatrices(Nt, fn), n = et.getFrustum(), J(Me, Re, et.camera, Nt, this.type);
                    }
                    et.isPointLightShadow !== !0 && this.type === u && se(et, Re), et.needsUpdate = !1;
                  }
                  P = this.type, k.needsUpdate = !1, s.setRenderTarget(Ae, ce, Ie);
                };
                function se(Ee, Me) {
                  const Re = e.update(z);
                  B.defines.VSM_SAMPLES !== Ee.blurSamples && (B.defines.VSM_SAMPLES = Ee.blurSamples, L.defines.VSM_SAMPLES = Ee.blurSamples, B.needsUpdate = !0, L.needsUpdate = !0), Ee.mapPass === null && (Ee.mapPass = new zr(i.x, i.y)), B.uniforms.shadow_pass.value = Ee.map.texture, B.uniforms.resolution.value = Ee.mapSize, B.uniforms.radius.value = Ee.radius, s.setRenderTarget(Ee.mapPass), s.clear(), s.renderBufferDirect(Me, null, Re, B, z, null), L.uniforms.shadow_pass.value = Ee.mapPass.texture, L.uniforms.resolution.value = Ee.mapSize, L.uniforms.radius.value = Ee.radius, s.setRenderTarget(Ee.map), s.clear(), s.renderBufferDirect(Me, null, Re, L, z, null);
                }
                function $(Ee, Me, Re, Ae) {
                  let ce = null;
                  const Ie = Re.isPointLight === !0 ? Ee.customDistanceMaterial : Ee.customDepthMaterial;
                  if (Ie !== void 0)
                    ce = Ie;
                  else if (ce = Re.isPointLight === !0 ? h : a, s.localClippingEnabled && Me.clipShadows === !0 && Array.isArray(Me.clippingPlanes) && Me.clippingPlanes.length !== 0 || Me.displacementMap && Me.displacementScale !== 0 || Me.alphaMap && Me.alphaTest > 0 || Me.map && Me.alphaTest > 0) {
                    const Qe = ce.uuid, Ue = Me.uuid;
                    let He = m[Qe];
                    He === void 0 && (He = {}, m[Qe] = He);
                    let Ze = He[Ue];
                    Ze === void 0 && (Ze = ce.clone(), He[Ue] = Ze, Me.addEventListener("dispose", Le)), ce = Ze;
                  }
                  if (ce.visible = Me.visible, ce.wireframe = Me.wireframe, Ae === u ? ce.side = Me.shadowSide !== null ? Me.shadowSide : Me.side : ce.side = Me.shadowSide !== null ? Me.shadowSide : I[Me.side], ce.alphaMap = Me.alphaMap, ce.alphaTest = Me.alphaTest, ce.map = Me.map, ce.clipShadows = Me.clipShadows, ce.clippingPlanes = Me.clippingPlanes, ce.clipIntersection = Me.clipIntersection, ce.displacementMap = Me.displacementMap, ce.displacementScale = Me.displacementScale, ce.displacementBias = Me.displacementBias, ce.wireframeLinewidth = Me.wireframeLinewidth, ce.linewidth = Me.linewidth, Re.isPointLight === !0 && ce.isMeshDistanceMaterial === !0) {
                    const Qe = s.properties.get(ce);
                    Qe.light = Re;
                  }
                  return ce;
                }
                function J(Ee, Me, Re, Ae, ce) {
                  if (Ee.visible === !1) return;
                  if (Ee.layers.test(Me.layers) && (Ee.isMesh || Ee.isLine || Ee.isPoints) && (Ee.castShadow || Ee.receiveShadow && ce === u) && (!Ee.frustumCulled || n.intersectsObject(Ee))) {
                    Ee.modelViewMatrix.multiplyMatrices(Re.matrixWorldInverse, Ee.matrixWorld);
                    const Ue = e.update(Ee), He = Ee.material;
                    if (Array.isArray(He)) {
                      const Ze = Ue.groups;
                      for (let dt = 0, Nt = Ze.length; dt < Nt; dt++) {
                        const et = Ze[dt], Lt = He[et.materialIndex];
                        if (Lt && Lt.visible) {
                          const Ot = $(Ee, Lt, Ae, ce);
                          Ee.onBeforeShadow(s, Ee, Me, Re, Ue, Ot, et), s.renderBufferDirect(Re, null, Ue, Ot, Ee, et), Ee.onAfterShadow(s, Ee, Me, Re, Ue, Ot, et);
                        }
                      }
                    } else if (He.visible) {
                      const Ze = $(Ee, He, Ae, ce);
                      Ee.onBeforeShadow(s, Ee, Me, Re, Ue, Ze, null), s.renderBufferDirect(Re, null, Ue, Ze, Ee, null), Ee.onAfterShadow(s, Ee, Me, Re, Ue, Ze, null);
                    }
                  }
                  const Qe = Ee.children;
                  for (let Ue = 0, He = Qe.length; Ue < He; Ue++)
                    J(Qe[Ue], Me, Re, Ae, ce);
                }
                function Le(Ee) {
                  Ee.target.removeEventListener("dispose", Le);
                  for (const Re in m) {
                    const Ae = m[Re], ce = Ee.target.uuid;
                    ce in Ae && (Ae[ce].dispose(), delete Ae[ce]);
                  }
                }
              }
              function Xg(s) {
                function e() {
                  let Pe = !1;
                  const Mt = new yi();
                  let Ft = null;
                  const yn = new yi(0, 0, 0, 0);
                  return { setMask: function(en) {
                    Ft !== en && !Pe && (s.colorMask(en, en, en, en), Ft = en);
                  }, setLocked: function(en) {
                    Pe = en;
                  }, setClear: function(en, $n, tn, Xt, si) {
                    si === !0 && (en *= Xt, $n *= Xt, tn *= Xt), Mt.set(en, $n, tn, Xt), yn.equals(Mt) === !1 && (s.clearColor(en, $n, tn, Xt), yn.copy(Mt));
                  }, reset: function() {
                    Pe = !1, Ft = null, yn.set(-1, 0, 0, 0);
                  } };
                }
                function t() {
                  let Pe = !1, Mt = null, Ft = null, yn = null;
                  return { setTest: function(en) {
                    en ? Ui(s.DEPTH_TEST) : An(s.DEPTH_TEST);
                  }, setMask: function(en) {
                    Mt !== en && !Pe && (s.depthMask(en), Mt = en);
                  }, setFunc: function(en) {
                    if (Ft !== en) {
                      switch (en) {
                        case Cn:
                          s.depthFunc(s.NEVER);
                          break;
                        case Tn:
                          s.depthFunc(s.ALWAYS);
                          break;
                        case wn:
                          s.depthFunc(s.LESS);
                          break;
                        case rn:
                          s.depthFunc(s.LEQUAL);
                          break;
                        case Bn:
                          s.depthFunc(s.EQUAL);
                          break;
                        case di:
                          s.depthFunc(s.GEQUAL);
                          break;
                        case ri:
                          s.depthFunc(s.GREATER);
                          break;
                        case Ni:
                          s.depthFunc(s.NOTEQUAL);
                          break;
                        default:
                          s.depthFunc(s.LEQUAL);
                      }
                      Ft = en;
                    }
                  }, setLocked: function(en) {
                    Pe = en;
                  }, setClear: function(en) {
                    yn !== en && (s.clearDepth(en), yn = en);
                  }, reset: function() {
                    Pe = !1, Mt = null, Ft = null, yn = null;
                  } };
                }
                function n() {
                  let Pe = !1, Mt = null, Ft = null, yn = null, en = null, $n = null, tn = null, Xt = null, si = null;
                  return { setTest: function(Fn) {
                    Pe || (Fn ? Ui(s.STENCIL_TEST) : An(s.STENCIL_TEST));
                  }, setMask: function(Fn) {
                    Mt !== Fn && !Pe && (s.stencilMask(Fn), Mt = Fn);
                  }, setFunc: function(Fn, Er, ws) {
                    (Ft !== Fn || yn !== Er || en !== ws) && (s.stencilFunc(Fn, Er, ws), Ft = Fn, yn = Er, en = ws);
                  }, setOp: function(Fn, Er, ws) {
                    ($n !== Fn || tn !== Er || Xt !== ws) && (s.stencilOp(Fn, Er, ws), $n = Fn, tn = Er, Xt = ws);
                  }, setLocked: function(Fn) {
                    Pe = Fn;
                  }, setClear: function(Fn) {
                    si !== Fn && (s.clearStencil(Fn), si = Fn);
                  }, reset: function() {
                    Pe = !1, Mt = null, Ft = null, yn = null, en = null, $n = null, tn = null, Xt = null, si = null;
                  } };
                }
                const i = new e(), r = new t(), o = new n(), a = /* @__PURE__ */ new WeakMap(), h = /* @__PURE__ */ new WeakMap();
                let m = {}, _ = {}, I = /* @__PURE__ */ new WeakMap(), B = [], L = null, N = !1, z = null, k = null, P = null, se = null, $ = null, J = null, Le = null, Ee = new sn(0, 0, 0), Me = 0, Re = !1, Ae = null, ce = null, Ie = null, Qe = null, Ue = null;
                const He = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                let Ze = !1, dt = 0;
                const Nt = s.getParameter(s.VERSION);
                Nt.indexOf("WebGL") !== -1 ? (dt = parseFloat(/^WebGL (\d)/.exec(Nt)[1]), Ze = dt >= 1) : Nt.indexOf("OpenGL ES") !== -1 && (dt = parseFloat(/^OpenGL ES (\d)/.exec(Nt)[1]), Ze = dt >= 2);
                let et = null, Lt = {};
                const Ot = s.getParameter(s.SCISSOR_BOX), fn = s.getParameter(s.VIEWPORT), ni = new yi().fromArray(Ot), Si = new yi().fromArray(fn);
                function Hi(Pe, Mt, Ft, yn) {
                  const en = new Uint8Array(4), $n = s.createTexture();
                  s.bindTexture(Pe, $n), s.texParameteri(Pe, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(Pe, s.TEXTURE_MAG_FILTER, s.NEAREST);
                  for (let tn = 0; tn < Ft; tn++)
                    Pe === s.TEXTURE_3D || Pe === s.TEXTURE_2D_ARRAY ? s.texImage3D(Mt, 0, s.RGBA, 1, 1, yn, 0, s.RGBA, s.UNSIGNED_BYTE, en) : s.texImage2D(Mt + tn, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, en);
                  return $n;
                }
                const _i = {};
                _i[s.TEXTURE_2D] = Hi(s.TEXTURE_2D, s.TEXTURE_2D, 1), _i[s.TEXTURE_CUBE_MAP] = Hi(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), _i[s.TEXTURE_2D_ARRAY] = Hi(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), _i[s.TEXTURE_3D] = Hi(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), r.setClear(1), o.setClear(0), Ui(s.DEPTH_TEST), r.setFunc(rn), Tt(!1), wt(l), Ui(s.CULL_FACE), ot(b);
                function Ui(Pe) {
                  m[Pe] !== !0 && (s.enable(Pe), m[Pe] = !0);
                }
                function An(Pe) {
                  m[Pe] !== !1 && (s.disable(Pe), m[Pe] = !1);
                }
                function mt(Pe, Mt) {
                  return _[Pe] !== Mt ? (s.bindFramebuffer(Pe, Mt), _[Pe] = Mt, Pe === s.DRAW_FRAMEBUFFER && (_[s.FRAMEBUFFER] = Mt), Pe === s.FRAMEBUFFER && (_[s.DRAW_FRAMEBUFFER] = Mt), !0) : !1;
                }
                function Gt(Pe, Mt) {
                  let Ft = B, yn = !1;
                  if (Pe) {
                    Ft = I.get(Mt), Ft === void 0 && (Ft = [], I.set(Mt, Ft));
                    const en = Pe.textures;
                    if (Ft.length !== en.length || Ft[0] !== s.COLOR_ATTACHMENT0) {
                      for (let $n = 0, tn = en.length; $n < tn; $n++)
                        Ft[$n] = s.COLOR_ATTACHMENT0 + $n;
                      Ft.length = en.length, yn = !0;
                    }
                  } else
                    Ft[0] !== s.BACK && (Ft[0] = s.BACK, yn = !0);
                  yn && s.drawBuffers(Ft);
                }
                function Ht(Pe) {
                  return L !== Pe ? (s.useProgram(Pe), L = Pe, !0) : !1;
                }
                const ze = { [W]: s.FUNC_ADD, [ie]: s.FUNC_SUBTRACT, [te]: s.FUNC_REVERSE_SUBTRACT };
                ze[X] = s.MIN, ze[Q] = s.MAX;
                const gt = { [O]: s.ZERO, [K]: s.ONE, [ne]: s.SRC_COLOR, [be]: s.SRC_ALPHA, [It]: s.SRC_ALPHA_SATURATE, [st]: s.DST_COLOR, [ke]: s.DST_ALPHA, [pe]: s.ONE_MINUS_SRC_COLOR, [Te]: s.ONE_MINUS_SRC_ALPHA, [ut]: s.ONE_MINUS_DST_COLOR, [Ve]: s.ONE_MINUS_DST_ALPHA, [ht]: s.CONSTANT_COLOR, [Rt]: s.ONE_MINUS_CONSTANT_COLOR, [Qt]: s.CONSTANT_ALPHA, [cn]: s.ONE_MINUS_CONSTANT_ALPHA };
                function ot(Pe, Mt, Ft, yn, en, $n, tn, Xt, si, Fn) {
                  if (Pe === b) {
                    N === !0 && (An(s.BLEND), N = !1);
                    return;
                  }
                  if (N === !1 && (Ui(s.BLEND), N = !0), Pe !== Z) {
                    if (Pe !== z || Fn !== Re) {
                      if ((k !== W || $ !== W) && (s.blendEquation(s.FUNC_ADD), k = W, $ = W), Fn)
                        switch (Pe) {
                          case D:
                            s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                            break;
                          case S:
                            s.blendFunc(s.ONE, s.ONE);
                            break;
                          case U:
                            s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                            break;
                          case G:
                            s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
                            break;
                          default:
                            console.error("THREE.WebGLState: Invalid blending: ", Pe);
                            break;
                        }
                      else
                        switch (Pe) {
                          case D:
                            s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                            break;
                          case S:
                            s.blendFunc(s.SRC_ALPHA, s.ONE);
                            break;
                          case U:
                            s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                            break;
                          case G:
                            s.blendFunc(s.ZERO, s.SRC_COLOR);
                            break;
                          default:
                            console.error("THREE.WebGLState: Invalid blending: ", Pe);
                            break;
                        }
                      P = null, se = null, J = null, Le = null, Ee.set(0, 0, 0), Me = 0, z = Pe, Re = Fn;
                    }
                    return;
                  }
                  en = en || Mt, $n = $n || Ft, tn = tn || yn, (Mt !== k || en !== $) && (s.blendEquationSeparate(ze[Mt], ze[en]), k = Mt, $ = en), (Ft !== P || yn !== se || $n !== J || tn !== Le) && (s.blendFuncSeparate(gt[Ft], gt[yn], gt[$n], gt[tn]), P = Ft, se = yn, J = $n, Le = tn), (Xt.equals(Ee) === !1 || si !== Me) && (s.blendColor(Xt.r, Xt.g, Xt.b, si), Ee.copy(Xt), Me = si), z = Pe, Re = !1;
                }
                function Bt(Pe, Mt) {
                  Pe.side === T ? An(s.CULL_FACE) : Ui(s.CULL_FACE);
                  let Ft = Pe.side === x;
                  Mt && (Ft = !Ft), Tt(Ft), Pe.blending === D && Pe.transparent === !1 ? ot(b) : ot(Pe.blending, Pe.blendEquation, Pe.blendSrc, Pe.blendDst, Pe.blendEquationAlpha, Pe.blendSrcAlpha, Pe.blendDstAlpha, Pe.blendColor, Pe.blendAlpha, Pe.premultipliedAlpha), r.setFunc(Pe.depthFunc), r.setTest(Pe.depthTest), r.setMask(Pe.depthWrite), i.setMask(Pe.colorWrite);
                  const yn = Pe.stencilWrite;
                  o.setTest(yn), yn && (o.setMask(Pe.stencilWriteMask), o.setFunc(Pe.stencilFunc, Pe.stencilRef, Pe.stencilFuncMask), o.setOp(Pe.stencilFail, Pe.stencilZFail, Pe.stencilZPass)), nn(Pe.polygonOffset, Pe.polygonOffsetFactor, Pe.polygonOffsetUnits), Pe.alphaToCoverage === !0 ? Ui(s.SAMPLE_ALPHA_TO_COVERAGE) : An(s.SAMPLE_ALPHA_TO_COVERAGE);
                }
                function Tt(Pe) {
                  Ae !== Pe && (Pe ? s.frontFace(s.CW) : s.frontFace(s.CCW), Ae = Pe);
                }
                function wt(Pe) {
                  Pe !== y ? (Ui(s.CULL_FACE), Pe !== ce && (Pe === l ? s.cullFace(s.BACK) : Pe === d ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : An(s.CULL_FACE), ce = Pe;
                }
                function Kt(Pe) {
                  Pe !== Ie && (Ze && s.lineWidth(Pe), Ie = Pe);
                }
                function nn(Pe, Mt, Ft) {
                  Pe ? (Ui(s.POLYGON_OFFSET_FILL), (Qe !== Mt || Ue !== Ft) && (s.polygonOffset(Mt, Ft), Qe = Mt, Ue = Ft)) : An(s.POLYGON_OFFSET_FILL);
                }
                function kn(Pe) {
                  Pe ? Ui(s.SCISSOR_TEST) : An(s.SCISSOR_TEST);
                }
                function zn(Pe) {
                  Pe === void 0 && (Pe = s.TEXTURE0 + He - 1), et !== Pe && (s.activeTexture(Pe), et = Pe);
                }
                function wi(Pe, Mt, Ft) {
                  Ft === void 0 && (et === null ? Ft = s.TEXTURE0 + He - 1 : Ft = et);
                  let yn = Lt[Ft];
                  yn === void 0 && (yn = { type: void 0, texture: void 0 }, Lt[Ft] = yn), (yn.type !== Pe || yn.texture !== Mt) && (et !== Ft && (s.activeTexture(Ft), et = Ft), s.bindTexture(Pe, Mt || _i[Pe]), yn.type = Pe, yn.texture = Mt);
                }
                function er() {
                  const Pe = Lt[et];
                  Pe !== void 0 && Pe.type !== void 0 && (s.bindTexture(Pe.type, null), Pe.type = void 0, Pe.texture = void 0);
                }
                function zi() {
                  try {
                    s.compressedTexImage2D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function Se() {
                  try {
                    s.compressedTexImage3D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function ue() {
                  try {
                    s.texSubImage2D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function it() {
                  try {
                    s.texSubImage3D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function At() {
                  try {
                    s.compressedTexSubImage2D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function yt() {
                  try {
                    s.compressedTexSubImage3D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function vt() {
                  try {
                    s.texStorage2D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function En() {
                  try {
                    s.texStorage3D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function kt() {
                  try {
                    s.texImage2D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function on() {
                  try {
                    s.texImage3D.apply(s, arguments);
                  } catch (Pe) {
                    console.error("THREE.WebGLState:", Pe);
                  }
                }
                function Li(Pe) {
                  ni.equals(Pe) === !1 && (s.scissor(Pe.x, Pe.y, Pe.z, Pe.w), ni.copy(Pe));
                }
                function an(Pe) {
                  Si.equals(Pe) === !1 && (s.viewport(Pe.x, Pe.y, Pe.z, Pe.w), Si.copy(Pe));
                }
                function xn(Pe, Mt) {
                  let Ft = h.get(Mt);
                  Ft === void 0 && (Ft = /* @__PURE__ */ new WeakMap(), h.set(Mt, Ft));
                  let yn = Ft.get(Pe);
                  yn === void 0 && (yn = s.getUniformBlockIndex(Mt, Pe.name), Ft.set(Pe, yn));
                }
                function Zn(Pe, Mt) {
                  const yn = h.get(Mt).get(Pe);
                  a.get(Mt) !== yn && (s.uniformBlockBinding(Mt, yn, Pe.__bindingPointIndex), a.set(Mt, yn));
                }
                function Pn() {
                  s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), m = {}, et = null, Lt = {}, _ = {}, I = /* @__PURE__ */ new WeakMap(), B = [], L = null, N = !1, z = null, k = null, P = null, se = null, $ = null, J = null, Le = null, Ee = new sn(0, 0, 0), Me = 0, Re = !1, Ae = null, ce = null, Ie = null, Qe = null, Ue = null, ni.set(0, 0, s.canvas.width, s.canvas.height), Si.set(0, 0, s.canvas.width, s.canvas.height), i.reset(), r.reset(), o.reset();
                }
                return { buffers: { color: i, depth: r, stencil: o }, enable: Ui, disable: An, bindFramebuffer: mt, drawBuffers: Gt, useProgram: Ht, setBlending: ot, setMaterial: Bt, setFlipSided: Tt, setCullFace: wt, setLineWidth: Kt, setPolygonOffset: nn, setScissorTest: kn, activeTexture: zn, bindTexture: wi, unbindTexture: er, compressedTexImage2D: zi, compressedTexImage3D: Se, texImage2D: kt, texImage3D: on, updateUBOMapping: xn, uniformBlockBinding: Zn, texStorage2D: vt, texStorage3D: En, texSubImage2D: ue, texSubImage3D: it, compressedTexSubImage2D: At, compressedTexSubImage3D: yt, scissor: Li, viewport: an, reset: Pn };
              }
              function Yg(s, e, t, n, i, r, o) {
                const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, h = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), m = e.has("OCULUS_multiview") ? e.get("OCULUS_multiview") : null, _ = new pt(), I = /* @__PURE__ */ new WeakMap();
                let B;
                const L = /* @__PURE__ */ new WeakMap();
                let N = [], z = !1, k = !1;
                try {
                  k = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
                } catch {
                }
                function P(Se, ue) {
                  return k ? (
                    // eslint-disable-next-line compat/compat
                    new OffscreenCanvas(Se, ue)
                  ) : Ao("canvas");
                }
                function se(Se, ue, it) {
                  let At = 1;
                  const yt = zi(Se);
                  if ((yt.width > it || yt.height > it) && (At = it / Math.max(yt.width, yt.height)), At < 1)
                    if (typeof HTMLImageElement < "u" && Se instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Se instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Se instanceof ImageBitmap || typeof VideoFrame < "u" && Se instanceof VideoFrame) {
                      const vt = Math.floor(At * yt.width), En = Math.floor(At * yt.height);
                      B === void 0 && (B = P(vt, En));
                      const kt = ue ? P(vt, En) : B;
                      return kt.width = vt, kt.height = En, kt.getContext("2d").drawImage(Se, 0, 0, vt, En), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + yt.width + "x" + yt.height + ") to (" + vt + "x" + En + ")."), kt;
                    } else
                      return "data" in Se && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + yt.width + "x" + yt.height + ")."), Se;
                  return Se;
                }
                function $(Se) {
                  return Se.generateMipmaps && Se.minFilter !== Pt && Se.minFilter !== vn;
                }
                function J(Se) {
                  s.generateMipmap(Se);
                }
                function Le(Se, ue, it, At, yt = !1) {
                  if (Se !== null) {
                    if (s[Se] !== void 0) return s[Se];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Se + "'");
                  }
                  let vt = ue;
                  if (ue === s.RED && (it === s.FLOAT && (vt = s.R32F), it === s.HALF_FLOAT && (vt = s.R16F), it === s.UNSIGNED_BYTE && (vt = s.R8)), ue === s.RED_INTEGER && (it === s.UNSIGNED_BYTE && (vt = s.R8UI), it === s.UNSIGNED_SHORT && (vt = s.R16UI), it === s.UNSIGNED_INT && (vt = s.R32UI), it === s.BYTE && (vt = s.R8I), it === s.SHORT && (vt = s.R16I), it === s.INT && (vt = s.R32I)), ue === s.RG && (it === s.FLOAT && (vt = s.RG32F), it === s.HALF_FLOAT && (vt = s.RG16F), it === s.UNSIGNED_BYTE && (vt = s.RG8)), ue === s.RG_INTEGER && (it === s.UNSIGNED_BYTE && (vt = s.RG8UI), it === s.UNSIGNED_SHORT && (vt = s.RG16UI), it === s.UNSIGNED_INT && (vt = s.RG32UI), it === s.BYTE && (vt = s.RG8I), it === s.SHORT && (vt = s.RG16I), it === s.INT && (vt = s.RG32I)), ue === s.RGB && it === s.UNSIGNED_INT_5_9_9_9_REV && (vt = s.RGB9_E5), ue === s.RGBA) {
                    const En = yt ? lo : Mi.getTransfer(At);
                    it === s.FLOAT && (vt = s.RGBA32F), it === s.HALF_FLOAT && (vt = s.RGBA16F), it === s.UNSIGNED_BYTE && (vt = En === Fi ? s.SRGB8_ALPHA8 : s.RGBA8), it === s.UNSIGNED_SHORT_4_4_4_4 && (vt = s.RGBA4), it === s.UNSIGNED_SHORT_5_5_5_1 && (vt = s.RGB5_A1);
                  }
                  return (vt === s.R16F || vt === s.R32F || vt === s.RG16F || vt === s.RG32F || vt === s.RGBA16F || vt === s.RGBA32F) && e.get("EXT_color_buffer_float"), vt;
                }
                function Ee(Se, ue) {
                  return $(Se) === !0 || Se.isFramebufferTexture && Se.minFilter !== Pt && Se.minFilter !== vn ? Math.log2(Math.max(ue.width, ue.height)) + 1 : Se.mipmaps !== void 0 && Se.mipmaps.length > 0 ? Se.mipmaps.length : Se.isCompressedTexture && Array.isArray(Se.image) ? ue.mipmaps.length : 1;
                }
                function Me(Se) {
                  const ue = Se.target;
                  ue.removeEventListener("dispose", Me), Ae(ue), ue.isVideoTexture && I.delete(ue);
                }
                function Re(Se) {
                  const ue = Se.target;
                  ue.removeEventListener("dispose", Re), Ie(ue);
                }
                function Ae(Se) {
                  const ue = n.get(Se);
                  if (ue.__webglInit === void 0) return;
                  const it = Se.source, At = L.get(it);
                  if (At) {
                    const yt = At[ue.__cacheKey];
                    yt.usedTimes--, yt.usedTimes === 0 && ce(Se), Object.keys(At).length === 0 && L.delete(it);
                  }
                  n.remove(Se);
                }
                function ce(Se) {
                  const ue = n.get(Se);
                  s.deleteTexture(ue.__webglTexture);
                  const it = Se.source, At = L.get(it);
                  delete At[ue.__cacheKey], o.memory.textures--;
                }
                function Ie(Se) {
                  const ue = n.get(Se);
                  if (Se.depthTexture && Se.depthTexture.dispose(), Se.isWebGLCubeRenderTarget)
                    for (let At = 0; At < 6; At++) {
                      if (Array.isArray(ue.__webglFramebuffer[At]))
                        for (let yt = 0; yt < ue.__webglFramebuffer[At].length; yt++) s.deleteFramebuffer(ue.__webglFramebuffer[At][yt]);
                      else
                        s.deleteFramebuffer(ue.__webglFramebuffer[At]);
                      ue.__webglDepthbuffer && s.deleteRenderbuffer(ue.__webglDepthbuffer[At]);
                    }
                  else {
                    if (Array.isArray(ue.__webglFramebuffer))
                      for (let At = 0; At < ue.__webglFramebuffer.length; At++) s.deleteFramebuffer(ue.__webglFramebuffer[At]);
                    else
                      s.deleteFramebuffer(ue.__webglFramebuffer);
                    if (ue.__webglDepthbuffer && s.deleteRenderbuffer(ue.__webglDepthbuffer), ue.__webglMultisampledFramebuffer && s.deleteFramebuffer(ue.__webglMultisampledFramebuffer), ue.__webglColorRenderbuffer)
                      for (let At = 0; At < ue.__webglColorRenderbuffer.length; At++)
                        ue.__webglColorRenderbuffer[At] && s.deleteRenderbuffer(ue.__webglColorRenderbuffer[At]);
                    ue.__webglDepthRenderbuffer && s.deleteRenderbuffer(ue.__webglDepthRenderbuffer);
                  }
                  const it = Se.textures;
                  for (let At = 0, yt = it.length; At < yt; At++) {
                    const vt = n.get(it[At]);
                    vt.__webglTexture && (s.deleteTexture(vt.__webglTexture), o.memory.textures--), n.remove(it[At]);
                  }
                  n.remove(Se);
                }
                let Qe = 0;
                function Ue() {
                  Qe = 0;
                }
                function He() {
                  const Se = Qe;
                  return Se >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Se + " texture units while this GPU supports only " + i.maxTextures), Qe += 1, Se;
                }
                function Ze(Se) {
                  const ue = [];
                  return ue.push(Se.wrapS), ue.push(Se.wrapT), ue.push(Se.wrapR || 0), ue.push(Se.magFilter), ue.push(Se.minFilter), ue.push(Se.anisotropy), ue.push(Se.internalFormat), ue.push(Se.format), ue.push(Se.type), ue.push(Se.generateMipmaps), ue.push(Se.premultiplyAlpha), ue.push(Se.flipY), ue.push(Se.unpackAlignment), ue.push(Se.colorSpace), ue.join();
                }
                function dt(Se, ue) {
                  const it = n.get(Se);
                  if (Se.isVideoTexture && wi(Se), Se.isRenderTargetTexture === !1 && Se.version > 0 && it.__version !== Se.version) {
                    const At = Se.image;
                    if (At === null)
                      console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else if (At.complete === !1)
                      console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                    else if (An(it, Se, ue))
                      return;
                  }
                  t.bindTexture(s.TEXTURE_2D, it.__webglTexture, s.TEXTURE0 + ue);
                }
                function Nt(Se, ue) {
                  const it = n.get(Se);
                  if (Se.version > 0 && it.__version !== Se.version) {
                    An(it, Se, ue);
                    return;
                  }
                  t.bindTexture(s.TEXTURE_2D_ARRAY, it.__webglTexture, s.TEXTURE0 + ue);
                }
                function et(Se, ue) {
                  const it = n.get(Se);
                  if (Se.version > 0 && it.__version !== Se.version) {
                    An(it, Se, ue);
                    return;
                  }
                  t.bindTexture(s.TEXTURE_3D, it.__webglTexture, s.TEXTURE0 + ue);
                }
                function Lt(Se, ue) {
                  const it = n.get(Se);
                  if (Se.version > 0 && it.__version !== Se.version) {
                    mt(it, Se, ue);
                    return;
                  }
                  t.bindTexture(s.TEXTURE_CUBE_MAP, it.__webglTexture, s.TEXTURE0 + ue);
                }
                const Ot = { [we]: s.REPEAT, [Oe]: s.CLAMP_TO_EDGE, [Ct]: s.MIRRORED_REPEAT }, fn = { [Pt]: s.NEAREST, [_t]: s.NEAREST_MIPMAP_NEAREST, [qt]: s.NEAREST_MIPMAP_LINEAR, [vn]: s.LINEAR, [Oi]: s.LINEAR_MIPMAP_NEAREST, [Ei]: s.LINEAR_MIPMAP_LINEAR }, ni = { [nl]: s.NEVER, [ll]: s.ALWAYS, [il]: s.LESS, [va]: s.LEQUAL, [rl]: s.EQUAL, [al]: s.GEQUAL, [sl]: s.GREATER, [ol]: s.NOTEQUAL };
                function Si(Se, ue) {
                  if (ue.type === tt && e.has("OES_texture_float_linear") === !1 && (ue.magFilter === vn || ue.magFilter === Oi || ue.magFilter === qt || ue.magFilter === Ei || ue.minFilter === vn || ue.minFilter === Oi || ue.minFilter === qt || ue.minFilter === Ei) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(Se, s.TEXTURE_WRAP_S, Ot[ue.wrapS]), s.texParameteri(Se, s.TEXTURE_WRAP_T, Ot[ue.wrapT]), (Se === s.TEXTURE_3D || Se === s.TEXTURE_2D_ARRAY) && s.texParameteri(Se, s.TEXTURE_WRAP_R, Ot[ue.wrapR]), s.texParameteri(Se, s.TEXTURE_MAG_FILTER, fn[ue.magFilter]), s.texParameteri(Se, s.TEXTURE_MIN_FILTER, fn[ue.minFilter]), ue.compareFunction && (s.texParameteri(Se, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(Se, s.TEXTURE_COMPARE_FUNC, ni[ue.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
                    if (ue.magFilter === Pt || ue.minFilter !== qt && ue.minFilter !== Ei || ue.type === tt && e.has("OES_texture_float_linear") === !1) return;
                    if (ue.anisotropy > 1 || n.get(ue).__currentAnisotropy) {
                      const it = e.get("EXT_texture_filter_anisotropic");
                      s.texParameterf(Se, it.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(ue.anisotropy, i.getMaxAnisotropy())), n.get(ue).__currentAnisotropy = ue.anisotropy;
                    }
                  }
                }
                function Hi(Se, ue) {
                  let it = !1;
                  Se.__webglInit === void 0 && (Se.__webglInit = !0, ue.addEventListener("dispose", Me));
                  const At = ue.source;
                  let yt = L.get(At);
                  yt === void 0 && (yt = {}, L.set(At, yt));
                  const vt = Ze(ue);
                  if (vt !== Se.__cacheKey) {
                    yt[vt] === void 0 && (yt[vt] = { texture: s.createTexture(), usedTimes: 0 }, o.memory.textures++, it = !0), yt[vt].usedTimes++;
                    const En = yt[Se.__cacheKey];
                    En !== void 0 && (yt[Se.__cacheKey].usedTimes--, En.usedTimes === 0 && ce(ue)), Se.__cacheKey = vt, Se.__webglTexture = yt[vt].texture;
                  }
                  return it;
                }
                function _i(Se) {
                  z = Se;
                }
                function Ui() {
                  const Se = z;
                  z = !1;
                  for (const ue of N)
                    An(ue.textureProperties, ue.texture, ue.slot), ue.texture.isPendingDeferredUpload = !1;
                  N = [], z = Se;
                }
                function An(Se, ue, it) {
                  if (z)
                    return ue.isPendingDeferredUpload || (ue.isPendingDeferredUpload = !0, N.push({ textureProperties: Se, texture: ue, slot: it })), !1;
                  let At = s.TEXTURE_2D;
                  (ue.isDataArrayTexture || ue.isCompressedArrayTexture) && (At = s.TEXTURE_2D_ARRAY), ue.isData3DTexture && (At = s.TEXTURE_3D);
                  const yt = Hi(Se, ue), vt = ue.source;
                  t.bindTexture(At, Se.__webglTexture, s.TEXTURE0 + it);
                  const En = n.get(vt);
                  if (vt.version !== En.__version || yt === !0) {
                    t.activeTexture(s.TEXTURE0 + it);
                    const kt = Mi.getPrimaries(Mi.workingColorSpace), on = ue.colorSpace === Tr ? null : Mi.getPrimaries(ue.colorSpace), Li = ue.colorSpace === Tr || kt === on ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
                    s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, ue.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ue.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, ue.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Li);
                    let an = se(ue.image, !1, i.maxTextureSize);
                    an = er(ue, an);
                    const xn = r.convert(ue.format, ue.colorSpace), Zn = r.convert(ue.type);
                    let Pn = Le(ue.internalFormat, xn, Zn, ue.colorSpace, ue.isVideoTexture);
                    Si(At, ue);
                    let Pe;
                    const Mt = ue.mipmaps, Ft = ue.isVideoTexture !== !0, yn = En.__version === void 0 || yt === !0, en = vt.dataReady, $n = Ee(ue, an);
                    if (ue.isDepthTexture)
                      Pn = s.DEPTH_COMPONENT16, ue.type === tt ? Pn = s.DEPTH_COMPONENT32F : ue.type === Fe ? Pn = s.DEPTH_COMPONENT24 : ue.type === zt && (Pn = s.DEPTH24_STENCIL8), yn && (Ft ? t.texStorage2D(s.TEXTURE_2D, 1, Pn, an.width, an.height) : t.texImage2D(s.TEXTURE_2D, 0, Pn, an.width, an.height, 0, xn, Zn, null));
                    else if (ue.isDataTexture)
                      if (Mt.length > 0) {
                        Ft && yn && t.texStorage2D(s.TEXTURE_2D, $n, Pn, Mt[0].width, Mt[0].height);
                        for (let tn = 0, Xt = Mt.length; tn < Xt; tn++)
                          Pe = Mt[tn], Ft ? en && t.texSubImage2D(s.TEXTURE_2D, tn, 0, 0, Pe.width, Pe.height, xn, Zn, Pe.data) : t.texImage2D(s.TEXTURE_2D, tn, Pn, Pe.width, Pe.height, 0, xn, Zn, Pe.data);
                        ue.generateMipmaps = !1;
                      } else
                        Ft ? (yn && t.texStorage2D(s.TEXTURE_2D, $n, Pn, an.width, an.height), en && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, an.width, an.height, xn, Zn, an.data)) : t.texImage2D(s.TEXTURE_2D, 0, Pn, an.width, an.height, 0, xn, Zn, an.data);
                    else if (ue.isCompressedTexture)
                      if (ue.isCompressedArrayTexture) {
                        Ft && yn && t.texStorage3D(s.TEXTURE_2D_ARRAY, $n, Pn, Mt[0].width, Mt[0].height, an.depth);
                        for (let tn = 0, Xt = Mt.length; tn < Xt; tn++)
                          Pe = Mt[tn], ue.format !== _e ? xn !== null ? Ft ? en && t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, tn, 0, 0, 0, Pe.width, Pe.height, an.depth, xn, Pe.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, tn, Pn, Pe.width, Pe.height, an.depth, 0, Pe.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ft ? en && t.texSubImage3D(s.TEXTURE_2D_ARRAY, tn, 0, 0, 0, Pe.width, Pe.height, an.depth, xn, Zn, Pe.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, tn, Pn, Pe.width, Pe.height, an.depth, 0, xn, Zn, Pe.data);
                      } else {
                        Ft && yn && t.texStorage2D(s.TEXTURE_2D, $n, Pn, Mt[0].width, Mt[0].height);
                        for (let tn = 0, Xt = Mt.length; tn < Xt; tn++)
                          Pe = Mt[tn], ue.format !== _e ? xn !== null ? Ft ? en && t.compressedTexSubImage2D(s.TEXTURE_2D, tn, 0, 0, Pe.width, Pe.height, xn, Pe.data) : t.compressedTexImage2D(s.TEXTURE_2D, tn, Pn, Pe.width, Pe.height, 0, Pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ft ? en && t.texSubImage2D(s.TEXTURE_2D, tn, 0, 0, Pe.width, Pe.height, xn, Zn, Pe.data) : t.texImage2D(s.TEXTURE_2D, tn, Pn, Pe.width, Pe.height, 0, xn, Zn, Pe.data);
                      }
                    else if (ue.isDataArrayTexture)
                      Ft ? (yn && t.texStorage3D(s.TEXTURE_2D_ARRAY, $n, Pn, an.width, an.height, an.depth), en && t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, an.width, an.height, an.depth, xn, Zn, an.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Pn, an.width, an.height, an.depth, 0, xn, Zn, an.data);
                    else if (ue.isData3DTexture)
                      Ft ? (yn && t.texStorage3D(s.TEXTURE_3D, $n, Pn, an.width, an.height, an.depth), en && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, an.width, an.height, an.depth, xn, Zn, an.data)) : t.texImage3D(s.TEXTURE_3D, 0, Pn, an.width, an.height, an.depth, 0, xn, Zn, an.data);
                    else if (ue.isFramebufferTexture) {
                      if (yn)
                        if (Ft)
                          t.texStorage2D(s.TEXTURE_2D, $n, Pn, an.width, an.height);
                        else {
                          let tn = an.width, Xt = an.height;
                          for (let si = 0; si < $n; si++)
                            t.texImage2D(s.TEXTURE_2D, si, Pn, tn, Xt, 0, xn, Zn, null), tn >>= 1, Xt >>= 1;
                        }
                    } else if (Mt.length > 0) {
                      if (Ft && yn) {
                        const tn = zi(Mt[0]);
                        t.texStorage2D(s.TEXTURE_2D, $n, Pn, tn.width, tn.height);
                      }
                      for (let tn = 0, Xt = Mt.length; tn < Xt; tn++)
                        Pe = Mt[tn], Ft ? en && t.texSubImage2D(s.TEXTURE_2D, tn, 0, 0, xn, Zn, Pe) : t.texImage2D(s.TEXTURE_2D, tn, Pn, xn, Zn, Pe);
                      ue.generateMipmaps = !1;
                    } else if (Ft) {
                      if (yn) {
                        const tn = zi(an);
                        t.texStorage2D(s.TEXTURE_2D, $n, Pn, tn.width, tn.height);
                      }
                      en && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, xn, Zn, an);
                    } else
                      t.texImage2D(s.TEXTURE_2D, 0, Pn, xn, Zn, an);
                    $(ue) && J(At), En.__version = vt.version, ue.onUpdate && ue.onUpdate(ue);
                  }
                  return Se.__version = ue.version, !0;
                }
                function mt(Se, ue, it) {
                  if (ue.image.length !== 6) return;
                  const At = Hi(Se, ue), yt = ue.source;
                  t.bindTexture(s.TEXTURE_CUBE_MAP, Se.__webglTexture, s.TEXTURE0 + it);
                  const vt = n.get(yt);
                  if (yt.version !== vt.__version || At === !0) {
                    t.activeTexture(s.TEXTURE0 + it);
                    const En = Mi.getPrimaries(Mi.workingColorSpace), kt = ue.colorSpace === Tr ? null : Mi.getPrimaries(ue.colorSpace), on = ue.colorSpace === Tr || En === kt ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
                    s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, ue.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ue.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, ue.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, on);
                    const Li = ue.isCompressedTexture || ue.image[0].isCompressedTexture, an = ue.image[0] && ue.image[0].isDataTexture, xn = [];
                    for (let Xt = 0; Xt < 6; Xt++)
                      !Li && !an ? xn[Xt] = se(ue.image[Xt], !0, i.maxCubemapSize) : xn[Xt] = an ? ue.image[Xt].image : ue.image[Xt], xn[Xt] = er(ue, xn[Xt]);
                    const Zn = xn[0], Pn = r.convert(ue.format, ue.colorSpace), Pe = r.convert(ue.type), Mt = Le(ue.internalFormat, Pn, Pe, ue.colorSpace), Ft = ue.isVideoTexture !== !0, yn = vt.__version === void 0 || At === !0, en = yt.dataReady;
                    let $n = Ee(ue, Zn);
                    Si(s.TEXTURE_CUBE_MAP, ue);
                    let tn;
                    if (Li) {
                      Ft && yn && t.texStorage2D(s.TEXTURE_CUBE_MAP, $n, Mt, Zn.width, Zn.height);
                      for (let Xt = 0; Xt < 6; Xt++) {
                        tn = xn[Xt].mipmaps;
                        for (let si = 0; si < tn.length; si++) {
                          const Fn = tn[si];
                          ue.format !== _e ? Pn !== null ? Ft ? en && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si, 0, 0, Fn.width, Fn.height, Pn, Fn.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si, Mt, Fn.width, Fn.height, 0, Fn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ft ? en && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si, 0, 0, Fn.width, Fn.height, Pn, Pe, Fn.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si, Mt, Fn.width, Fn.height, 0, Pn, Pe, Fn.data);
                        }
                      }
                    } else {
                      if (tn = ue.mipmaps, Ft && yn) {
                        tn.length > 0 && $n++;
                        const Xt = zi(xn[0]);
                        t.texStorage2D(s.TEXTURE_CUBE_MAP, $n, Mt, Xt.width, Xt.height);
                      }
                      for (let Xt = 0; Xt < 6; Xt++)
                        if (an) {
                          Ft ? en && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, 0, 0, 0, xn[Xt].width, xn[Xt].height, Pn, Pe, xn[Xt].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, 0, Mt, xn[Xt].width, xn[Xt].height, 0, Pn, Pe, xn[Xt].data);
                          for (let si = 0; si < tn.length; si++) {
                            const Er = tn[si].image[Xt].image;
                            Ft ? en && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si + 1, 0, 0, Er.width, Er.height, Pn, Pe, Er.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si + 1, Mt, Er.width, Er.height, 0, Pn, Pe, Er.data);
                          }
                        } else {
                          Ft ? en && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, 0, 0, 0, Pn, Pe, xn[Xt]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, 0, Mt, Pn, Pe, xn[Xt]);
                          for (let si = 0; si < tn.length; si++) {
                            const Fn = tn[si];
                            Ft ? en && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si + 1, 0, 0, Pn, Pe, Fn.image[Xt]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, si + 1, Mt, Pn, Pe, Fn.image[Xt]);
                          }
                        }
                    }
                    $(ue) && J(s.TEXTURE_CUBE_MAP), vt.__version = yt.version, ue.onUpdate && ue.onUpdate(ue);
                  }
                  Se.__version = ue.version;
                }
                function Gt(Se, ue, it, At, yt, vt) {
                  const En = r.convert(it.format, it.colorSpace), kt = r.convert(it.type), on = Le(it.internalFormat, En, kt, it.colorSpace);
                  if (!n.get(ue).__hasExternalTextures) {
                    const xn = Math.max(1, ue.width >> vt), Zn = Math.max(1, ue.height >> vt);
                    ue.isWebGLMultiviewRenderTarget === !0 ? t.texStorage3D(s.TEXTURE_2D_ARRAY, 0, on, ue.width, ue.height, ue.numViews) : yt === s.TEXTURE_3D || yt === s.TEXTURE_2D_ARRAY ? t.texImage3D(yt, vt, on, xn, Zn, ue.depth, 0, En, kt, null) : t.texImage2D(yt, vt, on, xn, Zn, 0, En, kt, null);
                  }
                  t.bindFramebuffer(s.FRAMEBUFFER, Se);
                  const an = zn(ue);
                  ue.isWebGLMultiviewRenderTarget === !0 ? an ? m.framebufferTextureMultisampleMultiviewOVR(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, n.get(it).__webglTexture, 0, kn(ue), 0, ue.numViews) : m.framebufferTextureMultiviewOVR(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, n.get(it).__webglTexture, 0, 0, ue.numViews) : (yt === s.TEXTURE_2D || yt >= s.TEXTURE_CUBE_MAP_POSITIVE_X && yt <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && (an ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, At, yt, n.get(it).__webglTexture, 0, kn(ue)) : s.framebufferTexture2D(s.FRAMEBUFFER, At, yt, n.get(it).__webglTexture, vt)), t.bindFramebuffer(s.FRAMEBUFFER, null);
                }
                function Ht(Se, ue, it) {
                  if (s.bindRenderbuffer(s.RENDERBUFFER, Se), ue.isWebGLMultiviewRenderTarget === !0) {
                    const At = zn(ue), yt = ue.numViews, vt = ue.depthTexture;
                    let En = s.DEPTH_COMPONENT24, kt = s.DEPTH_ATTACHMENT;
                    vt && vt.isDepthTexture && (vt.type === tt ? En = s.DEPTH_COMPONENT32F : vt.type === zt && (En = s.DEPTH24_STENCIL8, kt = s.DEPTH_STENCIL_ATTACHMENT));
                    let on = n.get(ue.depthTexture).__webglTexture;
                    on === void 0 && (on = s.createTexture(), s.bindTexture(s.TEXTURE_2D_ARRAY, on), s.texStorage3D(s.TEXTURE_2D_ARRAY, 1, En, ue.width, ue.height, yt)), At ? m.framebufferTextureMultisampleMultiviewOVR(s.FRAMEBUFFER, kt, on, 0, kn(ue), 0, yt) : m.framebufferTextureMultiviewOVR(s.FRAMEBUFFER, kt, on, 0, 0, yt);
                  } else if (ue.depthBuffer && !ue.stencilBuffer) {
                    let At = s.DEPTH_COMPONENT24;
                    if (it || zn(ue)) {
                      const yt = ue.depthTexture;
                      yt && yt.isDepthTexture && (yt.type === tt ? At = s.DEPTH_COMPONENT32F : yt.type === Fe && (At = s.DEPTH_COMPONENT24));
                      const vt = kn(ue);
                      zn(ue) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, vt, At, ue.width, ue.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, vt, At, ue.width, ue.height);
                    } else
                      s.renderbufferStorage(s.RENDERBUFFER, At, ue.width, ue.height);
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, Se);
                  } else if (ue.depthBuffer && ue.stencilBuffer) {
                    const At = kn(ue);
                    it && zn(ue) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, At, s.DEPTH24_STENCIL8, ue.width, ue.height) : zn(ue) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, At, s.DEPTH24_STENCIL8, ue.width, ue.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, ue.width, ue.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, Se);
                  } else {
                    const At = ue.textures;
                    for (let yt = 0; yt < At.length; yt++) {
                      const vt = At[yt], En = r.convert(vt.format, vt.colorSpace), kt = r.convert(vt.type), on = Le(vt.internalFormat, En, kt, vt.colorSpace), Li = kn(ue);
                      it && zn(ue) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Li, on, ue.width, ue.height) : zn(ue) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Li, on, ue.width, ue.height) : s.renderbufferStorage(s.RENDERBUFFER, on, ue.width, ue.height);
                    }
                  }
                  s.bindRenderbuffer(s.RENDERBUFFER, null);
                }
                function ze(Se, ue) {
                  if (ue && ue.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                  if (t.bindFramebuffer(s.FRAMEBUFFER, Se), !(ue.depthTexture && ue.depthTexture.isDepthTexture))
                    throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                  (!n.get(ue.depthTexture).__webglTexture || ue.depthTexture.image.width !== ue.width || ue.depthTexture.image.height !== ue.height) && (ue.depthTexture.image.width = ue.width, ue.depthTexture.image.height = ue.height, ue.depthTexture.needsUpdate = !0), dt(ue.depthTexture, 0), ue.depthTexture.image.depth != 1 ? Nt(ue.depthTexture, 0) : dt(ue.depthTexture, 0);
                  const At = n.get(ue.depthTexture).__webglTexture, yt = kn(ue);
                  if (ue.isWebGLMultiviewRenderTarget === !0) {
                    const vt = zn(ue), En = ue.numViews;
                    if (ue.depthTexture.format === Ke)
                      vt ? m.framebufferTextureMultisampleMultiviewOVR(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, At, 0, yt, 0, En) : m.framebufferTextureMultiviewOVR(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, At, 0, 0, En);
                    else if (ue.depthTexture.format === rt)
                      vt ? m.framebufferTextureMultisampleMultiviewOVR(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, At, 0, yt, 0, En) : m.framebufferTextureMultiviewOVR(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, At, 0, 0, En);
                    else
                      throw new Error("Unknown depthTexture format");
                  } else if (ue.depthTexture.format === Ke)
                    zn(ue) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, At, 0, yt) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, At, 0);
                  else if (ue.depthTexture.format === rt)
                    zn(ue) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, At, 0, yt) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, At, 0);
                  else
                    throw new Error("Unknown depthTexture format");
                }
                function gt(Se) {
                  const ue = n.get(Se), it = Se.isWebGLCubeRenderTarget === !0;
                  if (Se.depthTexture && !ue.__autoAllocateDepthBuffer) {
                    if (it) throw new Error("target.depthTexture not supported in Cube render targets");
                    ze(ue.__webglFramebuffer, Se);
                  } else if (it) {
                    ue.__webglDepthbuffer = [];
                    for (let At = 0; At < 6; At++)
                      t.bindFramebuffer(s.FRAMEBUFFER, ue.__webglFramebuffer[At]), ue.__webglDepthbuffer[At] = s.createRenderbuffer(), Ht(ue.__webglDepthbuffer[At], Se, !1);
                  } else
                    t.bindFramebuffer(s.FRAMEBUFFER, ue.__webglFramebuffer), ue.__webglDepthbuffer = s.createRenderbuffer(), Ht(ue.__webglDepthbuffer, Se, !1);
                  t.bindFramebuffer(s.FRAMEBUFFER, null);
                }
                function ot(Se, ue, it) {
                  const At = n.get(Se);
                  ue !== void 0 && Gt(At.__webglFramebuffer, Se, Se.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), it !== void 0 && gt(Se);
                }
                function Bt(Se) {
                  const ue = Se.texture, it = n.get(Se), At = n.get(ue);
                  Se.addEventListener("dispose", Re);
                  const yt = Se.textures, vt = Se.isWebGLCubeRenderTarget === !0, En = yt.length > 1;
                  if (En || (At.__webglTexture === void 0 && (At.__webglTexture = s.createTexture()), At.__version = ue.version, o.memory.textures++), vt) {
                    it.__webglFramebuffer = [];
                    for (let kt = 0; kt < 6; kt++)
                      if (ue.mipmaps && ue.mipmaps.length > 0) {
                        it.__webglFramebuffer[kt] = [];
                        for (let on = 0; on < ue.mipmaps.length; on++)
                          it.__webglFramebuffer[kt][on] = s.createFramebuffer();
                      } else
                        it.__webglFramebuffer[kt] = s.createFramebuffer();
                  } else {
                    if (ue.mipmaps && ue.mipmaps.length > 0) {
                      it.__webglFramebuffer = [];
                      for (let kt = 0; kt < ue.mipmaps.length; kt++)
                        it.__webglFramebuffer[kt] = s.createFramebuffer();
                    } else
                      it.__webglFramebuffer = s.createFramebuffer();
                    if (En)
                      for (let kt = 0, on = yt.length; kt < on; kt++) {
                        const Li = n.get(yt[kt]);
                        Li.__webglTexture === void 0 && (Li.__webglTexture = s.createTexture(), o.memory.textures++);
                      }
                    if (Se.samples > 0 && zn(Se) === !1) {
                      it.__webglMultisampledFramebuffer = s.createFramebuffer(), it.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, it.__webglMultisampledFramebuffer);
                      for (let kt = 0; kt < yt.length; kt++) {
                        const on = yt[kt];
                        it.__webglColorRenderbuffer[kt] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, it.__webglColorRenderbuffer[kt]);
                        const Li = r.convert(on.format, on.colorSpace), an = r.convert(on.type), xn = Le(on.internalFormat, Li, an, on.colorSpace, Se.isXRRenderTarget === !0), Zn = kn(Se);
                        s.renderbufferStorageMultisample(s.RENDERBUFFER, Zn, xn, Se.width, Se.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + kt, s.RENDERBUFFER, it.__webglColorRenderbuffer[kt]);
                      }
                      s.bindRenderbuffer(s.RENDERBUFFER, null), Se.depthBuffer && (it.__webglDepthRenderbuffer = s.createRenderbuffer(), Ht(it.__webglDepthRenderbuffer, Se, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
                    }
                  }
                  if (vt) {
                    t.bindTexture(s.TEXTURE_CUBE_MAP, At.__webglTexture), Si(s.TEXTURE_CUBE_MAP, ue);
                    for (let kt = 0; kt < 6; kt++)
                      if (ue.mipmaps && ue.mipmaps.length > 0)
                        for (let on = 0; on < ue.mipmaps.length; on++)
                          Gt(it.__webglFramebuffer[kt][on], Se, ue, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + kt, on);
                      else
                        Gt(it.__webglFramebuffer[kt], Se, ue, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + kt, 0);
                    $(ue) && J(s.TEXTURE_CUBE_MAP), t.unbindTexture();
                  } else if (En) {
                    for (let kt = 0, on = yt.length; kt < on; kt++) {
                      const Li = yt[kt], an = n.get(Li);
                      t.bindTexture(s.TEXTURE_2D, an.__webglTexture), Si(s.TEXTURE_2D, Li), Gt(it.__webglFramebuffer, Se, Li, s.COLOR_ATTACHMENT0 + kt, s.TEXTURE_2D, 0), $(Li) && J(s.TEXTURE_2D);
                    }
                    t.unbindTexture();
                  } else {
                    let kt = s.TEXTURE_2D;
                    if ((Se.isWebGL3DRenderTarget || Se.isWebGLArrayRenderTarget) && (kt = Se.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), Se.isWebGLMultiviewRenderTarget === !0 && (kt = s.TEXTURE_2D_ARRAY), t.bindTexture(kt, At.__webglTexture), Si(kt, ue), ue.mipmaps && ue.mipmaps.length > 0)
                      for (let on = 0; on < ue.mipmaps.length; on++)
                        Gt(it.__webglFramebuffer[on], Se, ue, s.COLOR_ATTACHMENT0, kt, on);
                    else
                      Gt(it.__webglFramebuffer, Se, ue, s.COLOR_ATTACHMENT0, kt, 0);
                    $(ue) && J(kt), t.unbindTexture();
                  }
                  (Se.depthBuffer || Se.isWebGLMultiviewRenderTarget === !0) && this.setupDepthRenderbuffer(Se);
                }
                function Tt(Se) {
                  const ue = Se.textures;
                  for (let it = 0, At = ue.length; it < At; it++) {
                    const yt = ue[it];
                    if ($(yt)) {
                      const vt = Se.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D, En = n.get(yt).__webglTexture;
                      t.bindTexture(vt, En), J(vt), t.unbindTexture();
                    }
                  }
                }
                const wt = [], Kt = [];
                function nn(Se) {
                  if (Se.samples > 0) {
                    if (zn(Se) === !1) {
                      const ue = Se.textures, it = Se.width, At = Se.height;
                      let yt = s.COLOR_BUFFER_BIT;
                      const vt = Se.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, En = n.get(Se), kt = ue.length > 1;
                      if (kt)
                        for (let on = 0; on < ue.length; on++)
                          t.bindFramebuffer(s.FRAMEBUFFER, En.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + on, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, En.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + on, s.TEXTURE_2D, null, 0);
                      t.bindFramebuffer(s.READ_FRAMEBUFFER, En.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, En.__webglFramebuffer);
                      for (let on = 0; on < ue.length; on++) {
                        if (Se.resolveDepthBuffer && (Se.depthBuffer && (yt |= s.DEPTH_BUFFER_BIT), Se.stencilBuffer && Se.resolveStencilBuffer && (yt |= s.STENCIL_BUFFER_BIT)), kt) {
                          s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, En.__webglColorRenderbuffer[on]);
                          const Li = n.get(ue[on]).__webglTexture;
                          s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Li, 0);
                        }
                        s.blitFramebuffer(0, 0, it, At, 0, 0, it, At, yt, s.NEAREST), h === !0 && (wt.length = 0, Kt.length = 0, wt.push(s.COLOR_ATTACHMENT0 + on), Se.depthBuffer && Se.resolveDepthBuffer === !1 && (wt.push(vt), Kt.push(vt), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, Kt)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, wt));
                      }
                      if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), kt)
                        for (let on = 0; on < ue.length; on++) {
                          t.bindFramebuffer(s.FRAMEBUFFER, En.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + on, s.RENDERBUFFER, En.__webglColorRenderbuffer[on]);
                          const Li = n.get(ue[on]).__webglTexture;
                          t.bindFramebuffer(s.FRAMEBUFFER, En.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + on, s.TEXTURE_2D, Li, 0);
                        }
                      t.bindFramebuffer(s.DRAW_FRAMEBUFFER, En.__webglMultisampledFramebuffer);
                    } else if (Se.depthBuffer && Se.resolveDepthBuffer === !1 && h) {
                      const ue = Se.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
                      s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [ue]);
                    }
                  }
                }
                function kn(Se) {
                  return Math.min(i.maxSamples, Se.samples);
                }
                function zn(Se) {
                  const ue = n.get(Se);
                  return Se.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && ue.__useRenderToTexture !== !1;
                }
                function wi(Se) {
                  const ue = o.render.frame;
                  I.get(Se) !== ue && (I.set(Se, ue), Se.update());
                }
                function er(Se, ue) {
                  const it = Se.colorSpace, At = Se.format, yt = Se.type;
                  return Se.isCompressedTexture === !0 || Se.isVideoTexture === !0 || it !== hs && it !== Tr && (Mi.getTransfer(it) === Fi ? (At !== _e || yt !== Ii) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", it)), ue;
                }
                function zi(Se) {
                  return typeof HTMLImageElement < "u" && Se instanceof HTMLImageElement ? (_.width = Se.naturalWidth || Se.width, _.height = Se.naturalHeight || Se.height) : typeof VideoFrame < "u" && Se instanceof VideoFrame ? (_.width = Se.displayWidth, _.height = Se.displayHeight) : (_.width = Se.width, _.height = Se.height), _;
                }
                this.allocateTextureUnit = He, this.resetTextureUnits = Ue, this.setTexture2D = dt, this.setTexture2DArray = Nt, this.setTexture3D = et, this.setTextureCube = Lt, this.rebindTextures = ot, this.uploadTexture = An, this.setupRenderTarget = Bt, this.updateRenderTargetMipmap = Tt, this.updateMultisampleRenderTarget = nn, this.setupDepthTexture = ze, this.setupDepthRenderbuffer = gt, this.setupFrameBufferTexture = Gt, this.useMultisampledRTT = zn, this.runDeferredUploads = Ui, this.setDeferTextureUploads = _i;
              }
              function Ld(s, e) {
                function t(n, i = Tr) {
                  let r;
                  const o = Mi.getTransfer(i);
                  if (n === Ii) return s.UNSIGNED_BYTE;
                  if (n === Ut) return s.UNSIGNED_SHORT_4_4_4_4;
                  if (n === hn) return s.UNSIGNED_SHORT_5_5_5_1;
                  if (n === ai) return s.UNSIGNED_INT_5_9_9_9_REV;
                  if (n === Sr) return s.BYTE;
                  if (n === ji) return s.SHORT;
                  if (n === Cr) return s.UNSIGNED_SHORT;
                  if (n === Y) return s.INT;
                  if (n === Fe) return s.UNSIGNED_INT;
                  if (n === tt) return s.FLOAT;
                  if (n === lt) return s.HALF_FLOAT;
                  if (n === jn) return s.ALPHA;
                  if (n === de) return s.RGB;
                  if (n === _e) return s.RGBA;
                  if (n === Ne) return s.LUMINANCE;
                  if (n === Ye) return s.LUMINANCE_ALPHA;
                  if (n === Ke) return s.DEPTH_COMPONENT;
                  if (n === rt) return s.DEPTH_STENCIL;
                  if (n === bt) return s.RED;
                  if (n === ln) return s.RED_INTEGER;
                  if (n === jt) return s.RG;
                  if (n === at) return s.RG_INTEGER;
                  if (n === mn) return s.RGBA_INTEGER;
                  if (n === _n || n === Rn || n === Bi || n === Wn)
                    if (o === Fi)
                      if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
                        if (n === _n) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (n === Rn) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (n === Bi) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (n === Wn) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                      } else
                        return null;
                    else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
                      if (n === _n) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                      if (n === Rn) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                      if (n === Bi) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                      if (n === Wn) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    } else
                      return null;
                  if (n === Nn || n === li || n === Gi || n === rr)
                    if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
                      if (n === Nn) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                      if (n === li) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                      if (n === Gi) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                      if (n === rr) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    } else
                      return null;
                  if (n === Wt || n === Kn || n === qi)
                    if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
                      if (n === Wt || n === Kn) return o === Fi ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                      if (n === qi) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
                    } else
                      return null;
                  if (n === fi || n === F || n === V || n === q || n === oe || n === me || n === De || n === Ge || n === ft || n === ct || n === je || n === nt || n === xt || n === Jt)
                    if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
                      if (n === fi) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                      if (n === F) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                      if (n === V) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                      if (n === q) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                      if (n === oe) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                      if (n === me) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                      if (n === De) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                      if (n === Ge) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                      if (n === ft) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                      if (n === ct) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                      if (n === je) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                      if (n === nt) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                      if (n === xt) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                      if (n === Jt) return o === Fi ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    } else
                      return null;
                  if (n === dn || n === Mn || n === Vn)
                    if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
                      if (n === dn) return o === Fi ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                      if (n === Mn) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                      if (n === Vn) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
                    } else
                      return null;
                  if (n === On || n === In || n === Ai || n === Ri)
                    if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
                      if (n === dn) return r.COMPRESSED_RED_RGTC1_EXT;
                      if (n === In) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                      if (n === Ai) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                      if (n === Ri) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
                    } else
                      return null;
                  return n === zt ? s.UNSIGNED_INT_24_8 : s[n] !== void 0 ? s[n] : null;
                }
                return { convert: t };
              }
              class xo extends bi {
                constructor() {
                  super(), this.isGroup = !0, this.type = "Group";
                }
              }
              class Wu extends mr {
                constructor(e = []) {
                  super(), this.isArrayCamera = !0, this.cameras = e;
                }
              }
              var Dd = new ye(), Pd = new ye();
              function qg(s, e, t) {
                Dd.setFromMatrixPosition(e.matrixWorld), Pd.setFromMatrixPosition(t.matrixWorld);
                var n = Dd.distanceTo(Pd), i = e.projectionMatrix.elements, r = t.projectionMatrix.elements, o = i[14] / (i[10] - 1), a = i[14] / (i[10] + 1), h = (i[9] + 1) / i[5], m = (i[9] - 1) / i[5], _ = (i[8] - 1) / i[0], I = (r[8] + 1) / r[0], B = o * _, L = o * I, N = n / (-_ + I), z = N * -_;
                e.matrixWorld.decompose(s.position, s.quaternion, s.scale), s.translateX(z), s.translateZ(N), s.matrixWorld.compose(s.position, s.quaternion, s.scale), s.matrixWorldInverse.copy(s.matrixWorld).invert();
                var k = o + N, P = a + N, se = B - z, $ = L + (n - z), J = h * a / P * k, Le = m * a / P * k;
                s.projectionMatrix.makePerspective(se, $, J, Le, k, P);
              }
              function Od(s) {
                var e, t, n = this, i = null, r = null, o = null, a = [], h = new pn(), m = new pn(), _ = 1, I = "local-floor";
                typeof window < "u" && "VRFrameData" in window && (r = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", J, !1));
                var B = new pn(), L = new xi(), N = new ye(), z = new mr();
                z.viewport = new yi(), z.layers.enable(1);
                var k = new mr();
                k.viewport = new yi(), k.layers.enable(2);
                var P = new Wu([z, k]);
                P.layers.enable(1), P.layers.enable(2);
                var se = new pt(), $;
                function J() {
                  var Ie = n.isPresenting = i !== null && i.isPresenting === !0;
                  if (Ie) {
                    var Qe = i.getEyeParameters("left");
                    e = 2 * Qe.renderWidth * _, t = Qe.renderHeight * _, $ = s.getPixelRatio(), s.getSize(se), s.setDrawingBufferSize(e, t, 1), z.viewport.set(0, 0, e / 2, t), k.viewport.set(e / 2, 0, e / 2, t), ce.start(), n.dispatchEvent({ type: "sessionstart" });
                  } else
                    n.enabled && s.setDrawingBufferSize(se.width, se.height, $), ce.stop(), n.dispatchEvent({ type: "sessionend" });
                }
                var Le = [], Ee = [];
                function Me(Ie) {
                  for (var Qe = navigator.getGamepads && navigator.getGamepads(), Ue = 0, He = Qe.length; Ue < He; Ue++) {
                    var Ze = Qe[Ue];
                    if (Ze && (Ze.id === "Daydream Controller" || Ze.id === "Gear VR Controller" || Ze.id === "Oculus Go Controller" || Ze.id === "OpenVR Gamepad" || Ze.id.startsWith("Oculus Touch") || Ze.id.startsWith("HTC Vive Focus") || Ze.id.startsWith("Spatial Controller"))) {
                      var dt = Ze.hand;
                      if (Ie === 0 && (dt === "" || dt === "right") || Ie === 1 && dt === "left") return Ze;
                    }
                  }
                }
                function Re() {
                  for (var Ie = 0; Ie < a.length; Ie++) {
                    var Qe = a[Ie], Ue = Me(Ie);
                    if (Ue !== void 0 && Ue.pose !== void 0) {
                      if (Ue.pose === null) return;
                      var He = Ue.pose;
                      He.hasPosition === !1 && Qe.position.set(0.2, -0.6, -0.05), He.position !== null && Qe.position.fromArray(He.position), He.orientation !== null && Qe.quaternion.fromArray(He.orientation), Qe.matrix.compose(Qe.position, Qe.quaternion, Qe.scale), Qe.matrix.premultiply(h), Qe.matrix.decompose(Qe.position, Qe.quaternion, Qe.scale), Qe.matrixWorldNeedsUpdate = !0, Qe.visible = !0;
                      var Ze = Ue.id === "Daydream Controller" ? 0 : 1;
                      Le[Ie] === void 0 && (Le[Ie] = !1), Le[Ie] !== Ue.buttons[Ze].pressed && (Le[Ie] = Ue.buttons[Ze].pressed, Le[Ie] === !0 ? Qe.dispatchEvent({ type: "selectstart" }) : (Qe.dispatchEvent({ type: "selectend" }), Qe.dispatchEvent({ type: "select" }))), Ze = 2, Ee[Ie] === void 0 && (Ee[Ie] = !1), Ue.buttons[Ze] !== void 0 && Ee[Ie] !== Ue.buttons[Ze].pressed && (Ee[Ie] = Ue.buttons[Ze].pressed, Ee[Ie] === !0 ? Qe.dispatchEvent({ type: "squeezestart" }) : (Qe.dispatchEvent({ type: "squeezeend" }), Qe.dispatchEvent({ type: "squeeze" })));
                    } else
                      Qe.visible = !1;
                  }
                }
                function Ae(Ie, Qe) {
                  Qe !== null && Qe.length === 4 && Ie.set(Qe[0] * e, Qe[1] * t, Qe[2] * e, Qe[3] * t);
                }
                this.enabled = !1, this.getController = function(Ie) {
                  var Qe = a[Ie];
                  return Qe === void 0 && (Qe = new xo(), Qe.matrixAutoUpdate = !1, Qe.visible = !1, a[Ie] = Qe), Qe;
                }, this.getDevice = function() {
                  return i;
                }, this.setDevice = function(Ie) {
                  Ie !== void 0 && (i = Ie), ce.setContext(Ie);
                }, this.setFramebufferScaleFactor = function(Ie) {
                  _ = Ie;
                }, this.setReferenceSpaceType = function(Ie) {
                  I = Ie;
                }, this.setPoseTarget = function(Ie) {
                  Ie !== void 0 && (o = Ie);
                }, this.cameraAutoUpdate = !0, this.updateCamera = function(Ie) {
                  var Qe = I === "local-floor" ? 1.6 : 0;
                  if (i.depthNear = Ie.near, i.depthFar = Ie.far, i.getFrameData(r), I === "local-floor") {
                    var Ue = i.stageParameters;
                    Ue ? h.fromArray(Ue.sittingToStandingTransform) : h.makeTranslation(0, Qe, 0);
                  }
                  var He = r.pose, Ze = o !== null ? o : Ie;
                  Ze.matrix.copy(h), Ze.matrix.decompose(Ze.position, Ze.quaternion, Ze.scale), He.orientation !== null && (L.fromArray(He.orientation), Ze.quaternion.multiply(L)), He.position !== null && (L.setFromRotationMatrix(h), N.fromArray(He.position), N.applyQuaternion(L), Ze.position.add(N)), Ze.updateMatrixWorld();
                  for (var dt = Ze.children, Nt = 0, et = dt.length; Nt < et; Nt++)
                    dt[Nt].updateMatrixWorld(!0);
                  z.near = Ie.near, k.near = Ie.near, z.far = Ie.far, k.far = Ie.far, z.matrixWorldInverse.fromArray(r.leftViewMatrix), k.matrixWorldInverse.fromArray(r.rightViewMatrix), m.copy(h).invert(), I === "local-floor" && (z.matrixWorldInverse.multiply(m), k.matrixWorldInverse.multiply(m));
                  var Lt = Ze.parent;
                  Lt !== null && (B.copy(Lt.matrixWorld).invert(), z.matrixWorldInverse.multiply(B), k.matrixWorldInverse.multiply(B)), z.matrixWorld.copy(z.matrixWorldInverse).invert(), k.matrixWorld.copy(k.matrixWorldInverse).invert(), z.projectionMatrix.fromArray(r.leftProjectionMatrix), k.projectionMatrix.fromArray(r.rightProjectionMatrix), qg(P, z, k);
                  var Ot = i.getLayers();
                  if (Ot.length) {
                    var fn = Ot[0];
                    Ae(z.viewport, fn.leftBounds), Ae(k.viewport, fn.rightBounds);
                  }
                  return Re(), P;
                }, this.getCamera = function() {
                  return P;
                }, this.getFoveation = function() {
                  return 1;
                }, this.setFoveation = function(Ie) {
                  Ie !== 1 && console.warn("THREE.WebVRManager: setFoveation() not used in WebVR.");
                }, this.getEnvironmentBlendMode = function() {
                  if (n.isPresenting)
                    return "opaque";
                }, this.getStandingMatrix = function() {
                  return h;
                }, this.isPresenting = !1;
                var ce = new Du();
                this.setAnimationLoop = function(Ie) {
                  ce.setAnimationLoop(Ie), this.isPresenting && ce.start();
                }, this.submitFrame = function() {
                  this.isPresenting && i.submitFrame();
                }, this.dispose = function() {
                  typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", J);
                }, this.setFrameOfReferenceType = function() {
                  console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.");
                };
              }
              Object.assign(Od.prototype, { addEventListener: Nr.prototype.addEventListener, hasEventListener: Nr.prototype.hasEventListener, removeEventListener: Nr.prototype.removeEventListener, dispatchEvent: Nr.prototype.dispatchEvent });
              class Fd extends zr {
                constructor(e, t, n, i = {}) {
                  super(e, t, i), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = n;
                }
                copy(e) {
                  return super.copy(e), this.numViews = e.numViews, this;
                }
              }
              Fd.prototype.isWebGLMultiviewRenderTarget = !0;
              const Jg = { type: "move" };
              class Ku {
                constructor() {
                  this._targetRay = null, this._grip = null, this._hand = null;
                }
                getHandSpace() {
                  return this._hand === null && (this._hand = new xo(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
                }
                getTargetRaySpace() {
                  return this._targetRay === null && (this._targetRay = new xo(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ye(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ye()), this._targetRay;
                }
                getGripSpace() {
                  return this._grip === null && (this._grip = new xo(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ye(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ye()), this._grip;
                }
                dispatchEvent(e) {
                  return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
                }
                connect(e) {
                  if (e && e.hand) {
                    const t = this._hand;
                    if (t)
                      for (const n of e.hand.values())
                        this._getHandJoint(t, n);
                  }
                  return this.dispatchEvent({ type: "connected", data: e }), this;
                }
                disconnect(e) {
                  return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
                }
                update(e, t, n) {
                  let i = null, r = null, o = null;
                  const a = this._targetRay, h = this._grip, m = this._hand;
                  if (e && t.session.visibilityState !== "visible-blurred") {
                    if (m && e.hand) {
                      o = !0;
                      for (const z of e.hand.values()) {
                        const k = t.getJointPose(z, n), P = this._getHandJoint(m, z);
                        k !== null && (P.matrix.fromArray(k.transform.matrix), P.matrix.decompose(P.position, P.rotation, P.scale), P.matrixWorldNeedsUpdate = !0, P.jointRadius = k.radius), P.visible = k !== null;
                      }
                      const _ = m.joints["index-finger-tip"], I = m.joints["thumb-tip"], B = _.position.distanceTo(I.position), L = 0.02, N = 5e-3;
                      m.inputState.pinching && B > L + N ? (m.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !m.inputState.pinching && B <= L - N && (m.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
                    } else
                      h !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (h.matrix.fromArray(r.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(r.linearVelocity)) : h.hasLinearVelocity = !1, r.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(r.angularVelocity)) : h.hasAngularVelocity = !1));
                    a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Jg)));
                  }
                  return a !== null && (a.visible = i !== null), h !== null && (h.visible = r !== null), m !== null && (m.visible = o !== null), this;
                }
                // private method
                _getHandJoint(e, t) {
                  if (e.joints[t.jointName] === void 0) {
                    const n = new xo();
                    n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
                  }
                  return e.joints[t.jointName];
                }
              }
              const Zg = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, $g = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
              class ev {
                constructor() {
                  this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
                }
                init(e, t, n) {
                  if (this.texture === null) {
                    const i = new Vi(), r = e.properties.get(i);
                    r.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
                  }
                }
                render(e, t) {
                  if (this.texture !== null) {
                    if (this.mesh === null) {
                      const n = t.cameras[0].viewport, i = new fs({ vertexShader: Zg, fragmentShader: $g, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: n.z }, depthHeight: { value: n.w } } });
                      this.mesh = new hr(new ia(20, 20), i);
                    }
                    e.render(this.mesh, t);
                  }
                }
                reset() {
                  this.texture = null, this.mesh = null;
                }
              }
              class tv extends Nr {
                constructor(e, t, n, i) {
                  super();
                  const r = this;
                  let o = null, a = 1;
                  var h = null;
                  let m = null, _ = "local-floor", I = 1, B = null, L = null;
                  var N = [];
                  let z = null, k = null, P = null, se = null;
                  const $ = new ev(), J = t.getContextAttributes();
                  let Le = null, Ee = null;
                  const Me = [], Re = [], Ae = new pt();
                  let ce = null;
                  const Ie = new mr();
                  Ie.layers.enable(1), Ie.viewport = new yi();
                  const Qe = new mr();
                  Qe.layers.enable(2), Qe.viewport = new yi();
                  const Ue = [Ie, Qe], He = new Wu();
                  He.layers.enable(1), He.layers.enable(2);
                  let Ze = null, dt = null;
                  this.cameraAutoUpdate = !0, this.layersEnabled = !1, this.enabled = !1, this.isPresenting = !1, this.isMultiview = !1, this.getCameraPose = function() {
                    return L;
                  }, this.getController = function(mt) {
                    let Gt = Me[mt];
                    return Gt === void 0 && (Gt = new Ku(), Me[mt] = Gt), Gt.getTargetRaySpace();
                  }, this.getControllerGrip = function(mt) {
                    let Gt = Me[mt];
                    return Gt === void 0 && (Gt = new Ku(), Me[mt] = Gt), Gt.getGripSpace();
                  }, this.getHand = function(mt) {
                    let Gt = Me[mt];
                    return Gt === void 0 && (Gt = new Ku(), Me[mt] = Gt), Gt.getHandSpace();
                  };
                  function Nt(mt) {
                    const Gt = Re.indexOf(mt.inputSource);
                    if (Gt === -1)
                      return;
                    const Ht = Me[Gt];
                    Ht !== void 0 && (Ht.update(mt.inputSource, mt.frame, B || m), Ht.dispatchEvent({ type: mt.type, data: mt.inputSource }));
                  }
                  function et() {
                    o.removeEventListener("select", Nt), o.removeEventListener("selectstart", Nt), o.removeEventListener("selectend", Nt), o.removeEventListener("squeeze", Nt), o.removeEventListener("squeezestart", Nt), o.removeEventListener("squeezeend", Nt), o.removeEventListener("end", et), o.removeEventListener("inputsourceschange", Lt);
                    for (let mt = 0; mt < Me.length; mt++) {
                      const Gt = Re[mt];
                      Gt !== null && (Re[mt] = null, Me[mt].disconnect(Gt));
                    }
                    Ze = null, dt = null, $.reset(), e.setRenderTarget(Le), P = null, k = null, z = null, o = null, Ee = null, An.stop(), r.isPresenting = !1, e.setPixelRatio(ce), e.setSize(Ae.width, Ae.height, !1), r.dispatchEvent({ type: "sessionend" });
                  }
                  this.setFramebufferScaleFactor = function(mt) {
                    a = mt, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
                  }, this.setReferenceSpaceType = function(mt) {
                    _ = mt, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
                  }, this.getReferenceSpace = function() {
                    return B || m;
                  }, this.setReferenceSpace = function(mt) {
                    B = mt;
                  }, this.getBaseLayer = function() {
                    return k !== null ? k : P;
                  }, this.getBinding = function() {
                    return z;
                  }, this.getFrame = function() {
                    return se;
                  }, this.getSession = function() {
                    return o;
                  }, this.setSession = async function(mt) {
                    if (o = mt, o !== null) {
                      if (Le = e.getRenderTarget(), o.addEventListener("select", Nt), o.addEventListener("selectstart", Nt), o.addEventListener("selectend", Nt), o.addEventListener("squeeze", Nt), o.addEventListener("squeezestart", Nt), o.addEventListener("squeezeend", Nt), o.addEventListener("end", et), o.addEventListener("inputsourceschange", Lt), J.xrCompatible !== !0 && await t.makeXRCompatible(), ce = e.getPixelRatio(), e.getSize(Ae), o.renderState.layers === void 0) {
                        const Gt = { antialias: J.antialias, alpha: !0, depth: J.depth, stencil: J.stencil, framebufferScaleFactor: a };
                        P = new XRWebGLLayer(o, t, Gt), o.updateRenderState({ baseLayer: P }), e.setPixelRatio(1), e.setSize(P.framebufferWidth, P.framebufferHeight, !1), Ee = new zr(P.framebufferWidth, P.framebufferHeight, { format: _e, type: Ii, colorSpace: e.outputColorSpace, stencilBuffer: J.stencil });
                      } else {
                        let Gt = null, Ht = null, ze = null;
                        J.depth && (ze = J.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, Gt = J.stencil ? rt : Ke, Ht = J.stencil ? zt : Fe), r.isMultiview = i && n.has("OCULUS_multiview");
                        const gt = { colorFormat: t.RGBA8, depthFormat: ze, scaleFactor: a };
                        r.isMultiview && (gt.textureType = "texture-array"), z = new XRWebGLBinding(o, t), k = z.createProjectionLayer(gt), o.updateRenderState({ layers: [k] }), e.setPixelRatio(1), e.setSize(k.textureWidth, k.textureHeight, !1);
                        const ot = { format: _e, type: Ii, depthTexture: new Qu(k.textureWidth, k.textureHeight, Ht, void 0, void 0, void 0, void 0, void 0, void 0, Gt), stencilBuffer: J.stencil, colorSpace: e.outputColorSpace, samples: J.antialias ? 4 : 0, resolveDepthBuffer: k.ignoreDepthValues === !1 };
                        if (r.isMultiview) {
                          const Bt = n.get("OCULUS_multiview");
                          this.maxNumViews = t.getParameter(Bt.MAX_VIEWS_OVR), Ee = new Fd(k.textureWidth, k.textureHeight, 2, ot);
                        } else
                          Ee = new zr(k.textureWidth, k.textureHeight, ot);
                      }
                      Ee.isXRRenderTarget = !0, this.setFoveation(I), B = null, m = await o.requestReferenceSpace(_), An.setContext(o), An.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" });
                    }
                  }, this.getEnvironmentBlendMode = function() {
                    if (o !== null)
                      return o.environmentBlendMode;
                  }, this.addLayer = function(mt) {
                    !window.XRWebGLBinding || !this.layersEnabled || !o || (N.push(mt), this.updateLayers());
                  }, this.removeLayer = function(mt) {
                    N.splice(N.indexOf(mt), 1), !(!window.XRWebGLBinding || !this.layersEnabled || !o) && this.updateLayers();
                  }, this.updateLayers = function() {
                    var mt = N.map(function(Gt) {
                      return Gt;
                    });
                    mt.unshift(o.renderState.layers[0]), o.updateRenderState({ layers: mt });
                  };
                  function Lt(mt) {
                    for (let Gt = 0; Gt < mt.removed.length; Gt++) {
                      const Ht = mt.removed[Gt], ze = Re.indexOf(Ht);
                      ze >= 0 && (Re[ze] = null, Me[ze].disconnect(Ht));
                    }
                    for (let Gt = 0; Gt < mt.added.length; Gt++) {
                      const Ht = mt.added[Gt];
                      let ze = Re.indexOf(Ht);
                      if (ze === -1) {
                        for (let ot = 0; ot < Me.length; ot++)
                          if (ot >= Re.length) {
                            Re.push(Ht), ze = ot;
                            break;
                          } else if (Re[ot] === null) {
                            Re[ot] = Ht, ze = ot;
                            break;
                          }
                        if (ze === -1) break;
                      }
                      const gt = Me[ze];
                      gt && gt.connect(Ht);
                    }
                  }
                  const Ot = new ye(), fn = new ye();
                  function ni(mt, Gt, Ht) {
                    Ot.setFromMatrixPosition(Gt.matrixWorld), fn.setFromMatrixPosition(Ht.matrixWorld);
                    const ze = Ot.distanceTo(fn), gt = Gt.projectionMatrix.elements, ot = Ht.projectionMatrix.elements, Bt = gt[14] / (gt[10] - 1), Tt = gt[14] / (gt[10] + 1), wt = (gt[9] + 1) / gt[5], Kt = (gt[9] - 1) / gt[5], nn = (gt[8] - 1) / gt[0], kn = (ot[8] + 1) / ot[0], zn = Bt * nn, wi = Bt * kn, er = ze / (-nn + kn), zi = er * -nn;
                    Gt.matrixWorld.decompose(mt.position, mt.quaternion, mt.scale), mt.translateX(zi), mt.translateZ(er), mt.matrixWorld.compose(mt.position, mt.quaternion, mt.scale), mt.matrixWorldInverse.copy(mt.matrixWorld).invert();
                    const Se = Bt + er, ue = Tt + er, it = zn - zi, At = wi + (ze - zi), yt = wt * Tt / ue * Se, vt = Kt * Tt / ue * Se;
                    mt.projectionMatrix.makePerspective(it, At, yt, vt, Se, ue), mt.projectionMatrixInverse.copy(mt.projectionMatrix).invert();
                  }
                  function Si(mt, Gt) {
                    Gt === null ? mt.matrixWorld.copy(mt.matrix) : mt.matrixWorld.multiplyMatrices(Gt.matrixWorld, mt.matrix), mt.matrixWorldInverse.copy(mt.matrixWorld).invert();
                  }
                  this.setPoseTarget = function(mt) {
                    mt !== void 0 && (h = mt);
                  }, this.updateCamera = function(mt) {
                    if (o === null) return;
                    $.texture !== null && (mt.near = $.depthNear, mt.far = $.depthFar), He.near = Qe.near = Ie.near = mt.near, He.far = Qe.far = Ie.far = mt.far, (Ze !== He.near || dt !== He.far) && (o.updateRenderState({ depthNear: He.near, depthFar: He.far }), Ze = He.near, dt = He.far, Ie.near = Ze, Ie.far = dt, Qe.near = Ze, Qe.far = dt, Ie.updateProjectionMatrix(), Qe.updateProjectionMatrix(), mt.updateProjectionMatrix());
                    const Gt = He.cameras;
                    var Ht = h || mt;
                    const ze = Ht.parent;
                    Si(He, ze);
                    for (let gt = 0; gt < Gt.length; gt++)
                      Si(Gt[gt], ze);
                    Gt.length === 2 ? ni(He, Ie, Qe) : He.projectionMatrix.copy(Ie.projectionMatrix), Hi(mt, He, Ht);
                  };
                  function Hi(mt, Gt, Ht) {
                    Gt.matrixWorld.decompose(Gt.position, Gt.quaternion, Gt.scale), Ht.parent === null ? Ht.matrix.copy(Gt.matrixWorld) : (Ht.matrix.copy(Ht.parent.matrixWorld), Ht.matrix.invert(), Ht.matrix.multiply(Gt.matrixWorld)), Ht.matrix.decompose(Ht.position, Ht.quaternion, Ht.scale), Ht.updateMatrixWorld(!0), mt.projectionMatrix.copy(Gt.projectionMatrix), mt.projectionMatrixInverse.copy(Gt.projectionMatrixInverse), mt.isPerspectiveCamera && (mt.fov = Hs * 2 * Math.atan(1 / mt.projectionMatrix.elements[5]), mt.zoom = 1);
                  }
                  this.getCamera = function() {
                    return He;
                  }, this.getFoveation = function() {
                    if (!(k === null && P === null))
                      return I;
                  }, this.setFoveation = function(mt) {
                    I = mt, k !== null && (k.fixedFoveation = mt), P !== null && P.fixedFoveation !== void 0 && (P.fixedFoveation = mt);
                  }, this.hasDepthSensing = function() {
                    return $.texture !== null;
                  };
                  let _i = null;
                  function Ui(mt, Gt) {
                    if (L = Gt.getViewerPose(B || m), se = Gt, L !== null) {
                      const Ht = L.views;
                      P !== null && (e.setRenderTargetFramebuffer(Ee, P.framebuffer), e.setRenderTarget(Ee));
                      let ze = !1;
                      Ht.length !== He.cameras.length && (He.cameras.length = 0, ze = !0);
                      for (let ot = 0; ot < Ht.length; ot++) {
                        const Bt = Ht[ot];
                        let Tt = null;
                        if (P !== null)
                          Tt = P.getViewport(Bt);
                        else {
                          const Kt = z.getViewSubImage(k, Bt);
                          Tt = Kt.viewport, ot === 0 && (e.setRenderTargetTextures(Ee, Kt.colorTexture, k.ignoreDepthValues ? void 0 : Kt.depthStencilTexture), e.setRenderTarget(Ee));
                        }
                        let wt = Ue[ot];
                        wt === void 0 && (wt = new mr(), wt.layers.enable(ot), wt.viewport = new yi(), Ue[ot] = wt), wt.matrix.fromArray(Bt.transform.matrix), wt.matrix.decompose(wt.position, wt.quaternion, wt.scale), wt.projectionMatrix.fromArray(Bt.projectionMatrix), wt.projectionMatrixInverse.copy(wt.projectionMatrix).invert(), wt.viewport.set(Tt.x, Tt.y, Tt.width, Tt.height), ot === 0 && (He.matrix.copy(wt.matrix), He.matrix.decompose(He.position, He.quaternion, He.scale)), ze === !0 && He.cameras.push(wt);
                      }
                      const gt = o.enabledFeatures;
                      if (gt && gt.includes("depth-sensing")) {
                        const ot = z.getDepthInformation(Ht[0]);
                        ot && ot.isValid && ot.texture && $.init(e, ot, o.renderState);
                      }
                    }
                    for (let Ht = 0; Ht < Me.length; Ht++) {
                      const ze = Re[Ht], gt = Me[Ht];
                      ze !== null && gt !== void 0 && gt.update(ze, Gt, B || m);
                    }
                    $.render(e, He), _i && _i(mt, Gt), Gt.detectedPlanes && r.dispatchEvent({ type: "planesdetected", data: Gt }), se = null;
                  }
                  const An = new Du();
                  An.setAnimationLoop(Ui), this.setAnimationLoop = function(mt) {
                    _i = mt;
                  }, this.dispose = function() {
                  };
                }
              }
              const bo = /* @__PURE__ */ new $r(), nv = /* @__PURE__ */ new pn();
              function iv(s, e) {
                function t(k, P) {
                  k.matrixAutoUpdate === !0 && k.updateMatrix(), P.value.copy(k.matrix);
                }
                function n(k, P) {
                  P.color.getRGB(k.fogColor.value, ed(s)), P.isFog ? (k.fogNear.value = P.near, k.fogFar.value = P.far) : P.isFogExp2 && (k.fogDensity.value = P.density);
                }
                function i(k, P, se, $, J) {
                  P.isMeshBasicMaterial || P.isMeshLambertMaterial ? r(k, P) : P.isMeshToonMaterial ? (r(k, P), I(k, P)) : P.isMeshPhongMaterial ? (r(k, P), _(k, P)) : P.isMeshStandardMaterial ? (r(k, P), B(k, P), P.isMeshPhysicalMaterial && L(k, P, J)) : P.isMeshMatcapMaterial ? (r(k, P), N(k, P)) : P.isMeshDepthMaterial ? r(k, P) : P.isMeshDistanceMaterial ? (r(k, P), z(k, P)) : P.isMeshNormalMaterial ? r(k, P) : P.isLineBasicMaterial ? (o(k, P), P.isLineDashedMaterial && a(k, P)) : P.isPointsMaterial ? h(k, P, se, $) : P.isSpriteMaterial ? m(k, P) : P.isShadowMaterial ? (k.color.value.copy(P.color), k.opacity.value = P.opacity) : P.isShaderMaterial && (P.uniformsNeedUpdate = !1);
                }
                function r(k, P) {
                  k.opacity.value = P.opacity, P.color && k.diffuse.value.copy(P.color), P.emissive && k.emissive.value.copy(P.emissive).multiplyScalar(P.emissiveIntensity), P.map && (k.map.value = P.map, t(P.map, k.mapTransform)), P.alphaMap && (k.alphaMap.value = P.alphaMap, t(P.alphaMap, k.alphaMapTransform)), P.bumpMap && (k.bumpMap.value = P.bumpMap, t(P.bumpMap, k.bumpMapTransform), k.bumpScale.value = P.bumpScale, P.side === x && (k.bumpScale.value *= -1)), P.normalMap && (k.normalMap.value = P.normalMap, t(P.normalMap, k.normalMapTransform), k.normalScale.value.copy(P.normalScale), P.side === x && k.normalScale.value.negate()), P.displacementMap && (k.displacementMap.value = P.displacementMap, t(P.displacementMap, k.displacementMapTransform), k.displacementScale.value = P.displacementScale, k.displacementBias.value = P.displacementBias), P.emissiveMap && (k.emissiveMap.value = P.emissiveMap, t(P.emissiveMap, k.emissiveMapTransform)), P.specularMap && (k.specularMap.value = P.specularMap, t(P.specularMap, k.specularMapTransform)), P.alphaTest > 0 && (k.alphaTest.value = P.alphaTest);
                  const se = e.get(P), $ = se.envMap, J = se.envMapRotation;
                  if ($ && (k.envMap.value = $, bo.copy(J), bo.x *= -1, bo.y *= -1, bo.z *= -1, $.isCubeTexture && $.isRenderTargetTexture === !1 && (bo.y *= -1, bo.z *= -1), k.envMapRotation.value.setFromMatrix4(nv.makeRotationFromEuler(bo)), k.flipEnvMap.value = $.isCubeTexture && $.isRenderTargetTexture === !1 ? -1 : 1, k.reflectivity.value = P.reflectivity, k.ior.value = P.ior, k.refractionRatio.value = P.refractionRatio), P.lightMap) {
                    k.lightMap.value = P.lightMap;
                    const Le = s._useLegacyLights === !0 ? Math.PI : 1;
                    k.lightMapIntensity.value = P.lightMapIntensity * Le, t(P.lightMap, k.lightMapTransform);
                  }
                  P.aoMap && (k.aoMap.value = P.aoMap, k.aoMapIntensity.value = P.aoMapIntensity, t(P.aoMap, k.aoMapTransform));
                }
                function o(k, P) {
                  k.diffuse.value.copy(P.color), k.opacity.value = P.opacity, P.map && (k.map.value = P.map, t(P.map, k.mapTransform));
                }
                function a(k, P) {
                  k.dashSize.value = P.dashSize, k.totalSize.value = P.dashSize + P.gapSize, k.scale.value = P.scale;
                }
                function h(k, P, se, $) {
                  k.diffuse.value.copy(P.color), k.opacity.value = P.opacity, k.size.value = P.size * se, k.scale.value = $ * 0.5, P.map && (k.map.value = P.map, t(P.map, k.uvTransform)), P.alphaMap && (k.alphaMap.value = P.alphaMap, t(P.alphaMap, k.alphaMapTransform)), P.alphaTest > 0 && (k.alphaTest.value = P.alphaTest);
                }
                function m(k, P) {
                  k.diffuse.value.copy(P.color), k.opacity.value = P.opacity, k.rotation.value = P.rotation, P.map && (k.map.value = P.map, t(P.map, k.mapTransform)), P.alphaMap && (k.alphaMap.value = P.alphaMap, t(P.alphaMap, k.alphaMapTransform)), P.alphaTest > 0 && (k.alphaTest.value = P.alphaTest);
                }
                function _(k, P) {
                  k.specular.value.copy(P.specular), k.shininess.value = Math.max(P.shininess, 1e-4);
                }
                function I(k, P) {
                  P.gradientMap && (k.gradientMap.value = P.gradientMap);
                }
                function B(k, P) {
                  k.metalness.value = P.metalness, P.metalnessMap && (k.metalnessMap.value = P.metalnessMap, t(P.metalnessMap, k.metalnessMapTransform)), k.roughness.value = P.roughness, P.roughnessMap && (k.roughnessMap.value = P.roughnessMap, t(P.roughnessMap, k.roughnessMapTransform)), P.envMap && (k.envMapIntensity.value = P.envMapIntensity);
                }
                function L(k, P, se) {
                  k.ior.value = P.ior, P.sheen > 0 && (k.sheenColor.value.copy(P.sheenColor).multiplyScalar(P.sheen), k.sheenRoughness.value = P.sheenRoughness, P.sheenColorMap && (k.sheenColorMap.value = P.sheenColorMap, t(P.sheenColorMap, k.sheenColorMapTransform)), P.sheenRoughnessMap && (k.sheenRoughnessMap.value = P.sheenRoughnessMap, t(P.sheenRoughnessMap, k.sheenRoughnessMapTransform))), P.clearcoat > 0 && (k.clearcoat.value = P.clearcoat, k.clearcoatRoughness.value = P.clearcoatRoughness, P.clearcoatMap && (k.clearcoatMap.value = P.clearcoatMap, t(P.clearcoatMap, k.clearcoatMapTransform)), P.clearcoatRoughnessMap && (k.clearcoatRoughnessMap.value = P.clearcoatRoughnessMap, t(P.clearcoatRoughnessMap, k.clearcoatRoughnessMapTransform)), P.clearcoatNormalMap && (k.clearcoatNormalMap.value = P.clearcoatNormalMap, t(P.clearcoatNormalMap, k.clearcoatNormalMapTransform), k.clearcoatNormalScale.value.copy(P.clearcoatNormalScale), P.side === x && k.clearcoatNormalScale.value.negate())), P.dispersion > 0 && (k.dispersion.value = P.dispersion), P.iridescence > 0 && (k.iridescence.value = P.iridescence, k.iridescenceIOR.value = P.iridescenceIOR, k.iridescenceThicknessMinimum.value = P.iridescenceThicknessRange[0], k.iridescenceThicknessMaximum.value = P.iridescenceThicknessRange[1], P.iridescenceMap && (k.iridescenceMap.value = P.iridescenceMap, t(P.iridescenceMap, k.iridescenceMapTransform)), P.iridescenceThicknessMap && (k.iridescenceThicknessMap.value = P.iridescenceThicknessMap, t(P.iridescenceThicknessMap, k.iridescenceThicknessMapTransform))), P.transmission > 0 && (k.transmission.value = P.transmission, k.transmissionSamplerMap.value = se.texture, k.transmissionSamplerSize.value.set(se.width, se.height), P.transmissionMap && (k.transmissionMap.value = P.transmissionMap, t(P.transmissionMap, k.transmissionMapTransform)), k.thickness.value = P.thickness, P.thicknessMap && (k.thicknessMap.value = P.thicknessMap, t(P.thicknessMap, k.thicknessMapTransform)), k.attenuationDistance.value = P.attenuationDistance, k.attenuationColor.value.copy(P.attenuationColor)), P.anisotropy > 0 && (k.anisotropyVector.value.set(P.anisotropy * Math.cos(P.anisotropyRotation), P.anisotropy * Math.sin(P.anisotropyRotation)), P.anisotropyMap && (k.anisotropyMap.value = P.anisotropyMap, t(P.anisotropyMap, k.anisotropyMapTransform))), k.specularIntensity.value = P.specularIntensity, k.specularColor.value.copy(P.specularColor), P.specularColorMap && (k.specularColorMap.value = P.specularColorMap, t(P.specularColorMap, k.specularColorMapTransform)), P.specularIntensityMap && (k.specularIntensityMap.value = P.specularIntensityMap, t(P.specularIntensityMap, k.specularIntensityMapTransform));
                }
                function N(k, P) {
                  P.matcap && (k.matcap.value = P.matcap);
                }
                function z(k, P) {
                  const se = e.get(P).light;
                  k.referencePosition.value.setFromMatrixPosition(se.matrixWorld), k.nearDistance.value = se.shadow.camera.near, k.farDistance.value = se.shadow.camera.far;
                }
                return { refreshFogUniforms: n, refreshMaterialUniforms: i };
              }
              function rv(s, e, t, n) {
                let i = {}, r = {}, o = [];
                const a = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
                function h(se, $) {
                  const J = $.program;
                  n.uniformBlockBinding(se, J);
                }
                function m(se, $) {
                  let J = i[se.id];
                  J === void 0 && (N(se), J = _(se), i[se.id] = J, se.addEventListener("dispose", k));
                  const Le = $.program;
                  n.updateUBOMapping(se, Le);
                  const Ee = e.render.frame;
                  r[se.id] !== Ee && (B(se), r[se.id] = Ee);
                }
                function _(se) {
                  const $ = I();
                  se.__bindingPointIndex = $;
                  const J = s.createBuffer(), Le = se.__size, Ee = se.usage;
                  return s.bindBuffer(s.UNIFORM_BUFFER, J), s.bufferData(s.UNIFORM_BUFFER, Le, Ee), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, $, J), J;
                }
                function I() {
                  for (let se = 0; se < a; se++)
                    if (o.indexOf(se) === -1)
                      return o.push(se), se;
                  return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
                }
                function B(se) {
                  const $ = i[se.id], J = se.uniforms, Le = se.__cache;
                  s.bindBuffer(s.UNIFORM_BUFFER, $);
                  for (let Ee = 0, Me = J.length; Ee < Me; Ee++) {
                    const Re = Array.isArray(J[Ee]) ? J[Ee] : [J[Ee]];
                    for (let Ae = 0, ce = Re.length; Ae < ce; Ae++) {
                      const Ie = Re[Ae];
                      if (L(Ie, Ee, Ae, Le) === !0) {
                        const Qe = Ie.__offset, Ue = Array.isArray(Ie.value) ? Ie.value : [Ie.value];
                        let He = 0;
                        for (let Ze = 0; Ze < Ue.length; Ze++) {
                          const dt = Ue[Ze], Nt = z(dt);
                          typeof dt == "number" || typeof dt == "boolean" ? (Ie.__data[0] = dt, s.bufferSubData(s.UNIFORM_BUFFER, Qe + He, Ie.__data)) : dt.isMatrix3 ? (Ie.__data[0] = dt.elements[0], Ie.__data[1] = dt.elements[1], Ie.__data[2] = dt.elements[2], Ie.__data[3] = 0, Ie.__data[4] = dt.elements[3], Ie.__data[5] = dt.elements[4], Ie.__data[6] = dt.elements[5], Ie.__data[7] = 0, Ie.__data[8] = dt.elements[6], Ie.__data[9] = dt.elements[7], Ie.__data[10] = dt.elements[8], Ie.__data[11] = 0) : (dt.toArray(Ie.__data, He), He += Nt.storage / Float32Array.BYTES_PER_ELEMENT);
                        }
                        s.bufferSubData(s.UNIFORM_BUFFER, Qe, Ie.__data);
                      }
                    }
                  }
                  s.bindBuffer(s.UNIFORM_BUFFER, null);
                }
                function L(se, $, J, Le) {
                  const Ee = se.value, Me = $ + "_" + J;
                  if (Le[Me] === void 0)
                    return typeof Ee == "number" || typeof Ee == "boolean" ? Le[Me] = Ee : Le[Me] = Ee.clone(), !0;
                  {
                    const Re = Le[Me];
                    if (typeof Ee == "number" || typeof Ee == "boolean") {
                      if (Re !== Ee)
                        return Le[Me] = Ee, !0;
                    } else if (Re.equals(Ee) === !1)
                      return Re.copy(Ee), !0;
                  }
                  return !1;
                }
                function N(se) {
                  const $ = se.uniforms;
                  let J = 0;
                  const Le = 16;
                  for (let Me = 0, Re = $.length; Me < Re; Me++) {
                    const Ae = Array.isArray($[Me]) ? $[Me] : [$[Me]];
                    for (let ce = 0, Ie = Ae.length; ce < Ie; ce++) {
                      const Qe = Ae[ce], Ue = Array.isArray(Qe.value) ? Qe.value : [Qe.value];
                      for (let He = 0, Ze = Ue.length; He < Ze; He++) {
                        const dt = Ue[He], Nt = z(dt), et = J % Le;
                        et !== 0 && Le - et < Nt.boundary && (J += Le - et), Qe.__data = new Float32Array(Nt.storage / Float32Array.BYTES_PER_ELEMENT), Qe.__offset = J, J += Nt.storage;
                      }
                    }
                  }
                  const Ee = J % Le;
                  return Ee > 0 && (J += Le - Ee), se.__size = J, se.__cache = {}, this;
                }
                function z(se) {
                  const $ = {
                    boundary: 0,
                    // bytes
                    storage: 0
                    // bytes
                  };
                  return typeof se == "number" || typeof se == "boolean" ? ($.boundary = 4, $.storage = 4) : se.isVector2 ? ($.boundary = 8, $.storage = 8) : se.isVector3 || se.isColor ? ($.boundary = 16, $.storage = 12) : se.isVector4 ? ($.boundary = 16, $.storage = 16) : se.isMatrix3 ? ($.boundary = 48, $.storage = 48) : se.isMatrix4 ? ($.boundary = 64, $.storage = 64) : se.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", se), $;
                }
                function k(se) {
                  const $ = se.target;
                  $.removeEventListener("dispose", k);
                  const J = o.indexOf($.__bindingPointIndex);
                  o.splice(J, 1), s.deleteBuffer(i[$.id]), delete i[$.id], delete r[$.id];
                }
                function P() {
                  for (const se in i)
                    s.deleteBuffer(i[se]);
                  o = [], i = {}, r = {};
                }
                return { bind: h, update: m, dispose: P };
              }
              class sv {
                constructor(e = {}) {
                  const { canvas: t = hl(), context: n = null, depth: i = !0, stencil: r = !1, alpha: o = !1, antialias: a = !1, premultipliedAlpha: h = !0, preserveDrawingBuffer: m = !1, powerPreference: _ = "default", failIfMajorPerformanceCaveat: I = !1, multiviewStereo: B = !1 } = e;
                  this.isWebGLRenderer = !0;
                  let L;
                  if (n !== null) {
                    if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                      throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                    L = n.getContextAttributes().alpha;
                  } else
                    L = o;
                  const N = new Uint32Array(4), z = new Int32Array(4);
                  let k = null, P = null;
                  const se = [], $ = [];
                  this.domElement = t, this.debug = {
                    /**
                    * Enables error checking and reporting when shader programs are being compiled
                    * @type {boolean}
                    */
                    checkShaderErrors: !0,
                    /**
                    * Callback for custom error reporting.
                    * @type {?Function}
                    */
                    onShaderError: null
                  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = mi, this._useLegacyLights = !1, this.toneMapping = $t, this.toneMappingExposure = 1;
                  const J = this;
                  let Le = !1, Ee = 0, Me = 0, Re = null, Ae = -1, ce = null;
                  const Ie = new yi(), Qe = new yi();
                  let Ue = null;
                  const He = new sn(0);
                  let Ze = 0, dt = t.width, Nt = t.height, et = 1, Lt = null, Ot = null;
                  const fn = new yi(0, 0, dt, Nt), ni = new yi(0, 0, dt, Nt);
                  let Si = !1;
                  const Hi = new Ia();
                  let _i = !1, Ui = !1;
                  const An = new pn(), mt = new ye(), Gt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
                  function Ht() {
                    return Re === null ? et : 1;
                  }
                  let ze = n;
                  function gt(ve, We) {
                    return t.getContext(ve, We);
                  }
                  try {
                    const ve = { alpha: !0, depth: i, stencil: r, antialias: a, premultipliedAlpha: h, preserveDrawingBuffer: m, powerPreference: _, failIfMajorPerformanceCaveat: I };
                    if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${C}`), t.addEventListener("webglcontextlost", Ft, !1), t.addEventListener("webglcontextrestored", yn, !1), t.addEventListener("webglcontextcreationerror", en, !1), ze === null) {
                      const We = "webgl2";
                      if (ze = gt(We, ve), ze === null)
                        throw gt(We) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    }
                  } catch (ve) {
                    throw console.error("THREE.WebGLRenderer: " + ve.message), ve;
                  }
                  let ot, Bt, Tt, wt, Kt, nn, kn, zn, wi, er, zi, Se, ue, it, At, yt, vt, En, kt, on, Li, an, xn, Zn, Pn;
                  function Pe() {
                    ot = new A0(ze), ot.init(), xn = new Ld(ze, ot), Bt = new c0(ze, ot, e, xn), Tt = new Xg(ze), wt = new v0(ze), Kt = new Fg(), nn = new Yg(ze, ot, Tt, Kt, Bt, xn, wt), kn = new h0(J), zn = new p0(J), wi = new sA(ze), Zn = new a0(ze, wi), er = new m0(ze, wi, wt, Zn), zi = new C0(ze, er, wi, wt), on = new E0(ze, Bt, nn), yt = new u0(Kt), Se = new Og(J, kn, zn, ot, Bt, Zn, yt), ue = new iv(J, Kt), it = new Ng(), At = new zg(ot), kt = new o0(J, kn, zn, Tt, zi, L, h), En = new y0(J, ot, ze), vt = new Kg(J, zi, Bt), Pn = new rv(ze, wt, Bt, Tt), Li = new l0(ze, ot, wt), an = new g0(ze, ot, wt), wt.programs = Se.programs, J.capabilities = Bt, J.extensions = ot, J.properties = Kt, J.renderLists = it, J.shadowMap = vt, J.state = Tt, J.info = wt;
                  }
                  Pe();
                  const Mt = typeof navigator < "u" && "xr" in navigator ? new tv(J, ze, ot, B) : new Od(J);
                  this.xr = Mt, this.getContext = function() {
                    return ze;
                  }, this.getContextAttributes = function() {
                    return ze.getContextAttributes();
                  }, this.forceContextLoss = function() {
                    const ve = ot.get("WEBGL_lose_context");
                    ve && ve.loseContext();
                  }, this.forceContextRestore = function() {
                    const ve = ot.get("WEBGL_lose_context");
                    ve && ve.restoreContext();
                  }, this.getPixelRatio = function() {
                    return et;
                  }, this.setPixelRatio = function(ve) {
                    ve !== void 0 && (et = ve, this.setSize(dt, Nt, !1));
                  }, this.getSize = function(ve) {
                    return ve.set(dt, Nt);
                  }, this.setSize = function(ve, We, $e = !0) {
                    if (Mt.isPresenting) {
                      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                      return;
                    }
                    dt = ve, Nt = We, t.width = Math.floor(ve * et), t.height = Math.floor(We * et), $e === !0 && (t.style.width = ve + "px", t.style.height = We + "px"), this.setViewport(0, 0, ve, We);
                  }, this.getDrawingBufferSize = function(ve) {
                    return ve.set(dt * et, Nt * et).floor();
                  }, this.setDrawingBufferSize = function(ve, We, $e) {
                    dt = ve, Nt = We, et = $e, t.width = Math.floor(ve * $e), t.height = Math.floor(We * $e), this.setViewport(0, 0, ve, We);
                  }, this.getCurrentViewport = function(ve) {
                    return ve.copy(Ie);
                  }, this.getViewport = function(ve) {
                    return ve.copy(fn);
                  }, this.setViewport = function(ve, We, $e, qe) {
                    ve.isVector4 ? fn.set(ve.x, ve.y, ve.z, ve.w) : fn.set(ve, We, $e, qe), Tt.viewport(Ie.copy(fn).multiplyScalar(et).round());
                  }, this.getScissor = function(ve) {
                    return ve.copy(ni);
                  }, this.setScissor = function(ve, We, $e, qe) {
                    ve.isVector4 ? ni.set(ve.x, ve.y, ve.z, ve.w) : ni.set(ve, We, $e, qe), Tt.scissor(Qe.copy(ni).multiplyScalar(et).round());
                  }, this.getScissorTest = function() {
                    return Si;
                  }, this.setScissorTest = function(ve) {
                    Tt.setScissorTest(Si = ve);
                  }, this.setOpaqueSort = function(ve) {
                    Lt = ve;
                  }, this.setTransparentSort = function(ve) {
                    Ot = ve;
                  }, this.getClearColor = function(ve) {
                    return ve.copy(kt.getClearColor());
                  }, this.setClearColor = function() {
                    kt.setClearColor.apply(kt, arguments);
                  }, this.getClearAlpha = function() {
                    return kt.getClearAlpha();
                  }, this.setClearAlpha = function() {
                    kt.setClearAlpha.apply(kt, arguments);
                  }, this.clear = function(ve = !0, We = !0, $e = !0) {
                    let qe = 0;
                    if (ve) {
                      let Je = !1;
                      if (Re !== null) {
                        const Zt = Re.texture.format;
                        Je = Zt === mn || Zt === at || Zt === ln;
                      }
                      if (Je) {
                        const Zt = Re.texture.type, bn = Zt === Ii || Zt === Fe || Zt === Cr || Zt === zt || Zt === Ut || Zt === hn, Sn = kt.getClearColor(), Un = kt.getClearAlpha(), Xn = Sn.r, ii = Sn.g, ci = Sn.b;
                        bn ? (N[0] = Xn, N[1] = ii, N[2] = ci, N[3] = Un, ze.clearBufferuiv(ze.COLOR, 0, N)) : (z[0] = Xn, z[1] = ii, z[2] = ci, z[3] = Un, ze.clearBufferiv(ze.COLOR, 0, z));
                      } else
                        qe |= ze.COLOR_BUFFER_BIT;
                    }
                    We && (qe |= ze.DEPTH_BUFFER_BIT), $e && (qe |= ze.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ze.clear(qe);
                  }, this.clearColor = function() {
                    this.clear(!0, !1, !1);
                  }, this.clearDepth = function() {
                    this.clear(!1, !0, !1);
                  }, this.clearStencil = function() {
                    this.clear(!1, !1, !0);
                  }, this.dispose = function() {
                    t.removeEventListener("webglcontextlost", Ft, !1), t.removeEventListener("webglcontextrestored", yn, !1), t.removeEventListener("webglcontextcreationerror", en, !1), it.dispose(), At.dispose(), Kt.dispose(), kn.dispose(), zn.dispose(), zi.dispose(), Zn.dispose(), Pn.dispose(), Se.dispose(), Mt.dispose(), Mt.removeEventListener("sessionstart", ws), Mt.removeEventListener("sessionend", _p), Fo.stop();
                  };
                  function Ft(ve) {
                    ve.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), Le = !0;
                  }
                  function yn() {
                    console.log("THREE.WebGLRenderer: Context Restored."), Le = !1;
                    const ve = wt.autoReset, We = vt.enabled, $e = vt.autoUpdate, qe = vt.needsUpdate, Je = vt.type;
                    Pe(), wt.autoReset = ve, vt.enabled = We, vt.autoUpdate = $e, vt.needsUpdate = qe, vt.type = Je;
                  }
                  function en(ve) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ve.statusMessage);
                  }
                  function $n(ve) {
                    const We = ve.target;
                    We.removeEventListener("dispose", $n), tn(We);
                  }
                  function tn(ve) {
                    Xt(ve), Kt.remove(ve);
                  }
                  function Xt(ve) {
                    const We = Kt.get(ve).programs;
                    We !== void 0 && (We.forEach(function($e) {
                      Se.releaseProgram($e);
                    }), ve.isShaderMaterial && Se.releaseShaderCache(ve));
                  }
                  this.renderBufferDirect = function(ve, We, $e, qe, Je, Zt) {
                    We === null && (We = Gt);
                    const bn = Je.isMesh && Je.matrixWorld.determinant() < 0, Sn = $E(ve, We, $e, qe, Je);
                    Tt.setMaterial(qe, bn);
                    let Un = $e.index, Xn = 1;
                    if (qe.wireframe === !0) {
                      if (Un = er.getWireframeAttribute($e), Un === void 0) return;
                      Xn = 2;
                    }
                    const ii = $e.drawRange, ci = $e.attributes.position;
                    let dr = ii.start * Xn, Fr = (ii.start + ii.count) * Xn;
                    Zt !== null && (dr = Math.max(dr, Zt.start * Xn), Fr = Math.min(Fr, (Zt.start + Zt.count) * Xn)), Un !== null ? (dr = Math.max(dr, 0), Fr = Math.min(Fr, Un.count)) : ci != null && (dr = Math.max(dr, 0), Fr = Math.min(Fr, ci.count));
                    const ns = Fr - dr;
                    if (ns < 0 || ns === 1 / 0) return;
                    Zn.setup(Je, qe, Sn, $e, Un);
                    let so, Ti = Li;
                    if (Un !== null && (so = wi.get(Un), Ti = an, Ti.setIndex(so)), Je.isMesh)
                      qe.wireframe === !0 ? (Tt.setLineWidth(qe.wireframeLinewidth * Ht()), Ti.setMode(ze.LINES)) : Ti.setMode(ze.TRIANGLES);
                    else if (Je.isLine) {
                      let Qs = qe.linewidth;
                      Qs === void 0 && (Qs = 1), Tt.setLineWidth(Qs * Ht()), Je.isLineSegments ? Ti.setMode(ze.LINES) : Je.isLineLoop ? Ti.setMode(ze.LINE_LOOP) : Ti.setMode(ze.LINE_STRIP);
                    } else Je.isPoints ? Ti.setMode(ze.POINTS) : Je.isSprite && Ti.setMode(ze.TRIANGLES);
                    if (Je.isBatchedMesh)
                      Je._multiDrawInstances !== null ? Ti.renderMultiDrawInstances(Je._multiDrawStarts, Je._multiDrawCounts, Je._multiDrawCount, Je._multiDrawInstances) : Ti.renderMultiDraw(Je._multiDrawStarts, Je._multiDrawCounts, Je._multiDrawCount);
                    else if (Je.isInstancedMesh)
                      Ti.renderInstances(dr, ns, Je.count);
                    else if ($e.isInstancedBufferGeometry) {
                      const Qs = $e._maxInstanceCount !== void 0 ? $e._maxInstanceCount : 1 / 0, oi = Math.min($e.instanceCount, Qs);
                      Ti.renderInstances(dr, ns, oi);
                    } else
                      Ti.render(dr, ns);
                  };
                  function si(ve, We, $e) {
                    ve.transparent === !0 && ve.side === T && ve.forceSinglePass === !1 ? (ve.side = x, ve.needsUpdate = !0, Dc(ve, We, $e), ve.side = f, ve.needsUpdate = !0, Dc(ve, We, $e), ve.side = T) : Dc(ve, We, $e);
                  }
                  this.compile = function(ve, We, $e = null) {
                    $e === null && ($e = ve), P = At.get($e), P.init(We), $.push(P), $e.traverseVisible(function(Je) {
                      Je.isLight && Je.layers.test(We.layers) && (P.pushLight(Je), Je.castShadow && P.pushShadow(Je));
                    }), ve !== $e && ve.traverseVisible(function(Je) {
                      Je.isLight && Je.layers.test(We.layers) && (P.pushLight(Je), Je.castShadow && P.pushShadow(Je));
                    }), P.setupLights(J._useLegacyLights);
                    const qe = /* @__PURE__ */ new Set();
                    return ve.traverse(function(Je) {
                      const Zt = Je.material;
                      if (Zt)
                        if (Array.isArray(Zt))
                          for (let bn = 0; bn < Zt.length; bn++) {
                            const Sn = Zt[bn];
                            si(Sn, $e, Je), qe.add(Sn);
                          }
                        else
                          si(Zt, $e, Je), qe.add(Zt);
                    }), $.pop(), P = null, qe;
                  }, this.compileAsync = function(ve, We, $e = null) {
                    const qe = this.compile(ve, We, $e);
                    return new Promise((Je) => {
                      function Zt() {
                        if (qe.forEach(function(bn) {
                          Kt.get(bn).currentProgram.isReady() && qe.delete(bn);
                        }), qe.size === 0) {
                          Je(ve);
                          return;
                        }
                        setTimeout(Zt, 10);
                      }
                      ot.get("KHR_parallel_shader_compile") !== null ? Zt() : setTimeout(Zt, 10);
                    });
                  };
                  let Fn = null;
                  function Er(ve) {
                    Fn && Fn(ve);
                  }
                  function ws() {
                    Fo.stop();
                  }
                  function _p() {
                    Fo.start();
                  }
                  const Fo = new Du();
                  Fo.setAnimationLoop(Er), typeof self < "u" && Fo.setContext(self), this.setAnimationLoop = function(ve) {
                    Fn = ve, Mt.setAnimationLoop(ve), ve === null ? Fo.stop() : Fo.start();
                  }, Mt.addEventListener("sessionstart", ws), Mt.addEventListener("sessionend", _p), this.render = function(ve, We) {
                    if (We !== void 0 && We.isCamera !== !0) {
                      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                      return;
                    }
                    if (Le === !0) return;
                    ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), We.parent === null && We.matrixWorldAutoUpdate === !0 && We.updateMatrixWorld(), Mt.enabled === !0 && Mt.isPresenting === !0 && (Mt.cameraAutoUpdate === !0 && Mt.updateCamera(We), We = Mt.getCamera()), ve.isScene === !0 && ve.onBeforeRender(J, ve, We, Re), P = At.get(ve, $.length), P.init(We), $.push(P), An.multiplyMatrices(We.projectionMatrix, We.matrixWorldInverse), Hi.setFromProjectionMatrix(An), Ui = this.localClippingEnabled, _i = yt.init(this.clippingPlanes, Ui), k = it.get(ve, se.length), k.init(), se.push(k), wp(ve, We, 0, J.sortObjects), k.finish(), J.sortObjects === !0 && k.sort(Lt, Ot);
                    const $e = Mt.enabled === !1 || Mt.isPresenting === !1 || Mt.hasDepthSensing() === !1;
                    $e && kt.addToRenderList(k, ve), this.info.render.frame++, _i === !0 && yt.beginShadows();
                    const qe = P.state.shadowsArray;
                    vt.render(qe, ve, We), _i === !0 && yt.endShadows(), this.info.autoReset === !0 && this.info.reset();
                    const Je = k.opaque, Zt = k.transmissive;
                    if (P.setupLights(J._useLegacyLights), We.isArrayCamera) {
                      const bn = We.cameras;
                      if (Zt.length > 0)
                        for (let Sn = 0, Un = bn.length; Sn < Un; Sn++) {
                          const Xn = bn[Sn];
                          Mp(Je, Zt, ve, Xn);
                        }
                      if ($e && kt.render(ve), Mt.enabled && Mt.isMultiview)
                        nn.setDeferTextureUploads(!0), Dh(k, ve, We, We.cameras[0].viewport);
                      else
                        for (let Sn = 0, Un = bn.length; Sn < Un; Sn++) {
                          const Xn = bn[Sn];
                          Dh(k, ve, Xn, Xn.viewport);
                        }
                    } else
                      Zt.length > 0 && Mp(Je, Zt, ve, We), $e && kt.render(ve), Dh(k, ve, We);
                    Re !== null && (nn.updateMultisampleRenderTarget(Re), nn.updateRenderTargetMipmap(Re)), ve.isScene === !0 && ve.onAfterRender(J, ve, We), nn.runDeferredUploads(), Mt.enabled && Mt.submitFrame && Mt.submitFrame(), Zn.resetDefaultState(), Ae = -1, ce = null, $.pop(), $.length > 0 ? (P = $[$.length - 1], _i === !0 && yt.setGlobalState(J.clippingPlanes, P.state.camera)) : P = null, se.pop(), se.length > 0 ? k = se[se.length - 1] : k = null;
                  };
                  function wp(ve, We, $e, qe) {
                    if (ve.visible === !1) return;
                    if (ve.layers.test(We.layers)) {
                      if (ve.isGroup)
                        $e = ve.renderOrder;
                      else if (ve.isLOD)
                        ve.autoUpdate === !0 && ve.update(We);
                      else if (ve.isLight)
                        P.pushLight(ve), ve.castShadow && P.pushShadow(ve);
                      else if (ve.isSprite) {
                        if (!ve.frustumCulled || Hi.intersectsSprite(ve)) {
                          qe && mt.setFromMatrixPosition(ve.matrixWorld).applyMatrix4(An);
                          const bn = zi.update(ve), Sn = ve.material;
                          Sn.visible && k.push(ve, bn, Sn, $e, mt.z, null);
                        }
                      } else if ((ve.isMesh || ve.isLine || ve.isPoints) && (!ve.frustumCulled || Hi.intersectsObject(ve))) {
                        const bn = zi.update(ve), Sn = ve.material;
                        if (qe && (ve.boundingSphere !== void 0 ? (ve.boundingSphere === null && ve.computeBoundingSphere(), mt.copy(ve.boundingSphere.center)) : (bn.boundingSphere === null && bn.computeBoundingSphere(), mt.copy(bn.boundingSphere.center)), mt.applyMatrix4(ve.matrixWorld).applyMatrix4(An)), Array.isArray(Sn)) {
                          const Un = bn.groups;
                          for (let Xn = 0, ii = Un.length; Xn < ii; Xn++) {
                            const ci = Un[Xn], dr = Sn[ci.materialIndex];
                            dr && dr.visible && k.push(ve, bn, dr, $e, mt.z, ci);
                          }
                        } else Sn.visible && k.push(ve, bn, Sn, $e, mt.z, null);
                      }
                    }
                    const Zt = ve.children;
                    for (let bn = 0, Sn = Zt.length; bn < Sn; bn++)
                      wp(Zt[bn], We, $e, qe);
                  }
                  function Dh(ve, We, $e, qe) {
                    const Je = ve.opaque, Zt = ve.transmissive, bn = ve.transparent;
                    P.setupLightsView($e), _i === !0 && yt.setGlobalState(J.clippingPlanes, $e), qe && Tt.viewport(Ie.copy(qe)), Je.length > 0 && Lc(Je, We, $e), Zt.length > 0 && Lc(Zt, We, $e), bn.length > 0 && Lc(bn, We, $e), Tt.buffers.depth.setTest(!0), Tt.buffers.depth.setMask(!0), Tt.buffers.color.setMask(!0), Tt.setPolygonOffset(!1);
                  }
                  function Mp(ve, We, $e, qe) {
                    if (($e.isScene === !0 ? $e.overrideMaterial : null) !== null)
                      return;
                    P.state.transmissionRenderTarget[qe.id] === void 0 && (P.state.transmissionRenderTarget[qe.id] = new zr(1, 1, { generateMipmaps: !0, type: ot.has("EXT_color_buffer_half_float") || ot.has("EXT_color_buffer_float") ? lt : Ii, minFilter: Ei, samples: 4, stencilBuffer: r, resolveDepthBuffer: !1, resolveStencilBuffer: !1 }));
                    const Zt = P.state.transmissionRenderTarget[qe.id], bn = qe.viewport || Ie;
                    Zt.setSize(bn.z, bn.w);
                    const Sn = J.getRenderTarget();
                    J.setRenderTarget(Zt), J.getClearColor(He), Ze = J.getClearAlpha(), Ze < 1 && J.setClearColor(16777215, 0.5), J.clear();
                    const Un = J.toneMapping;
                    J.toneMapping = $t;
                    const Xn = qe.viewport;
                    if (qe.viewport !== void 0 && (qe.viewport = void 0), P.setupLightsView(qe), _i === !0 && yt.setGlobalState(J.clippingPlanes, qe), Lc(ve, $e, qe), nn.updateMultisampleRenderTarget(Zt), nn.updateRenderTargetMipmap(Zt), ot.has("WEBGL_multisampled_render_to_texture") === !1) {
                      let ii = !1;
                      for (let ci = 0, dr = We.length; ci < dr; ci++) {
                        const Fr = We[ci], ns = Fr.object, so = Fr.geometry, Ti = Fr.material, Qs = Fr.group;
                        if (Ti.side === T && ns.layers.test(qe.layers)) {
                          const oi = Ti.side;
                          Ti.side = x, Ti.needsUpdate = !0, Sp(ns, $e, qe, so, Ti, Qs), Ti.side = oi, Ti.needsUpdate = !0, ii = !0;
                        }
                      }
                      ii === !0 && (nn.updateMultisampleRenderTarget(Zt), nn.updateRenderTargetMipmap(Zt));
                    }
                    J.setRenderTarget(Sn), J.setClearColor(He, Ze), Xn !== void 0 && (qe.viewport = Xn), J.toneMapping = Un;
                  }
                  function Lc(ve, We, $e) {
                    const qe = We.isScene === !0 ? We.overrideMaterial : null;
                    for (let Je = 0, Zt = ve.length; Je < Zt; Je++) {
                      const bn = ve[Je], Sn = bn.object, Un = bn.geometry, Xn = qe === null ? bn.material : qe, ii = bn.group;
                      Sn.layers.test($e.layers) && Sp(Sn, We, $e, Un, Xn, ii);
                    }
                  }
                  function Sp(ve, We, $e, qe, Je, Zt) {
                    ve.onBeforeRender(J, We, $e, qe, Je, Zt), ve.modelViewMatrix.multiplyMatrices($e.matrixWorldInverse, ve.matrixWorld), ve.normalMatrix.getNormalMatrix(ve.modelViewMatrix), Je.onBeforeRender(J, We, $e, qe, ve, Zt), Je.transparent === !0 && Je.side === T && Je.forceSinglePass === !1 ? (Je.side = x, Je.needsUpdate = !0, J.renderBufferDirect($e, We, qe, Je, ve, Zt), Je.side = f, Je.needsUpdate = !0, J.renderBufferDirect($e, We, qe, Je, ve, Zt), Je.side = T) : J.renderBufferDirect($e, We, qe, Je, ve, Zt), ve.onAfterRender(J, We, $e, qe, Je, Zt);
                  }
                  function Dc(ve, We, $e) {
                    We.isScene !== !0 && (We = Gt);
                    const qe = Kt.get(ve), Je = P.state.lights, Zt = P.state.shadowsArray, bn = Je.state.version, Sn = Se.getParameters(ve, Je.state, Zt, We, $e), Un = Se.getProgramCacheKey(Sn);
                    let Xn = qe.programs;
                    qe.environment = ve.isMeshStandardMaterial ? We.environment : null, qe.fog = We.fog, qe.envMap = (ve.isMeshStandardMaterial ? zn : kn).get(ve.envMap || qe.environment), qe.envMapRotation = qe.environment !== null && ve.envMap === null ? We.environmentRotation : ve.envMapRotation, Xn === void 0 && (ve.addEventListener("dispose", $n), Xn = /* @__PURE__ */ new Map(), qe.programs = Xn);
                    let ii = Xn.get(Un);
                    if (ii !== void 0) {
                      if (qe.currentProgram === ii && qe.lightsStateVersion === bn)
                        return Ip(ve, Sn), ii;
                    } else
                      Sn.uniforms = Se.getUniforms(ve), ve.onBuild($e, Sn, J), ve.onBeforeCompile(Sn, J), ii = Se.acquireProgram(Sn, Un), Xn.set(Un, ii), qe.uniforms = Sn.uniforms;
                    const ci = qe.uniforms;
                    return (!ve.isShaderMaterial && !ve.isRawShaderMaterial || ve.clipping === !0) && (ci.clippingPlanes = yt.uniform), Ip(ve, Sn), qe.needsLights = t1(ve), qe.lightsStateVersion = bn, qe.needsLights && (ci.ambientLightColor.value = Je.state.ambient, ci.lightProbe.value = Je.state.probe, ci.directionalLights.value = Je.state.directional, ci.directionalLightShadows.value = Je.state.directionalShadow, ci.spotLights.value = Je.state.spot, ci.spotLightShadows.value = Je.state.spotShadow, ci.rectAreaLights.value = Je.state.rectArea, ci.ltc_1.value = Je.state.rectAreaLTC1, ci.ltc_2.value = Je.state.rectAreaLTC2, ci.pointLights.value = Je.state.point, ci.pointLightShadows.value = Je.state.pointShadow, ci.hemisphereLights.value = Je.state.hemi, ci.directionalShadowMap.value = Je.state.directionalShadowMap, ci.directionalShadowMatrix.value = Je.state.directionalShadowMatrix, ci.spotShadowMap.value = Je.state.spotShadowMap, ci.spotLightMatrix.value = Je.state.spotLightMatrix, ci.spotLightMap.value = Je.state.spotLightMap, ci.pointShadowMap.value = Je.state.pointShadowMap, ci.pointShadowMatrix.value = Je.state.pointShadowMatrix), qe.currentProgram = ii, qe.uniformsList = null, ii;
                  }
                  function Tp(ve) {
                    if (ve.uniformsList === null) {
                      const We = ve.currentProgram.getUniforms();
                      ve.uniformsList = Ul.seqWithValue(We.seq, ve.uniforms);
                    }
                    return ve.uniformsList;
                  }
                  function Ip(ve, We) {
                    const $e = Kt.get(ve);
                    $e.outputColorSpace = We.outputColorSpace, $e.batching = We.batching, $e.instancing = We.instancing, $e.instancingColor = We.instancingColor, $e.instancingMorph = We.instancingMorph, $e.skinning = We.skinning, $e.morphTargets = We.morphTargets, $e.morphNormals = We.morphNormals, $e.morphColors = We.morphColors, $e.morphTargetsCount = We.morphTargetsCount, $e.numClippingPlanes = We.numClippingPlanes, $e.numIntersection = We.numClipIntersection, $e.vertexAlphas = We.vertexAlphas, $e.vertexTangents = We.vertexTangents, $e.toneMapping = We.toneMapping, $e.numMultiviewViews = We.numMultiviewViews;
                  }
                  function $E(ve, We, $e, qe, Je) {
                    We.isScene !== !0 && (We = Gt), nn.resetTextureUnits();
                    const Zt = We.fog, bn = qe.isMeshStandardMaterial ? We.environment : null, Sn = Re === null ? J.outputColorSpace : Re.isXRRenderTarget === !0 ? Re.texture.colorSpace : hs, Un = (qe.isMeshStandardMaterial ? zn : kn).get(qe.envMap || bn), Xn = qe.vertexColors === !0 && !!$e.attributes.color && $e.attributes.color.itemSize === 4, ii = !!$e.attributes.tangent && (!!qe.normalMap || qe.anisotropy > 0), ci = !!$e.morphAttributes.position, dr = !!$e.morphAttributes.normal, Fr = !!$e.morphAttributes.color;
                    let ns = $t;
                    qe.toneMapped && (Re === null || Re.isXRRenderTarget === !0) && (ns = J.toneMapping);
                    const so = Re && Re.isWebGLMultiviewRenderTarget ? Re.numViews : 0, Ti = $e.morphAttributes.position || $e.morphAttributes.normal || $e.morphAttributes.color, Qs = Ti !== void 0 ? Ti.length : 0, oi = Kt.get(qe), n1 = P.state.lights;
                    if (_i === !0 && (Ui === !0 || ve !== ce)) {
                      const ls = ve === ce && qe.id === Ae;
                      yt.setState(qe, ve, ls);
                    }
                    let Xi = !1;
                    qe.version === oi.__version ? (oi.needsLights && oi.lightsStateVersion !== n1.state.version || oi.outputColorSpace !== Sn || Je.isBatchedMesh && oi.batching === !1 || !Je.isBatchedMesh && oi.batching === !0 || Je.isInstancedMesh && oi.instancing === !1 || !Je.isInstancedMesh && oi.instancing === !0 || Je.isSkinnedMesh && oi.skinning === !1 || !Je.isSkinnedMesh && oi.skinning === !0 || Je.isInstancedMesh && oi.instancingColor === !0 && Je.instanceColor === null || Je.isInstancedMesh && oi.instancingColor === !1 && Je.instanceColor !== null || Je.isInstancedMesh && oi.instancingMorph === !0 && Je.morphTexture === null || Je.isInstancedMesh && oi.instancingMorph === !1 && Je.morphTexture !== null || oi.envMap !== Un || qe.fog === !0 && oi.fog !== Zt || oi.numClippingPlanes !== void 0 && (oi.numClippingPlanes !== yt.numPlanes || oi.numIntersection !== yt.numIntersection) || oi.vertexAlphas !== Xn || oi.vertexTangents !== ii || oi.morphTargets !== ci || oi.morphNormals !== dr || oi.morphColors !== Fr || oi.toneMapping !== ns || oi.morphTargetsCount !== Qs || oi.numMultiviewViews !== so) && (Xi = !0) : (Xi = !0, oi.__version = qe.version);
                    let Vs = oi.currentProgram;
                    Xi === !0 && (Vs = Dc(qe, We, Je));
                    let Bp = !1, $a = !1, Ph = !1;
                    const yr = Vs.getUniforms(), oo = oi.uniforms;
                    if (Tt.useProgram(Vs.program) && (Bp = !0, $a = !0, Ph = !0), qe.id !== Ae && (Ae = qe.id, $a = !0), Bp || ce !== ve) {
                      Vs.numMultiviewViews > 0 ? (En.updateCameraProjectionMatricesUniform(ve, yr), En.updateCameraViewMatricesUniform(ve, yr)) : (yr.setValue(ze, "projectionMatrix", ve.projectionMatrix), yr.setValue(ze, "viewMatrix", ve.matrixWorldInverse));
                      const ls = yr.map.cameraPosition;
                      ls !== void 0 && ls.setValue(ze, mt.setFromMatrixPosition(ve.matrixWorld)), Bt.logarithmicDepthBuffer && yr.setValue(ze, "logDepthBufFC", 2 / (Math.log(ve.far + 1) / Math.LN2)), (qe.isMeshPhongMaterial || qe.isMeshToonMaterial || qe.isMeshLambertMaterial || qe.isMeshBasicMaterial || qe.isMeshStandardMaterial || qe.isShaderMaterial) && yr.setValue(ze, "isOrthographic", ve.isOrthographicCamera === !0), ce !== ve && (ce = ve, $a = !0, Ph = !0);
                    }
                    if (Je.isSkinnedMesh) {
                      yr.setOptional(ze, Je, "bindMatrix"), yr.setOptional(ze, Je, "bindMatrixInverse");
                      const ls = Je.skeleton;
                      ls && (ls.boneTexture === null && ls.computeBoneTexture(), yr.setValue(ze, "boneTexture", ls.boneTexture, nn));
                    }
                    Je.isBatchedMesh && (yr.setOptional(ze, Je, "batchingTexture"), yr.setValue(ze, "batchingTexture", Je._matricesTexture, nn));
                    const Oh = $e.morphAttributes;
                    if ((Oh.position !== void 0 || Oh.normal !== void 0 || Oh.color !== void 0) && on.update(Je, $e, Vs), ($a || oi.receiveShadow !== Je.receiveShadow) && (oi.receiveShadow = Je.receiveShadow, yr.setValue(ze, "receiveShadow", Je.receiveShadow)), qe.isMeshGouraudMaterial && qe.envMap !== null && (oo.envMap.value = Un, oo.flipEnvMap.value = Un.isCubeTexture && Un.isRenderTargetTexture === !1 ? -1 : 1), qe.isMeshStandardMaterial && qe.envMap === null && We.environment !== null && (oo.envMapIntensity.value = We.environmentIntensity), $a && (yr.setValue(ze, "toneMappingExposure", J.toneMappingExposure), oi.needsLights && e1(oo, Ph), Zt && qe.fog === !0 && ue.refreshFogUniforms(oo, Zt), ue.refreshMaterialUniforms(oo, qe, et, Nt, P.state.transmissionRenderTarget[ve.id]), Ul.upload(ze, Tp(oi), oo, nn)), qe.isShaderMaterial && qe.uniformsNeedUpdate === !0 && (Ul.upload(ze, Tp(oi), oo, nn), qe.uniformsNeedUpdate = !1), qe.isSpriteMaterial && yr.setValue(ze, "center", Je.center), Vs.numMultiviewViews > 0 ? En.updateObjectMatricesUniforms(Je, ve, yr) : (yr.setValue(ze, "modelViewMatrix", Je.modelViewMatrix), yr.setValue(ze, "normalMatrix", Je.normalMatrix)), yr.setValue(ze, "modelMatrix", Je.matrixWorld), qe.isShaderMaterial || qe.isRawShaderMaterial) {
                      const ls = qe.uniformsGroups;
                      for (let Fh = 0, i1 = ls.length; Fh < i1; Fh++) {
                        const Rp = ls[Fh];
                        Pn.update(Rp, Vs), Pn.bind(Rp, Vs);
                      }
                    }
                    return Vs;
                  }
                  function e1(ve, We) {
                    ve.ambientLightColor.needsUpdate = We, ve.lightProbe.needsUpdate = We, ve.directionalLights.needsUpdate = We, ve.directionalLightShadows.needsUpdate = We, ve.pointLights.needsUpdate = We, ve.pointLightShadows.needsUpdate = We, ve.spotLights.needsUpdate = We, ve.spotLightShadows.needsUpdate = We, ve.rectAreaLights.needsUpdate = We, ve.hemisphereLights.needsUpdate = We;
                  }
                  function t1(ve) {
                    return ve.isMeshLambertMaterial || ve.isMeshToonMaterial || ve.isMeshPhongMaterial || ve.isMeshStandardMaterial || ve.isShadowMaterial || ve.isShaderMaterial && ve.lights === !0;
                  }
                  this.setTexture2D = /* @__PURE__ */ function() {
                    var ve = !1;
                    return function($e, qe) {
                      $e && $e.isWebGLRenderTarget && (ve || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), ve = !0), $e = $e.texture), nn.setTexture2D($e, qe);
                    };
                  }(), this.getActiveCubeFace = function() {
                    return Ee;
                  }, this.getActiveMipmapLevel = function() {
                    return Me;
                  }, this.getRenderTarget = function() {
                    return Re;
                  }, this.setRenderTargetTextures = function(ve, We, $e) {
                    Kt.get(ve.texture).__webglTexture = We, Kt.get(ve.depthTexture).__webglTexture = $e;
                    const qe = Kt.get(ve);
                    qe.__hasExternalTextures = !0, qe.__autoAllocateDepthBuffer = $e === void 0, !qe.__autoAllocateDepthBuffer && (!Re || !Re.isWebGLMultiviewRenderTarget) && ot.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), qe.__useRenderToTexture = !1);
                  }, this.setRenderTargetFramebuffer = function(ve, We) {
                    const $e = Kt.get(ve);
                    $e.__webglFramebuffer = We, $e.__useDefaultFramebuffer = We === void 0;
                  }, this.setRenderTarget = function(ve, We = 0, $e = 0) {
                    Re = ve, Ee = We, Me = $e;
                    let qe = !0, Je = null, Zt = !1, bn = !1;
                    if (ve) {
                      const Un = Kt.get(ve);
                      Un.__useDefaultFramebuffer !== void 0 ? (Tt.bindFramebuffer(ze.FRAMEBUFFER, null), qe = !1) : Un.__webglFramebuffer === void 0 ? nn.setupRenderTarget(ve) : Un.__hasExternalTextures && nn.rebindTextures(ve, Kt.get(ve.texture).__webglTexture, Kt.get(ve.depthTexture).__webglTexture);
                      const Xn = ve.texture;
                      (Xn.isData3DTexture || Xn.isDataArrayTexture || Xn.isCompressedArrayTexture) && (bn = !0);
                      const ii = Kt.get(ve).__webglFramebuffer;
                      ve.isWebGLCubeRenderTarget ? (Array.isArray(ii[We]) ? Je = ii[We][$e] : Je = ii[We], Zt = !0) : ve.samples > 0 && nn.useMultisampledRTT(ve) === !1 ? Je = Kt.get(ve).__webglMultisampledFramebuffer : Array.isArray(ii) ? Je = ii[$e] : Je = ii, Ie.copy(ve.viewport), Qe.copy(ve.scissor), Ue = ve.scissorTest;
                    } else
                      Ie.copy(fn).multiplyScalar(et).floor(), Qe.copy(ni).multiplyScalar(et).floor(), Ue = Si;
                    if (Tt.bindFramebuffer(ze.FRAMEBUFFER, Je) && qe && Tt.drawBuffers(ve, Je), Tt.viewport(Ie), Tt.scissor(Qe), Tt.setScissorTest(Ue), Zt) {
                      const Un = Kt.get(ve.texture);
                      ze.framebufferTexture2D(ze.FRAMEBUFFER, ze.COLOR_ATTACHMENT0, ze.TEXTURE_CUBE_MAP_POSITIVE_X + We, Un.__webglTexture, $e);
                    } else if (bn) {
                      const Un = Kt.get(ve.texture), Xn = We || 0;
                      ze.framebufferTextureLayer(ze.FRAMEBUFFER, ze.COLOR_ATTACHMENT0, Un.__webglTexture, $e || 0, Xn);
                    }
                    Ae = -1;
                  }, this.readRenderTargetPixels = function(ve, We, $e, qe, Je, Zt, bn) {
                    if (!(ve && ve.isWebGLRenderTarget)) {
                      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                      return;
                    }
                    let Sn = Kt.get(ve).__webglFramebuffer;
                    if (ve.isWebGLCubeRenderTarget && bn !== void 0 && (Sn = Sn[bn]), Sn) {
                      Tt.bindFramebuffer(ze.FRAMEBUFFER, Sn);
                      try {
                        const Un = ve.texture, Xn = Un.format, ii = Un.type;
                        if (!Bt.textureFormatReadable(Xn)) {
                          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                          return;
                        }
                        if (!Bt.textureTypeReadable(ii)) {
                          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                          return;
                        }
                        We >= 0 && We <= ve.width - qe && $e >= 0 && $e <= ve.height - Je && ze.readPixels(We, $e, qe, Je, xn.convert(Xn), xn.convert(ii), Zt);
                      } finally {
                        const Un = Re !== null ? Kt.get(Re).__webglFramebuffer : null;
                        Tt.bindFramebuffer(ze.FRAMEBUFFER, Un);
                      }
                    }
                  }, this.copyFramebufferToTexture = function(ve, We, $e = 0) {
                    const qe = Math.pow(2, -$e), Je = Math.floor(We.image.width * qe), Zt = Math.floor(We.image.height * qe);
                    nn.setTexture2D(We, 0), ze.copyTexSubImage2D(ze.TEXTURE_2D, $e, 0, 0, ve.x, ve.y, Je, Zt), Tt.unbindTexture();
                  }, this.copyTextureToTexture = function(ve, We, $e, qe = 0) {
                    const Je = We.image.width, Zt = We.image.height, bn = xn.convert($e.format), Sn = xn.convert($e.type);
                    nn.setTexture2D($e, 0), ze.pixelStorei(ze.UNPACK_FLIP_Y_WEBGL, $e.flipY), ze.pixelStorei(ze.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $e.premultiplyAlpha), ze.pixelStorei(ze.UNPACK_ALIGNMENT, $e.unpackAlignment), We.isDataTexture ? ze.texSubImage2D(ze.TEXTURE_2D, qe, ve.x, ve.y, Je, Zt, bn, Sn, We.image.data) : We.isCompressedTexture ? ze.compressedTexSubImage2D(ze.TEXTURE_2D, qe, ve.x, ve.y, We.mipmaps[0].width, We.mipmaps[0].height, bn, We.mipmaps[0].data) : ze.texSubImage2D(ze.TEXTURE_2D, qe, ve.x, ve.y, bn, Sn, We.image), qe === 0 && $e.generateMipmaps && ze.generateMipmap(ze.TEXTURE_2D), Tt.unbindTexture();
                  }, this.copyTextureToTexture3D = function(ve, We, $e, qe, Je = 0) {
                    const Zt = ve.max.x - ve.min.x, bn = ve.max.y - ve.min.y, Sn = ve.max.z - ve.min.z, Un = xn.convert(qe.format), Xn = xn.convert(qe.type);
                    let ii;
                    if (qe.isData3DTexture)
                      nn.setTexture3D(qe, 0), ii = ze.TEXTURE_3D;
                    else if (qe.isDataArrayTexture || qe.isCompressedArrayTexture)
                      nn.setTexture2DArray(qe, 0), ii = ze.TEXTURE_2D_ARRAY;
                    else {
                      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                      return;
                    }
                    ze.pixelStorei(ze.UNPACK_FLIP_Y_WEBGL, qe.flipY), ze.pixelStorei(ze.UNPACK_PREMULTIPLY_ALPHA_WEBGL, qe.premultiplyAlpha), ze.pixelStorei(ze.UNPACK_ALIGNMENT, qe.unpackAlignment);
                    const ci = ze.getParameter(ze.UNPACK_ROW_LENGTH), dr = ze.getParameter(ze.UNPACK_IMAGE_HEIGHT), Fr = ze.getParameter(ze.UNPACK_SKIP_PIXELS), ns = ze.getParameter(ze.UNPACK_SKIP_ROWS), so = ze.getParameter(ze.UNPACK_SKIP_IMAGES), Ti = $e.isCompressedTexture ? $e.mipmaps[Je] : $e.image;
                    ze.pixelStorei(ze.UNPACK_ROW_LENGTH, Ti.width), ze.pixelStorei(ze.UNPACK_IMAGE_HEIGHT, Ti.height), ze.pixelStorei(ze.UNPACK_SKIP_PIXELS, ve.min.x), ze.pixelStorei(ze.UNPACK_SKIP_ROWS, ve.min.y), ze.pixelStorei(ze.UNPACK_SKIP_IMAGES, ve.min.z), $e.isDataTexture || $e.isData3DTexture ? ze.texSubImage3D(ii, Je, We.x, We.y, We.z, Zt, bn, Sn, Un, Xn, Ti.data) : qe.isCompressedArrayTexture ? ze.compressedTexSubImage3D(ii, Je, We.x, We.y, We.z, Zt, bn, Sn, Un, Ti.data) : ze.texSubImage3D(ii, Je, We.x, We.y, We.z, Zt, bn, Sn, Un, Xn, Ti), ze.pixelStorei(ze.UNPACK_ROW_LENGTH, ci), ze.pixelStorei(ze.UNPACK_IMAGE_HEIGHT, dr), ze.pixelStorei(ze.UNPACK_SKIP_PIXELS, Fr), ze.pixelStorei(ze.UNPACK_SKIP_ROWS, ns), ze.pixelStorei(ze.UNPACK_SKIP_IMAGES, so), Je === 0 && qe.generateMipmaps && ze.generateMipmap(ii), Tt.unbindTexture();
                  }, this.initTexture = function(ve) {
                    ve.isCubeTexture ? nn.setTextureCube(ve, 0) : ve.isData3DTexture ? nn.setTexture3D(ve, 0) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? nn.setTexture2DArray(ve, 0) : nn.setTexture2D(ve, 0), Tt.unbindTexture();
                  }, this.resetState = function() {
                    Ee = 0, Me = 0, Re = null, Tt.reset(), Zn.reset();
                  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
                }
                get coordinateSystem() {
                  return ss;
                }
                get outputColorSpace() {
                  return this._outputColorSpace;
                }
                set outputColorSpace(e) {
                  this._outputColorSpace = e;
                  const t = this.getContext();
                  t.drawingBufferColorSpace = e === Uo ? "display-p3" : "srgb", t.unpackColorSpace = Mi.workingColorSpace === ao ? "display-p3" : "srgb";
                }
                get useLegacyLights() {
                  return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
                }
                set useLegacyLights(e) {
                  console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
                }
              }
              class Nl {
                constructor(e, t = 25e-5) {
                  this.isFogExp2 = !0, this.name = "", this.color = new sn(e), this.density = t;
                }
                clone() {
                  return new Nl(this.color, this.density);
                }
                toJSON() {
                  return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density };
                }
              }
              class kl {
                constructor(e, t = 1, n = 1e3) {
                  this.isFog = !0, this.name = "", this.color = new sn(e), this.near = t, this.far = n;
                }
                clone() {
                  return new kl(this.color, this.near, this.far);
                }
                toJSON() {
                  return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far };
                }
              }
              class Ud extends bi {
                constructor() {
                  super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new $r(), this.environmentIntensity = 1, this.environmentRotation = new $r(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
                }
                copy(e, t) {
                  return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
                }
              }
              class Gl {
                constructor(e, t) {
                  this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = ho, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = kr();
                }
                onUploadCallback() {
                }
                set needsUpdate(e) {
                  e === !0 && this.version++;
                }
                get updateRange() {
                  return fl("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
                }
                setUsage(e) {
                  return this.usage = e, this;
                }
                addUpdateRange(e, t) {
                  this.updateRanges.push({ start: e, count: t });
                }
                clearUpdateRanges() {
                  this.updateRanges.length = 0;
                }
                copy(e) {
                  return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
                }
                copyAt(e, t, n) {
                  e *= this.stride, n *= t.stride;
                  for (let i = 0, r = this.stride; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                  return this;
                }
                set(e, t = 0) {
                  return this.array.set(e, t), this;
                }
                clone(e) {
                  e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = kr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                  const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
                  return n.setUsage(this.usage), n;
                }
                onUpload(e) {
                  return this.onUploadCallback = e, this;
                }
                toJSON(e) {
                  return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = kr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
                }
              }
              const Vr = /* @__PURE__ */ new ye();
              class _o {
                constructor(e, t, n, i = !1) {
                  this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
                }
                get count() {
                  return this.data.count;
                }
                get array() {
                  return this.data.array;
                }
                set needsUpdate(e) {
                  this.data.needsUpdate = e;
                }
                applyMatrix4(e) {
                  for (let t = 0, n = this.data.count; t < n; t++)
                    Vr.fromBufferAttribute(this, t), Vr.applyMatrix4(e), this.setXYZ(t, Vr.x, Vr.y, Vr.z);
                  return this;
                }
                applyNormalMatrix(e) {
                  for (let t = 0, n = this.count; t < n; t++)
                    Vr.fromBufferAttribute(this, t), Vr.applyNormalMatrix(e), this.setXYZ(t, Vr.x, Vr.y, Vr.z);
                  return this;
                }
                transformDirection(e) {
                  for (let t = 0, n = this.count; t < n; t++)
                    Vr.fromBufferAttribute(this, t), Vr.transformDirection(e), this.setXYZ(t, Vr.x, Vr.y, Vr.z);
                  return this;
                }
                getComponent(e, t) {
                  let n = this.array[e * this.data.stride + this.offset + t];
                  return this.normalized && (n = Ir(n, this.array)), n;
                }
                setComponent(e, t, n) {
                  return this.normalized && (n = Hn(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
                }
                setX(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
                }
                setY(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
                }
                setZ(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
                }
                setW(e, t) {
                  return this.normalized && (t = Hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
                }
                getX(e) {
                  let t = this.data.array[e * this.data.stride + this.offset];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                getY(e) {
                  let t = this.data.array[e * this.data.stride + this.offset + 1];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                getZ(e) {
                  let t = this.data.array[e * this.data.stride + this.offset + 2];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                getW(e) {
                  let t = this.data.array[e * this.data.stride + this.offset + 3];
                  return this.normalized && (t = Ir(t, this.array)), t;
                }
                setXY(e, t, n) {
                  return e = e * this.data.stride + this.offset, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
                }
                setXYZ(e, t, n, i) {
                  return e = e * this.data.stride + this.offset, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array), i = Hn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
                }
                setXYZW(e, t, n, i, r) {
                  return e = e * this.data.stride + this.offset, this.normalized && (t = Hn(t, this.array), n = Hn(n, this.array), i = Hn(i, this.array), r = Hn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this;
                }
                clone(e) {
                  if (e === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const t = [];
                    for (let n = 0; n < this.count; n++) {
                      const i = n * this.data.stride + this.offset;
                      for (let r = 0; r < this.itemSize; r++)
                        t.push(this.data.array[i + r]);
                    }
                    return new Pi(new this.array.constructor(t), this.itemSize, this.normalized);
                  } else
                    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new _o(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
                }
                toJSON(e) {
                  if (e === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const t = [];
                    for (let n = 0; n < this.count; n++) {
                      const i = n * this.data.stride + this.offset;
                      for (let r = 0; r < this.itemSize; r++)
                        t.push(this.data.array[i + r]);
                    }
                    return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
                  } else
                    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
                }
              }
              class Xu extends Pr {
                constructor(e) {
                  super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new sn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
                }
              }
              let aa;
              const Ra = /* @__PURE__ */ new ye(), la = /* @__PURE__ */ new ye(), ca = /* @__PURE__ */ new ye(), ua = /* @__PURE__ */ new pt(), La = /* @__PURE__ */ new pt(), Nd = /* @__PURE__ */ new pn(), Ql = /* @__PURE__ */ new ye(), Da = /* @__PURE__ */ new ye(), Vl = /* @__PURE__ */ new ye(), kd = /* @__PURE__ */ new pt(), Yu = /* @__PURE__ */ new pt(), Gd = /* @__PURE__ */ new pt();
              class Qd extends bi {
                constructor(e = new Xu()) {
                  if (super(), this.isSprite = !0, this.type = "Sprite", aa === void 0) {
                    aa = new ti();
                    const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), n = new Gl(t, 5);
                    aa.setIndex([0, 1, 2, 0, 2, 3]), aa.setAttribute("position", new _o(n, 3, 0, !1)), aa.setAttribute("uv", new _o(n, 2, 3, !1));
                  }
                  this.geometry = aa, this.material = e, this.center = new pt(0.5, 0.5);
                }
                raycast(e, t) {
                  e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), la.setFromMatrixScale(this.matrixWorld), Nd.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ca.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && la.multiplyScalar(-ca.z);
                  const n = this.material.rotation;
                  let i, r;
                  n !== 0 && (r = Math.cos(n), i = Math.sin(n));
                  const o = this.center;
                  Hl(Ql.set(-0.5, -0.5, 0), ca, o, la, i, r), Hl(Da.set(0.5, -0.5, 0), ca, o, la, i, r), Hl(Vl.set(0.5, 0.5, 0), ca, o, la, i, r), kd.set(0, 0), Yu.set(1, 0), Gd.set(1, 1);
                  let a = e.ray.intersectTriangle(Ql, Da, Vl, !1, Ra);
                  if (a === null && (Hl(Da.set(-0.5, 0.5, 0), ca, o, la, i, r), Yu.set(0, 1), a = e.ray.intersectTriangle(Ql, Vl, Da, !1, Ra), a === null))
                    return;
                  const h = e.ray.origin.distanceTo(Ra);
                  h < e.near || h > e.far || t.push({ distance: h, point: Ra.clone(), uv: es.getInterpolation(Ra, Ql, Da, Vl, kd, Yu, Gd, new pt()), face: null, object: this });
                }
                copy(e, t) {
                  return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
                }
              }
              function Hl(s, e, t, n, i, r) {
                ua.subVectors(s, t).addScalar(0.5).multiply(n), i !== void 0 ? (La.x = r * ua.x - i * ua.y, La.y = i * ua.x + r * ua.y) : La.copy(ua), s.copy(e), s.x += La.x, s.y += La.y, s.applyMatrix4(Nd);
              }
              const zl = /* @__PURE__ */ new ye(), Vd = /* @__PURE__ */ new ye();
              class Hd extends bi {
                constructor() {
                  super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0;
                }
                copy(e) {
                  super.copy(e, !1);
                  const t = e.levels;
                  for (let n = 0, i = t.length; n < i; n++) {
                    const r = t[n];
                    this.addLevel(r.object.clone(), r.distance, r.hysteresis);
                  }
                  return this.autoUpdate = e.autoUpdate, this;
                }
                addLevel(e, t = 0, n = 0) {
                  t = Math.abs(t);
                  const i = this.levels;
                  let r;
                  for (r = 0; r < i.length && !(t < i[r].distance); r++)
                    ;
                  return i.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
                }
                getCurrentLevel() {
                  return this._currentLevel;
                }
                getObjectForDistance(e) {
                  const t = this.levels;
                  if (t.length > 0) {
                    let n, i;
                    for (n = 1, i = t.length; n < i; n++) {
                      let r = t[n].distance;
                      if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r)
                        break;
                    }
                    return t[n - 1].object;
                  }
                  return null;
                }
                raycast(e, t) {
                  if (this.levels.length > 0) {
                    zl.setFromMatrixPosition(this.matrixWorld);
                    const i = e.ray.origin.distanceTo(zl);
                    this.getObjectForDistance(i).raycast(e, t);
                  }
                }
                update(e) {
                  const t = this.levels;
                  if (t.length > 1) {
                    zl.setFromMatrixPosition(e.matrixWorld), Vd.setFromMatrixPosition(this.matrixWorld);
                    const n = zl.distanceTo(Vd) / e.zoom;
                    t[0].object.visible = !0;
                    let i, r;
                    for (i = 1, r = t.length; i < r; i++) {
                      let o = t[i].distance;
                      if (t[i].object.visible && (o -= o * t[i].hysteresis), n >= o)
                        t[i - 1].object.visible = !1, t[i].object.visible = !0;
                      else
                        break;
                    }
                    for (this._currentLevel = i - 1; i < r; i++)
                      t[i].object.visible = !1;
                  }
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
                  const n = this.levels;
                  for (let i = 0, r = n.length; i < r; i++) {
                    const o = n[i];
                    t.object.levels.push({ object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis });
                  }
                  return t;
                }
              }
              const zd = /* @__PURE__ */ new ye(), jd = /* @__PURE__ */ new yi(), Wd = /* @__PURE__ */ new yi(), ov = /* @__PURE__ */ new ye(), Kd = /* @__PURE__ */ new pn(), jl = /* @__PURE__ */ new ye(), qu = /* @__PURE__ */ new pr(), Xd = /* @__PURE__ */ new pn(), Ju = /* @__PURE__ */ new Ar();
              class Yd extends hr {
                constructor(e, t) {
                  super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = fe, this.bindMatrix = new pn(), this.bindMatrixInverse = new pn(), this.boundingBox = null, this.boundingSphere = null;
                }
                computeBoundingBox() {
                  const e = this.geometry;
                  this.boundingBox === null && (this.boundingBox = new Zi()), this.boundingBox.makeEmpty();
                  const t = e.getAttribute("position");
                  for (let n = 0; n < t.count; n++)
                    this.getVertexPosition(n, jl), this.boundingBox.expandByPoint(jl);
                }
                computeBoundingSphere() {
                  const e = this.geometry;
                  this.boundingSphere === null && (this.boundingSphere = new pr()), this.boundingSphere.makeEmpty();
                  const t = e.getAttribute("position");
                  for (let n = 0; n < t.count; n++)
                    this.getVertexPosition(n, jl), this.boundingSphere.expandByPoint(jl);
                }
                copy(e, t) {
                  return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
                }
                raycast(e, t) {
                  const n = this.material, i = this.matrixWorld;
                  n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), qu.copy(this.boundingSphere), qu.applyMatrix4(i), e.ray.intersectsSphere(qu) !== !1 && (Xd.copy(i).invert(), Ju.copy(e.ray).applyMatrix4(Xd), !(this.boundingBox !== null && Ju.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Ju)));
                }
                getVertexPosition(e, t) {
                  return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
                }
                bind(e, t) {
                  this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
                }
                pose() {
                  this.skeleton.pose();
                }
                normalizeSkinWeights() {
                  const e = new yi(), t = this.geometry.attributes.skinWeight;
                  for (let n = 0, i = t.count; n < i; n++) {
                    e.fromBufferAttribute(t, n);
                    const r = 1 / e.manhattanLength();
                    r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
                  }
                }
                updateMatrixWorld(e) {
                  super.updateMatrixWorld(e), this.bindMode === fe ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === ge ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
                }
                applyBoneTransform(e, t) {
                  const n = this.skeleton, i = this.geometry;
                  jd.fromBufferAttribute(i.attributes.skinIndex, e), Wd.fromBufferAttribute(i.attributes.skinWeight, e), zd.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                  for (let r = 0; r < 4; r++) {
                    const o = Wd.getComponent(r);
                    if (o !== 0) {
                      const a = jd.getComponent(r);
                      Kd.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(ov.copy(zd).applyMatrix4(Kd), o);
                    }
                  }
                  return t.applyMatrix4(this.bindMatrixInverse);
                }
              }
              class Zu extends bi {
                constructor() {
                  super(), this.isBone = !0, this.type = "Bone";
                }
              }
              class $s extends Vi {
                constructor(e = null, t = 1, n = 1, i, r, o, a, h, m = Pt, _ = Pt, I, B) {
                  super(null, o, a, h, m, _, i, r, I, B), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
                }
              }
              const qd = /* @__PURE__ */ new pn(), av = /* @__PURE__ */ new pn();
              class Wl {
                constructor(e = [], t = []) {
                  this.uuid = kr(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
                }
                init() {
                  const e = this.bones, t = this.boneInverses;
                  if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
                    this.calculateInverses();
                  else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let n = 0, i = this.bones.length; n < i; n++)
                      this.boneInverses.push(new pn());
                  }
                }
                calculateInverses() {
                  this.boneInverses.length = 0;
                  for (let e = 0, t = this.bones.length; e < t; e++) {
                    const n = new pn();
                    this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
                  }
                }
                pose() {
                  for (let e = 0, t = this.bones.length; e < t; e++) {
                    const n = this.bones[e];
                    n && n.matrixWorld.copy(this.boneInverses[e]).invert();
                  }
                  for (let e = 0, t = this.bones.length; e < t; e++) {
                    const n = this.bones[e];
                    n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
                  }
                }
                update() {
                  const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
                  for (let r = 0, o = e.length; r < o; r++) {
                    const a = e[r] ? e[r].matrixWorld : av;
                    qd.multiplyMatrices(a, t[r]), qd.toArray(n, r * 16);
                  }
                  i !== null && (i.needsUpdate = !0);
                }
                clone() {
                  return new Wl(this.bones, this.boneInverses);
                }
                computeBoneTexture() {
                  let e = Math.sqrt(this.bones.length * 4);
                  e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
                  const t = new Float32Array(e * e * 4);
                  t.set(this.boneMatrices);
                  const n = new $s(t, e, e, _e, tt);
                  return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
                }
                getBoneByName(e) {
                  for (let t = 0, n = this.bones.length; t < n; t++) {
                    const i = this.bones[t];
                    if (i.name === e)
                      return i;
                  }
                }
                dispose() {
                  this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
                }
                fromJSON(e, t) {
                  this.uuid = e.uuid;
                  for (let n = 0, i = e.bones.length; n < i; n++) {
                    const r = e.bones[n];
                    let o = t[r];
                    o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new Zu()), this.bones.push(o), this.boneInverses.push(new pn().fromArray(e.boneInverses[n]));
                  }
                  return this.init(), this;
                }
                toJSON() {
                  const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
                  e.uuid = this.uuid;
                  const t = this.bones, n = this.boneInverses;
                  for (let i = 0, r = t.length; i < r; i++) {
                    const o = t[i];
                    e.bones.push(o.uuid);
                    const a = n[i];
                    e.boneInverses.push(a.toArray());
                  }
                  return e;
                }
              }
              class ha extends Pi {
                constructor(e, t, n, i = 1) {
                  super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
                }
                copy(e) {
                  return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
                }
              }
              const da = /* @__PURE__ */ new pn(), Jd = /* @__PURE__ */ new pn(), Kl = [], Zd = /* @__PURE__ */ new Zi(), lv = /* @__PURE__ */ new pn(), Pa = /* @__PURE__ */ new hr(), Oa = /* @__PURE__ */ new pr();
              class $d extends hr {
                constructor(e, t, n) {
                  super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new ha(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                  for (let i = 0; i < n; i++)
                    this.setMatrixAt(i, lv);
                }
                computeBoundingBox() {
                  const e = this.geometry, t = this.count;
                  this.boundingBox === null && (this.boundingBox = new Zi()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                  for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, da), Zd.copy(e.boundingBox).applyMatrix4(da), this.boundingBox.union(Zd);
                }
                computeBoundingSphere() {
                  const e = this.geometry, t = this.count;
                  this.boundingSphere === null && (this.boundingSphere = new pr()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                  for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, da), Oa.copy(e.boundingSphere).applyMatrix4(da), this.boundingSphere.union(Oa);
                }
                copy(e, t) {
                  return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
                }
                getColorAt(e, t) {
                  t.fromArray(this.instanceColor.array, e * 3);
                }
                getMatrixAt(e, t) {
                  t.fromArray(this.instanceMatrix.array, e * 16);
                }
                getMorphAt(e, t) {
                  const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, r = n.length + 1, o = e * r + 1;
                  for (let a = 0; a < n.length; a++)
                    n[a] = i[o + a];
                }
                raycast(e, t) {
                  const n = this.matrixWorld, i = this.count;
                  if (Pa.geometry = this.geometry, Pa.material = this.material, Pa.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Oa.copy(this.boundingSphere), Oa.applyMatrix4(n), e.ray.intersectsSphere(Oa) !== !1))
                    for (let r = 0; r < i; r++) {
                      this.getMatrixAt(r, da), Jd.multiplyMatrices(n, da), Pa.matrixWorld = Jd, Pa.raycast(e, Kl);
                      for (let o = 0, a = Kl.length; o < a; o++) {
                        const h = Kl[o];
                        h.instanceId = r, h.object = this, t.push(h);
                      }
                      Kl.length = 0;
                    }
                }
                setColorAt(e, t) {
                  this.instanceColor === null && (this.instanceColor = new ha(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
                }
                setMatrixAt(e, t) {
                  t.toArray(this.instanceMatrix.array, e * 16);
                }
                setMorphAt(e, t) {
                  const n = t.morphTargetInfluences, i = n.length + 1;
                  this.morphTexture === null && (this.morphTexture = new $s(new Float32Array(i * this.count), i, this.count, bt, tt));
                  const r = this.morphTexture.source.data.data;
                  let o = 0;
                  for (let m = 0; m < n.length; m++)
                    o += n[m];
                  const a = this.geometry.morphTargetsRelative ? 1 : 1 - o, h = i * e;
                  r[h] = a, r.set(n, h + 1);
                }
                updateMorphTargets() {
                }
                dispose() {
                  return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
                }
              }
              function cv(s, e) {
                return s.z - e.z;
              }
              function uv(s, e) {
                return e.z - s.z;
              }
              class hv {
                constructor() {
                  this.index = 0, this.pool = [], this.list = [];
                }
                push(e, t) {
                  const n = this.pool, i = this.list;
                  this.index >= n.length && n.push({ start: -1, count: -1, z: -1 });
                  const r = n[this.index];
                  i.push(r), this.index++, r.start = e.start, r.count = e.count, r.z = t;
                }
                reset() {
                  this.list.length = 0, this.index = 0;
                }
              }
              const fa = "batchId", eo = /* @__PURE__ */ new pn(), ef = /* @__PURE__ */ new pn(), dv = /* @__PURE__ */ new pn(), tf = /* @__PURE__ */ new pn(), $u = /* @__PURE__ */ new Ia(), Xl = /* @__PURE__ */ new Zi(), wo = /* @__PURE__ */ new pr(), Fa = /* @__PURE__ */ new ye(), eh = /* @__PURE__ */ new hv(), Or = /* @__PURE__ */ new hr(), Yl = [];
              function fv(s, e, t = 0) {
                const n = e.itemSize;
                if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
                  const i = s.count;
                  for (let r = 0; r < i; r++)
                    for (let o = 0; o < n; o++)
                      e.setComponent(r + t, o, s.getComponent(r, o));
                } else
                  e.array.set(s.array, t * n);
                e.needsUpdate = !0;
              }
              class nf extends hr {
                get maxGeometryCount() {
                  return this._maxGeometryCount;
                }
                constructor(e, t, n = t * 2, i) {
                  super(new ti(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture();
                }
                _initMatricesTexture() {
                  let e = Math.sqrt(this._maxGeometryCount * 4);
                  e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
                  const t = new Float32Array(e * e * 4), n = new $s(t, e, e, _e, tt);
                  this._matricesTexture = n;
                }
                _initializeGeometry(e) {
                  const t = this.geometry, n = this._maxVertexCount, i = this._maxGeometryCount, r = this._maxIndexCount;
                  if (this._geometryInitialized === !1) {
                    for (const a in e.attributes) {
                      const h = e.getAttribute(a), { array: m, itemSize: _, normalized: I } = h, B = new m.constructor(n * _), L = new Pi(B, _, I);
                      t.setAttribute(a, L);
                    }
                    if (e.getIndex() !== null) {
                      const a = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
                      t.setIndex(new Pi(a, 1));
                    }
                    const o = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
                    t.setAttribute(fa, new Pi(o, 1)), this._geometryInitialized = !0;
                  }
                }
                // Make sure the geometry is compatible with the existing combined geometry attributes
                _validateGeometry(e) {
                  if (e.getAttribute(fa))
                    throw new Error(`BatchedMesh: Geometry cannot use attribute "${fa}"`);
                  const t = this.geometry;
                  if (!!e.getIndex() != !!t.getIndex())
                    throw new Error('BatchedMesh: All geometries must consistently have "index".');
                  for (const n in t.attributes) {
                    if (n === fa)
                      continue;
                    if (!e.hasAttribute(n))
                      throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                    const i = e.getAttribute(n), r = t.getAttribute(n);
                    if (i.itemSize !== r.itemSize || i.normalized !== r.normalized)
                      throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
                  }
                }
                setCustomSort(e) {
                  return this.customSort = e, this;
                }
                computeBoundingBox() {
                  this.boundingBox === null && (this.boundingBox = new Zi());
                  const e = this._geometryCount, t = this.boundingBox, n = this._active;
                  t.makeEmpty();
                  for (let i = 0; i < e; i++)
                    n[i] !== !1 && (this.getMatrixAt(i, eo), this.getBoundingBoxAt(i, Xl).applyMatrix4(eo), t.union(Xl));
                }
                computeBoundingSphere() {
                  this.boundingSphere === null && (this.boundingSphere = new pr());
                  const e = this._geometryCount, t = this.boundingSphere, n = this._active;
                  t.makeEmpty();
                  for (let i = 0; i < e; i++)
                    n[i] !== !1 && (this.getMatrixAt(i, eo), this.getBoundingSphereAt(i, wo).applyMatrix4(eo), t.union(wo));
                }
                addGeometry(e, t = -1, n = -1) {
                  if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount)
                    throw new Error("BatchedMesh: Maximum geometry count reached.");
                  const i = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
                  let r = null;
                  const o = this._reservedRanges, a = this._drawRanges, h = this._bounds;
                  this._geometryCount !== 0 && (r = o[o.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, r === null ? i.vertexStart = 0 : i.vertexStart = r.vertexStart + r.vertexCount;
                  const m = e.getIndex(), _ = m !== null;
                  if (_ && (n === -1 ? i.indexCount = m.count : i.indexCount = n, r === null ? i.indexStart = 0 : i.indexStart = r.indexStart + r.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
                    throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                  const I = this._visibility, B = this._active, L = this._matricesTexture, N = this._matricesTexture.image.data;
                  I.push(!0), B.push(!0);
                  const z = this._geometryCount;
                  this._geometryCount++, dv.toArray(N, z * 16), L.needsUpdate = !0, o.push(i), a.push({ start: _ ? i.indexStart : i.vertexStart, count: -1 }), h.push({ boxInitialized: !1, box: new Zi(), sphereInitialized: !1, sphere: new pr() });
                  const k = this.geometry.getAttribute(fa);
                  for (let P = 0; P < i.vertexCount; P++)
                    k.setX(i.vertexStart + P, z);
                  return k.needsUpdate = !0, this.setGeometryAt(z, e), z;
                }
                setGeometryAt(e, t) {
                  if (e >= this._geometryCount)
                    throw new Error("BatchedMesh: Maximum geometry count reached.");
                  this._validateGeometry(t);
                  const n = this.geometry, i = n.getIndex() !== null, r = n.getIndex(), o = t.getIndex(), a = this._reservedRanges[e];
                  if (i && o.count > a.indexCount || t.attributes.position.count > a.vertexCount)
                    throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
                  const h = a.vertexStart, m = a.vertexCount;
                  for (const L in n.attributes) {
                    if (L === fa)
                      continue;
                    const N = t.getAttribute(L), z = n.getAttribute(L);
                    fv(N, z, h);
                    const k = N.itemSize;
                    for (let P = N.count, se = m; P < se; P++) {
                      const $ = h + P;
                      for (let J = 0; J < k; J++)
                        z.setComponent($, J, 0);
                    }
                    z.needsUpdate = !0, z.addUpdateRange(h * k, m * k);
                  }
                  if (i) {
                    const L = a.indexStart;
                    for (let N = 0; N < o.count; N++)
                      r.setX(L + N, h + o.getX(N));
                    for (let N = o.count, z = a.indexCount; N < z; N++)
                      r.setX(L + N, h);
                    r.needsUpdate = !0, r.addUpdateRange(L, a.indexCount);
                  }
                  const _ = this._bounds[e];
                  t.boundingBox !== null ? (_.box.copy(t.boundingBox), _.boxInitialized = !0) : _.boxInitialized = !1, t.boundingSphere !== null ? (_.sphere.copy(t.boundingSphere), _.sphereInitialized = !0) : _.sphereInitialized = !1;
                  const I = this._drawRanges[e], B = t.getAttribute("position");
                  return I.count = i ? o.count : B.count, this._visibilityChanged = !0, e;
                }
                deleteGeometry(e) {
                  const t = this._active;
                  return e >= t.length || t[e] === !1 ? this : (t[e] = !1, this._visibilityChanged = !0, this);
                }
                getInstanceCountAt(e) {
                  return this._multiDrawInstances === null ? null : this._multiDrawInstances[e];
                }
                setInstanceCountAt(e, t) {
                  return this._multiDrawInstances === null && (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(1)), this._multiDrawInstances[e] = t, e;
                }
                // get bounding box and compute it if it doesn't exist
                getBoundingBoxAt(e, t) {
                  if (this._active[e] === !1)
                    return null;
                  const i = this._bounds[e], r = i.box, o = this.geometry;
                  if (i.boxInitialized === !1) {
                    r.makeEmpty();
                    const a = o.index, h = o.attributes.position, m = this._drawRanges[e];
                    for (let _ = m.start, I = m.start + m.count; _ < I; _++) {
                      let B = _;
                      a && (B = a.getX(B)), r.expandByPoint(Fa.fromBufferAttribute(h, B));
                    }
                    i.boxInitialized = !0;
                  }
                  return t.copy(r), t;
                }
                // get bounding sphere and compute it if it doesn't exist
                getBoundingSphereAt(e, t) {
                  if (this._active[e] === !1)
                    return null;
                  const i = this._bounds[e], r = i.sphere, o = this.geometry;
                  if (i.sphereInitialized === !1) {
                    r.makeEmpty(), this.getBoundingBoxAt(e, Xl), Xl.getCenter(r.center);
                    const a = o.index, h = o.attributes.position, m = this._drawRanges[e];
                    let _ = 0;
                    for (let I = m.start, B = m.start + m.count; I < B; I++) {
                      let L = I;
                      a && (L = a.getX(L)), Fa.fromBufferAttribute(h, L), _ = Math.max(_, r.center.distanceToSquared(Fa));
                    }
                    r.radius = Math.sqrt(_), i.sphereInitialized = !0;
                  }
                  return t.copy(r), t;
                }
                setMatrixAt(e, t) {
                  const n = this._active, i = this._matricesTexture, r = this._matricesTexture.image.data, o = this._geometryCount;
                  return e >= o || n[e] === !1 ? this : (t.toArray(r, e * 16), i.needsUpdate = !0, this);
                }
                getMatrixAt(e, t) {
                  const n = this._active, i = this._matricesTexture.image.data, r = this._geometryCount;
                  return e >= r || n[e] === !1 ? null : t.fromArray(i, e * 16);
                }
                setVisibleAt(e, t) {
                  const n = this._visibility, i = this._active, r = this._geometryCount;
                  return e >= r || i[e] === !1 || n[e] === t ? this : (n[e] = t, this._visibilityChanged = !0, this);
                }
                getVisibleAt(e) {
                  const t = this._visibility, n = this._active, i = this._geometryCount;
                  return e >= i || n[e] === !1 ? !1 : t[e];
                }
                raycast(e, t) {
                  const n = this._visibility, i = this._active, r = this._drawRanges, o = this._geometryCount, a = this.matrixWorld, h = this.geometry;
                  Or.material = this.material, Or.geometry.index = h.index, Or.geometry.attributes = h.attributes, Or.geometry.boundingBox === null && (Or.geometry.boundingBox = new Zi()), Or.geometry.boundingSphere === null && (Or.geometry.boundingSphere = new pr());
                  for (let m = 0; m < o; m++) {
                    if (!n[m] || !i[m])
                      continue;
                    const _ = r[m];
                    Or.geometry.setDrawRange(_.start, _.count), this.getMatrixAt(m, Or.matrixWorld).premultiply(a), this.getBoundingBoxAt(m, Or.geometry.boundingBox), this.getBoundingSphereAt(m, Or.geometry.boundingSphere), Or.raycast(e, Yl);
                    for (let I = 0, B = Yl.length; I < B; I++) {
                      const L = Yl[I];
                      L.object = this, L.batchId = m, t.push(L);
                    }
                    Yl.length = 0;
                  }
                  Or.material = null, Or.geometry.index = null, Or.geometry.attributes = {}, Or.geometry.setDrawRange(0, 1 / 0);
                }
                copy(e) {
                  return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({ boxInitialized: t.boxInitialized, box: t.box.clone(), sphereInitialized: t.sphereInitialized, sphere: t.sphere.clone() })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
                }
                dispose() {
                  return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
                }
                onBeforeRender(e, t, n, i, r) {
                  if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                    return;
                  const o = i.getIndex(), a = o === null ? 1 : o.array.BYTES_PER_ELEMENT, h = this._active, m = this._visibility, _ = this._multiDrawStarts, I = this._multiDrawCounts, B = this._drawRanges, L = this.perObjectFrustumCulled;
                  L && (tf.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), $u.setFromProjectionMatrix(tf, e.coordinateSystem));
                  let N = 0;
                  if (this.sortObjects) {
                    ef.copy(this.matrixWorld).invert(), Fa.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ef);
                    for (let P = 0, se = m.length; P < se; P++)
                      if (m[P] && h[P]) {
                        this.getMatrixAt(P, eo), this.getBoundingSphereAt(P, wo).applyMatrix4(eo);
                        let $ = !1;
                        if (L && ($ = !$u.intersectsSphere(wo)), !$) {
                          const J = Fa.distanceTo(wo.center);
                          eh.push(B[P], J);
                        }
                      }
                    const z = eh.list, k = this.customSort;
                    k === null ? z.sort(r.transparent ? uv : cv) : k.call(this, z, n);
                    for (let P = 0, se = z.length; P < se; P++) {
                      const $ = z[P];
                      _[N] = $.start * a, I[N] = $.count, N++;
                    }
                    eh.reset();
                  } else
                    for (let z = 0, k = m.length; z < k; z++)
                      if (m[z] && h[z]) {
                        let P = !1;
                        if (L && (this.getMatrixAt(z, eo), this.getBoundingSphereAt(z, wo).applyMatrix4(eo), P = !$u.intersectsSphere(wo)), !P) {
                          const se = B[z];
                          _[N] = se.start * a, I[N] = se.count, N++;
                        }
                      }
                  this._multiDrawCount = N, this._visibilityChanged = !1;
                }
                onBeforeShadow(e, t, n, i, r, o) {
                  this.onBeforeRender(e, null, i, r, o);
                }
              }
              class Hr extends Pr {
                constructor(e) {
                  super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new sn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
                }
              }
              const ql = /* @__PURE__ */ new ye(), Jl = /* @__PURE__ */ new ye(), rf = /* @__PURE__ */ new pn(), Ua = /* @__PURE__ */ new Ar(), Zl = /* @__PURE__ */ new pr(), th = /* @__PURE__ */ new ye(), sf = /* @__PURE__ */ new ye();
              class to extends bi {
                constructor(e = new ti(), t = new Hr()) {
                  super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
                }
                copy(e, t) {
                  return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
                }
                computeLineDistances() {
                  const e = this.geometry;
                  if (e.index === null) {
                    const t = e.attributes.position, n = [0];
                    for (let i = 1, r = t.count; i < r; i++)
                      ql.fromBufferAttribute(t, i - 1), Jl.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += ql.distanceTo(Jl);
                    e.setAttribute("lineDistance", new gn(n, 1));
                  } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                  return this;
                }
                raycast(e, t) {
                  const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, o = n.drawRange;
                  if (n.boundingSphere === null && n.computeBoundingSphere(), Zl.copy(n.boundingSphere), Zl.applyMatrix4(i), Zl.radius += r, e.ray.intersectsSphere(Zl) === !1) return;
                  rf.copy(i).invert(), Ua.copy(e.ray).applyMatrix4(rf);
                  const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = a * a, m = this.isLineSegments ? 2 : 1, _ = n.index, B = n.attributes.position;
                  if (_ !== null) {
                    const L = Math.max(0, o.start), N = Math.min(_.count, o.start + o.count);
                    for (let z = L, k = N - 1; z < k; z += m) {
                      const P = _.getX(z), se = _.getX(z + 1), $ = $l(this, e, Ua, h, P, se);
                      $ && t.push($);
                    }
                    if (this.isLineLoop) {
                      const z = _.getX(N - 1), k = _.getX(L), P = $l(this, e, Ua, h, z, k);
                      P && t.push(P);
                    }
                  } else {
                    const L = Math.max(0, o.start), N = Math.min(B.count, o.start + o.count);
                    for (let z = L, k = N - 1; z < k; z += m) {
                      const P = $l(this, e, Ua, h, z, z + 1);
                      P && t.push(P);
                    }
                    if (this.isLineLoop) {
                      const z = $l(this, e, Ua, h, N - 1, L);
                      z && t.push(z);
                    }
                  }
                }
                updateMorphTargets() {
                  const t = this.geometry.morphAttributes, n = Object.keys(t);
                  if (n.length > 0) {
                    const i = t[n[0]];
                    if (i !== void 0) {
                      this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                      for (let r = 0, o = i.length; r < o; r++) {
                        const a = i[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
                      }
                    }
                  }
                }
              }
              function $l(s, e, t, n, i, r) {
                const o = s.geometry.attributes.position;
                if (ql.fromBufferAttribute(o, i), Jl.fromBufferAttribute(o, r), t.distanceSqToSegment(ql, Jl, th, sf) > n) return;
                th.applyMatrix4(s.matrixWorld);
                const h = e.ray.origin.distanceTo(th);
                if (!(h < e.near || h > e.far))
                  return {
                    distance: h,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: sf.clone().applyMatrix4(s.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: s
                  };
              }
              const of = /* @__PURE__ */ new ye(), af = /* @__PURE__ */ new ye();
              class bs extends to {
                constructor(e, t) {
                  super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
                }
                computeLineDistances() {
                  const e = this.geometry;
                  if (e.index === null) {
                    const t = e.attributes.position, n = [];
                    for (let i = 0, r = t.count; i < r; i += 2)
                      of.fromBufferAttribute(t, i), af.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + of.distanceTo(af);
                    e.setAttribute("lineDistance", new gn(n, 1));
                  } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                  return this;
                }
              }
              class lf extends to {
                constructor(e, t) {
                  super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
                }
              }
              class nh extends Pr {
                constructor(e) {
                  super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new sn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
                }
              }
              const cf = /* @__PURE__ */ new pn(), ih = /* @__PURE__ */ new Ar(), ec = /* @__PURE__ */ new pr(), tc = /* @__PURE__ */ new ye();
              class uf extends bi {
                constructor(e = new ti(), t = new nh()) {
                  super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
                }
                copy(e, t) {
                  return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
                }
                raycast(e, t) {
                  const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, o = n.drawRange;
                  if (n.boundingSphere === null && n.computeBoundingSphere(), ec.copy(n.boundingSphere), ec.applyMatrix4(i), ec.radius += r, e.ray.intersectsSphere(ec) === !1) return;
                  cf.copy(i).invert(), ih.copy(e.ray).applyMatrix4(cf);
                  const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = a * a, m = n.index, I = n.attributes.position;
                  if (m !== null) {
                    const B = Math.max(0, o.start), L = Math.min(m.count, o.start + o.count);
                    for (let N = B, z = L; N < z; N++) {
                      const k = m.getX(N);
                      tc.fromBufferAttribute(I, k), hf(tc, k, h, i, e, t, this);
                    }
                  } else {
                    const B = Math.max(0, o.start), L = Math.min(I.count, o.start + o.count);
                    for (let N = B, z = L; N < z; N++)
                      tc.fromBufferAttribute(I, N), hf(tc, N, h, i, e, t, this);
                  }
                }
                updateMorphTargets() {
                  const t = this.geometry.morphAttributes, n = Object.keys(t);
                  if (n.length > 0) {
                    const i = t[n[0]];
                    if (i !== void 0) {
                      this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                      for (let r = 0, o = i.length; r < o; r++) {
                        const a = i[r].name || String(r);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
                      }
                    }
                  }
                }
              }
              function hf(s, e, t, n, i, r, o) {
                const a = ih.distanceSqToPoint(s);
                if (a < t) {
                  const h = new ye();
                  ih.closestPointToPoint(s, h), h.applyMatrix4(n);
                  const m = i.ray.origin.distanceTo(h);
                  if (m < i.near || m > i.far) return;
                  r.push({ distance: m, distanceToRay: Math.sqrt(a), point: h, index: e, face: null, object: o });
                }
              }
              class pv extends Vi {
                constructor(e, t, n, i, r, o, a, h, m) {
                  super(e, t, n, i, r, o, a, h, m), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : vn, this.magFilter = r !== void 0 ? r : vn, this.generateMipmaps = !1;
                  const _ = this;
                  function I() {
                    _.needsUpdate = !0, e.requestVideoFrameCallback(I);
                  }
                  "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(I);
                }
                clone() {
                  return new this.constructor(this.image).copy(this);
                }
                update() {
                  const e = this.image;
                  "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
                }
              }
              class Av extends Vi {
                constructor(e, t) {
                  super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Pt, this.minFilter = Pt, this.generateMipmaps = !1, this.needsUpdate = !0;
                }
              }
              class nc extends Vi {
                constructor(e, t, n, i, r, o, a, h, m, _, I, B) {
                  super(null, o, a, h, m, _, i, r, I, B), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
                }
              }
              class mv extends nc {
                constructor(e, t, n, i, r, o) {
                  super(e, t, n, r, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = Oe;
                }
              }
              class gv extends nc {
                constructor(e, t, n) {
                  super(void 0, e[0].width, e[0].height, t, n, H), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
                }
              }
              class vv extends Vi {
                constructor(e, t, n, i, r, o, a, h, m) {
                  super(e, t, n, i, r, o, a, h, m), this.isCanvasTexture = !0, this.needsUpdate = !0;
                }
              }
              class As {
                constructor() {
                  this.type = "Curve", this.arcLengthDivisions = 200;
                }
                // Virtual base class method to overwrite and implement in subclasses
                //	- t [0 .. 1]
                getPoint() {
                  return console.warn("THREE.Curve: .getPoint() not implemented."), null;
                }
                // Get point at relative position in curve according to arc length
                // - u [0 .. 1]
                getPointAt(e, t) {
                  const n = this.getUtoTmapping(e);
                  return this.getPoint(n, t);
                }
                // Get sequence of points using getPoint( t )
                getPoints(e = 5) {
                  const t = [];
                  for (let n = 0; n <= e; n++)
                    t.push(this.getPoint(n / e));
                  return t;
                }
                // Get sequence of points using getPointAt( u )
                getSpacedPoints(e = 5) {
                  const t = [];
                  for (let n = 0; n <= e; n++)
                    t.push(this.getPointAt(n / e));
                  return t;
                }
                // Get total curve arc length
                getLength() {
                  const e = this.getLengths();
                  return e[e.length - 1];
                }
                // Get list of cumulative segment lengths
                getLengths(e = this.arcLengthDivisions) {
                  if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                  this.needsUpdate = !1;
                  const t = [];
                  let n, i = this.getPoint(0), r = 0;
                  t.push(0);
                  for (let o = 1; o <= e; o++)
                    n = this.getPoint(o / e), r += n.distanceTo(i), t.push(r), i = n;
                  return this.cacheArcLengths = t, t;
                }
                updateArcLengths() {
                  this.needsUpdate = !0, this.getLengths();
                }
                // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
                getUtoTmapping(e, t) {
                  const n = this.getLengths();
                  let i = 0;
                  const r = n.length;
                  let o;
                  t ? o = t : o = e * n[r - 1];
                  let a = 0, h = r - 1, m;
                  for (; a <= h; )
                    if (i = Math.floor(a + (h - a) / 2), m = n[i] - o, m < 0)
                      a = i + 1;
                    else if (m > 0)
                      h = i - 1;
                    else {
                      h = i;
                      break;
                    }
                  if (i = h, n[i] === o)
                    return i / (r - 1);
                  const _ = n[i], B = n[i + 1] - _, L = (o - _) / B;
                  return (i + L) / (r - 1);
                }
                // Returns a unit vector tangent at t
                // In case any sub curve does not implement its tangent derivation,
                // 2 points a small delta apart will be used to find its gradient
                // which seems to give a reasonable approximation
                getTangent(e, t) {
                  let i = e - 1e-4, r = e + 1e-4;
                  i < 0 && (i = 0), r > 1 && (r = 1);
                  const o = this.getPoint(i), a = this.getPoint(r), h = t || (o.isVector2 ? new pt() : new ye());
                  return h.copy(a).sub(o).normalize(), h;
                }
                getTangentAt(e, t) {
                  const n = this.getUtoTmapping(e);
                  return this.getTangent(n, t);
                }
                computeFrenetFrames(e, t) {
                  const n = new ye(), i = [], r = [], o = [], a = new ye(), h = new pn();
                  for (let L = 0; L <= e; L++) {
                    const N = L / e;
                    i[L] = this.getTangentAt(N, new ye());
                  }
                  r[0] = new ye(), o[0] = new ye();
                  let m = Number.MAX_VALUE;
                  const _ = Math.abs(i[0].x), I = Math.abs(i[0].y), B = Math.abs(i[0].z);
                  _ <= m && (m = _, n.set(1, 0, 0)), I <= m && (m = I, n.set(0, 1, 0)), B <= m && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), o[0].crossVectors(i[0], r[0]);
                  for (let L = 1; L <= e; L++) {
                    if (r[L] = r[L - 1].clone(), o[L] = o[L - 1].clone(), a.crossVectors(i[L - 1], i[L]), a.length() > Number.EPSILON) {
                      a.normalize();
                      const N = Math.acos(Yi(i[L - 1].dot(i[L]), -1, 1));
                      r[L].applyMatrix4(h.makeRotationAxis(a, N));
                    }
                    o[L].crossVectors(i[L], r[L]);
                  }
                  if (t === !0) {
                    let L = Math.acos(Yi(r[0].dot(r[e]), -1, 1));
                    L /= e, i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (L = -L);
                    for (let N = 1; N <= e; N++)
                      r[N].applyMatrix4(h.makeRotationAxis(i[N], L * N)), o[N].crossVectors(i[N], r[N]);
                  }
                  return { tangents: i, normals: r, binormals: o };
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  return this.arcLengthDivisions = e.arcLengthDivisions, this;
                }
                toJSON() {
                  const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
                  return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
                }
                fromJSON(e) {
                  return this.arcLengthDivisions = e.arcLengthDivisions, this;
                }
              }
              class ic extends As {
                constructor(e = 0, t = 0, n = 1, i = 1, r = 0, o = Math.PI * 2, a = !1, h = 0) {
                  super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = h;
                }
                getPoint(e, t = new pt()) {
                  const n = t, i = Math.PI * 2;
                  let r = this.aEndAngle - this.aStartAngle;
                  const o = Math.abs(r) < Number.EPSILON;
                  for (; r < 0; ) r += i;
                  for (; r > i; ) r -= i;
                  r < Number.EPSILON && (o ? r = 0 : r = i), this.aClockwise === !0 && !o && (r === i ? r = -i : r = r - i);
                  const a = this.aStartAngle + e * r;
                  let h = this.aX + this.xRadius * Math.cos(a), m = this.aY + this.yRadius * Math.sin(a);
                  if (this.aRotation !== 0) {
                    const _ = Math.cos(this.aRotation), I = Math.sin(this.aRotation), B = h - this.aX, L = m - this.aY;
                    h = B * _ - L * I + this.aX, m = B * I + L * _ + this.aY;
                  }
                  return n.set(h, m);
                }
                copy(e) {
                  return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
                }
              }
              class df extends ic {
                constructor(e, t, n, i, r, o) {
                  super(e, t, n, n, i, r, o), this.isArcCurve = !0, this.type = "ArcCurve";
                }
              }
              function rh() {
                let s = 0, e = 0, t = 0, n = 0;
                function i(r, o, a, h) {
                  s = r, e = a, t = -3 * r + 3 * o - 2 * a - h, n = 2 * r - 2 * o + a + h;
                }
                return { initCatmullRom: function(r, o, a, h, m) {
                  i(o, a, m * (a - r), m * (h - o));
                }, initNonuniformCatmullRom: function(r, o, a, h, m, _, I) {
                  let B = (o - r) / m - (a - r) / (m + _) + (a - o) / _, L = (a - o) / _ - (h - o) / (_ + I) + (h - a) / I;
                  B *= _, L *= _, i(o, a, B, L);
                }, calc: function(r) {
                  const o = r * r, a = o * r;
                  return s + e * r + t * o + n * a;
                } };
              }
              const rc = /* @__PURE__ */ new ye(), sh = /* @__PURE__ */ new rh(), oh = /* @__PURE__ */ new rh(), ah = /* @__PURE__ */ new rh();
              class ff extends As {
                constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
                  super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
                }
                getPoint(e, t = new ye()) {
                  const n = t, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * e;
                  let a = Math.floor(o), h = o - a;
                  this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : h === 0 && a === r - 1 && (a = r - 2, h = 1);
                  let m, _;
                  this.closed || a > 0 ? m = i[(a - 1) % r] : (rc.subVectors(i[0], i[1]).add(i[0]), m = rc);
                  const I = i[a % r], B = i[(a + 1) % r];
                  if (this.closed || a + 2 < r ? _ = i[(a + 2) % r] : (rc.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), _ = rc), this.curveType === "centripetal" || this.curveType === "chordal") {
                    const L = this.curveType === "chordal" ? 0.5 : 0.25;
                    let N = Math.pow(m.distanceToSquared(I), L), z = Math.pow(I.distanceToSquared(B), L), k = Math.pow(B.distanceToSquared(_), L);
                    z < 1e-4 && (z = 1), N < 1e-4 && (N = z), k < 1e-4 && (k = z), sh.initNonuniformCatmullRom(m.x, I.x, B.x, _.x, N, z, k), oh.initNonuniformCatmullRom(m.y, I.y, B.y, _.y, N, z, k), ah.initNonuniformCatmullRom(m.z, I.z, B.z, _.z, N, z, k);
                  } else this.curveType === "catmullrom" && (sh.initCatmullRom(m.x, I.x, B.x, _.x, this.tension), oh.initCatmullRom(m.y, I.y, B.y, _.y, this.tension), ah.initCatmullRom(m.z, I.z, B.z, _.z, this.tension));
                  return n.set(sh.calc(h), oh.calc(h), ah.calc(h)), n;
                }
                copy(e) {
                  super.copy(e), this.points = [];
                  for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(i.clone());
                  }
                  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
                }
                toJSON() {
                  const e = super.toJSON();
                  e.points = [];
                  for (let t = 0, n = this.points.length; t < n; t++) {
                    const i = this.points[t];
                    e.points.push(i.toArray());
                  }
                  return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
                }
                fromJSON(e) {
                  super.fromJSON(e), this.points = [];
                  for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(new ye().fromArray(i));
                  }
                  return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
                }
              }
              function pf(s, e, t, n, i) {
                const r = (n - e) * 0.5, o = (i - t) * 0.5, a = s * s, h = s * a;
                return (2 * t - 2 * n + r + o) * h + (-3 * t + 3 * n - 2 * r - o) * a + r * s + t;
              }
              function Ev(s, e) {
                const t = 1 - s;
                return t * t * e;
              }
              function yv(s, e) {
                return 2 * (1 - s) * s * e;
              }
              function Cv(s, e) {
                return s * s * e;
              }
              function Na(s, e, t, n) {
                return Ev(s, e) + yv(s, t) + Cv(s, n);
              }
              function xv(s, e) {
                const t = 1 - s;
                return t * t * t * e;
              }
              function bv(s, e) {
                const t = 1 - s;
                return 3 * t * t * s * e;
              }
              function _v(s, e) {
                return 3 * (1 - s) * s * s * e;
              }
              function wv(s, e) {
                return s * s * s * e;
              }
              function ka(s, e, t, n, i) {
                return xv(s, e) + bv(s, t) + _v(s, n) + wv(s, i);
              }
              class lh extends As {
                constructor(e = new pt(), t = new pt(), n = new pt(), i = new pt()) {
                  super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
                }
                getPoint(e, t = new pt()) {
                  const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
                  return n.set(ka(e, i.x, r.x, o.x, a.x), ka(e, i.y, r.y, o.y, a.y)), n;
                }
                copy(e) {
                  return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
                }
              }
              class Af extends As {
                constructor(e = new ye(), t = new ye(), n = new ye(), i = new ye()) {
                  super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
                }
                getPoint(e, t = new ye()) {
                  const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
                  return n.set(ka(e, i.x, r.x, o.x, a.x), ka(e, i.y, r.y, o.y, a.y), ka(e, i.z, r.z, o.z, a.z)), n;
                }
                copy(e) {
                  return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
                }
              }
              class ch extends As {
                constructor(e = new pt(), t = new pt()) {
                  super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
                }
                getPoint(e, t = new pt()) {
                  const n = t;
                  return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
                }
                // Line curve is linear, so we can overwrite default getPointAt
                getPointAt(e, t) {
                  return this.getPoint(e, t);
                }
                getTangent(e, t = new pt()) {
                  return t.subVectors(this.v2, this.v1).normalize();
                }
                getTangentAt(e, t) {
                  return this.getTangent(e, t);
                }
                copy(e) {
                  return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
                }
              }
              class mf extends As {
                constructor(e = new ye(), t = new ye()) {
                  super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
                }
                getPoint(e, t = new ye()) {
                  const n = t;
                  return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
                }
                // Line curve is linear, so we can overwrite default getPointAt
                getPointAt(e, t) {
                  return this.getPoint(e, t);
                }
                getTangent(e, t = new ye()) {
                  return t.subVectors(this.v2, this.v1).normalize();
                }
                getTangentAt(e, t) {
                  return this.getTangent(e, t);
                }
                copy(e) {
                  return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
                }
              }
              class uh extends As {
                constructor(e = new pt(), t = new pt(), n = new pt()) {
                  super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
                }
                getPoint(e, t = new pt()) {
                  const n = t, i = this.v0, r = this.v1, o = this.v2;
                  return n.set(Na(e, i.x, r.x, o.x), Na(e, i.y, r.y, o.y)), n;
                }
                copy(e) {
                  return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
                }
              }
              class hh extends As {
                constructor(e = new ye(), t = new ye(), n = new ye()) {
                  super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
                }
                getPoint(e, t = new ye()) {
                  const n = t, i = this.v0, r = this.v1, o = this.v2;
                  return n.set(Na(e, i.x, r.x, o.x), Na(e, i.y, r.y, o.y), Na(e, i.z, r.z, o.z)), n;
                }
                copy(e) {
                  return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
                }
              }
              class dh extends As {
                constructor(e = []) {
                  super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
                }
                getPoint(e, t = new pt()) {
                  const n = t, i = this.points, r = (i.length - 1) * e, o = Math.floor(r), a = r - o, h = i[o === 0 ? o : o - 1], m = i[o], _ = i[o > i.length - 2 ? i.length - 1 : o + 1], I = i[o > i.length - 3 ? i.length - 1 : o + 2];
                  return n.set(pf(a, h.x, m.x, _.x, I.x), pf(a, h.y, m.y, _.y, I.y)), n;
                }
                copy(e) {
                  super.copy(e), this.points = [];
                  for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(i.clone());
                  }
                  return this;
                }
                toJSON() {
                  const e = super.toJSON();
                  e.points = [];
                  for (let t = 0, n = this.points.length; t < n; t++) {
                    const i = this.points[t];
                    e.points.push(i.toArray());
                  }
                  return e;
                }
                fromJSON(e) {
                  super.fromJSON(e), this.points = [];
                  for (let t = 0, n = e.points.length; t < n; t++) {
                    const i = e.points[t];
                    this.points.push(new pt().fromArray(i));
                  }
                  return this;
                }
              }
              var sc = /* @__PURE__ */ Object.freeze({ __proto__: null, ArcCurve: df, CatmullRomCurve3: ff, CubicBezierCurve: lh, CubicBezierCurve3: Af, EllipseCurve: ic, LineCurve: ch, LineCurve3: mf, QuadraticBezierCurve: uh, QuadraticBezierCurve3: hh, SplineCurve: dh });
              class gf extends As {
                constructor() {
                  super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
                }
                add(e) {
                  this.curves.push(e);
                }
                closePath() {
                  const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
                  if (!e.equals(t)) {
                    const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                    this.curves.push(new sc[n](t, e));
                  }
                  return this;
                }
                // To get accurate point with reference to
                // entire path distance at time t,
                // following has to be done:
                // 1. Length of each sub path have to be known
                // 2. Locate and identify type of curve
                // 3. Get t for the curve
                // 4. Return curve.getPointAt(t')
                getPoint(e, t) {
                  const n = e * this.getLength(), i = this.getCurveLengths();
                  let r = 0;
                  for (; r < i.length; ) {
                    if (i[r] >= n) {
                      const o = i[r] - n, a = this.curves[r], h = a.getLength(), m = h === 0 ? 0 : 1 - o / h;
                      return a.getPointAt(m, t);
                    }
                    r++;
                  }
                  return null;
                }
                // We cannot use the default THREE.Curve getPoint() with getLength() because in
                // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
                // getPoint() depends on getLength
                getLength() {
                  const e = this.getCurveLengths();
                  return e[e.length - 1];
                }
                // cacheLengths must be recalculated.
                updateArcLengths() {
                  this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
                }
                // Compute lengths and cache them
                // We cannot overwrite getLengths() because UtoT mapping uses it.
                getCurveLengths() {
                  if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                  const e = [];
                  let t = 0;
                  for (let n = 0, i = this.curves.length; n < i; n++)
                    t += this.curves[n].getLength(), e.push(t);
                  return this.cacheLengths = e, e;
                }
                getSpacedPoints(e = 40) {
                  const t = [];
                  for (let n = 0; n <= e; n++)
                    t.push(this.getPoint(n / e));
                  return this.autoClose && t.push(t[0]), t;
                }
                getPoints(e = 12) {
                  const t = [];
                  let n;
                  for (let i = 0, r = this.curves; i < r.length; i++) {
                    const o = r[i], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, h = o.getPoints(a);
                    for (let m = 0; m < h.length; m++) {
                      const _ = h[m];
                      n && n.equals(_) || (t.push(_), n = _);
                    }
                  }
                  return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
                }
                copy(e) {
                  super.copy(e), this.curves = [];
                  for (let t = 0, n = e.curves.length; t < n; t++) {
                    const i = e.curves[t];
                    this.curves.push(i.clone());
                  }
                  return this.autoClose = e.autoClose, this;
                }
                toJSON() {
                  const e = super.toJSON();
                  e.autoClose = this.autoClose, e.curves = [];
                  for (let t = 0, n = this.curves.length; t < n; t++) {
                    const i = this.curves[t];
                    e.curves.push(i.toJSON());
                  }
                  return e;
                }
                fromJSON(e) {
                  super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                  for (let t = 0, n = e.curves.length; t < n; t++) {
                    const i = e.curves[t];
                    this.curves.push(new sc[i.type]().fromJSON(i));
                  }
                  return this;
                }
              }
              class Ga extends gf {
                constructor(e) {
                  super(), this.type = "Path", this.currentPoint = new pt(), e && this.setFromPoints(e);
                }
                setFromPoints(e) {
                  this.moveTo(e[0].x, e[0].y);
                  for (let t = 1, n = e.length; t < n; t++)
                    this.lineTo(e[t].x, e[t].y);
                  return this;
                }
                moveTo(e, t) {
                  return this.currentPoint.set(e, t), this;
                }
                lineTo(e, t) {
                  const n = new ch(this.currentPoint.clone(), new pt(e, t));
                  return this.curves.push(n), this.currentPoint.set(e, t), this;
                }
                quadraticCurveTo(e, t, n, i) {
                  const r = new uh(this.currentPoint.clone(), new pt(e, t), new pt(n, i));
                  return this.curves.push(r), this.currentPoint.set(n, i), this;
                }
                bezierCurveTo(e, t, n, i, r, o) {
                  const a = new lh(this.currentPoint.clone(), new pt(e, t), new pt(n, i), new pt(r, o));
                  return this.curves.push(a), this.currentPoint.set(r, o), this;
                }
                splineThru(e) {
                  const t = [this.currentPoint.clone()].concat(e), n = new dh(t);
                  return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
                }
                arc(e, t, n, i, r, o) {
                  const a = this.currentPoint.x, h = this.currentPoint.y;
                  return this.absarc(e + a, t + h, n, i, r, o), this;
                }
                absarc(e, t, n, i, r, o) {
                  return this.absellipse(e, t, n, n, i, r, o), this;
                }
                ellipse(e, t, n, i, r, o, a, h) {
                  const m = this.currentPoint.x, _ = this.currentPoint.y;
                  return this.absellipse(e + m, t + _, n, i, r, o, a, h), this;
                }
                absellipse(e, t, n, i, r, o, a, h) {
                  const m = new ic(e, t, n, i, r, o, a, h);
                  if (this.curves.length > 0) {
                    const I = m.getPoint(0);
                    I.equals(this.currentPoint) || this.lineTo(I.x, I.y);
                  }
                  this.curves.push(m);
                  const _ = m.getPoint(1);
                  return this.currentPoint.copy(_), this;
                }
                copy(e) {
                  return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.currentPoint = this.currentPoint.toArray(), e;
                }
                fromJSON(e) {
                  return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
                }
              }
              class Qa extends ti {
                constructor(e = [new pt(0, -0.5), new pt(0.5, 0), new pt(0, 0.5)], t = 12, n = 0, i = Math.PI * 2) {
                  super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }, t = Math.floor(t), i = Yi(i, 0, Math.PI * 2);
                  const r = [], o = [], a = [], h = [], m = [], _ = 1 / t, I = new ye(), B = new pt(), L = new ye(), N = new ye(), z = new ye();
                  let k = 0, P = 0;
                  for (let se = 0; se <= e.length - 1; se++)
                    switch (se) {
                      case 0:
                        k = e[se + 1].x - e[se].x, P = e[se + 1].y - e[se].y, L.x = P * 1, L.y = -k, L.z = P * 0, z.copy(L), L.normalize(), h.push(L.x, L.y, L.z);
                        break;
                      case e.length - 1:
                        h.push(z.x, z.y, z.z);
                        break;
                      default:
                        k = e[se + 1].x - e[se].x, P = e[se + 1].y - e[se].y, L.x = P * 1, L.y = -k, L.z = P * 0, N.copy(L), L.x += z.x, L.y += z.y, L.z += z.z, L.normalize(), h.push(L.x, L.y, L.z), z.copy(N);
                    }
                  for (let se = 0; se <= t; se++) {
                    const $ = n + se * _ * i, J = Math.sin($), Le = Math.cos($);
                    for (let Ee = 0; Ee <= e.length - 1; Ee++) {
                      I.x = e[Ee].x * J, I.y = e[Ee].y, I.z = e[Ee].x * Le, o.push(I.x, I.y, I.z), B.x = se / t, B.y = Ee / (e.length - 1), a.push(B.x, B.y);
                      const Me = h[3 * Ee + 0] * J, Re = h[3 * Ee + 1], Ae = h[3 * Ee + 0] * Le;
                      m.push(Me, Re, Ae);
                    }
                  }
                  for (let se = 0; se < t; se++)
                    for (let $ = 0; $ < e.length - 1; $++) {
                      const J = $ + se * e.length, Le = J, Ee = J + e.length, Me = J + e.length + 1, Re = J + 1;
                      r.push(Le, Ee, Re), r.push(Me, Re, Ee);
                    }
                  this.setIndex(r), this.setAttribute("position", new gn(o, 3)), this.setAttribute("uv", new gn(a, 2)), this.setAttribute("normal", new gn(m, 3));
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new Qa(e.points, e.segments, e.phiStart, e.phiLength);
                }
              }
              class oc extends Qa {
                constructor(e = 1, t = 1, n = 4, i = 8) {
                  const r = new Ga();
                  r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: n, radialSegments: i };
                }
                static fromJSON(e) {
                  return new oc(e.radius, e.length, e.capSegments, e.radialSegments);
                }
              }
              class ac extends ti {
                constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
                  super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: i }, t = Math.max(3, t);
                  const r = [], o = [], a = [], h = [], m = new ye(), _ = new pt();
                  o.push(0, 0, 0), a.push(0, 0, 1), h.push(0.5, 0.5);
                  for (let I = 0, B = 3; I <= t; I++, B += 3) {
                    const L = n + I / t * i;
                    m.x = e * Math.cos(L), m.y = e * Math.sin(L), o.push(m.x, m.y, m.z), a.push(0, 0, 1), _.x = (o[B] / e + 1) / 2, _.y = (o[B + 1] / e + 1) / 2, h.push(_.x, _.y);
                  }
                  for (let I = 1; I <= t; I++)
                    r.push(I, I + 1, 0);
                  this.setIndex(r), this.setAttribute("position", new gn(o, 3)), this.setAttribute("normal", new gn(a, 3)), this.setAttribute("uv", new gn(h, 2));
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new ac(e.radius, e.segments, e.thetaStart, e.thetaLength);
                }
              }
              class pa extends ti {
                constructor(e = 1, t = 1, n = 1, i = 32, r = 1, o = !1, a = 0, h = Math.PI * 2) {
                  super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: i, heightSegments: r, openEnded: o, thetaStart: a, thetaLength: h };
                  const m = this;
                  i = Math.floor(i), r = Math.floor(r);
                  const _ = [], I = [], B = [], L = [];
                  let N = 0;
                  const z = [], k = n / 2;
                  let P = 0;
                  se(), o === !1 && (e > 0 && $(!0), t > 0 && $(!1)), this.setIndex(_), this.setAttribute("position", new gn(I, 3)), this.setAttribute("normal", new gn(B, 3)), this.setAttribute("uv", new gn(L, 2));
                  function se() {
                    const J = new ye(), Le = new ye();
                    let Ee = 0;
                    const Me = (t - e) / n;
                    for (let Re = 0; Re <= r; Re++) {
                      const Ae = [], ce = Re / r, Ie = ce * (t - e) + e;
                      for (let Qe = 0; Qe <= i; Qe++) {
                        const Ue = Qe / i, He = Ue * h + a, Ze = Math.sin(He), dt = Math.cos(He);
                        Le.x = Ie * Ze, Le.y = -ce * n + k, Le.z = Ie * dt, I.push(Le.x, Le.y, Le.z), J.set(Ze, Me, dt).normalize(), B.push(J.x, J.y, J.z), L.push(Ue, 1 - ce), Ae.push(N++);
                      }
                      z.push(Ae);
                    }
                    for (let Re = 0; Re < i; Re++)
                      for (let Ae = 0; Ae < r; Ae++) {
                        const ce = z[Ae][Re], Ie = z[Ae + 1][Re], Qe = z[Ae + 1][Re + 1], Ue = z[Ae][Re + 1];
                        _.push(ce, Ie, Ue), _.push(Ie, Qe, Ue), Ee += 6;
                      }
                    m.addGroup(P, Ee, 0), P += Ee;
                  }
                  function $(J) {
                    const Le = N, Ee = new pt(), Me = new ye();
                    let Re = 0;
                    const Ae = J === !0 ? e : t, ce = J === !0 ? 1 : -1;
                    for (let Qe = 1; Qe <= i; Qe++)
                      I.push(0, k * ce, 0), B.push(0, ce, 0), L.push(0.5, 0.5), N++;
                    const Ie = N;
                    for (let Qe = 0; Qe <= i; Qe++) {
                      const He = Qe / i * h + a, Ze = Math.cos(He), dt = Math.sin(He);
                      Me.x = Ae * dt, Me.y = k * ce, Me.z = Ae * Ze, I.push(Me.x, Me.y, Me.z), B.push(0, ce, 0), Ee.x = Ze * 0.5 + 0.5, Ee.y = dt * 0.5 * ce + 0.5, L.push(Ee.x, Ee.y), N++;
                    }
                    for (let Qe = 0; Qe < i; Qe++) {
                      const Ue = Le + Qe, He = Ie + Qe;
                      J === !0 ? _.push(He, He + 1, Ue) : _.push(He + 1, He, Ue), Re += 3;
                    }
                    m.addGroup(P, Re, J === !0 ? 1 : 2), P += Re;
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new pa(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
                }
              }
              class lc extends pa {
                constructor(e = 1, t = 1, n = 32, i = 1, r = !1, o = 0, a = Math.PI * 2) {
                  super(0, e, t, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: o, thetaLength: a };
                }
                static fromJSON(e) {
                  return new lc(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
                }
              }
              class no extends ti {
                constructor(e = [], t = [], n = 1, i = 0) {
                  super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: i };
                  const r = [], o = [];
                  a(i), m(n), _(), this.setAttribute("position", new gn(r, 3)), this.setAttribute("normal", new gn(r.slice(), 3)), this.setAttribute("uv", new gn(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
                  function a(se) {
                    const $ = new ye(), J = new ye(), Le = new ye();
                    for (let Ee = 0; Ee < t.length; Ee += 3)
                      L(t[Ee + 0], $), L(t[Ee + 1], J), L(t[Ee + 2], Le), h($, J, Le, se);
                  }
                  function h(se, $, J, Le) {
                    const Ee = Le + 1, Me = [];
                    for (let Re = 0; Re <= Ee; Re++) {
                      Me[Re] = [];
                      const Ae = se.clone().lerp(J, Re / Ee), ce = $.clone().lerp(J, Re / Ee), Ie = Ee - Re;
                      for (let Qe = 0; Qe <= Ie; Qe++)
                        Qe === 0 && Re === Ee ? Me[Re][Qe] = Ae : Me[Re][Qe] = Ae.clone().lerp(ce, Qe / Ie);
                    }
                    for (let Re = 0; Re < Ee; Re++)
                      for (let Ae = 0; Ae < 2 * (Ee - Re) - 1; Ae++) {
                        const ce = Math.floor(Ae / 2);
                        Ae % 2 === 0 ? (B(Me[Re][ce + 1]), B(Me[Re + 1][ce]), B(Me[Re][ce])) : (B(Me[Re][ce + 1]), B(Me[Re + 1][ce + 1]), B(Me[Re + 1][ce]));
                      }
                  }
                  function m(se) {
                    const $ = new ye();
                    for (let J = 0; J < r.length; J += 3)
                      $.x = r[J + 0], $.y = r[J + 1], $.z = r[J + 2], $.normalize().multiplyScalar(se), r[J + 0] = $.x, r[J + 1] = $.y, r[J + 2] = $.z;
                  }
                  function _() {
                    const se = new ye();
                    for (let $ = 0; $ < r.length; $ += 3) {
                      se.x = r[$ + 0], se.y = r[$ + 1], se.z = r[$ + 2];
                      const J = k(se) / 2 / Math.PI + 0.5, Le = P(se) / Math.PI + 0.5;
                      o.push(J, 1 - Le);
                    }
                    N(), I();
                  }
                  function I() {
                    for (let se = 0; se < o.length; se += 6) {
                      const $ = o[se + 0], J = o[se + 2], Le = o[se + 4], Ee = Math.max($, J, Le), Me = Math.min($, J, Le);
                      Ee > 0.9 && Me < 0.1 && ($ < 0.2 && (o[se + 0] += 1), J < 0.2 && (o[se + 2] += 1), Le < 0.2 && (o[se + 4] += 1));
                    }
                  }
                  function B(se) {
                    r.push(se.x, se.y, se.z);
                  }
                  function L(se, $) {
                    const J = se * 3;
                    $.x = e[J + 0], $.y = e[J + 1], $.z = e[J + 2];
                  }
                  function N() {
                    const se = new ye(), $ = new ye(), J = new ye(), Le = new ye(), Ee = new pt(), Me = new pt(), Re = new pt();
                    for (let Ae = 0, ce = 0; Ae < r.length; Ae += 9, ce += 6) {
                      se.set(r[Ae + 0], r[Ae + 1], r[Ae + 2]), $.set(r[Ae + 3], r[Ae + 4], r[Ae + 5]), J.set(r[Ae + 6], r[Ae + 7], r[Ae + 8]), Ee.set(o[ce + 0], o[ce + 1]), Me.set(o[ce + 2], o[ce + 3]), Re.set(o[ce + 4], o[ce + 5]), Le.copy(se).add($).add(J).divideScalar(3);
                      const Ie = k(Le);
                      z(Ee, ce + 0, se, Ie), z(Me, ce + 2, $, Ie), z(Re, ce + 4, J, Ie);
                    }
                  }
                  function z(se, $, J, Le) {
                    Le < 0 && se.x === 1 && (o[$] = se.x - 1), J.x === 0 && J.z === 0 && (o[$] = Le / 2 / Math.PI + 0.5);
                  }
                  function k(se) {
                    return Math.atan2(se.z, -se.x);
                  }
                  function P(se) {
                    return Math.atan2(-se.y, Math.sqrt(se.x * se.x + se.z * se.z));
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new no(e.vertices, e.indices, e.radius, e.details);
                }
              }
              class cc extends no {
                constructor(e = 1, t = 0) {
                  const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [
                    // (±1, ±1, ±1)
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    -1,
                    1,
                    1,
                    1,
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    1,
                    1,
                    -1,
                    1,
                    1,
                    1,
                    // (0, ±1/φ, ±φ)
                    0,
                    -i,
                    -n,
                    0,
                    -i,
                    n,
                    0,
                    i,
                    -n,
                    0,
                    i,
                    n,
                    // (±1/φ, ±φ, 0)
                    -i,
                    -n,
                    0,
                    -i,
                    n,
                    0,
                    i,
                    -n,
                    0,
                    i,
                    n,
                    0,
                    // (±φ, 0, ±1/φ)
                    -n,
                    0,
                    -i,
                    n,
                    0,
                    -i,
                    -n,
                    0,
                    i,
                    n,
                    0,
                    i
                  ], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                  super(r, o, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t };
                }
                static fromJSON(e) {
                  return new cc(e.radius, e.detail);
                }
              }
              const uc = /* @__PURE__ */ new ye(), hc = /* @__PURE__ */ new ye(), fh = /* @__PURE__ */ new ye(), dc = /* @__PURE__ */ new es();
              class vf extends ti {
                constructor(e = null, t = 1) {
                  if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) {
                    const i = Math.pow(10, 4), r = Math.cos(Bs * t), o = e.getIndex(), a = e.getAttribute("position"), h = o ? o.count : a.count, m = [0, 0, 0], _ = ["a", "b", "c"], I = new Array(3), B = {}, L = [];
                    for (let N = 0; N < h; N += 3) {
                      o ? (m[0] = o.getX(N), m[1] = o.getX(N + 1), m[2] = o.getX(N + 2)) : (m[0] = N, m[1] = N + 1, m[2] = N + 2);
                      const { a: z, b: k, c: P } = dc;
                      if (z.fromBufferAttribute(a, m[0]), k.fromBufferAttribute(a, m[1]), P.fromBufferAttribute(a, m[2]), dc.getNormal(fh), I[0] = `${Math.round(z.x * i)},${Math.round(z.y * i)},${Math.round(z.z * i)}`, I[1] = `${Math.round(k.x * i)},${Math.round(k.y * i)},${Math.round(k.z * i)}`, I[2] = `${Math.round(P.x * i)},${Math.round(P.y * i)},${Math.round(P.z * i)}`, !(I[0] === I[1] || I[1] === I[2] || I[2] === I[0]))
                        for (let se = 0; se < 3; se++) {
                          const $ = (se + 1) % 3, J = I[se], Le = I[$], Ee = dc[_[se]], Me = dc[_[$]], Re = `${J}_${Le}`, Ae = `${Le}_${J}`;
                          Ae in B && B[Ae] ? (fh.dot(B[Ae].normal) <= r && (L.push(Ee.x, Ee.y, Ee.z), L.push(Me.x, Me.y, Me.z)), B[Ae] = null) : Re in B || (B[Re] = { index0: m[se], index1: m[$], normal: fh.clone() });
                        }
                    }
                    for (const N in B)
                      if (B[N]) {
                        const { index0: z, index1: k } = B[N];
                        uc.fromBufferAttribute(a, z), hc.fromBufferAttribute(a, k), L.push(uc.x, uc.y, uc.z), L.push(hc.x, hc.y, hc.z);
                      }
                    this.setAttribute("position", new gn(L, 3));
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
              }
              class Mo extends Ga {
                constructor(e) {
                  super(e), this.uuid = kr(), this.type = "Shape", this.holes = [];
                }
                getPointsHoles(e) {
                  const t = [];
                  for (let n = 0, i = this.holes.length; n < i; n++)
                    t[n] = this.holes[n].getPoints(e);
                  return t;
                }
                // get points of shape and holes (keypoints based on segments parameter)
                extractPoints(e) {
                  return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
                }
                copy(e) {
                  super.copy(e), this.holes = [];
                  for (let t = 0, n = e.holes.length; t < n; t++) {
                    const i = e.holes[t];
                    this.holes.push(i.clone());
                  }
                  return this;
                }
                toJSON() {
                  const e = super.toJSON();
                  e.uuid = this.uuid, e.holes = [];
                  for (let t = 0, n = this.holes.length; t < n; t++) {
                    const i = this.holes[t];
                    e.holes.push(i.toJSON());
                  }
                  return e;
                }
                fromJSON(e) {
                  super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                  for (let t = 0, n = e.holes.length; t < n; t++) {
                    const i = e.holes[t];
                    this.holes.push(new Ga().fromJSON(i));
                  }
                  return this;
                }
              }
              const Mv = { triangulate: function(s, e, t = 2) {
                const n = e && e.length, i = n ? e[0] * t : s.length;
                let r = Ef(s, 0, i, t, !0);
                const o = [];
                if (!r || r.next === r.prev) return o;
                let a, h, m, _, I, B, L;
                if (n && (r = Rv(s, e, r, t)), s.length > 80 * t) {
                  a = m = s[0], h = _ = s[1];
                  for (let N = t; N < i; N += t)
                    I = s[N], B = s[N + 1], I < a && (a = I), B < h && (h = B), I > m && (m = I), B > _ && (_ = B);
                  L = Math.max(m - a, _ - h), L = L !== 0 ? 32767 / L : 0;
                }
                return Va(r, o, t, a, h, L, 0), o;
              } };
              function Ef(s, e, t, n, i) {
                let r, o;
                if (i === Vv(s, e, t, n) > 0)
                  for (r = e; r < t; r += n) o = xf(r, s[r], s[r + 1], o);
                else
                  for (r = t - n; r >= e; r -= n) o = xf(r, s[r], s[r + 1], o);
                return o && fc(o, o.next) && (za(o), o = o.next), o;
              }
              function So(s, e) {
                if (!s) return s;
                e || (e = s);
                let t = s, n;
                do
                  if (n = !1, !t.steiner && (fc(t, t.next) || $i(t.prev, t, t.next) === 0)) {
                    if (za(t), t = e = t.prev, t === t.next) break;
                    n = !0;
                  } else
                    t = t.next;
                while (n || t !== e);
                return e;
              }
              function Va(s, e, t, n, i, r, o) {
                if (!s) return;
                !o && r && Fv(s, n, i, r);
                let a = s, h, m;
                for (; s.prev !== s.next; ) {
                  if (h = s.prev, m = s.next, r ? Tv(s, n, i, r) : Sv(s)) {
                    e.push(h.i / t | 0), e.push(s.i / t | 0), e.push(m.i / t | 0), za(s), s = m.next, a = m.next;
                    continue;
                  }
                  if (s = m, s === a) {
                    o ? o === 1 ? (s = Iv(So(s), e, t), Va(s, e, t, n, i, r, 2)) : o === 2 && Bv(s, e, t, n, i, r) : Va(So(s), e, t, n, i, r, 1);
                    break;
                  }
                }
              }
              function Sv(s) {
                const e = s.prev, t = s, n = s.next;
                if ($i(e, t, n) >= 0) return !1;
                const i = e.x, r = t.x, o = n.x, a = e.y, h = t.y, m = n.y, _ = i < r ? i < o ? i : o : r < o ? r : o, I = a < h ? a < m ? a : m : h < m ? h : m, B = i > r ? i > o ? i : o : r > o ? r : o, L = a > h ? a > m ? a : m : h > m ? h : m;
                let N = n.next;
                for (; N !== e; ) {
                  if (N.x >= _ && N.x <= B && N.y >= I && N.y <= L && Aa(i, a, r, h, o, m, N.x, N.y) && $i(N.prev, N, N.next) >= 0) return !1;
                  N = N.next;
                }
                return !0;
              }
              function Tv(s, e, t, n) {
                const i = s.prev, r = s, o = s.next;
                if ($i(i, r, o) >= 0) return !1;
                const a = i.x, h = r.x, m = o.x, _ = i.y, I = r.y, B = o.y, L = a < h ? a < m ? a : m : h < m ? h : m, N = _ < I ? _ < B ? _ : B : I < B ? I : B, z = a > h ? a > m ? a : m : h > m ? h : m, k = _ > I ? _ > B ? _ : B : I > B ? I : B, P = ph(L, N, e, t, n), se = ph(z, k, e, t, n);
                let $ = s.prevZ, J = s.nextZ;
                for (; $ && $.z >= P && J && J.z <= se; ) {
                  if ($.x >= L && $.x <= z && $.y >= N && $.y <= k && $ !== i && $ !== o && Aa(a, _, h, I, m, B, $.x, $.y) && $i($.prev, $, $.next) >= 0 || ($ = $.prevZ, J.x >= L && J.x <= z && J.y >= N && J.y <= k && J !== i && J !== o && Aa(a, _, h, I, m, B, J.x, J.y) && $i(J.prev, J, J.next) >= 0)) return !1;
                  J = J.nextZ;
                }
                for (; $ && $.z >= P; ) {
                  if ($.x >= L && $.x <= z && $.y >= N && $.y <= k && $ !== i && $ !== o && Aa(a, _, h, I, m, B, $.x, $.y) && $i($.prev, $, $.next) >= 0) return !1;
                  $ = $.prevZ;
                }
                for (; J && J.z <= se; ) {
                  if (J.x >= L && J.x <= z && J.y >= N && J.y <= k && J !== i && J !== o && Aa(a, _, h, I, m, B, J.x, J.y) && $i(J.prev, J, J.next) >= 0) return !1;
                  J = J.nextZ;
                }
                return !0;
              }
              function Iv(s, e, t) {
                let n = s;
                do {
                  const i = n.prev, r = n.next.next;
                  !fc(i, r) && yf(i, n, n.next, r) && Ha(i, r) && Ha(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), za(n), za(n.next), n = s = r), n = n.next;
                } while (n !== s);
                return So(n);
              }
              function Bv(s, e, t, n, i, r) {
                let o = s;
                do {
                  let a = o.next.next;
                  for (; a !== o.prev; ) {
                    if (o.i !== a.i && kv(o, a)) {
                      let h = Cf(o, a);
                      o = So(o, o.next), h = So(h, h.next), Va(o, e, t, n, i, r, 0), Va(h, e, t, n, i, r, 0);
                      return;
                    }
                    a = a.next;
                  }
                  o = o.next;
                } while (o !== s);
              }
              function Rv(s, e, t, n) {
                const i = [];
                let r, o, a, h, m;
                for (r = 0, o = e.length; r < o; r++)
                  a = e[r] * n, h = r < o - 1 ? e[r + 1] * n : s.length, m = Ef(s, a, h, n, !1), m === m.next && (m.steiner = !0), i.push(Nv(m));
                for (i.sort(Lv), r = 0; r < i.length; r++)
                  t = Dv(i[r], t);
                return t;
              }
              function Lv(s, e) {
                return s.x - e.x;
              }
              function Dv(s, e) {
                const t = Pv(s, e);
                if (!t)
                  return e;
                const n = Cf(t, s);
                return So(n, n.next), So(t, t.next);
              }
              function Pv(s, e) {
                let t = e, n = -1 / 0, i;
                const r = s.x, o = s.y;
                do {
                  if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
                    const B = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
                    if (B <= r && B > n && (n = B, i = t.x < t.next.x ? t : t.next, B === r))
                      return i;
                  }
                  t = t.next;
                } while (t !== e);
                if (!i) return null;
                const a = i, h = i.x, m = i.y;
                let _ = 1 / 0, I;
                t = i;
                do
                  r >= t.x && t.x >= h && r !== t.x && Aa(o < m ? r : n, o, h, m, o < m ? n : r, o, t.x, t.y) && (I = Math.abs(o - t.y) / (r - t.x), Ha(t, s) && (I < _ || I === _ && (t.x > i.x || t.x === i.x && Ov(i, t))) && (i = t, _ = I)), t = t.next;
                while (t !== a);
                return i;
              }
              function Ov(s, e) {
                return $i(s.prev, s, e.prev) < 0 && $i(e.next, s, s.next) < 0;
              }
              function Fv(s, e, t, n) {
                let i = s;
                do
                  i.z === 0 && (i.z = ph(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                while (i !== s);
                i.prevZ.nextZ = null, i.prevZ = null, Uv(i);
              }
              function Uv(s) {
                let e, t, n, i, r, o, a, h, m = 1;
                do {
                  for (t = s, s = null, r = null, o = 0; t; ) {
                    for (o++, n = t, a = 0, e = 0; e < m && (a++, n = n.nextZ, !!n); e++)
                      ;
                    for (h = m; a > 0 || h > 0 && n; )
                      a !== 0 && (h === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, h--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
                    t = n;
                  }
                  r.nextZ = null, m *= 2;
                } while (o > 1);
                return s;
              }
              function ph(s, e, t, n, i) {
                return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
              }
              function Nv(s) {
                let e = s, t = s;
                do
                  (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
                while (e !== s);
                return t;
              }
              function Aa(s, e, t, n, i, r, o, a) {
                return (i - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (i - o) * (n - a);
              }
              function kv(s, e) {
                return s.next.i !== e.i && s.prev.i !== e.i && !Gv(s, e) && // dones't intersect other edges
                (Ha(s, e) && Ha(e, s) && Qv(s, e) && // locally visible
                ($i(s.prev, s, e.prev) || $i(s, e.prev, e)) || // does not create opposite-facing sectors
                fc(s, e) && $i(s.prev, s, s.next) > 0 && $i(e.prev, e, e.next) > 0);
              }
              function $i(s, e, t) {
                return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
              }
              function fc(s, e) {
                return s.x === e.x && s.y === e.y;
              }
              function yf(s, e, t, n) {
                const i = Ac($i(s, e, t)), r = Ac($i(s, e, n)), o = Ac($i(t, n, s)), a = Ac($i(t, n, e));
                return !!(i !== r && o !== a || i === 0 && pc(s, t, e) || r === 0 && pc(s, n, e) || o === 0 && pc(t, s, n) || a === 0 && pc(t, e, n));
              }
              function pc(s, e, t) {
                return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
              }
              function Ac(s) {
                return s > 0 ? 1 : s < 0 ? -1 : 0;
              }
              function Gv(s, e) {
                let t = s;
                do {
                  if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && yf(t, t.next, s, e)) return !0;
                  t = t.next;
                } while (t !== s);
                return !1;
              }
              function Ha(s, e) {
                return $i(s.prev, s, s.next) < 0 ? $i(s, e, s.next) >= 0 && $i(s, s.prev, e) >= 0 : $i(s, e, s.prev) < 0 || $i(s, s.next, e) < 0;
              }
              function Qv(s, e) {
                let t = s, n = !1;
                const i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
                do
                  t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
                while (t !== s);
                return n;
              }
              function Cf(s, e) {
                const t = new Ah(s.i, s.x, s.y), n = new Ah(e.i, e.x, e.y), i = s.next, r = e.prev;
                return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
              }
              function xf(s, e, t, n) {
                const i = new Ah(s, e, t);
                return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
              }
              function za(s) {
                s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
              }
              function Ah(s, e, t) {
                this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
              }
              function Vv(s, e, t, n) {
                let i = 0;
                for (let r = e, o = t - n; r < t; r += n)
                  i += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
                return i;
              }
              class _s {
                // calculate area of the contour polygon
                static area(e) {
                  const t = e.length;
                  let n = 0;
                  for (let i = t - 1, r = 0; r < t; i = r++)
                    n += e[i].x * e[r].y - e[r].x * e[i].y;
                  return n * 0.5;
                }
                static isClockWise(e) {
                  return _s.area(e) < 0;
                }
                static triangulateShape(e, t) {
                  const n = [], i = [], r = [];
                  bf(e), _f(n, e);
                  let o = e.length;
                  t.forEach(bf);
                  for (let h = 0; h < t.length; h++)
                    i.push(o), o += t[h].length, _f(n, t[h]);
                  const a = Mv.triangulate(n, i);
                  for (let h = 0; h < a.length; h += 3)
                    r.push(a.slice(h, h + 3));
                  return r;
                }
              }
              function bf(s) {
                const e = s.length;
                e > 2 && s[e - 1].equals(s[0]) && s.pop();
              }
              function _f(s, e) {
                for (let t = 0; t < e.length; t++)
                  s.push(e[t].x), s.push(e[t].y);
              }
              class mc extends ti {
                constructor(e = new Mo([new pt(0.5, 0.5), new pt(-0.5, 0.5), new pt(-0.5, -0.5), new pt(0.5, -0.5)]), t = {}) {
                  super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e];
                  const n = this, i = [], r = [];
                  for (let a = 0, h = e.length; a < h; a++) {
                    const m = e[a];
                    o(m);
                  }
                  this.setAttribute("position", new gn(i, 3)), this.setAttribute("uv", new gn(r, 2)), this.computeVertexNormals();
                  function o(a) {
                    const h = [], m = t.curveSegments !== void 0 ? t.curveSegments : 12, _ = t.steps !== void 0 ? t.steps : 1, I = t.depth !== void 0 ? t.depth : 1;
                    let B = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, L = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, N = t.bevelSize !== void 0 ? t.bevelSize : L - 0.1, z = t.bevelOffset !== void 0 ? t.bevelOffset : 0, k = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
                    const P = t.extrudePath, se = t.UVGenerator !== void 0 ? t.UVGenerator : Hv;
                    let $, J = !1, Le, Ee, Me, Re;
                    P && ($ = P.getSpacedPoints(_), J = !0, B = !1, Le = P.computeFrenetFrames(_, !1), Ee = new ye(), Me = new ye(), Re = new ye()), B || (k = 0, L = 0, N = 0, z = 0);
                    const Ae = a.extractPoints(m);
                    let ce = Ae.shape;
                    const Ie = Ae.holes;
                    if (!_s.isClockWise(ce)) {
                      ce = ce.reverse();
                      for (let gt = 0, ot = Ie.length; gt < ot; gt++) {
                        const Bt = Ie[gt];
                        _s.isClockWise(Bt) && (Ie[gt] = Bt.reverse());
                      }
                    }
                    const Ue = _s.triangulateShape(ce, Ie), He = ce;
                    for (let gt = 0, ot = Ie.length; gt < ot; gt++) {
                      const Bt = Ie[gt];
                      ce = ce.concat(Bt);
                    }
                    function Ze(gt, ot, Bt) {
                      return ot || console.error("THREE.ExtrudeGeometry: vec does not exist"), gt.clone().addScaledVector(ot, Bt);
                    }
                    const dt = ce.length, Nt = Ue.length;
                    function et(gt, ot, Bt) {
                      let Tt, wt, Kt;
                      const nn = gt.x - ot.x, kn = gt.y - ot.y, zn = Bt.x - gt.x, wi = Bt.y - gt.y, er = nn * nn + kn * kn, zi = nn * wi - kn * zn;
                      if (Math.abs(zi) > Number.EPSILON) {
                        const Se = Math.sqrt(er), ue = Math.sqrt(zn * zn + wi * wi), it = ot.x - kn / Se, At = ot.y + nn / Se, yt = Bt.x - wi / ue, vt = Bt.y + zn / ue, En = ((yt - it) * wi - (vt - At) * zn) / (nn * wi - kn * zn);
                        Tt = it + nn * En - gt.x, wt = At + kn * En - gt.y;
                        const kt = Tt * Tt + wt * wt;
                        if (kt <= 2)
                          return new pt(Tt, wt);
                        Kt = Math.sqrt(kt / 2);
                      } else {
                        let Se = !1;
                        nn > Number.EPSILON ? zn > Number.EPSILON && (Se = !0) : nn < -Number.EPSILON ? zn < -Number.EPSILON && (Se = !0) : Math.sign(kn) === Math.sign(wi) && (Se = !0), Se ? (Tt = -kn, wt = nn, Kt = Math.sqrt(er)) : (Tt = nn, wt = kn, Kt = Math.sqrt(er / 2));
                      }
                      return new pt(Tt / Kt, wt / Kt);
                    }
                    const Lt = [];
                    for (let gt = 0, ot = He.length, Bt = ot - 1, Tt = gt + 1; gt < ot; gt++, Bt++, Tt++)
                      Bt === ot && (Bt = 0), Tt === ot && (Tt = 0), Lt[gt] = et(He[gt], He[Bt], He[Tt]);
                    const Ot = [];
                    let fn, ni = Lt.concat();
                    for (let gt = 0, ot = Ie.length; gt < ot; gt++) {
                      const Bt = Ie[gt];
                      fn = [];
                      for (let Tt = 0, wt = Bt.length, Kt = wt - 1, nn = Tt + 1; Tt < wt; Tt++, Kt++, nn++)
                        Kt === wt && (Kt = 0), nn === wt && (nn = 0), fn[Tt] = et(Bt[Tt], Bt[Kt], Bt[nn]);
                      Ot.push(fn), ni = ni.concat(fn);
                    }
                    for (let gt = 0; gt < k; gt++) {
                      const ot = gt / k, Bt = L * Math.cos(ot * Math.PI / 2), Tt = N * Math.sin(ot * Math.PI / 2) + z;
                      for (let wt = 0, Kt = He.length; wt < Kt; wt++) {
                        const nn = Ze(He[wt], Lt[wt], Tt);
                        An(nn.x, nn.y, -Bt);
                      }
                      for (let wt = 0, Kt = Ie.length; wt < Kt; wt++) {
                        const nn = Ie[wt];
                        fn = Ot[wt];
                        for (let kn = 0, zn = nn.length; kn < zn; kn++) {
                          const wi = Ze(nn[kn], fn[kn], Tt);
                          An(wi.x, wi.y, -Bt);
                        }
                      }
                    }
                    const Si = N + z;
                    for (let gt = 0; gt < dt; gt++) {
                      const ot = B ? Ze(ce[gt], ni[gt], Si) : ce[gt];
                      J ? (Me.copy(Le.normals[0]).multiplyScalar(ot.x), Ee.copy(Le.binormals[0]).multiplyScalar(ot.y), Re.copy($[0]).add(Me).add(Ee), An(Re.x, Re.y, Re.z)) : An(ot.x, ot.y, 0);
                    }
                    for (let gt = 1; gt <= _; gt++)
                      for (let ot = 0; ot < dt; ot++) {
                        const Bt = B ? Ze(ce[ot], ni[ot], Si) : ce[ot];
                        J ? (Me.copy(Le.normals[gt]).multiplyScalar(Bt.x), Ee.copy(Le.binormals[gt]).multiplyScalar(Bt.y), Re.copy($[gt]).add(Me).add(Ee), An(Re.x, Re.y, Re.z)) : An(Bt.x, Bt.y, I / _ * gt);
                      }
                    for (let gt = k - 1; gt >= 0; gt--) {
                      const ot = gt / k, Bt = L * Math.cos(ot * Math.PI / 2), Tt = N * Math.sin(ot * Math.PI / 2) + z;
                      for (let wt = 0, Kt = He.length; wt < Kt; wt++) {
                        const nn = Ze(He[wt], Lt[wt], Tt);
                        An(nn.x, nn.y, I + Bt);
                      }
                      for (let wt = 0, Kt = Ie.length; wt < Kt; wt++) {
                        const nn = Ie[wt];
                        fn = Ot[wt];
                        for (let kn = 0, zn = nn.length; kn < zn; kn++) {
                          const wi = Ze(nn[kn], fn[kn], Tt);
                          J ? An(wi.x, wi.y + $[_ - 1].y, $[_ - 1].x + Bt) : An(wi.x, wi.y, I + Bt);
                        }
                      }
                    }
                    Hi(), _i();
                    function Hi() {
                      const gt = i.length / 3;
                      if (B) {
                        let ot = 0, Bt = dt * ot;
                        for (let Tt = 0; Tt < Nt; Tt++) {
                          const wt = Ue[Tt];
                          mt(wt[2] + Bt, wt[1] + Bt, wt[0] + Bt);
                        }
                        ot = _ + k * 2, Bt = dt * ot;
                        for (let Tt = 0; Tt < Nt; Tt++) {
                          const wt = Ue[Tt];
                          mt(wt[0] + Bt, wt[1] + Bt, wt[2] + Bt);
                        }
                      } else {
                        for (let ot = 0; ot < Nt; ot++) {
                          const Bt = Ue[ot];
                          mt(Bt[2], Bt[1], Bt[0]);
                        }
                        for (let ot = 0; ot < Nt; ot++) {
                          const Bt = Ue[ot];
                          mt(Bt[0] + dt * _, Bt[1] + dt * _, Bt[2] + dt * _);
                        }
                      }
                      n.addGroup(gt, i.length / 3 - gt, 0);
                    }
                    function _i() {
                      const gt = i.length / 3;
                      let ot = 0;
                      Ui(He, ot), ot += He.length;
                      for (let Bt = 0, Tt = Ie.length; Bt < Tt; Bt++) {
                        const wt = Ie[Bt];
                        Ui(wt, ot), ot += wt.length;
                      }
                      n.addGroup(gt, i.length / 3 - gt, 1);
                    }
                    function Ui(gt, ot) {
                      let Bt = gt.length;
                      for (; --Bt >= 0; ) {
                        const Tt = Bt;
                        let wt = Bt - 1;
                        wt < 0 && (wt = gt.length - 1);
                        for (let Kt = 0, nn = _ + k * 2; Kt < nn; Kt++) {
                          const kn = dt * Kt, zn = dt * (Kt + 1), wi = ot + Tt + kn, er = ot + wt + kn, zi = ot + wt + zn, Se = ot + Tt + zn;
                          Gt(wi, er, zi, Se);
                        }
                      }
                    }
                    function An(gt, ot, Bt) {
                      h.push(gt), h.push(ot), h.push(Bt);
                    }
                    function mt(gt, ot, Bt) {
                      Ht(gt), Ht(ot), Ht(Bt);
                      const Tt = i.length / 3, wt = se.generateTopUV(n, i, Tt - 3, Tt - 2, Tt - 1);
                      ze(wt[0]), ze(wt[1]), ze(wt[2]);
                    }
                    function Gt(gt, ot, Bt, Tt) {
                      Ht(gt), Ht(ot), Ht(Tt), Ht(ot), Ht(Bt), Ht(Tt);
                      const wt = i.length / 3, Kt = se.generateSideWallUV(n, i, wt - 6, wt - 3, wt - 2, wt - 1);
                      ze(Kt[0]), ze(Kt[1]), ze(Kt[3]), ze(Kt[1]), ze(Kt[2]), ze(Kt[3]);
                    }
                    function Ht(gt) {
                      i.push(h[gt * 3 + 0]), i.push(h[gt * 3 + 1]), i.push(h[gt * 3 + 2]);
                    }
                    function ze(gt) {
                      r.push(gt.x), r.push(gt.y);
                    }
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                toJSON() {
                  const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
                  return zv(t, n, e);
                }
                static fromJSON(e, t) {
                  const n = [];
                  for (let r = 0, o = e.shapes.length; r < o; r++) {
                    const a = t[e.shapes[r]];
                    n.push(a);
                  }
                  const i = e.options.extrudePath;
                  return i !== void 0 && (e.options.extrudePath = new sc[i.type]().fromJSON(i)), new mc(n, e.options);
                }
              }
              const Hv = { generateTopUV: function(s, e, t, n, i) {
                const r = e[t * 3], o = e[t * 3 + 1], a = e[n * 3], h = e[n * 3 + 1], m = e[i * 3], _ = e[i * 3 + 1];
                return [new pt(r, o), new pt(a, h), new pt(m, _)];
              }, generateSideWallUV: function(s, e, t, n, i, r) {
                const o = e[t * 3], a = e[t * 3 + 1], h = e[t * 3 + 2], m = e[n * 3], _ = e[n * 3 + 1], I = e[n * 3 + 2], B = e[i * 3], L = e[i * 3 + 1], N = e[i * 3 + 2], z = e[r * 3], k = e[r * 3 + 1], P = e[r * 3 + 2];
                return Math.abs(a - _) < Math.abs(o - m) ? [new pt(o, 1 - h), new pt(m, 1 - I), new pt(B, 1 - N), new pt(z, 1 - P)] : [new pt(a, 1 - h), new pt(_, 1 - I), new pt(L, 1 - N), new pt(k, 1 - P)];
              } };
              function zv(s, e, t) {
                if (t.shapes = [], Array.isArray(s))
                  for (let n = 0, i = s.length; n < i; n++) {
                    const r = s[n];
                    t.shapes.push(r.uuid);
                  }
                else
                  t.shapes.push(s.uuid);
                return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
              }
              class gc extends no {
                constructor(e = 1, t = 0) {
                  const n = (1 + Math.sqrt(5)) / 2, i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                  super(i, r, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t };
                }
                static fromJSON(e) {
                  return new gc(e.radius, e.detail);
                }
              }
              class ja extends no {
                constructor(e = 1, t = 0) {
                  const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                  super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t };
                }
                static fromJSON(e) {
                  return new ja(e.radius, e.detail);
                }
              }
              class vc extends ti {
                constructor(e = 0.5, t = 1, n = 32, i = 1, r = 0, o = Math.PI * 2) {
                  super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }, n = Math.max(3, n), i = Math.max(1, i);
                  const a = [], h = [], m = [], _ = [];
                  let I = e;
                  const B = (t - e) / i, L = new ye(), N = new pt();
                  for (let z = 0; z <= i; z++) {
                    for (let k = 0; k <= n; k++) {
                      const P = r + k / n * o;
                      L.x = I * Math.cos(P), L.y = I * Math.sin(P), h.push(L.x, L.y, L.z), m.push(0, 0, 1), N.x = (L.x / t + 1) / 2, N.y = (L.y / t + 1) / 2, _.push(N.x, N.y);
                    }
                    I += B;
                  }
                  for (let z = 0; z < i; z++) {
                    const k = z * (n + 1);
                    for (let P = 0; P < n; P++) {
                      const se = P + k, $ = se, J = se + n + 1, Le = se + n + 2, Ee = se + 1;
                      a.push($, J, Ee), a.push(J, Le, Ee);
                    }
                  }
                  this.setIndex(a), this.setAttribute("position", new gn(h, 3)), this.setAttribute("normal", new gn(m, 3)), this.setAttribute("uv", new gn(_, 2));
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new vc(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
                }
              }
              class Ec extends ti {
                constructor(e = new Mo([new pt(0, 0.5), new pt(-0.5, -0.5), new pt(0.5, -0.5)]), t = 12) {
                  super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t };
                  const n = [], i = [], r = [], o = [];
                  let a = 0, h = 0;
                  if (Array.isArray(e) === !1)
                    m(e);
                  else
                    for (let _ = 0; _ < e.length; _++)
                      m(e[_]), this.addGroup(a, h, _), a += h, h = 0;
                  this.setIndex(n), this.setAttribute("position", new gn(i, 3)), this.setAttribute("normal", new gn(r, 3)), this.setAttribute("uv", new gn(o, 2));
                  function m(_) {
                    const I = i.length / 3, B = _.extractPoints(t);
                    let L = B.shape;
                    const N = B.holes;
                    _s.isClockWise(L) === !1 && (L = L.reverse());
                    for (let k = 0, P = N.length; k < P; k++) {
                      const se = N[k];
                      _s.isClockWise(se) === !0 && (N[k] = se.reverse());
                    }
                    const z = _s.triangulateShape(L, N);
                    for (let k = 0, P = N.length; k < P; k++) {
                      const se = N[k];
                      L = L.concat(se);
                    }
                    for (let k = 0, P = L.length; k < P; k++) {
                      const se = L[k];
                      i.push(se.x, se.y, 0), r.push(0, 0, 1), o.push(se.x, se.y);
                    }
                    for (let k = 0, P = z.length; k < P; k++) {
                      const se = z[k], $ = se[0] + I, J = se[1] + I, Le = se[2] + I;
                      n.push($, J, Le), h += 3;
                    }
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                toJSON() {
                  const e = super.toJSON(), t = this.parameters.shapes;
                  return jv(t, e);
                }
                static fromJSON(e, t) {
                  const n = [];
                  for (let i = 0, r = e.shapes.length; i < r; i++) {
                    const o = t[e.shapes[i]];
                    n.push(o);
                  }
                  return new Ec(n, e.curveSegments);
                }
              }
              function jv(s, e) {
                if (e.shapes = [], Array.isArray(s))
                  for (let t = 0, n = s.length; t < n; t++) {
                    const i = s[t];
                    e.shapes.push(i.uuid);
                  }
                else
                  e.shapes.push(s.uuid);
                return e;
              }
              class Wa extends ti {
                constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
                  super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: i, phiLength: r, thetaStart: o, thetaLength: a }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                  const h = Math.min(o + a, Math.PI);
                  let m = 0;
                  const _ = [], I = new ye(), B = new ye(), L = [], N = [], z = [], k = [];
                  for (let P = 0; P <= n; P++) {
                    const se = [], $ = P / n;
                    let J = 0;
                    P === 0 && o === 0 ? J = 0.5 / t : P === n && h === Math.PI && (J = -0.5 / t);
                    for (let Le = 0; Le <= t; Le++) {
                      const Ee = Le / t;
                      I.x = -e * Math.cos(i + Ee * r) * Math.sin(o + $ * a), I.y = e * Math.cos(o + $ * a), I.z = e * Math.sin(i + Ee * r) * Math.sin(o + $ * a), N.push(I.x, I.y, I.z), B.copy(I).normalize(), z.push(B.x, B.y, B.z), k.push(Ee + J, 1 - $), se.push(m++);
                    }
                    _.push(se);
                  }
                  for (let P = 0; P < n; P++)
                    for (let se = 0; se < t; se++) {
                      const $ = _[P][se + 1], J = _[P][se], Le = _[P + 1][se], Ee = _[P + 1][se + 1];
                      (P !== 0 || o > 0) && L.push($, J, Ee), (P !== n - 1 || h < Math.PI) && L.push(J, Le, Ee);
                    }
                  this.setIndex(L), this.setAttribute("position", new gn(N, 3)), this.setAttribute("normal", new gn(z, 3)), this.setAttribute("uv", new gn(k, 2));
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new Wa(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
                }
              }
              class yc extends no {
                constructor(e = 1, t = 0) {
                  const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                  super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t };
                }
                static fromJSON(e) {
                  return new yc(e.radius, e.detail);
                }
              }
              class Cc extends ti {
                constructor(e = 1, t = 0.4, n = 12, i = 48, r = Math.PI * 2) {
                  super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: i, arc: r }, n = Math.floor(n), i = Math.floor(i);
                  const o = [], a = [], h = [], m = [], _ = new ye(), I = new ye(), B = new ye();
                  for (let L = 0; L <= n; L++)
                    for (let N = 0; N <= i; N++) {
                      const z = N / i * r, k = L / n * Math.PI * 2;
                      I.x = (e + t * Math.cos(k)) * Math.cos(z), I.y = (e + t * Math.cos(k)) * Math.sin(z), I.z = t * Math.sin(k), a.push(I.x, I.y, I.z), _.x = e * Math.cos(z), _.y = e * Math.sin(z), B.subVectors(I, _).normalize(), h.push(B.x, B.y, B.z), m.push(N / i), m.push(L / n);
                    }
                  for (let L = 1; L <= n; L++)
                    for (let N = 1; N <= i; N++) {
                      const z = (i + 1) * L + N - 1, k = (i + 1) * (L - 1) + N - 1, P = (i + 1) * (L - 1) + N, se = (i + 1) * L + N;
                      o.push(z, k, se), o.push(k, P, se);
                    }
                  this.setIndex(o), this.setAttribute("position", new gn(a, 3)), this.setAttribute("normal", new gn(h, 3)), this.setAttribute("uv", new gn(m, 2));
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new Cc(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
                }
              }
              class xc extends ti {
                constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, o = 3) {
                  super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: i, p: r, q: o }, n = Math.floor(n), i = Math.floor(i);
                  const a = [], h = [], m = [], _ = [], I = new ye(), B = new ye(), L = new ye(), N = new ye(), z = new ye(), k = new ye(), P = new ye();
                  for (let $ = 0; $ <= n; ++$) {
                    const J = $ / n * r * Math.PI * 2;
                    se(J, r, o, e, L), se(J + 0.01, r, o, e, N), k.subVectors(N, L), P.addVectors(N, L), z.crossVectors(k, P), P.crossVectors(z, k), z.normalize(), P.normalize();
                    for (let Le = 0; Le <= i; ++Le) {
                      const Ee = Le / i * Math.PI * 2, Me = -t * Math.cos(Ee), Re = t * Math.sin(Ee);
                      I.x = L.x + (Me * P.x + Re * z.x), I.y = L.y + (Me * P.y + Re * z.y), I.z = L.z + (Me * P.z + Re * z.z), h.push(I.x, I.y, I.z), B.subVectors(I, L).normalize(), m.push(B.x, B.y, B.z), _.push($ / n), _.push(Le / i);
                    }
                  }
                  for (let $ = 1; $ <= n; $++)
                    for (let J = 1; J <= i; J++) {
                      const Le = (i + 1) * ($ - 1) + (J - 1), Ee = (i + 1) * $ + (J - 1), Me = (i + 1) * $ + J, Re = (i + 1) * ($ - 1) + J;
                      a.push(Le, Ee, Re), a.push(Ee, Me, Re);
                    }
                  this.setIndex(a), this.setAttribute("position", new gn(h, 3)), this.setAttribute("normal", new gn(m, 3)), this.setAttribute("uv", new gn(_, 2));
                  function se($, J, Le, Ee, Me) {
                    const Re = Math.cos($), Ae = Math.sin($), ce = Le / J * $, Ie = Math.cos(ce);
                    Me.x = Ee * (2 + Ie) * 0.5 * Re, Me.y = Ee * (2 + Ie) * Ae * 0.5, Me.z = Ee * Math.sin(ce) * 0.5;
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                static fromJSON(e) {
                  return new xc(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
                }
              }
              class bc extends ti {
                constructor(e = new hh(new ye(-1, -1, 0), new ye(-1, 1, 0), new ye(1, 1, 0)), t = 64, n = 1, i = 8, r = !1) {
                  super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: i, closed: r };
                  const o = e.computeFrenetFrames(t, r);
                  this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                  const a = new ye(), h = new ye(), m = new pt();
                  let _ = new ye();
                  const I = [], B = [], L = [], N = [];
                  z(), this.setIndex(N), this.setAttribute("position", new gn(I, 3)), this.setAttribute("normal", new gn(B, 3)), this.setAttribute("uv", new gn(L, 2));
                  function z() {
                    for (let $ = 0; $ < t; $++)
                      k($);
                    k(r === !1 ? t : 0), se(), P();
                  }
                  function k($) {
                    _ = e.getPointAt($ / t, _);
                    const J = o.normals[$], Le = o.binormals[$];
                    for (let Ee = 0; Ee <= i; Ee++) {
                      const Me = Ee / i * Math.PI * 2, Re = Math.sin(Me), Ae = -Math.cos(Me);
                      h.x = Ae * J.x + Re * Le.x, h.y = Ae * J.y + Re * Le.y, h.z = Ae * J.z + Re * Le.z, h.normalize(), B.push(h.x, h.y, h.z), a.x = _.x + n * h.x, a.y = _.y + n * h.y, a.z = _.z + n * h.z, I.push(a.x, a.y, a.z);
                    }
                  }
                  function P() {
                    for (let $ = 1; $ <= t; $++)
                      for (let J = 1; J <= i; J++) {
                        const Le = (i + 1) * ($ - 1) + (J - 1), Ee = (i + 1) * $ + (J - 1), Me = (i + 1) * $ + J, Re = (i + 1) * ($ - 1) + J;
                        N.push(Le, Ee, Re), N.push(Ee, Me, Re);
                      }
                  }
                  function se() {
                    for (let $ = 0; $ <= t; $++)
                      for (let J = 0; J <= i; J++)
                        m.x = $ / t, m.y = J / i, L.push(m.x, m.y);
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.path = this.parameters.path.toJSON(), e;
                }
                static fromJSON(e) {
                  return new bc(new sc[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
                }
              }
              class wf extends ti {
                constructor(e = null) {
                  if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) {
                    const t = [], n = /* @__PURE__ */ new Set(), i = new ye(), r = new ye();
                    if (e.index !== null) {
                      const o = e.attributes.position, a = e.index;
                      let h = e.groups;
                      h.length === 0 && (h = [{ start: 0, count: a.count, materialIndex: 0 }]);
                      for (let m = 0, _ = h.length; m < _; ++m) {
                        const I = h[m], B = I.start, L = I.count;
                        for (let N = B, z = B + L; N < z; N += 3)
                          for (let k = 0; k < 3; k++) {
                            const P = a.getX(N + k), se = a.getX(N + (k + 1) % 3);
                            i.fromBufferAttribute(o, P), r.fromBufferAttribute(o, se), Mf(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
                          }
                      }
                    } else {
                      const o = e.attributes.position;
                      for (let a = 0, h = o.count / 3; a < h; a++)
                        for (let m = 0; m < 3; m++) {
                          const _ = 3 * a + m, I = 3 * a + (m + 1) % 3;
                          i.fromBufferAttribute(o, _), r.fromBufferAttribute(o, I), Mf(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
                        }
                    }
                    this.setAttribute("position", new gn(t, 3));
                  }
                }
                copy(e) {
                  return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
                }
              }
              function Mf(s, e, t) {
                const n = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
                return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
              }
              var Sf = /* @__PURE__ */ Object.freeze({ __proto__: null, BoxGeometry: go, CapsuleGeometry: oc, CircleGeometry: ac, ConeGeometry: lc, CylinderGeometry: pa, DodecahedronGeometry: cc, EdgesGeometry: vf, ExtrudeGeometry: mc, IcosahedronGeometry: gc, LatheGeometry: Qa, OctahedronGeometry: ja, PlaneGeometry: ia, PolyhedronGeometry: no, RingGeometry: vc, ShapeGeometry: Ec, SphereGeometry: Wa, TetrahedronGeometry: yc, TorusGeometry: Cc, TorusKnotGeometry: xc, TubeGeometry: bc, WireframeGeometry: wf });
              class Tf extends Pr {
                constructor(e) {
                  super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new sn(0), this.transparent = !0, this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
                }
              }
              class If extends fs {
                constructor(e) {
                  super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
                }
              }
              class mh extends Pr {
                constructor(e) {
                  super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new sn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rr, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $r(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
                }
              }
              class Bf extends mh {
                constructor(e) {
                  super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new pt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
                    return Yi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
                  }, set: function(t) {
                    this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                  } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new sn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new sn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new sn(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
                }
                get anisotropy() {
                  return this._anisotropy;
                }
                set anisotropy(e) {
                  this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
                }
                get clearcoat() {
                  return this._clearcoat;
                }
                set clearcoat(e) {
                  this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
                }
                get iridescence() {
                  return this._iridescence;
                }
                set iridescence(e) {
                  this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
                }
                get dispersion() {
                  return this._dispersion;
                }
                set dispersion(e) {
                  this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
                }
                get sheen() {
                  return this._sheen;
                }
                set sheen(e) {
                  this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
                }
                get transmission() {
                  return this._transmission;
                }
                set transmission(e) {
                  this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
                }
                copy(e) {
                  return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
                }
              }
              class Rf extends Pr {
                constructor(e) {
                  super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new sn(16777215), this.specular = new sn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rr, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $r(), this.combine = Be, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
                }
              }
              class Lf extends Pr {
                constructor(e) {
                  super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new sn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rr, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
                }
              }
              class Df extends Pr {
                constructor(e) {
                  super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rr, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
                }
              }
              class Pf extends Pr {
                constructor(e) {
                  super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new sn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rr, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $r(), this.combine = Be, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
                }
              }
              class Of extends Pr {
                constructor(e) {
                  super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new sn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rr, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
                }
              }
              class Ff extends Hr {
                constructor(e) {
                  super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
                }
                copy(e) {
                  return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
                }
              }
              function To(s, e, t) {
                return !s || // let 'undefined' and 'null' pass
                !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
              }
              function Uf(s) {
                return ArrayBuffer.isView(s) && !(s instanceof DataView);
              }
              function Nf(s) {
                function e(i, r) {
                  return s[i] - s[r];
                }
                const t = s.length, n = new Array(t);
                for (let i = 0; i !== t; ++i) n[i] = i;
                return n.sort(e), n;
              }
              function gh(s, e, t) {
                const n = s.length, i = new s.constructor(n);
                for (let r = 0, o = 0; o !== n; ++r) {
                  const a = t[r] * e;
                  for (let h = 0; h !== e; ++h)
                    i[o++] = s[a + h];
                }
                return i;
              }
              function vh(s, e, t, n) {
                let i = 1, r = s[0];
                for (; r !== void 0 && r[n] === void 0; )
                  r = s[i++];
                if (r === void 0) return;
                let o = r[n];
                if (o !== void 0)
                  if (Array.isArray(o))
                    do
                      o = r[n], o !== void 0 && (e.push(r.time), t.push.apply(t, o)), r = s[i++];
                    while (r !== void 0);
                  else if (o.toArray !== void 0)
                    do
                      o = r[n], o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), r = s[i++];
                    while (r !== void 0);
                  else
                    do
                      o = r[n], o !== void 0 && (e.push(r.time), t.push(o)), r = s[i++];
                    while (r !== void 0);
              }
              function Wv(s, e, t, n, i = 30) {
                const r = s.clone();
                r.name = e;
                const o = [];
                for (let h = 0; h < r.tracks.length; ++h) {
                  const m = r.tracks[h], _ = m.getValueSize(), I = [], B = [];
                  for (let L = 0; L < m.times.length; ++L) {
                    const N = m.times[L] * i;
                    if (!(N < t || N >= n)) {
                      I.push(m.times[L]);
                      for (let z = 0; z < _; ++z)
                        B.push(m.values[L * _ + z]);
                    }
                  }
                  I.length !== 0 && (m.times = To(I, m.times.constructor), m.values = To(B, m.values.constructor), o.push(m));
                }
                r.tracks = o;
                let a = 1 / 0;
                for (let h = 0; h < r.tracks.length; ++h)
                  a > r.tracks[h].times[0] && (a = r.tracks[h].times[0]);
                for (let h = 0; h < r.tracks.length; ++h)
                  r.tracks[h].shift(-1 * a);
                return r.resetDuration(), r;
              }
              function Kv(s, e = 0, t = s, n = 30) {
                n <= 0 && (n = 30);
                const i = t.tracks.length, r = e / n;
                for (let o = 0; o < i; ++o) {
                  const a = t.tracks[o], h = a.ValueTypeName;
                  if (h === "bool" || h === "string") continue;
                  const m = s.tracks.find(function(P) {
                    return P.name === a.name && P.ValueTypeName === h;
                  });
                  if (m === void 0) continue;
                  let _ = 0;
                  const I = a.getValueSize();
                  a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (_ = I / 3);
                  let B = 0;
                  const L = m.getValueSize();
                  m.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (B = L / 3);
                  const N = a.times.length - 1;
                  let z;
                  if (r <= a.times[0]) {
                    const P = _, se = I - _;
                    z = a.values.slice(P, se);
                  } else if (r >= a.times[N]) {
                    const P = N * I + _, se = P + I - _;
                    z = a.values.slice(P, se);
                  } else {
                    const P = a.createInterpolant(), se = _, $ = I - _;
                    P.evaluate(r), z = P.resultBuffer.slice(se, $);
                  }
                  h === "quaternion" && new xi().fromArray(z).normalize().conjugate().toArray(z);
                  const k = m.times.length;
                  for (let P = 0; P < k; ++P) {
                    const se = P * L + B;
                    if (h === "quaternion")
                      xi.multiplyQuaternionsFlat(m.values, se, z, 0, m.values, se);
                    else {
                      const $ = L - B * 2;
                      for (let J = 0; J < $; ++J)
                        m.values[se + J] -= z[J];
                    }
                  }
                }
                return s.blendMode = us, s;
              }
              const Xv = { convertArray: To, isTypedArray: Uf, getKeyframeOrder: Nf, sortedArray: gh, flattenJSON: vh, subclip: Wv, makeClipAdditive: Kv };
              class Ka {
                constructor(e, t, n, i) {
                  this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
                }
                evaluate(e) {
                  const t = this.parameterPositions;
                  let n = this._cachedIndex, i = t[n], r = t[n - 1];
                  e: {
                    t: {
                      let o;
                      n: {
                        i: if (!(e < i)) {
                          for (let a = n + 2; ; ) {
                            if (i === void 0) {
                              if (e < r) break i;
                              return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                            }
                            if (n === a) break;
                            if (r = i, i = t[++n], e < i)
                              break t;
                          }
                          o = t.length;
                          break n;
                        }
                        if (!(e >= r)) {
                          const a = t[1];
                          e < a && (n = 2, r = a);
                          for (let h = n - 2; ; ) {
                            if (r === void 0)
                              return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (n === h) break;
                            if (i = r, r = t[--n - 1], e >= r)
                              break t;
                          }
                          o = n, n = 0;
                          break n;
                        }
                        break e;
                      }
                      for (; n < o; ) {
                        const a = n + o >>> 1;
                        e < t[a] ? o = a : n = a + 1;
                      }
                      if (i = t[n], r = t[n - 1], r === void 0)
                        return this._cachedIndex = 0, this.copySampleValue_(0);
                      if (i === void 0)
                        return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                    }
                    this._cachedIndex = n, this.intervalChanged_(n, r, i);
                  }
                  return this.interpolate_(n, r, e, i);
                }
                getSettings_() {
                  return this.settings || this.DefaultSettings_;
                }
                copySampleValue_(e) {
                  const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
                  for (let o = 0; o !== i; ++o)
                    t[o] = n[r + o];
                  return t;
                }
                // Template methods for derived classes:
                interpolate_() {
                  throw new Error("call to abstract method");
                }
                intervalChanged_() {
                }
              }
              class kf extends Ka {
                constructor(e, t, n, i) {
                  super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Ji, endingEnd: Ji };
                }
                intervalChanged_(e, t, n) {
                  const i = this.parameterPositions;
                  let r = e - 2, o = e + 1, a = i[r], h = i[o];
                  if (a === void 0)
                    switch (this.getSettings_().endingStart) {
                      case xr:
                        r = e, a = 2 * t - n;
                        break;
                      case Yr:
                        r = i.length - 2, a = t + i[r] - i[r + 1];
                        break;
                      default:
                        r = e, a = n;
                    }
                  if (h === void 0)
                    switch (this.getSettings_().endingEnd) {
                      case xr:
                        o = e, h = 2 * n - t;
                        break;
                      case Yr:
                        o = 1, h = n + i[1] - i[0];
                        break;
                      default:
                        o = e - 1, h = t;
                    }
                  const m = (n - t) * 0.5, _ = this.valueSize;
                  this._weightPrev = m / (t - a), this._weightNext = m / (h - n), this._offsetPrev = r * _, this._offsetNext = o * _;
                }
                interpolate_(e, t, n, i) {
                  const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, h = e * a, m = h - a, _ = this._offsetPrev, I = this._offsetNext, B = this._weightPrev, L = this._weightNext, N = (n - t) / (i - t), z = N * N, k = z * N, P = -B * k + 2 * B * z - B * N, se = (1 + B) * k + (-1.5 - 2 * B) * z + (-0.5 + B) * N + 1, $ = (-1 - L) * k + (1.5 + L) * z + 0.5 * N, J = L * k - L * z;
                  for (let Le = 0; Le !== a; ++Le)
                    r[Le] = P * o[_ + Le] + se * o[m + Le] + $ * o[h + Le] + J * o[I + Le];
                  return r;
                }
              }
              class Eh extends Ka {
                constructor(e, t, n, i) {
                  super(e, t, n, i);
                }
                interpolate_(e, t, n, i) {
                  const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, h = e * a, m = h - a, _ = (n - t) / (i - t), I = 1 - _;
                  for (let B = 0; B !== a; ++B)
                    r[B] = o[m + B] * I + o[h + B] * _;
                  return r;
                }
              }
              class Gf extends Ka {
                constructor(e, t, n, i) {
                  super(e, t, n, i);
                }
                interpolate_(e) {
                  return this.copySampleValue_(e - 1);
                }
              }
              class ms {
                constructor(e, t, n, i) {
                  if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
                  if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                  this.name = e, this.times = To(t, this.TimeBufferType), this.values = To(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
                }
                // Serialization (in static context, because of constructor invocation
                // and automatic invocation of .toJSON):
                static toJSON(e) {
                  const t = e.constructor;
                  let n;
                  if (t.toJSON !== this.toJSON)
                    n = t.toJSON(e);
                  else {
                    n = { name: e.name, times: To(e.times, Array), values: To(e.values, Array) };
                    const i = e.getInterpolation();
                    i !== e.DefaultInterpolation && (n.interpolation = i);
                  }
                  return n.type = e.ValueTypeName, n;
                }
                InterpolantFactoryMethodDiscrete(e) {
                  return new Gf(this.times, this.values, this.getValueSize(), e);
                }
                InterpolantFactoryMethodLinear(e) {
                  return new Eh(this.times, this.values, this.getValueSize(), e);
                }
                InterpolantFactoryMethodSmooth(e) {
                  return new kf(this.times, this.values, this.getValueSize(), e);
                }
                setInterpolation(e) {
                  let t;
                  switch (e) {
                    case or:
                      t = this.InterpolantFactoryMethodDiscrete;
                      break;
                    case ar:
                      t = this.InterpolantFactoryMethodLinear;
                      break;
                    case cr:
                      t = this.InterpolantFactoryMethodSmooth;
                      break;
                  }
                  if (t === void 0) {
                    const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (this.createInterpolant === void 0)
                      if (e !== this.DefaultInterpolation)
                        this.setInterpolation(this.DefaultInterpolation);
                      else
                        throw new Error(n);
                    return console.warn("THREE.KeyframeTrack:", n), this;
                  }
                  return this.createInterpolant = t, this;
                }
                getInterpolation() {
                  switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                      return or;
                    case this.InterpolantFactoryMethodLinear:
                      return ar;
                    case this.InterpolantFactoryMethodSmooth:
                      return cr;
                  }
                }
                getValueSize() {
                  return this.values.length / this.times.length;
                }
                // move all keyframes either forwards or backwards in time
                shift(e) {
                  if (e !== 0) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                      t[n] += e;
                  }
                  return this;
                }
                // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
                scale(e) {
                  if (e !== 1) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                      t[n] *= e;
                  }
                  return this;
                }
                // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
                // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
                trim(e, t) {
                  const n = this.times, i = n.length;
                  let r = 0, o = i - 1;
                  for (; r !== i && n[r] < e; )
                    ++r;
                  for (; o !== -1 && n[o] > t; )
                    --o;
                  if (++o, r !== 0 || o !== i) {
                    r >= o && (o = Math.max(o, 1), r = o - 1);
                    const a = this.getValueSize();
                    this.times = n.slice(r, o), this.values = this.values.slice(r * a, o * a);
                  }
                  return this;
                }
                // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
                validate() {
                  let e = !0;
                  const t = this.getValueSize();
                  t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                  const n = this.times, i = this.values, r = n.length;
                  r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                  let o = null;
                  for (let a = 0; a !== r; a++) {
                    const h = n[a];
                    if (typeof h == "number" && isNaN(h)) {
                      console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, h), e = !1;
                      break;
                    }
                    if (o !== null && o > h) {
                      console.error("THREE.KeyframeTrack: Out of order keys.", this, a, h, o), e = !1;
                      break;
                    }
                    o = h;
                  }
                  if (i !== void 0 && Uf(i))
                    for (let a = 0, h = i.length; a !== h; ++a) {
                      const m = i[a];
                      if (isNaN(m)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, m), e = !1;
                        break;
                      }
                    }
                  return e;
                }
                // removes equivalent sequential keys as common in morph target sequences
                // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
                optimize() {
                  const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === cr, r = e.length - 1;
                  let o = 1;
                  for (let a = 1; a < r; ++a) {
                    let h = !1;
                    const m = e[a], _ = e[a + 1];
                    if (m !== _ && (a !== 1 || m !== e[0]))
                      if (i)
                        h = !0;
                      else {
                        const I = a * n, B = I - n, L = I + n;
                        for (let N = 0; N !== n; ++N) {
                          const z = t[I + N];
                          if (z !== t[B + N] || z !== t[L + N]) {
                            h = !0;
                            break;
                          }
                        }
                      }
                    if (h) {
                      if (a !== o) {
                        e[o] = e[a];
                        const I = a * n, B = o * n;
                        for (let L = 0; L !== n; ++L)
                          t[B + L] = t[I + L];
                      }
                      ++o;
                    }
                  }
                  if (r > 0) {
                    e[o] = e[r];
                    for (let a = r * n, h = o * n, m = 0; m !== n; ++m)
                      t[h + m] = t[a + m];
                    ++o;
                  }
                  return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this;
                }
                clone() {
                  const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
                  return i.createInterpolant = this.createInterpolant, i;
                }
              }
              ms.prototype.TimeBufferType = Float32Array, ms.prototype.ValueBufferType = Float32Array, ms.prototype.DefaultInterpolation = ar;
              class Io extends ms {
              }
              Io.prototype.ValueTypeName = "bool", Io.prototype.ValueBufferType = Array, Io.prototype.DefaultInterpolation = or, Io.prototype.InterpolantFactoryMethodLinear = void 0, Io.prototype.InterpolantFactoryMethodSmooth = void 0;
              class yh extends ms {
              }
              yh.prototype.ValueTypeName = "color";
              class Xa extends ms {
              }
              Xa.prototype.ValueTypeName = "number";
              class Qf extends Ka {
                constructor(e, t, n, i) {
                  super(e, t, n, i);
                }
                interpolate_(e, t, n, i) {
                  const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, h = (n - t) / (i - t);
                  let m = e * a;
                  for (let _ = m + a; m !== _; m += 4)
                    xi.slerpFlat(r, 0, o, m - a, o, m, h);
                  return r;
                }
              }
              class ma extends ms {
                InterpolantFactoryMethodLinear(e) {
                  return new Qf(this.times, this.values, this.getValueSize(), e);
                }
              }
              ma.prototype.ValueTypeName = "quaternion", ma.prototype.DefaultInterpolation = ar, ma.prototype.InterpolantFactoryMethodSmooth = void 0;
              class Bo extends ms {
              }
              Bo.prototype.ValueTypeName = "string", Bo.prototype.ValueBufferType = Array, Bo.prototype.DefaultInterpolation = or, Bo.prototype.InterpolantFactoryMethodLinear = void 0, Bo.prototype.InterpolantFactoryMethodSmooth = void 0;
              class Ya extends ms {
              }
              Ya.prototype.ValueTypeName = "vector";
              class qa {
                constructor(e = "", t = -1, n = [], i = rs) {
                  this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = kr(), this.duration < 0 && this.resetDuration();
                }
                static parse(e) {
                  const t = [], n = e.tracks, i = 1 / (e.fps || 1);
                  for (let o = 0, a = n.length; o !== a; ++o)
                    t.push(qv(n[o]).scale(i));
                  const r = new this(e.name, e.duration, t, e.blendMode);
                  return r.uuid = e.uuid, r;
                }
                static toJSON(e) {
                  const t = [], n = e.tracks, i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
                  for (let r = 0, o = n.length; r !== o; ++r)
                    t.push(ms.toJSON(n[r]));
                  return i;
                }
                static CreateFromMorphTargetSequence(e, t, n, i) {
                  const r = t.length, o = [];
                  for (let a = 0; a < r; a++) {
                    let h = [], m = [];
                    h.push((a + r - 1) % r, a, (a + 1) % r), m.push(0, 1, 0);
                    const _ = Nf(h);
                    h = gh(h, 1, _), m = gh(m, 1, _), !i && h[0] === 0 && (h.push(r), m.push(m[0])), o.push(new Xa(".morphTargetInfluences[" + t[a].name + "]", h, m).scale(1 / n));
                  }
                  return new this(e, -1, o);
                }
                static findByName(e, t) {
                  let n = e;
                  if (!Array.isArray(e)) {
                    const i = e;
                    n = i.geometry && i.geometry.animations || i.animations;
                  }
                  for (let i = 0; i < n.length; i++)
                    if (n[i].name === t)
                      return n[i];
                  return null;
                }
                static CreateClipsFromMorphTargetSequences(e, t, n) {
                  const i = {}, r = /^([\w-]*?)([\d]+)$/;
                  for (let a = 0, h = e.length; a < h; a++) {
                    const m = e[a], _ = m.name.match(r);
                    if (_ && _.length > 1) {
                      const I = _[1];
                      let B = i[I];
                      B || (i[I] = B = []), B.push(m);
                    }
                  }
                  const o = [];
                  for (const a in i)
                    o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
                  return o;
                }
                // parse the animation.hierarchy format
                static parseAnimation(e, t) {
                  if (!e)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                  const n = function(I, B, L, N, z) {
                    if (L.length !== 0) {
                      const k = [], P = [];
                      vh(L, k, P, N), k.length !== 0 && z.push(new I(B, k, P));
                    }
                  }, i = [], r = e.name || "default", o = e.fps || 30, a = e.blendMode;
                  let h = e.length || -1;
                  const m = e.hierarchy || [];
                  for (let I = 0; I < m.length; I++) {
                    const B = m[I].keys;
                    if (!(!B || B.length === 0))
                      if (B[0].morphTargets) {
                        const L = {};
                        let N;
                        for (N = 0; N < B.length; N++)
                          if (B[N].morphTargets)
                            for (let z = 0; z < B[N].morphTargets.length; z++)
                              L[B[N].morphTargets[z]] = -1;
                        for (const z in L) {
                          const k = [], P = [];
                          for (let se = 0; se !== B[N].morphTargets.length; ++se) {
                            const $ = B[N];
                            k.push($.time), P.push($.morphTarget === z ? 1 : 0);
                          }
                          i.push(new Xa(".morphTargetInfluence[" + z + "]", k, P));
                        }
                        h = L.length * o;
                      } else {
                        const L = ".bones[" + t[I].name + "]";
                        n(Ya, L + ".position", B, "pos", i), n(ma, L + ".quaternion", B, "rot", i), n(Ya, L + ".scale", B, "scl", i);
                      }
                  }
                  return i.length === 0 ? null : new this(r, h, i, a);
                }
                resetDuration() {
                  const e = this.tracks;
                  let t = 0;
                  for (let n = 0, i = e.length; n !== i; ++n) {
                    const r = this.tracks[n];
                    t = Math.max(t, r.times[r.times.length - 1]);
                  }
                  return this.duration = t, this;
                }
                trim() {
                  for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].trim(0, this.duration);
                  return this;
                }
                validate() {
                  let e = !0;
                  for (let t = 0; t < this.tracks.length; t++)
                    e = e && this.tracks[t].validate();
                  return e;
                }
                optimize() {
                  for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].optimize();
                  return this;
                }
                clone() {
                  const e = [];
                  for (let t = 0; t < this.tracks.length; t++)
                    e.push(this.tracks[t].clone());
                  return new this.constructor(this.name, this.duration, e, this.blendMode);
                }
                toJSON() {
                  return this.constructor.toJSON(this);
                }
              }
              function Yv(s) {
                switch (s.toLowerCase()) {
                  case "scalar":
                  case "double":
                  case "float":
                  case "number":
                  case "integer":
                    return Xa;
                  case "vector":
                  case "vector2":
                  case "vector3":
                  case "vector4":
                    return Ya;
                  case "color":
                    return yh;
                  case "quaternion":
                    return ma;
                  case "bool":
                  case "boolean":
                    return Io;
                  case "string":
                    return Bo;
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
              }
              function qv(s) {
                if (s.type === void 0)
                  throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const e = Yv(s.type);
                if (s.times === void 0) {
                  const t = [], n = [];
                  vh(s.keys, t, n, "value"), s.times = t, s.values = n;
                }
                return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
              }
              const Ns = { enabled: !1, files: {}, add: function(s, e) {
                this.enabled !== !1 && (this.files[s] = e);
              }, get: function(s) {
                if (this.enabled !== !1)
                  return this.files[s];
              }, remove: function(s) {
                delete this.files[s];
              }, clear: function() {
                this.files = {};
              } };
              class Ch {
                constructor(e, t, n) {
                  const i = this;
                  let r = !1, o = 0, a = 0, h;
                  const m = [];
                  this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(_) {
                    a++, r === !1 && i.onStart !== void 0 && i.onStart(_, o, a), r = !0;
                  }, this.itemEnd = function(_) {
                    o++, i.onProgress !== void 0 && i.onProgress(_, o, a), o === a && (r = !1, i.onLoad !== void 0 && i.onLoad());
                  }, this.itemError = function(_) {
                    i.onError !== void 0 && i.onError(_);
                  }, this.resolveURL = function(_) {
                    return h ? h(_) : _;
                  }, this.setURLModifier = function(_) {
                    return h = _, this;
                  }, this.addHandler = function(_, I) {
                    return m.push(_, I), this;
                  }, this.removeHandler = function(_) {
                    const I = m.indexOf(_);
                    return I !== -1 && m.splice(I, 2), this;
                  }, this.getHandler = function(_) {
                    for (let I = 0, B = m.length; I < B; I += 2) {
                      const L = m[I], N = m[I + 1];
                      if (L.global && (L.lastIndex = 0), L.test(_))
                        return N;
                    }
                    return null;
                  };
                }
              }
              const Vf = /* @__PURE__ */ new Ch();
              class Xr {
                constructor(e) {
                  this.manager = e !== void 0 ? e : Vf, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
                }
                load() {
                }
                loadAsync(e, t) {
                  const n = this;
                  return new Promise(function(i, r) {
                    n.load(e, i, t, r);
                  });
                }
                parse() {
                }
                setCrossOrigin(e) {
                  return this.crossOrigin = e, this;
                }
                setWithCredentials(e) {
                  return this.withCredentials = e, this;
                }
                setPath(e) {
                  return this.path = e, this;
                }
                setResourcePath(e) {
                  return this.resourcePath = e, this;
                }
                setRequestHeader(e) {
                  return this.requestHeader = e, this;
                }
              }
              Xr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
              const ks = {};
              class Jv extends Error {
                constructor(e, t) {
                  super(e), this.response = t;
                }
              }
              class Gs extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                  const r = Ns.get(e);
                  if (r !== void 0)
                    return this.manager.itemStart(e), setTimeout(() => {
                      t && t(r), this.manager.itemEnd(e);
                    }, 0), r;
                  if (ks[e] !== void 0) {
                    ks[e].push({ onLoad: t, onProgress: n, onError: i });
                    return;
                  }
                  ks[e] = [], ks[e].push({ onLoad: t, onProgress: n, onError: i });
                  const o = new Request(e, {
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                    // An abort controller could be added within a future PR
                  }), a = this.mimeType, h = this.responseType;
                  fetch(o).then((m) => {
                    if (m.status === 200 || m.status === 0) {
                      if (m.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || m.body === void 0 || m.body.getReader === void 0)
                        return m;
                      const _ = ks[e], I = m.body.getReader(), B = m.headers.get("X-File-Size") || m.headers.get("Content-Length"), L = B ? parseInt(B) : 0, N = L !== 0;
                      let z = 0;
                      const k = new ReadableStream({ start(P) {
                        se();
                        function se() {
                          I.read().then(({ done: $, value: J }) => {
                            if ($)
                              P.close();
                            else {
                              z += J.byteLength;
                              const Le = new ProgressEvent("progress", { lengthComputable: N, loaded: z, total: L });
                              for (let Ee = 0, Me = _.length; Ee < Me; Ee++) {
                                const Re = _[Ee];
                                Re.onProgress && Re.onProgress(Le);
                              }
                              P.enqueue(J), se();
                            }
                          });
                        }
                      } });
                      return new Response(k);
                    } else
                      throw new Jv(`fetch for "${m.url}" responded with ${m.status}: ${m.statusText}`, m);
                  }).then((m) => {
                    switch (h) {
                      case "arraybuffer":
                        return m.arrayBuffer();
                      case "blob":
                        return m.blob();
                      case "document":
                        return m.text().then((_) => new DOMParser().parseFromString(_, a));
                      case "json":
                        return m.json();
                      default:
                        if (a === void 0)
                          return m.text();
                        {
                          const I = /charset="?([^;"\s]*)"?/i.exec(a), B = I && I[1] ? I[1].toLowerCase() : void 0, L = new TextDecoder(B);
                          return m.arrayBuffer().then((N) => L.decode(N));
                        }
                    }
                  }).then((m) => {
                    Ns.add(e, m);
                    const _ = ks[e];
                    delete ks[e];
                    for (let I = 0, B = _.length; I < B; I++) {
                      const L = _[I];
                      L.onLoad && L.onLoad(m);
                    }
                  }).catch((m) => {
                    const _ = ks[e];
                    if (_ === void 0)
                      throw this.manager.itemError(e), m;
                    delete ks[e];
                    for (let I = 0, B = _.length; I < B; I++) {
                      const L = _[I];
                      L.onError && L.onError(m);
                    }
                    this.manager.itemError(e);
                  }).finally(() => {
                    this.manager.itemEnd(e);
                  }), this.manager.itemStart(e);
                }
                setResponseType(e) {
                  return this.responseType = e, this;
                }
                setMimeType(e) {
                  return this.mimeType = e, this;
                }
              }
              class Zv extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = this, o = new Gs(this.manager);
                  o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
                    try {
                      t(r.parse(JSON.parse(a)));
                    } catch (h) {
                      i ? i(h) : console.error(h), r.manager.itemError(e);
                    }
                  }, n, i);
                }
                parse(e) {
                  const t = [];
                  for (let n = 0; n < e.length; n++) {
                    const i = qa.parse(e[n]);
                    t.push(i);
                  }
                  return t;
                }
              }
              class $v extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = this, o = [], a = new nc(), h = new Gs(this.manager);
                  h.setPath(this.path), h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setWithCredentials(r.withCredentials);
                  let m = 0;
                  function _(I) {
                    h.load(e[I], function(B) {
                      const L = r.parse(B, !0);
                      o[I] = { width: L.width, height: L.height, format: L.format, mipmaps: L.mipmaps }, m += 1, m === 6 && (L.mipmapCount === 1 && (a.minFilter = vn), a.image = o, a.format = L.format, a.needsUpdate = !0, t && t(a));
                    }, n, i);
                  }
                  if (Array.isArray(e))
                    for (let I = 0, B = e.length; I < B; ++I)
                      _(I);
                  else
                    h.load(e, function(I) {
                      const B = r.parse(I, !0);
                      if (B.isCubemap) {
                        const L = B.mipmaps.length / B.mipmapCount;
                        for (let N = 0; N < L; N++) {
                          o[N] = { mipmaps: [] };
                          for (let z = 0; z < B.mipmapCount; z++)
                            o[N].mipmaps.push(B.mipmaps[N * B.mipmapCount + z]), o[N].format = B.format, o[N].width = B.width, o[N].height = B.height;
                        }
                        a.image = o;
                      } else
                        a.image.width = B.width, a.image.height = B.height, a.mipmaps = B.mipmaps;
                      B.mipmapCount === 1 && (a.minFilter = vn), a.format = B.format, a.needsUpdate = !0, t && t(a);
                    }, n, i);
                  return a;
                }
              }
              class Ja extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                  const r = this, o = Ns.get(e);
                  if (o !== void 0)
                    return r.manager.itemStart(e), setTimeout(function() {
                      t && t(o), r.manager.itemEnd(e);
                    }, 0), o;
                  const a = Ao("img");
                  function h() {
                    _(), Ns.add(e, this), t && t(this), r.manager.itemEnd(e);
                  }
                  function m(I) {
                    _(), i && i(I), r.manager.itemError(e), r.manager.itemEnd(e);
                  }
                  function _() {
                    a.removeEventListener("load", h, !1), a.removeEventListener("error", m, !1);
                  }
                  return a.addEventListener("load", h, !1), a.addEventListener("error", m, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a;
                }
              }
              class eE extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = new Ta();
                  r.colorSpace = mi;
                  const o = new Ja(this.manager);
                  o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                  let a = 0;
                  function h(m) {
                    o.load(e[m], function(_) {
                      r.images[m] = _, a++, a === 6 && (r.needsUpdate = !0, t && t(r));
                    }, void 0, i);
                  }
                  for (let m = 0; m < e.length; ++m)
                    h(m);
                  return r;
                }
              }
              class tE extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = this, o = new $s(), a = new Gs(this.manager);
                  return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, function(h) {
                    let m;
                    try {
                      m = r.parse(h);
                    } catch (_) {
                      if (i !== void 0)
                        i(_);
                      else {
                        console.error(_);
                        return;
                      }
                    }
                    m.image !== void 0 ? o.image = m.image : m.data !== void 0 && (o.image.width = m.width, o.image.height = m.height, o.image.data = m.data), o.wrapS = m.wrapS !== void 0 ? m.wrapS : Oe, o.wrapT = m.wrapT !== void 0 ? m.wrapT : Oe, o.magFilter = m.magFilter !== void 0 ? m.magFilter : vn, o.minFilter = m.minFilter !== void 0 ? m.minFilter : vn, o.anisotropy = m.anisotropy !== void 0 ? m.anisotropy : 1, m.colorSpace !== void 0 && (o.colorSpace = m.colorSpace), m.flipY !== void 0 && (o.flipY = m.flipY), m.format !== void 0 && (o.format = m.format), m.type !== void 0 && (o.type = m.type), m.mipmaps !== void 0 && (o.mipmaps = m.mipmaps, o.minFilter = Ei), m.mipmapCount === 1 && (o.minFilter = vn), m.generateMipmaps !== void 0 && (o.generateMipmaps = m.generateMipmaps), o.needsUpdate = !0, t && t(o, m);
                  }, n, i), o;
                }
              }
              class nE extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = new Vi(), o = new Ja(this.manager);
                  return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
                    r.image = a, r.needsUpdate = !0, t !== void 0 && t(r);
                  }, n, i), r;
                }
              }
              class io extends bi {
                constructor(e, t = 1) {
                  super(), this.isLight = !0, this.type = "Light", this.color = new sn(e), this.intensity = t;
                }
                dispose() {
                }
                copy(e, t) {
                  return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
                }
              }
              class Hf extends io {
                constructor(e, t, n) {
                  super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(bi.DEFAULT_UP), this.updateMatrix(), this.groundColor = new sn(t);
                }
                copy(e, t) {
                  return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
                }
              }
              const xh = /* @__PURE__ */ new pn(), zf = /* @__PURE__ */ new ye(), jf = /* @__PURE__ */ new ye();
              class bh {
                constructor(e) {
                  this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new pt(512, 512), this.map = null, this.mapPass = null, this.matrix = new pn(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ia(), this._frameExtents = new pt(1, 1), this._viewportCount = 1, this._viewports = [new yi(0, 0, 1, 1)];
                }
                getViewportCount() {
                  return this._viewportCount;
                }
                getFrustum() {
                  return this._frustum;
                }
                updateMatrices(e) {
                  const t = this.camera, n = this.matrix;
                  zf.setFromMatrixPosition(e.matrixWorld), t.position.copy(zf), jf.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(jf), t.updateMatrixWorld(), xh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(xh), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(xh);
                }
                getViewport(e) {
                  return this._viewports[e];
                }
                getFrameExtents() {
                  return this._frameExtents;
                }
                dispose() {
                  this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
                }
                copy(e) {
                  return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                toJSON() {
                  const e = {};
                  return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
                }
              }
              class iE extends bh {
                constructor() {
                  super(new mr(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
                }
                updateMatrices(e) {
                  const t = this.camera, n = Hs * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
                  (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
                }
                copy(e) {
                  return super.copy(e), this.focus = e.focus, this;
                }
              }
              class Wf extends io {
                constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 2) {
                  super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(bi.DEFAULT_UP), this.updateMatrix(), this.target = new bi(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new iE();
                }
                get power() {
                  return this.intensity * Math.PI;
                }
                set power(e) {
                  this.intensity = e / Math.PI;
                }
                dispose() {
                  this.shadow.dispose();
                }
                copy(e, t) {
                  return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
                }
              }
              const Kf = /* @__PURE__ */ new pn(), Za = /* @__PURE__ */ new ye(), _h = /* @__PURE__ */ new ye();
              class rE extends bh {
                constructor() {
                  super(new mr(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new pt(4, 2), this._viewportCount = 6, this._viewports = [
                    // These viewports map a cube-map onto a 2D texture with the
                    // following orientation:
                    //
                    //  xzXZ
                    //   y Y
                    //
                    // X - Positive x direction
                    // x - Negative x direction
                    // Y - Positive y direction
                    // y - Negative y direction
                    // Z - Positive z direction
                    // z - Negative z direction
                    // positive X
                    new yi(2, 1, 1, 1),
                    // negative X
                    new yi(0, 1, 1, 1),
                    // positive Z
                    new yi(3, 1, 1, 1),
                    // negative Z
                    new yi(1, 1, 1, 1),
                    // positive Y
                    new yi(3, 0, 1, 1),
                    // negative Y
                    new yi(1, 0, 1, 1)
                  ], this._cubeDirections = [new ye(1, 0, 0), new ye(-1, 0, 0), new ye(0, 0, 1), new ye(0, 0, -1), new ye(0, 1, 0), new ye(0, -1, 0)], this._cubeUps = [new ye(0, 1, 0), new ye(0, 1, 0), new ye(0, 1, 0), new ye(0, 1, 0), new ye(0, 0, 1), new ye(0, 0, -1)];
                }
                updateMatrices(e, t = 0) {
                  const n = this.camera, i = this.matrix, r = e.distance || n.far;
                  r !== n.far && (n.far = r, n.updateProjectionMatrix()), Za.setFromMatrixPosition(e.matrixWorld), n.position.copy(Za), _h.copy(n.position), _h.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(_h), n.updateMatrixWorld(), i.makeTranslation(-Za.x, -Za.y, -Za.z), Kf.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Kf);
                }
              }
              class Xf extends io {
                constructor(e, t, n = 0, i = 2) {
                  super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new rE();
                }
                get power() {
                  return this.intensity * 4 * Math.PI;
                }
                set power(e) {
                  this.intensity = e / (4 * Math.PI);
                }
                dispose() {
                  this.shadow.dispose();
                }
                copy(e, t) {
                  return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
                }
              }
              class sE extends bh {
                constructor() {
                  super(new Pl(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
                }
              }
              class Yf extends io {
                constructor(e, t) {
                  super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(bi.DEFAULT_UP), this.updateMatrix(), this.target = new bi(), this.shadow = new sE();
                }
                dispose() {
                  this.shadow.dispose();
                }
                copy(e) {
                  return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
                }
              }
              class qf extends io {
                constructor(e, t) {
                  super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
                }
              }
              class Jf extends io {
                constructor(e, t, n = 10, i = 10) {
                  super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
                }
                get power() {
                  return this.intensity * this.width * this.height * Math.PI;
                }
                set power(e) {
                  this.intensity = e / (this.width * this.height * Math.PI);
                }
                copy(e) {
                  return super.copy(e), this.width = e.width, this.height = e.height, this;
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return t.object.width = this.width, t.object.height = this.height, t;
                }
              }
              class Zf {
                constructor() {
                  this.isSphericalHarmonics3 = !0, this.coefficients = [];
                  for (let e = 0; e < 9; e++)
                    this.coefficients.push(new ye());
                }
                set(e) {
                  for (let t = 0; t < 9; t++)
                    this.coefficients[t].copy(e[t]);
                  return this;
                }
                zero() {
                  for (let e = 0; e < 9; e++)
                    this.coefficients[e].set(0, 0, 0);
                  return this;
                }
                // get the radiance in the direction of the normal
                // target is a Vector3
                getAt(e, t) {
                  const n = e.x, i = e.y, r = e.z, o = this.coefficients;
                  return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * i), t.addScaledVector(o[2], 0.488603 * r), t.addScaledVector(o[3], 0.488603 * n), t.addScaledVector(o[4], 1.092548 * (n * i)), t.addScaledVector(o[5], 1.092548 * (i * r)), t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(o[7], 1.092548 * (n * r)), t.addScaledVector(o[8], 0.546274 * (n * n - i * i)), t;
                }
                // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
                // target is a Vector3
                // https://graphics.stanford.edu/papers/envmap/envmap.pdf
                getIrradianceAt(e, t) {
                  const n = e.x, i = e.y, r = e.z, o = this.coefficients;
                  return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 1.023328 * i), t.addScaledVector(o[2], 1.023328 * r), t.addScaledVector(o[3], 1.023328 * n), t.addScaledVector(o[4], 0.858086 * n * i), t.addScaledVector(o[5], 0.858086 * i * r), t.addScaledVector(o[6], 0.743125 * r * r - 0.247708), t.addScaledVector(o[7], 0.858086 * n * r), t.addScaledVector(o[8], 0.429043 * (n * n - i * i)), t;
                }
                add(e) {
                  for (let t = 0; t < 9; t++)
                    this.coefficients[t].add(e.coefficients[t]);
                  return this;
                }
                addScaledSH(e, t) {
                  for (let n = 0; n < 9; n++)
                    this.coefficients[n].addScaledVector(e.coefficients[n], t);
                  return this;
                }
                scale(e) {
                  for (let t = 0; t < 9; t++)
                    this.coefficients[t].multiplyScalar(e);
                  return this;
                }
                lerp(e, t) {
                  for (let n = 0; n < 9; n++)
                    this.coefficients[n].lerp(e.coefficients[n], t);
                  return this;
                }
                equals(e) {
                  for (let t = 0; t < 9; t++)
                    if (!this.coefficients[t].equals(e.coefficients[t]))
                      return !1;
                  return !0;
                }
                copy(e) {
                  return this.set(e.coefficients);
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                fromArray(e, t = 0) {
                  const n = this.coefficients;
                  for (let i = 0; i < 9; i++)
                    n[i].fromArray(e, t + i * 3);
                  return this;
                }
                toArray(e = [], t = 0) {
                  const n = this.coefficients;
                  for (let i = 0; i < 9; i++)
                    n[i].toArray(e, t + i * 3);
                  return e;
                }
                // evaluate the basis functions
                // shBasis is an Array[ 9 ]
                static getBasisAt(e, t) {
                  const n = e.x, i = e.y, r = e.z;
                  t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - i * i);
                }
              }
              class $f extends io {
                constructor(e = new Zf(), t = 1) {
                  super(void 0, t), this.isLightProbe = !0, this.sh = e;
                }
                copy(e) {
                  return super.copy(e), this.sh.copy(e.sh), this;
                }
                fromJSON(e) {
                  return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return t.object.sh = this.sh.toArray(), t;
                }
              }
              class _c extends Xr {
                constructor(e) {
                  super(e), this.textures = {};
                }
                load(e, t, n, i) {
                  const r = this, o = new Gs(r.manager);
                  o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
                    try {
                      t(r.parse(JSON.parse(a)));
                    } catch (h) {
                      i ? i(h) : console.error(h), r.manager.itemError(e);
                    }
                  }, n, i);
                }
                parse(e) {
                  const t = this.textures;
                  function n(r) {
                    return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
                  }
                  const i = _c.createMaterialFromType(e.type);
                  if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new sn().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
                    for (const r in e.uniforms) {
                      const o = e.uniforms[r];
                      switch (i.uniforms[r] = {}, o.type) {
                        case "t":
                          i.uniforms[r].value = n(o.value);
                          break;
                        case "c":
                          i.uniforms[r].value = new sn().setHex(o.value);
                          break;
                        case "v2":
                          i.uniforms[r].value = new pt().fromArray(o.value);
                          break;
                        case "v3":
                          i.uniforms[r].value = new ye().fromArray(o.value);
                          break;
                        case "v4":
                          i.uniforms[r].value = new yi().fromArray(o.value);
                          break;
                        case "m3":
                          i.uniforms[r].value = new Gn().fromArray(o.value);
                          break;
                        case "m4":
                          i.uniforms[r].value = new pn().fromArray(o.value);
                          break;
                        default:
                          i.uniforms[r].value = o.value;
                      }
                    }
                  if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
                    for (const r in e.extensions)
                      i.extensions[r] = e.extensions[r];
                  if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
                    let r = e.normalScale;
                    Array.isArray(r) === !1 && (r = [r, r]), i.normalScale = new pt().fromArray(r);
                  }
                  return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new pt().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
                }
                setTextures(e) {
                  return this.textures = e, this;
                }
                static createMaterialFromType(e) {
                  const t = { ShadowMaterial: Tf, SpriteMaterial: Xu, RawShaderMaterial: If, ShaderMaterial: fs, PointsMaterial: nh, MeshPhysicalMaterial: Bf, MeshStandardMaterial: mh, MeshPhongMaterial: Rf, MeshToonMaterial: Lf, MeshNormalMaterial: Df, MeshLambertMaterial: Pf, MeshDepthMaterial: zu, MeshDistanceMaterial: ju, MeshBasicMaterial: qs, MeshMatcapMaterial: Of, LineDashedMaterial: Ff, LineBasicMaterial: Hr, Material: Pr };
                  return new t[e]();
                }
              }
              class wh {
                static decodeText(e) {
                  if (typeof TextDecoder < "u")
                    return new TextDecoder().decode(e);
                  let t = "";
                  for (let n = 0, i = e.length; n < i; n++)
                    t += String.fromCharCode(e[n]);
                  try {
                    return decodeURIComponent(escape(t));
                  } catch {
                    return t;
                  }
                }
                static extractUrlBase(e) {
                  const t = e.lastIndexOf("/");
                  return t === -1 ? "./" : e.slice(0, t + 1);
                }
                static resolveURL(e, t) {
                  return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
                }
              }
              class ep extends ti {
                constructor() {
                  super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
                }
                copy(e) {
                  return super.copy(e), this.instanceCount = e.instanceCount, this;
                }
                toJSON() {
                  const e = super.toJSON();
                  return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
                }
              }
              class tp extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = this, o = new Gs(r.manager);
                  o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
                    try {
                      t(r.parse(JSON.parse(a)));
                    } catch (h) {
                      i ? i(h) : console.error(h), r.manager.itemError(e);
                    }
                  }, n, i);
                }
                parse(e) {
                  const t = {}, n = {};
                  function i(L, N) {
                    if (t[N] !== void 0) return t[N];
                    const k = L.interleavedBuffers[N], P = r(L, k.buffer), se = zs(k.type, P), $ = new Gl(se, k.stride);
                    return $.uuid = k.uuid, t[N] = $, $;
                  }
                  function r(L, N) {
                    if (n[N] !== void 0) return n[N];
                    const k = L.arrayBuffers[N], P = new Uint32Array(k).buffer;
                    return n[N] = P, P;
                  }
                  const o = e.isInstancedBufferGeometry ? new ep() : new ti(), a = e.data.index;
                  if (a !== void 0) {
                    const L = zs(a.type, a.array);
                    o.setIndex(new Pi(L, 1));
                  }
                  const h = e.data.attributes;
                  for (const L in h) {
                    const N = h[L];
                    let z;
                    if (N.isInterleavedBufferAttribute) {
                      const k = i(e.data, N.data);
                      z = new _o(k, N.itemSize, N.offset, N.normalized);
                    } else {
                      const k = zs(N.type, N.array), P = N.isInstancedBufferAttribute ? ha : Pi;
                      z = new P(k, N.itemSize, N.normalized);
                    }
                    N.name !== void 0 && (z.name = N.name), N.usage !== void 0 && z.setUsage(N.usage), o.setAttribute(L, z);
                  }
                  const m = e.data.morphAttributes;
                  if (m)
                    for (const L in m) {
                      const N = m[L], z = [];
                      for (let k = 0, P = N.length; k < P; k++) {
                        const se = N[k];
                        let $;
                        if (se.isInterleavedBufferAttribute) {
                          const J = i(e.data, se.data);
                          $ = new _o(J, se.itemSize, se.offset, se.normalized);
                        } else {
                          const J = zs(se.type, se.array);
                          $ = new Pi(J, se.itemSize, se.normalized);
                        }
                        se.name !== void 0 && ($.name = se.name), z.push($);
                      }
                      o.morphAttributes[L] = z;
                    }
                  e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
                  const I = e.data.groups || e.data.drawcalls || e.data.offsets;
                  if (I !== void 0)
                    for (let L = 0, N = I.length; L !== N; ++L) {
                      const z = I[L];
                      o.addGroup(z.start, z.count, z.materialIndex);
                    }
                  const B = e.data.boundingSphere;
                  if (B !== void 0) {
                    const L = new ye();
                    B.center !== void 0 && L.fromArray(B.center), o.boundingSphere = new pr(L, B.radius);
                  }
                  return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
                }
              }
              class oE extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = this, o = this.path === "" ? wh.extractUrlBase(e) : this.path;
                  this.resourcePath = this.resourcePath || o;
                  const a = new Gs(this.manager);
                  a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(h) {
                    let m = null;
                    try {
                      m = JSON.parse(h);
                    } catch (I) {
                      i !== void 0 && i(I), console.error("THREE:ObjectLoader: Can't parse " + e + ".", I.message);
                      return;
                    }
                    const _ = m.metadata;
                    if (_ === void 0 || _.type === void 0 || _.type.toLowerCase() === "geometry") {
                      i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                      return;
                    }
                    r.parse(m, t);
                  }, n, i);
                }
                async loadAsync(e, t) {
                  const n = this, i = this.path === "" ? wh.extractUrlBase(e) : this.path;
                  this.resourcePath = this.resourcePath || i;
                  const r = new Gs(this.manager);
                  r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
                  const o = await r.loadAsync(e, t), a = JSON.parse(o), h = a.metadata;
                  if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry")
                    throw new Error("THREE.ObjectLoader: Can't load " + e);
                  return await n.parseAsync(a);
                }
                parse(e, t) {
                  const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), o = this.parseImages(e.images, function() {
                    t !== void 0 && t(m);
                  }), a = this.parseTextures(e.textures, o), h = this.parseMaterials(e.materials, a), m = this.parseObject(e.object, r, h, a, n), _ = this.parseSkeletons(e.skeletons, m);
                  if (this.bindSkeletons(m, _), t !== void 0) {
                    let I = !1;
                    for (const B in o)
                      if (o[B].data instanceof HTMLImageElement) {
                        I = !0;
                        break;
                      }
                    I === !1 && t(m);
                  }
                  return m;
                }
                async parseAsync(e) {
                  const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, r), a = this.parseMaterials(e.materials, o), h = this.parseObject(e.object, i, a, o, t), m = this.parseSkeletons(e.skeletons, h);
                  return this.bindSkeletons(h, m), h;
                }
                parseShapes(e) {
                  const t = {};
                  if (e !== void 0)
                    for (let n = 0, i = e.length; n < i; n++) {
                      const r = new Mo().fromJSON(e[n]);
                      t[r.uuid] = r;
                    }
                  return t;
                }
                parseSkeletons(e, t) {
                  const n = {}, i = {};
                  if (t.traverse(function(r) {
                    r.isBone && (i[r.uuid] = r);
                  }), e !== void 0)
                    for (let r = 0, o = e.length; r < o; r++) {
                      const a = new Wl().fromJSON(e[r], i);
                      n[a.uuid] = a;
                    }
                  return n;
                }
                parseGeometries(e, t) {
                  const n = {};
                  if (e !== void 0) {
                    const r = new tp();
                    for (let o = 0, a = e.length; o < a; o++) {
                      let h;
                      const m = e[o];
                      switch (m.type) {
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                          h = r.parse(m);
                          break;
                        case "Geometry":
                          if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                            var i = new THREE.LegacyJSONLoader();
                            h = i.parse(m, this.resourcePath).geometry;
                          } else
                            console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                          break;
                        default:
                          m.type in Sf ? h = Sf[m.type].fromJSON(m, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${m.type}"`);
                      }
                      h.uuid = m.uuid, m.name !== void 0 && (h.name = m.name), m.userData !== void 0 && (h.userData = m.userData), n[m.uuid] = h;
                    }
                  }
                  return n;
                }
                parseMaterials(e, t) {
                  const n = {}, i = {};
                  if (e !== void 0) {
                    const r = new _c();
                    r.setTextures(t);
                    for (let o = 0, a = e.length; o < a; o++) {
                      const h = e[o];
                      n[h.uuid] === void 0 && (n[h.uuid] = r.parse(h)), i[h.uuid] = n[h.uuid];
                    }
                  }
                  return i;
                }
                parseAnimations(e) {
                  const t = {};
                  if (e !== void 0)
                    for (let n = 0; n < e.length; n++) {
                      const i = e[n], r = qa.parse(i);
                      t[r.uuid] = r;
                    }
                  return t;
                }
                parseImages(e, t) {
                  const n = this, i = {};
                  let r;
                  function o(h) {
                    return n.manager.itemStart(h), r.load(h, function() {
                      n.manager.itemEnd(h);
                    }, void 0, function() {
                      n.manager.itemError(h), n.manager.itemEnd(h);
                    });
                  }
                  function a(h) {
                    if (typeof h == "string") {
                      const m = h, _ = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m) ? m : n.resourcePath + m;
                      return o(_);
                    } else
                      return h.data ? { data: zs(h.type, h.data), width: h.width, height: h.height } : null;
                  }
                  if (e !== void 0 && e.length > 0) {
                    const h = new Ch(t);
                    r = new Ja(h), r.setCrossOrigin(this.crossOrigin);
                    for (let m = 0, _ = e.length; m < _; m++) {
                      const I = e[m], B = I.url;
                      if (Array.isArray(B)) {
                        const L = [];
                        for (let N = 0, z = B.length; N < z; N++) {
                          const k = B[N], P = a(k);
                          P !== null && (P instanceof HTMLImageElement ? L.push(P) : L.push(new $s(P.data, P.width, P.height)));
                        }
                        i[I.uuid] = new Ki(L);
                      } else {
                        const L = a(I.url);
                        i[I.uuid] = new Ki(L);
                      }
                    }
                  }
                  return i;
                }
                async parseImagesAsync(e) {
                  const t = this, n = {};
                  let i;
                  async function r(o) {
                    if (typeof o == "string") {
                      const a = o, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                      return await i.loadAsync(h);
                    } else
                      return o.data ? { data: zs(o.type, o.data), width: o.width, height: o.height } : null;
                  }
                  if (e !== void 0 && e.length > 0) {
                    i = new Ja(this.manager), i.setCrossOrigin(this.crossOrigin);
                    for (let o = 0, a = e.length; o < a; o++) {
                      const h = e[o], m = h.url;
                      if (Array.isArray(m)) {
                        const _ = [];
                        for (let I = 0, B = m.length; I < B; I++) {
                          const L = m[I], N = await r(L);
                          N !== null && (N instanceof HTMLImageElement ? _.push(N) : _.push(new $s(N.data, N.width, N.height)));
                        }
                        n[h.uuid] = new Ki(_);
                      } else {
                        const _ = await r(h.url);
                        n[h.uuid] = new Ki(_);
                      }
                    }
                  }
                  return n;
                }
                parseTextures(e, t) {
                  function n(r, o) {
                    return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), o[r]);
                  }
                  const i = {};
                  if (e !== void 0)
                    for (let r = 0, o = e.length; r < o; r++) {
                      const a = e[r];
                      a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                      const h = t[a.image], m = h.data;
                      let _;
                      Array.isArray(m) ? (_ = new Ta(), m.length === 6 && (_.needsUpdate = !0)) : (m && m.data ? _ = new $s() : _ = new Vi(), m && (_.needsUpdate = !0)), _.source = h, _.uuid = a.uuid, a.name !== void 0 && (_.name = a.name), a.mapping !== void 0 && (_.mapping = n(a.mapping, aE)), a.channel !== void 0 && (_.channel = a.channel), a.offset !== void 0 && _.offset.fromArray(a.offset), a.repeat !== void 0 && _.repeat.fromArray(a.repeat), a.center !== void 0 && _.center.fromArray(a.center), a.rotation !== void 0 && (_.rotation = a.rotation), a.wrap !== void 0 && (_.wrapS = n(a.wrap[0], np), _.wrapT = n(a.wrap[1], np)), a.format !== void 0 && (_.format = a.format), a.internalFormat !== void 0 && (_.internalFormat = a.internalFormat), a.type !== void 0 && (_.type = a.type), a.colorSpace !== void 0 && (_.colorSpace = a.colorSpace), a.minFilter !== void 0 && (_.minFilter = n(a.minFilter, ip)), a.magFilter !== void 0 && (_.magFilter = n(a.magFilter, ip)), a.anisotropy !== void 0 && (_.anisotropy = a.anisotropy), a.flipY !== void 0 && (_.flipY = a.flipY), a.generateMipmaps !== void 0 && (_.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (_.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (_.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (_.compareFunction = a.compareFunction), a.userData !== void 0 && (_.userData = a.userData), i[a.uuid] = _;
                    }
                  return i;
                }
                parseObject(e, t, n, i, r) {
                  let o;
                  function a(B) {
                    return t[B] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", B), t[B];
                  }
                  function h(B) {
                    if (B !== void 0) {
                      if (Array.isArray(B)) {
                        const L = [];
                        for (let N = 0, z = B.length; N < z; N++) {
                          const k = B[N];
                          n[k] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", k), L.push(n[k]);
                        }
                        return L;
                      }
                      return n[B] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", B), n[B];
                    }
                  }
                  function m(B) {
                    return i[B] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", B), i[B];
                  }
                  let _, I;
                  switch (e.type) {
                    case "Scene":
                      o = new Ud(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new sn(e.background) : o.background = m(e.background)), e.environment !== void 0 && (o.environment = m(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new kl(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Nl(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
                      break;
                    case "PerspectiveCamera":
                      o = new mr(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                      break;
                    case "OrthographicCamera":
                      o = new Pl(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                      break;
                    case "AmbientLight":
                      o = new qf(e.color, e.intensity);
                      break;
                    case "DirectionalLight":
                      o = new Yf(e.color, e.intensity);
                      break;
                    case "PointLight":
                      o = new Xf(e.color, e.intensity, e.distance, e.decay);
                      break;
                    case "RectAreaLight":
                      o = new Jf(e.color, e.intensity, e.width, e.height);
                      break;
                    case "SpotLight":
                      o = new Wf(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                      break;
                    case "HemisphereLight":
                      o = new Hf(e.color, e.groundColor, e.intensity);
                      break;
                    case "LightProbe":
                      o = new $f().fromJSON(e);
                      break;
                    case "SkinnedMesh":
                      _ = a(e.geometry), I = h(e.material), o = new Yd(_, I), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
                      break;
                    case "Mesh":
                      _ = a(e.geometry), I = h(e.material), o = new hr(_, I);
                      break;
                    case "InstancedMesh":
                      _ = a(e.geometry), I = h(e.material);
                      const B = e.count, L = e.instanceMatrix, N = e.instanceColor;
                      o = new $d(_, I, B), o.instanceMatrix = new ha(new Float32Array(L.array), 16), N !== void 0 && (o.instanceColor = new ha(new Float32Array(N.array), N.itemSize));
                      break;
                    case "BatchedMesh":
                      _ = a(e.geometry), I = h(e.material), o = new nf(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, I), o.geometry = _, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((z) => {
                        const k = new Zi();
                        k.min.fromArray(z.boxMin), k.max.fromArray(z.boxMax);
                        const P = new pr();
                        return P.radius = z.sphereRadius, P.center.fromArray(z.sphereCenter), { boxInitialized: z.boxInitialized, box: k, sphereInitialized: z.sphereInitialized, sphere: P };
                      }), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = m(e.matricesTexture.uuid);
                      break;
                    case "LOD":
                      o = new Hd();
                      break;
                    case "Line":
                      o = new to(a(e.geometry), h(e.material));
                      break;
                    case "LineLoop":
                      o = new lf(a(e.geometry), h(e.material));
                      break;
                    case "LineSegments":
                      o = new bs(a(e.geometry), h(e.material));
                      break;
                    case "PointCloud":
                    case "Points":
                      o = new uf(a(e.geometry), h(e.material));
                      break;
                    case "Sprite":
                      o = new Qd(h(e.material));
                      break;
                    case "Group":
                      o = new xo();
                      break;
                    case "Bone":
                      o = new Zu();
                      break;
                    default:
                      o = new bi();
                  }
                  if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
                    const B = e.children;
                    for (let L = 0; L < B.length; L++)
                      o.add(this.parseObject(B[L], t, n, i, r));
                  }
                  if (e.animations !== void 0) {
                    const B = e.animations;
                    for (let L = 0; L < B.length; L++) {
                      const N = B[L];
                      o.animations.push(r[N]);
                    }
                  }
                  if (e.type === "LOD") {
                    e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
                    const B = e.levels;
                    for (let L = 0; L < B.length; L++) {
                      const N = B[L], z = o.getObjectByProperty("uuid", N.object);
                      z !== void 0 && o.addLevel(z, N.distance, N.hysteresis);
                    }
                  }
                  return o;
                }
                bindSkeletons(e, t) {
                  Object.keys(t).length !== 0 && e.traverse(function(n) {
                    if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                      const i = t[n.skeleton];
                      i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
                    }
                  });
                }
              }
              const aE = { UVMapping: xe, CubeReflectionMapping: H, CubeRefractionMapping: M, EquirectangularReflectionMapping: R, EquirectangularRefractionMapping: ee, CubeUVReflectionMapping: he }, np = { RepeatWrapping: we, ClampToEdgeWrapping: Oe, MirroredRepeatWrapping: Ct }, ip = { NearestFilter: Pt, NearestMipmapNearestFilter: _t, NearestMipmapLinearFilter: qt, LinearFilter: vn, LinearMipmapNearestFilter: Oi, LinearMipmapLinearFilter: Ei };
              class lE extends Xr {
                constructor(e) {
                  super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
                }
                setOptions(e) {
                  return this.options = e, this;
                }
                load(e, t, n, i) {
                  e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                  const r = this, o = Ns.get(e);
                  if (o !== void 0) {
                    if (r.manager.itemStart(e), o.then) {
                      o.then((m) => {
                        t && t(m), r.manager.itemEnd(e);
                      }).catch((m) => {
                        i && i(m);
                      });
                      return;
                    }
                    return setTimeout(function() {
                      t && t(o), r.manager.itemEnd(e);
                    }, 0), o;
                  }
                  const a = {};
                  a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
                  const h = fetch(e, a).then(function(m) {
                    return m.blob();
                  }).then(function(m) {
                    return createImageBitmap(m, Object.assign(r.options, { colorSpaceConversion: "none" }));
                  }).then(function(m) {
                    return Ns.add(e, m), t && t(m), r.manager.itemEnd(e), m;
                  }).catch(function(m) {
                    i && i(m), Ns.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
                  });
                  Ns.add(e, h), r.manager.itemStart(e);
                }
              }
              let wc;
              class Mh {
                static getContext() {
                  return wc === void 0 && (wc = new (window.AudioContext || window.webkitAudioContext)()), wc;
                }
                static setContext(e) {
                  wc = e;
                }
              }
              class cE extends Xr {
                constructor(e) {
                  super(e);
                }
                load(e, t, n, i) {
                  const r = this, o = new Gs(this.manager);
                  o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(h) {
                    try {
                      const m = h.slice(0);
                      Mh.getContext().decodeAudioData(m, function(I) {
                        t(I);
                      }).catch(a);
                    } catch (m) {
                      a(m);
                    }
                  }, n, i);
                  function a(h) {
                    i ? i(h) : console.error(h), r.manager.itemError(e);
                  }
                }
              }
              const rp = /* @__PURE__ */ new pn(), sp = /* @__PURE__ */ new pn(), Ro = /* @__PURE__ */ new pn();
              class uE {
                constructor() {
                  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new mr(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new mr(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
                }
                update(e) {
                  const t = this._cache;
                  if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                    t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Ro.copy(e.projectionMatrix);
                    const i = t.eyeSep / 2, r = i * t.near / t.focus, o = t.near * Math.tan(Bs * t.fov * 0.5) / t.zoom;
                    let a, h;
                    sp.elements[12] = -i, rp.elements[12] = i, a = -o * t.aspect + r, h = o * t.aspect + r, Ro.elements[0] = 2 * t.near / (h - a), Ro.elements[8] = (h + a) / (h - a), this.cameraL.projectionMatrix.copy(Ro), a = -o * t.aspect - r, h = o * t.aspect - r, Ro.elements[0] = 2 * t.near / (h - a), Ro.elements[8] = (h + a) / (h - a), this.cameraR.projectionMatrix.copy(Ro);
                  }
                  this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(sp), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(rp);
                }
              }
              class op {
                constructor(e = !0) {
                  this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
                }
                start() {
                  this.startTime = ap(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
                }
                stop() {
                  this.getElapsedTime(), this.running = !1, this.autoStart = !1;
                }
                getElapsedTime() {
                  return this.getDelta(), this.elapsedTime;
                }
                getDelta() {
                  let e = 0;
                  if (this.autoStart && !this.running)
                    return this.start(), 0;
                  if (this.running) {
                    const t = ap();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
                  }
                  return e;
                }
              }
              function ap() {
                return (typeof performance > "u" ? Date : performance).now();
              }
              const Lo = /* @__PURE__ */ new ye(), lp = /* @__PURE__ */ new xi(), hE = /* @__PURE__ */ new ye(), Do = /* @__PURE__ */ new ye();
              class dE extends bi {
                constructor() {
                  super(), this.type = "AudioListener", this.context = Mh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new op();
                }
                getInput() {
                  return this.gain;
                }
                removeFilter() {
                  return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
                }
                getFilter() {
                  return this.filter;
                }
                setFilter(e) {
                  return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
                }
                getMasterVolume() {
                  return this.gain.gain.value;
                }
                setMasterVolume(e) {
                  return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
                }
                updateMatrixWorld(e) {
                  super.updateMatrixWorld(e);
                  const t = this.context.listener, n = this.up;
                  if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Lo, lp, hE), Do.set(0, 0, -1).applyQuaternion(lp), t.positionX) {
                    const i = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(Lo.x, i), t.positionY.linearRampToValueAtTime(Lo.y, i), t.positionZ.linearRampToValueAtTime(Lo.z, i), t.forwardX.linearRampToValueAtTime(Do.x, i), t.forwardY.linearRampToValueAtTime(Do.y, i), t.forwardZ.linearRampToValueAtTime(Do.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
                  } else
                    t.setPosition(Lo.x, Lo.y, Lo.z), t.setOrientation(Do.x, Do.y, Do.z, n.x, n.y, n.z);
                }
              }
              class cp extends bi {
                constructor(e) {
                  super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
                }
                getOutput() {
                  return this.gain;
                }
                setNodeSource(e) {
                  return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
                }
                setMediaElementSource(e) {
                  return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
                }
                setMediaStreamSource(e) {
                  return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
                }
                setBuffer(e) {
                  return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
                }
                play(e = 0) {
                  if (this.isPlaying === !0) {
                    console.warn("THREE.Audio: Audio is already playing.");
                    return;
                  }
                  if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return;
                  }
                  this._startedAt = this.context.currentTime + e;
                  const t = this.context.createBufferSource();
                  return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
                }
                pause() {
                  if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return;
                  }
                  return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                }
                stop() {
                  if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return;
                  }
                  return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
                }
                connect() {
                  if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let e = 1, t = this.filters.length; e < t; e++)
                      this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput());
                  } else
                    this.source.connect(this.getOutput());
                  return this._connected = !0, this;
                }
                disconnect() {
                  if (this._connected !== !1) {
                    if (this.filters.length > 0) {
                      this.source.disconnect(this.filters[0]);
                      for (let e = 1, t = this.filters.length; e < t; e++)
                        this.filters[e - 1].disconnect(this.filters[e]);
                      this.filters[this.filters.length - 1].disconnect(this.getOutput());
                    } else
                      this.source.disconnect(this.getOutput());
                    return this._connected = !1, this;
                  }
                }
                getFilters() {
                  return this.filters;
                }
                setFilters(e) {
                  return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
                }
                setDetune(e) {
                  return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
                }
                getDetune() {
                  return this.detune;
                }
                getFilter() {
                  return this.getFilters()[0];
                }
                setFilter(e) {
                  return this.setFilters(e ? [e] : []);
                }
                setPlaybackRate(e) {
                  if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return;
                  }
                  return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
                }
                getPlaybackRate() {
                  return this.playbackRate;
                }
                onEnded() {
                  this.isPlaying = !1;
                }
                getLoop() {
                  return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
                }
                setLoop(e) {
                  if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return;
                  }
                  return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
                }
                setLoopStart(e) {
                  return this.loopStart = e, this;
                }
                setLoopEnd(e) {
                  return this.loopEnd = e, this;
                }
                getVolume() {
                  return this.gain.gain.value;
                }
                setVolume(e) {
                  return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
                }
              }
              const Po = /* @__PURE__ */ new ye(), up = /* @__PURE__ */ new xi(), fE = /* @__PURE__ */ new ye(), Oo = /* @__PURE__ */ new ye();
              class pE extends cp {
                constructor(e) {
                  super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
                }
                connect() {
                  super.connect(), this.panner.connect(this.gain);
                }
                disconnect() {
                  super.disconnect(), this.panner.disconnect(this.gain);
                }
                getOutput() {
                  return this.panner;
                }
                getRefDistance() {
                  return this.panner.refDistance;
                }
                setRefDistance(e) {
                  return this.panner.refDistance = e, this;
                }
                getRolloffFactor() {
                  return this.panner.rolloffFactor;
                }
                setRolloffFactor(e) {
                  return this.panner.rolloffFactor = e, this;
                }
                getDistanceModel() {
                  return this.panner.distanceModel;
                }
                setDistanceModel(e) {
                  return this.panner.distanceModel = e, this;
                }
                getMaxDistance() {
                  return this.panner.maxDistance;
                }
                setMaxDistance(e) {
                  return this.panner.maxDistance = e, this;
                }
                setDirectionalCone(e, t, n) {
                  return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
                }
                updateMatrixWorld(e) {
                  if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
                  this.matrixWorld.decompose(Po, up, fE), Oo.set(0, 0, 1).applyQuaternion(up);
                  const t = this.panner;
                  if (t.positionX) {
                    const n = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(Po.x, n), t.positionY.linearRampToValueAtTime(Po.y, n), t.positionZ.linearRampToValueAtTime(Po.z, n), t.orientationX.linearRampToValueAtTime(Oo.x, n), t.orientationY.linearRampToValueAtTime(Oo.y, n), t.orientationZ.linearRampToValueAtTime(Oo.z, n);
                  } else
                    t.setPosition(Po.x, Po.y, Po.z), t.setOrientation(Oo.x, Oo.y, Oo.z);
                }
              }
              class AE {
                constructor(e, t = 2048) {
                  this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
                }
                getFrequencyData() {
                  return this.analyser.getByteFrequencyData(this.data), this.data;
                }
                getAverageFrequency() {
                  let e = 0;
                  const t = this.getFrequencyData();
                  for (let n = 0; n < t.length; n++)
                    e += t[n];
                  return e / t.length;
                }
              }
              class hp {
                constructor(e, t, n) {
                  this.binding = e, this.valueSize = n;
                  let i, r, o;
                  switch (t) {
                    case "quaternion":
                      i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                      break;
                    case "string":
                    case "bool":
                      i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                      break;
                    default:
                      i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
                  }
                  this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
                }
                // accumulate data in the 'incoming' region into 'accu<i>'
                accumulate(e, t) {
                  const n = this.buffer, i = this.valueSize, r = e * i + i;
                  let o = this.cumulativeWeight;
                  if (o === 0) {
                    for (let a = 0; a !== i; ++a)
                      n[r + a] = n[a];
                    o = t;
                  } else {
                    o += t;
                    const a = t / o;
                    this._mixBufferRegion(n, r, 0, a, i);
                  }
                  this.cumulativeWeight = o;
                }
                // accumulate data in the 'incoming' region into 'add'
                accumulateAdditive(e) {
                  const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
                  this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
                }
                // apply the state of 'accu<i>' to the binding when accus differ
                apply(e) {
                  const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
                  if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                    const h = t * this._origIndex;
                    this._mixBufferRegion(n, i, h, 1 - r, t);
                  }
                  o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                  for (let h = t, m = t + t; h !== m; ++h)
                    if (n[h] !== n[h + t]) {
                      a.setValue(n, i);
                      break;
                    }
                }
                // remember the state of the bound property and copy it to both accus
                saveOriginalState() {
                  const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
                  e.getValue(t, i);
                  for (let r = n, o = i; r !== o; ++r)
                    t[r] = t[i + r % n];
                  this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
                }
                // apply the state previously taken via 'saveOriginalState' to the binding
                restoreOriginalState() {
                  const e = this.valueSize * 3;
                  this.binding.setValue(this.buffer, e);
                }
                _setAdditiveIdentityNumeric() {
                  const e = this._addIndex * this.valueSize, t = e + this.valueSize;
                  for (let n = e; n < t; n++)
                    this.buffer[n] = 0;
                }
                _setAdditiveIdentityQuaternion() {
                  this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
                }
                _setAdditiveIdentityOther() {
                  const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
                  for (let n = 0; n < this.valueSize; n++)
                    this.buffer[t + n] = this.buffer[e + n];
                }
                // mix functions
                _select(e, t, n, i, r) {
                  if (i >= 0.5)
                    for (let o = 0; o !== r; ++o)
                      e[t + o] = e[n + o];
                }
                _slerp(e, t, n, i) {
                  xi.slerpFlat(e, t, e, t, e, n, i);
                }
                _slerpAdditive(e, t, n, i, r) {
                  const o = this._workIndex * r;
                  xi.multiplyQuaternionsFlat(e, o, e, t, e, n), xi.slerpFlat(e, t, e, t, e, o, i);
                }
                _lerp(e, t, n, i, r) {
                  const o = 1 - i;
                  for (let a = 0; a !== r; ++a) {
                    const h = t + a;
                    e[h] = e[h] * o + e[n + a] * i;
                  }
                }
                _lerpAdditive(e, t, n, i, r) {
                  for (let o = 0; o !== r; ++o) {
                    const a = t + o;
                    e[a] = e[a] + e[n + o] * i;
                  }
                }
              }
              const Sh = "\\[\\]\\.:\\/", mE = new RegExp("[" + Sh + "]", "g"), Th = "[^" + Sh + "]", gE = "[^" + Sh.replace("\\.", "") + "]", vE = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", Th), EE = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", gE), yE = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Th), CE = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Th), xE = new RegExp("^" + vE + EE + yE + CE + "$"), bE = ["material", "materials", "bones", "map"];
              class _E {
                constructor(e, t, n) {
                  const i = n || Ci.parseTrackName(t);
                  this._targetGroup = e, this._bindings = e.subscribe_(t, i);
                }
                getValue(e, t) {
                  this.bind();
                  const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
                  i !== void 0 && i.getValue(e, t);
                }
                setValue(e, t) {
                  const n = this._bindings;
                  for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(e, t);
                }
                bind() {
                  const e = this._bindings;
                  for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].bind();
                }
                unbind() {
                  const e = this._bindings;
                  for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].unbind();
                }
              }
              class Ci {
                constructor(e, t, n) {
                  this.path = t, this.parsedPath = n || Ci.parseTrackName(t), this.node = Ci.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
                }
                static create(e, t, n) {
                  return e && e.isAnimationObjectGroup ? new Ci.Composite(e, t, n) : new Ci(e, t, n);
                }
                /**
                * Replaces spaces with underscores and removes unsupported characters from
                * node names, to ensure compatibility with parseTrackName().
                *
                * @param {string} name Node name to be sanitized.
                * @return {string}
                */
                static sanitizeNodeName(e) {
                  return e.replace(/\s/g, "_").replace(mE, "");
                }
                static parseTrackName(e) {
                  const t = xE.exec(e);
                  if (t === null)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                  const n = {
                    // directoryName: matches[ 1 ], // (tschw) currently unused
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    // required
                    propertyIndex: t[6]
                  }, i = n.nodeName && n.nodeName.lastIndexOf(".");
                  if (i !== void 0 && i !== -1) {
                    const r = n.nodeName.substring(i + 1);
                    bE.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r);
                  }
                  if (n.propertyName === null || n.propertyName.length === 0)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                  return n;
                }
                static findNode(e, t) {
                  if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
                    return e;
                  if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (n !== void 0)
                      return n;
                  }
                  if (e.children) {
                    const n = function(r) {
                      for (let o = 0; o < r.length; o++) {
                        const a = r[o];
                        if (a.name === t || a.uuid === t)
                          return a;
                        const h = n(a.children);
                        if (h) return h;
                      }
                      return null;
                    }, i = n(e.children);
                    if (i)
                      return i;
                  }
                  return null;
                }
                // these are used to "bind" a nonexistent property
                _getValue_unavailable() {
                }
                _setValue_unavailable() {
                }
                // Getters
                _getValue_direct(e, t) {
                  e[t] = this.targetObject[this.propertyName];
                }
                _getValue_array(e, t) {
                  const n = this.resolvedProperty;
                  for (let i = 0, r = n.length; i !== r; ++i)
                    e[t++] = n[i];
                }
                _getValue_arrayElement(e, t) {
                  e[t] = this.resolvedProperty[this.propertyIndex];
                }
                _getValue_toArray(e, t) {
                  this.resolvedProperty.toArray(e, t);
                }
                // Direct
                _setValue_direct(e, t) {
                  this.targetObject[this.propertyName] = e[t];
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                  this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                  this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
                }
                // EntireArray
                _setValue_array(e, t) {
                  const n = this.resolvedProperty;
                  for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                }
                _setValue_array_setNeedsUpdate(e, t) {
                  const n = this.resolvedProperty;
                  for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                  this.targetObject.needsUpdate = !0;
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                  const n = this.resolvedProperty;
                  for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                  this.targetObject.matrixWorldNeedsUpdate = !0;
                }
                // ArrayElement
                _setValue_arrayElement(e, t) {
                  this.resolvedProperty[this.propertyIndex] = e[t];
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                  this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                  this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
                }
                // HasToFromArray
                _setValue_fromArray(e, t) {
                  this.resolvedProperty.fromArray(e, t);
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                  this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                  this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
                }
                _getValue_unbound(e, t) {
                  this.bind(), this.getValue(e, t);
                }
                _setValue_unbound(e, t) {
                  this.bind(), this.setValue(e, t);
                }
                // create getter / setter pair for a property in the scene graph
                bind() {
                  let e = this.node;
                  const t = this.parsedPath, n = t.objectName, i = t.propertyName;
                  let r = t.propertyIndex;
                  if (e || (e = Ci.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                    console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                    return;
                  }
                  if (n) {
                    let m = t.objectIndex;
                    switch (n) {
                      case "materials":
                        if (!e.material) {
                          console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                          return;
                        }
                        if (!e.material.materials) {
                          console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                          return;
                        }
                        e = e.material.materials;
                        break;
                      case "bones":
                        if (!e.skeleton) {
                          console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                          return;
                        }
                        e = e.skeleton.bones;
                        for (let _ = 0; _ < e.length; _++)
                          if (e[_].name === m) {
                            m = _;
                            break;
                          }
                        break;
                      case "map":
                        if ("map" in e) {
                          e = e.map;
                          break;
                        }
                        if (!e.material) {
                          console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                          return;
                        }
                        if (!e.material.map) {
                          console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                          return;
                        }
                        e = e.material.map;
                        break;
                      default:
                        if (e[n] === void 0) {
                          console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                          return;
                        }
                        e = e[n];
                    }
                    if (m !== void 0) {
                      if (e[m] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        return;
                      }
                      e = e[m];
                    }
                  }
                  const o = e[i];
                  if (o === void 0) {
                    const m = t.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + m + "." + i + " but it wasn't found.", e);
                    return;
                  }
                  let a = this.Versioning.None;
                  this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
                  let h = this.BindingType.Direct;
                  if (r !== void 0) {
                    if (i === "morphTargetInfluences") {
                      if (!e.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return;
                      }
                      if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                      }
                      e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
                    }
                    h = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
                  } else o.fromArray !== void 0 && o.toArray !== void 0 ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (h = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
                  this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][a];
                }
                unbind() {
                  this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
                }
              }
              Ci.Composite = _E, Ci.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ci.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ci.prototype.GetterByBindingType = [Ci.prototype._getValue_direct, Ci.prototype._getValue_array, Ci.prototype._getValue_arrayElement, Ci.prototype._getValue_toArray], Ci.prototype.SetterByBindingTypeAndVersioning = [[
                // Direct
                Ci.prototype._setValue_direct,
                Ci.prototype._setValue_direct_setNeedsUpdate,
                Ci.prototype._setValue_direct_setMatrixWorldNeedsUpdate
              ], [
                // EntireArray
                Ci.prototype._setValue_array,
                Ci.prototype._setValue_array_setNeedsUpdate,
                Ci.prototype._setValue_array_setMatrixWorldNeedsUpdate
              ], [
                // ArrayElement
                Ci.prototype._setValue_arrayElement,
                Ci.prototype._setValue_arrayElement_setNeedsUpdate,
                Ci.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
              ], [
                // HasToFromArray
                Ci.prototype._setValue_fromArray,
                Ci.prototype._setValue_fromArray_setNeedsUpdate,
                Ci.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
              ]];
              class wE {
                constructor() {
                  this.isAnimationObjectGroup = !0, this.uuid = kr(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                  const e = {};
                  this._indicesByUUID = e;
                  for (let n = 0, i = arguments.length; n !== i; ++n)
                    e[arguments[n].uuid] = n;
                  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                  const t = this;
                  this.stats = { objects: { get total() {
                    return t._objects.length;
                  }, get inUse() {
                    return this.total - t.nCachedObjects_;
                  } }, get bindingsPerObject() {
                    return t._bindings.length;
                  } };
                }
                add() {
                  const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length;
                  let a, h = e.length, m = this.nCachedObjects_;
                  for (let _ = 0, I = arguments.length; _ !== I; ++_) {
                    const B = arguments[_], L = B.uuid;
                    let N = t[L];
                    if (N === void 0) {
                      N = h++, t[L] = N, e.push(B);
                      for (let z = 0, k = o; z !== k; ++z)
                        r[z].push(new Ci(B, n[z], i[z]));
                    } else if (N < m) {
                      a = e[N];
                      const z = --m, k = e[z];
                      t[k.uuid] = N, e[N] = k, t[L] = z, e[z] = B;
                      for (let P = 0, se = o; P !== se; ++P) {
                        const $ = r[P], J = $[z];
                        let Le = $[N];
                        $[N] = J, Le === void 0 && (Le = new Ci(B, n[P], i[P])), $[z] = Le;
                      }
                    } else e[N] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
                  }
                  this.nCachedObjects_ = m;
                }
                remove() {
                  const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
                  let r = this.nCachedObjects_;
                  for (let o = 0, a = arguments.length; o !== a; ++o) {
                    const h = arguments[o], m = h.uuid, _ = t[m];
                    if (_ !== void 0 && _ >= r) {
                      const I = r++, B = e[I];
                      t[B.uuid] = _, e[_] = B, t[m] = I, e[I] = h;
                      for (let L = 0, N = i; L !== N; ++L) {
                        const z = n[L], k = z[I], P = z[_];
                        z[_] = k, z[I] = P;
                      }
                    }
                  }
                  this.nCachedObjects_ = r;
                }
                // remove & forget
                uncache() {
                  const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
                  let r = this.nCachedObjects_, o = e.length;
                  for (let a = 0, h = arguments.length; a !== h; ++a) {
                    const m = arguments[a], _ = m.uuid, I = t[_];
                    if (I !== void 0)
                      if (delete t[_], I < r) {
                        const B = --r, L = e[B], N = --o, z = e[N];
                        t[L.uuid] = I, e[I] = L, t[z.uuid] = B, e[B] = z, e.pop();
                        for (let k = 0, P = i; k !== P; ++k) {
                          const se = n[k], $ = se[B], J = se[N];
                          se[I] = $, se[B] = J, se.pop();
                        }
                      } else {
                        const B = --o, L = e[B];
                        B > 0 && (t[L.uuid] = I), e[I] = L, e.pop();
                        for (let N = 0, z = i; N !== z; ++N) {
                          const k = n[N];
                          k[I] = k[B], k.pop();
                        }
                      }
                  }
                  this.nCachedObjects_ = r;
                }
                // Internal interface used by befriended PropertyBinding.Composite:
                subscribe_(e, t) {
                  const n = this._bindingsIndicesByPath;
                  let i = n[e];
                  const r = this._bindings;
                  if (i !== void 0) return r[i];
                  const o = this._paths, a = this._parsedPaths, h = this._objects, m = h.length, _ = this.nCachedObjects_, I = new Array(m);
                  i = r.length, n[e] = i, o.push(e), a.push(t), r.push(I);
                  for (let B = _, L = h.length; B !== L; ++B) {
                    const N = h[B];
                    I[B] = new Ci(N, e, t);
                  }
                  return I;
                }
                unsubscribe_(e) {
                  const t = this._bindingsIndicesByPath, n = t[e];
                  if (n !== void 0) {
                    const i = this._paths, r = this._parsedPaths, o = this._bindings, a = o.length - 1, h = o[a], m = e[a];
                    t[m] = n, o[n] = h, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop();
                  }
                }
              }
              class dp {
                constructor(e, t, n = null, i = t.blendMode) {
                  this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
                  const r = t.tracks, o = r.length, a = new Array(o), h = { endingStart: Ji, endingEnd: Ji };
                  for (let m = 0; m !== o; ++m) {
                    const _ = r[m].createInterpolant(null);
                    a[m] = _, _.settings = h;
                  }
                  this._interpolantSettings = h, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Qi, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
                }
                // State & Scheduling
                play() {
                  return this._mixer._activateAction(this), this;
                }
                stop() {
                  return this._mixer._deactivateAction(this), this.reset();
                }
                reset() {
                  return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
                }
                isRunning() {
                  return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
                }
                // return true when play has been called
                isScheduled() {
                  return this._mixer._isActiveAction(this);
                }
                startAt(e) {
                  return this._startTime = e, this;
                }
                setLoop(e, t) {
                  return this.loop = e, this.repetitions = t, this;
                }
                // Weight
                // set the weight stopping any scheduled fading
                // although .enabled = false yields an effective weight of zero, this
                // method does *not* change .enabled, because it would be confusing
                setEffectiveWeight(e) {
                  return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
                }
                // return the weight considering fading and .enabled
                getEffectiveWeight() {
                  return this._effectiveWeight;
                }
                fadeIn(e) {
                  return this._scheduleFading(e, 0, 1);
                }
                fadeOut(e) {
                  return this._scheduleFading(e, 1, 0);
                }
                crossFadeFrom(e, t, n) {
                  if (e.fadeOut(t), this.fadeIn(t), n) {
                    const i = this._clip.duration, r = e._clip.duration, o = r / i, a = i / r;
                    e.warp(1, o, t), this.warp(a, 1, t);
                  }
                  return this;
                }
                crossFadeTo(e, t, n) {
                  return e.crossFadeFrom(this, t, n);
                }
                stopFading() {
                  const e = this._weightInterpolant;
                  return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
                }
                // Time Scale Control
                // set the time scale stopping any scheduled warping
                // although .paused = true yields an effective time scale of zero, this
                // method does *not* change .paused, because it would be confusing
                setEffectiveTimeScale(e) {
                  return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
                }
                // return the time scale considering warping and .paused
                getEffectiveTimeScale() {
                  return this._effectiveTimeScale;
                }
                setDuration(e) {
                  return this.timeScale = this._clip.duration / e, this.stopWarping();
                }
                syncWith(e) {
                  return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
                }
                halt(e) {
                  return this.warp(this._effectiveTimeScale, 0, e);
                }
                warp(e, t, n) {
                  const i = this._mixer, r = i.time, o = this.timeScale;
                  let a = this._timeScaleInterpolant;
                  a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
                  const h = a.parameterPositions, m = a.sampleValues;
                  return h[0] = r, h[1] = r + n, m[0] = e / o, m[1] = t / o, this;
                }
                stopWarping() {
                  const e = this._timeScaleInterpolant;
                  return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
                }
                // Object Accessors
                getMixer() {
                  return this._mixer;
                }
                getClip() {
                  return this._clip;
                }
                getRoot() {
                  return this._localRoot || this._mixer._root;
                }
                // Interna
                _update(e, t, n, i) {
                  if (!this.enabled) {
                    this._updateWeight(e);
                    return;
                  }
                  const r = this._startTime;
                  if (r !== null) {
                    const h = (e - r) * n;
                    h < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * h);
                  }
                  t *= this._updateTimeScale(e);
                  const o = this._updateTime(t), a = this._updateWeight(e);
                  if (a > 0) {
                    const h = this._interpolants, m = this._propertyBindings;
                    switch (this.blendMode) {
                      case us:
                        for (let _ = 0, I = h.length; _ !== I; ++_)
                          h[_].evaluate(o), m[_].accumulateAdditive(a);
                        break;
                      case rs:
                      default:
                        for (let _ = 0, I = h.length; _ !== I; ++_)
                          h[_].evaluate(o), m[_].accumulate(i, a);
                    }
                  }
                }
                _updateWeight(e) {
                  let t = 0;
                  if (this.enabled) {
                    t = this.weight;
                    const n = this._weightInterpolant;
                    if (n !== null) {
                      const i = n.evaluate(e)[0];
                      t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
                    }
                  }
                  return this._effectiveWeight = t, t;
                }
                _updateTimeScale(e) {
                  let t = 0;
                  if (!this.paused) {
                    t = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (n !== null) {
                      const i = n.evaluate(e)[0];
                      t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
                    }
                  }
                  return this._effectiveTimeScale = t, t;
                }
                _updateTime(e) {
                  const t = this._clip.duration, n = this.loop;
                  let i = this.time + e, r = this._loopCount;
                  const o = n === sr;
                  if (e === 0)
                    return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
                  if (n === Wi) {
                    r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                      if (i >= t)
                        i = t;
                      else if (i < 0)
                        i = 0;
                      else {
                        this.time = i;
                        break e;
                      }
                      this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 });
                    }
                  } else {
                    if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), i >= t || i < 0) {
                      const a = Math.floor(i / t);
                      i -= t * a, r += Math.abs(a);
                      const h = this.repetitions - r;
                      if (h <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
                      else {
                        if (h === 1) {
                          const m = e < 0;
                          this._setEndings(m, !m, o);
                        } else
                          this._setEndings(!1, !1, o);
                        this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a });
                      }
                    } else
                      this.time = i;
                    if (o && (r & 1) === 1)
                      return t - i;
                  }
                  return i;
                }
                _setEndings(e, t, n) {
                  const i = this._interpolantSettings;
                  n ? (i.endingStart = xr, i.endingEnd = xr) : (e ? i.endingStart = this.zeroSlopeAtStart ? xr : Ji : i.endingStart = Yr, t ? i.endingEnd = this.zeroSlopeAtEnd ? xr : Ji : i.endingEnd = Yr);
                }
                _scheduleFading(e, t, n) {
                  const i = this._mixer, r = i.time;
                  let o = this._weightInterpolant;
                  o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
                  const a = o.parameterPositions, h = o.sampleValues;
                  return a[0] = r, h[0] = t, a[1] = r + e, h[1] = n, this;
                }
              }
              const ME = new Float32Array(1);
              class SE extends Nr {
                constructor(e) {
                  super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
                }
                _bindAction(e, t) {
                  const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, o = e._propertyBindings, a = e._interpolants, h = n.uuid, m = this._bindingsByRootAndName;
                  let _ = m[h];
                  _ === void 0 && (_ = {}, m[h] = _);
                  for (let I = 0; I !== r; ++I) {
                    const B = i[I], L = B.name;
                    let N = _[L];
                    if (N !== void 0)
                      ++N.referenceCount, o[I] = N;
                    else {
                      if (N = o[I], N !== void 0) {
                        N._cacheIndex === null && (++N.referenceCount, this._addInactiveBinding(N, h, L));
                        continue;
                      }
                      const z = t && t._propertyBindings[I].binding.parsedPath;
                      N = new hp(Ci.create(n, L, z), B.ValueTypeName, B.getValueSize()), ++N.referenceCount, this._addInactiveBinding(N, h, L), o[I] = N;
                    }
                    a[I].resultBuffer = N.buffer;
                  }
                }
                _activateAction(e) {
                  if (!this._isActiveAction(e)) {
                    if (e._cacheIndex === null) {
                      const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i];
                      this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, i, n);
                    }
                    const t = e._propertyBindings;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                      const r = t[n];
                      r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
                    }
                    this._lendAction(e);
                  }
                }
                _deactivateAction(e) {
                  if (this._isActiveAction(e)) {
                    const t = e._propertyBindings;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                      const r = t[n];
                      --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
                    }
                    this._takeBackAction(e);
                  }
                }
                // Memory manager
                _initMemoryManager() {
                  this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                  const e = this;
                  this.stats = { actions: { get total() {
                    return e._actions.length;
                  }, get inUse() {
                    return e._nActiveActions;
                  } }, bindings: { get total() {
                    return e._bindings.length;
                  }, get inUse() {
                    return e._nActiveBindings;
                  } }, controlInterpolants: { get total() {
                    return e._controlInterpolants.length;
                  }, get inUse() {
                    return e._nActiveControlInterpolants;
                  } } };
                }
                // Memory management for AnimationAction objects
                _isActiveAction(e) {
                  const t = e._cacheIndex;
                  return t !== null && t < this._nActiveActions;
                }
                _addInactiveAction(e, t, n) {
                  const i = this._actions, r = this._actionsByClip;
                  let o = r[t];
                  if (o === void 0)
                    o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = o;
                  else {
                    const a = o.knownActions;
                    e._byClipCacheIndex = a.length, a.push(e);
                  }
                  e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e;
                }
                _removeInactiveAction(e) {
                  const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
                  n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                  const r = e._clip.uuid, o = this._actionsByClip, a = o[r], h = a.knownActions, m = h[h.length - 1], _ = e._byClipCacheIndex;
                  m._byClipCacheIndex = _, h[_] = m, h.pop(), e._byClipCacheIndex = null;
                  const I = a.actionByRoot, B = (e._localRoot || this._root).uuid;
                  delete I[B], h.length === 0 && delete o[r], this._removeInactiveBindingsForAction(e);
                }
                _removeInactiveBindingsForAction(e) {
                  const t = e._propertyBindings;
                  for (let n = 0, i = t.length; n !== i; ++n) {
                    const r = t[n];
                    --r.referenceCount === 0 && this._removeInactiveBinding(r);
                  }
                }
                _lendAction(e) {
                  const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i];
                  e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
                }
                _takeBackAction(e) {
                  const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i];
                  e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
                }
                // Memory management for PropertyMixer objects
                _addInactiveBinding(e, t, n) {
                  const i = this._bindingsByRootAndName, r = this._bindings;
                  let o = i[t];
                  o === void 0 && (o = {}, i[t] = o), o[n] = e, e._cacheIndex = r.length, r.push(e);
                }
                _removeInactiveBinding(e) {
                  const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName, a = o[i], h = t[t.length - 1], m = e._cacheIndex;
                  h._cacheIndex = m, t[m] = h, t.pop(), delete a[r], Object.keys(a).length === 0 && delete o[i];
                }
                _lendBinding(e) {
                  const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i];
                  e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
                }
                _takeBackBinding(e) {
                  const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i];
                  e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
                }
                // Memory management of Interpolants for weight and time scale
                _lendControlInterpolant() {
                  const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
                  let n = e[t];
                  return n === void 0 && (n = new Eh(new Float32Array(2), new Float32Array(2), 1, ME), n.__cacheIndex = t, e[t] = n), n;
                }
                _takeBackControlInterpolant(e) {
                  const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i];
                  e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r;
                }
                // return an action for a clip optionally using a custom root target
                // object (this method allocates a lot of dynamic memory in case a
                // previously unknown clip/root combination is specified)
                clipAction(e, t, n) {
                  const i = t || this._root, r = i.uuid;
                  let o = typeof e == "string" ? qa.findByName(i, e) : e;
                  const a = o !== null ? o.uuid : e, h = this._actionsByClip[a];
                  let m = null;
                  if (n === void 0 && (o !== null ? n = o.blendMode : n = rs), h !== void 0) {
                    const I = h.actionByRoot[r];
                    if (I !== void 0 && I.blendMode === n)
                      return I;
                    m = h.knownActions[0], o === null && (o = m._clip);
                  }
                  if (o === null) return null;
                  const _ = new dp(this, o, t, n);
                  return this._bindAction(_, m), this._addInactiveAction(_, a, r), _;
                }
                // get an existing action
                existingAction(e, t) {
                  const n = t || this._root, i = n.uuid, r = typeof e == "string" ? qa.findByName(n, e) : e, o = r ? r.uuid : e, a = this._actionsByClip[o];
                  return a !== void 0 && a.actionByRoot[i] || null;
                }
                // deactivates all previously scheduled actions
                stopAllAction() {
                  const e = this._actions, t = this._nActiveActions;
                  for (let n = t - 1; n >= 0; --n)
                    e[n].stop();
                  return this;
                }
                // advance the time and update apply the animation
                update(e) {
                  e *= this.timeScale;
                  const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1;
                  for (let m = 0; m !== n; ++m)
                    t[m]._update(i, e, r, o);
                  const a = this._bindings, h = this._nActiveBindings;
                  for (let m = 0; m !== h; ++m)
                    a[m].apply(o);
                  return this;
                }
                // Allows you to seek to a specific time in an animation.
                setTime(e) {
                  this.time = 0;
                  for (let t = 0; t < this._actions.length; t++)
                    this._actions[t].time = 0;
                  return this.update(e);
                }
                // return this mixer's root target object
                getRoot() {
                  return this._root;
                }
                // free all resources specific to a particular clip
                uncacheClip(e) {
                  const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n];
                  if (r !== void 0) {
                    const o = r.knownActions;
                    for (let a = 0, h = o.length; a !== h; ++a) {
                      const m = o[a];
                      this._deactivateAction(m);
                      const _ = m._cacheIndex, I = t[t.length - 1];
                      m._cacheIndex = null, m._byClipCacheIndex = null, I._cacheIndex = _, t[_] = I, t.pop(), this._removeInactiveBindingsForAction(m);
                    }
                    delete i[n];
                  }
                }
                // free all resources specific to a particular root target object
                uncacheRoot(e) {
                  const t = e.uuid, n = this._actionsByClip;
                  for (const o in n) {
                    const a = n[o].actionByRoot, h = a[t];
                    h !== void 0 && (this._deactivateAction(h), this._removeInactiveAction(h));
                  }
                  const i = this._bindingsByRootAndName, r = i[t];
                  if (r !== void 0)
                    for (const o in r) {
                      const a = r[o];
                      a.restoreOriginalState(), this._removeInactiveBinding(a);
                    }
                }
                // remove a targeted clip from the cache
                uncacheAction(e, t) {
                  const n = this.existingAction(e, t);
                  n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
                }
              }
              class Ih {
                constructor(e) {
                  this.value = e;
                }
                clone() {
                  return new Ih(this.value.clone === void 0 ? this.value : this.value.clone());
                }
              }
              let TE = 0;
              class IE extends Nr {
                constructor() {
                  super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: TE++ }), this.name = "", this.usage = ho, this.uniforms = [];
                }
                add(e) {
                  return this.uniforms.push(e), this;
                }
                remove(e) {
                  const t = this.uniforms.indexOf(e);
                  return t !== -1 && this.uniforms.splice(t, 1), this;
                }
                setName(e) {
                  return this.name = e, this;
                }
                setUsage(e) {
                  return this.usage = e, this;
                }
                dispose() {
                  return this.dispatchEvent({ type: "dispose" }), this;
                }
                copy(e) {
                  this.name = e.name, this.usage = e.usage;
                  const t = e.uniforms;
                  this.uniforms.length = 0;
                  for (let n = 0, i = t.length; n < i; n++) {
                    const r = Array.isArray(t[n]) ? t[n] : [t[n]];
                    for (let o = 0; o < r.length; o++)
                      this.uniforms.push(r[o].clone());
                  }
                  return this;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              class BE extends Gl {
                constructor(e, t, n = 1) {
                  super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
                }
                copy(e) {
                  return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
                }
                clone(e) {
                  const t = super.clone(e);
                  return t.meshPerAttribute = this.meshPerAttribute, t;
                }
                toJSON(e) {
                  const t = super.toJSON(e);
                  return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
                }
              }
              class RE {
                constructor(e, t, n, i, r) {
                  this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0;
                }
                set needsUpdate(e) {
                  e === !0 && this.version++;
                }
                setBuffer(e) {
                  return this.buffer = e, this;
                }
                setType(e, t) {
                  return this.type = e, this.elementSize = t, this;
                }
                setItemSize(e) {
                  return this.itemSize = e, this;
                }
                setCount(e) {
                  return this.count = e, this;
                }
              }
              const fp = /* @__PURE__ */ new pn();
              class LE {
                constructor(e, t, n = 0, i = 1 / 0) {
                  this.ray = new Ar(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new El(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
                }
                set(e, t) {
                  this.ray.set(e, t);
                }
                setFromCamera(e, t) {
                  t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
                }
                setFromXRController(e) {
                  return fp.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(fp), this;
                }
                intersectObject(e, t = !0, n = []) {
                  return Bh(e, this, n, t), n.sort(pp), n;
                }
                intersectObjects(e, t = !0, n = []) {
                  for (let i = 0, r = e.length; i < r; i++)
                    Bh(e[i], this, n, t);
                  return n.sort(pp), n;
                }
              }
              function pp(s, e) {
                return s.distance - e.distance;
              }
              function Bh(s, e, t, n) {
                if (s.layers.test(e.layers) && s.raycast(e, t), n === !0) {
                  const i = s.children;
                  for (let r = 0, o = i.length; r < o; r++)
                    Bh(i[r], e, t, !0);
                }
              }
              class DE {
                constructor(e = 1, t = 0, n = 0) {
                  return this.radius = e, this.phi = t, this.theta = n, this;
                }
                set(e, t, n) {
                  return this.radius = e, this.phi = t, this.theta = n, this;
                }
                copy(e) {
                  return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
                }
                // restrict phi to be between EPS and PI-EPS
                makeSafe() {
                  return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
                }
                setFromVector3(e) {
                  return this.setFromCartesianCoords(e.x, e.y, e.z);
                }
                setFromCartesianCoords(e, t, n) {
                  return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Yi(t / this.radius, -1, 1))), this;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              class PE {
                constructor(e = 1, t = 0, n = 0) {
                  return this.radius = e, this.theta = t, this.y = n, this;
                }
                set(e, t, n) {
                  return this.radius = e, this.theta = t, this.y = n, this;
                }
                copy(e) {
                  return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
                }
                setFromVector3(e) {
                  return this.setFromCartesianCoords(e.x, e.y, e.z);
                }
                setFromCartesianCoords(e, t, n) {
                  return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              const Ap = /* @__PURE__ */ new pt();
              class OE {
                constructor(e = new pt(1 / 0, 1 / 0), t = new pt(-1 / 0, -1 / 0)) {
                  this.isBox2 = !0, this.min = e, this.max = t;
                }
                set(e, t) {
                  return this.min.copy(e), this.max.copy(t), this;
                }
                setFromPoints(e) {
                  this.makeEmpty();
                  for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                  return this;
                }
                setFromCenterAndSize(e, t) {
                  const n = Ap.copy(t).multiplyScalar(0.5);
                  return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                copy(e) {
                  return this.min.copy(e.min), this.max.copy(e.max), this;
                }
                makeEmpty() {
                  return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
                }
                isEmpty() {
                  return this.max.x < this.min.x || this.max.y < this.min.y;
                }
                getCenter(e) {
                  return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
                }
                getSize(e) {
                  return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
                }
                expandByPoint(e) {
                  return this.min.min(e), this.max.max(e), this;
                }
                expandByVector(e) {
                  return this.min.sub(e), this.max.add(e), this;
                }
                expandByScalar(e) {
                  return this.min.addScalar(-e), this.max.addScalar(e), this;
                }
                containsPoint(e) {
                  return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
                }
                containsBox(e) {
                  return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
                }
                getParameter(e, t) {
                  return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
                }
                intersectsBox(e) {
                  return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
                }
                clampPoint(e, t) {
                  return t.copy(e).clamp(this.min, this.max);
                }
                distanceToPoint(e) {
                  return this.clampPoint(e, Ap).distanceTo(e);
                }
                intersect(e) {
                  return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
                }
                union(e) {
                  return this.min.min(e.min), this.max.max(e.max), this;
                }
                translate(e) {
                  return this.min.add(e), this.max.add(e), this;
                }
                equals(e) {
                  return e.min.equals(this.min) && e.max.equals(this.max);
                }
              }
              const mp = /* @__PURE__ */ new ye(), Mc = /* @__PURE__ */ new ye();
              class FE {
                constructor(e = new ye(), t = new ye()) {
                  this.start = e, this.end = t;
                }
                set(e, t) {
                  return this.start.copy(e), this.end.copy(t), this;
                }
                copy(e) {
                  return this.start.copy(e.start), this.end.copy(e.end), this;
                }
                getCenter(e) {
                  return e.addVectors(this.start, this.end).multiplyScalar(0.5);
                }
                delta(e) {
                  return e.subVectors(this.end, this.start);
                }
                distanceSq() {
                  return this.start.distanceToSquared(this.end);
                }
                distance() {
                  return this.start.distanceTo(this.end);
                }
                at(e, t) {
                  return this.delta(t).multiplyScalar(e).add(this.start);
                }
                closestPointToPointParameter(e, t) {
                  mp.subVectors(e, this.start), Mc.subVectors(this.end, this.start);
                  const n = Mc.dot(Mc);
                  let r = Mc.dot(mp) / n;
                  return t && (r = Yi(r, 0, 1)), r;
                }
                closestPointToPoint(e, t, n) {
                  const i = this.closestPointToPointParameter(e, t);
                  return this.delta(n).multiplyScalar(i).add(this.start);
                }
                applyMatrix4(e) {
                  return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
                }
                equals(e) {
                  return e.start.equals(this.start) && e.end.equals(this.end);
                }
                clone() {
                  return new this.constructor().copy(this);
                }
              }
              const gp = /* @__PURE__ */ new ye();
              class UE extends bi {
                constructor(e, t) {
                  super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
                  const n = new ti(), i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                  for (let o = 0, a = 1, h = 32; o < h; o++, a++) {
                    const m = o / h * Math.PI * 2, _ = a / h * Math.PI * 2;
                    i.push(Math.cos(m), Math.sin(m), 1, Math.cos(_), Math.sin(_), 1);
                  }
                  n.setAttribute("position", new gn(i, 3));
                  const r = new Hr({ fog: !1, toneMapped: !1 });
                  this.cone = new bs(n, r), this.add(this.cone), this.update();
                }
                dispose() {
                  this.cone.geometry.dispose(), this.cone.material.dispose();
                }
                update() {
                  this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
                  const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
                  this.cone.scale.set(t, t, e), gp.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(gp), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
                }
              }
              const ro = /* @__PURE__ */ new ye(), Sc = /* @__PURE__ */ new pn(), Rh = /* @__PURE__ */ new pn();
              class NE extends bs {
                constructor(e) {
                  const t = vp(e), n = new ti(), i = [], r = [], o = new sn(0, 0, 1), a = new sn(0, 1, 0);
                  for (let m = 0; m < t.length; m++) {
                    const _ = t[m];
                    _.parent && _.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b));
                  }
                  n.setAttribute("position", new gn(i, 3)), n.setAttribute("color", new gn(r, 3));
                  const h = new Hr({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
                  super(n, h), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
                }
                updateMatrixWorld(e) {
                  const t = this.bones, n = this.geometry, i = n.getAttribute("position");
                  Rh.copy(this.root.matrixWorld).invert();
                  for (let r = 0, o = 0; r < t.length; r++) {
                    const a = t[r];
                    a.parent && a.parent.isBone && (Sc.multiplyMatrices(Rh, a.matrixWorld), ro.setFromMatrixPosition(Sc), i.setXYZ(o, ro.x, ro.y, ro.z), Sc.multiplyMatrices(Rh, a.parent.matrixWorld), ro.setFromMatrixPosition(Sc), i.setXYZ(o + 1, ro.x, ro.y, ro.z), o += 2);
                  }
                  n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
              }
              function vp(s) {
                const e = [];
                s.isBone === !0 && e.push(s);
                for (let t = 0; t < s.children.length; t++)
                  e.push.apply(e, vp(s.children[t]));
                return e;
              }
              class kE extends hr {
                constructor(e, t, n) {
                  const i = new Wa(t, 4, 2), r = new qs({ wireframe: !0, fog: !1, toneMapped: !1 });
                  super(i, r), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
                update() {
                  this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
                }
              }
              const GE = /* @__PURE__ */ new ye(), Ep = /* @__PURE__ */ new sn(), yp = /* @__PURE__ */ new sn();
              class QE extends bi {
                constructor(e, t, n) {
                  super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
                  const i = new ja(t);
                  i.rotateY(Math.PI * 0.5), this.material = new qs({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
                  const r = i.getAttribute("position"), o = new Float32Array(r.count * 3);
                  i.setAttribute("color", new Pi(o, 3)), this.add(new hr(i, this.material)), this.update();
                }
                dispose() {
                  this.children[0].geometry.dispose(), this.children[0].material.dispose();
                }
                update() {
                  const e = this.children[0];
                  if (this.color !== void 0)
                    this.material.color.set(this.color);
                  else {
                    const t = e.geometry.getAttribute("color");
                    Ep.copy(this.light.color), yp.copy(this.light.groundColor);
                    for (let n = 0, i = t.count; n < i; n++) {
                      const r = n < i / 2 ? Ep : yp;
                      t.setXYZ(n, r.r, r.g, r.b);
                    }
                    t.needsUpdate = !0;
                  }
                  this.light.updateWorldMatrix(!0, !1), e.lookAt(GE.setFromMatrixPosition(this.light.matrixWorld).negate());
                }
              }
              class VE extends bs {
                constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
                  n = new sn(n), i = new sn(i);
                  const r = t / 2, o = e / t, a = e / 2, h = [], m = [];
                  for (let B = 0, L = 0, N = -a; B <= t; B++, N += o) {
                    h.push(-a, 0, N, a, 0, N), h.push(N, 0, -a, N, 0, a);
                    const z = B === r ? n : i;
                    z.toArray(m, L), L += 3, z.toArray(m, L), L += 3, z.toArray(m, L), L += 3, z.toArray(m, L), L += 3;
                  }
                  const _ = new ti();
                  _.setAttribute("position", new gn(h, 3)), _.setAttribute("color", new gn(m, 3));
                  const I = new Hr({ vertexColors: !0, toneMapped: !1 });
                  super(_, I), this.type = "GridHelper";
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
              }
              class HE extends bs {
                constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, o = 8947848) {
                  r = new sn(r), o = new sn(o);
                  const a = [], h = [];
                  if (t > 1)
                    for (let I = 0; I < t; I++) {
                      const B = I / t * (Math.PI * 2), L = Math.sin(B) * e, N = Math.cos(B) * e;
                      a.push(0, 0, 0), a.push(L, 0, N);
                      const z = I & 1 ? r : o;
                      h.push(z.r, z.g, z.b), h.push(z.r, z.g, z.b);
                    }
                  for (let I = 0; I < n; I++) {
                    const B = I & 1 ? r : o, L = e - e / n * I;
                    for (let N = 0; N < i; N++) {
                      let z = N / i * (Math.PI * 2), k = Math.sin(z) * L, P = Math.cos(z) * L;
                      a.push(k, 0, P), h.push(B.r, B.g, B.b), z = (N + 1) / i * (Math.PI * 2), k = Math.sin(z) * L, P = Math.cos(z) * L, a.push(k, 0, P), h.push(B.r, B.g, B.b);
                    }
                  }
                  const m = new ti();
                  m.setAttribute("position", new gn(a, 3)), m.setAttribute("color", new gn(h, 3));
                  const _ = new Hr({ vertexColors: !0, toneMapped: !1 });
                  super(m, _), this.type = "PolarGridHelper";
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
              }
              const Cp = /* @__PURE__ */ new ye(), Tc = /* @__PURE__ */ new ye(), xp = /* @__PURE__ */ new ye();
              class zE extends bi {
                constructor(e, t, n) {
                  super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
                  let i = new ti();
                  i.setAttribute("position", new gn([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                  const r = new Hr({ fog: !1, toneMapped: !1 });
                  this.lightPlane = new to(i, r), this.add(this.lightPlane), i = new ti(), i.setAttribute("position", new gn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new to(i, r), this.add(this.targetLine), this.update();
                }
                dispose() {
                  this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
                }
                update() {
                  this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Cp.setFromMatrixPosition(this.light.matrixWorld), Tc.setFromMatrixPosition(this.light.target.matrixWorld), xp.subVectors(Tc, Cp), this.lightPlane.lookAt(Tc), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Tc), this.targetLine.scale.z = xp.length();
                }
              }
              const Ic = /* @__PURE__ */ new ye(), nr = /* @__PURE__ */ new Rl();
              class jE extends bs {
                constructor(e) {
                  const t = new ti(), n = new Hr({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], o = {};
                  a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
                  function a(N, z) {
                    h(N), h(z);
                  }
                  function h(N) {
                    i.push(0, 0, 0), r.push(0, 0, 0), o[N] === void 0 && (o[N] = []), o[N].push(i.length / 3 - 1);
                  }
                  t.setAttribute("position", new gn(i, 3)), t.setAttribute("color", new gn(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
                  const m = new sn(16755200), _ = new sn(16711680), I = new sn(43775), B = new sn(16777215), L = new sn(3355443);
                  this.setColors(m, _, I, B, L);
                }
                setColors(e, t, n, i, r) {
                  const a = this.geometry.getAttribute("color");
                  a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, r.r, r.g, r.b), a.setXYZ(41, r.r, r.g, r.b), a.setXYZ(42, r.r, r.g, r.b), a.setXYZ(43, r.r, r.g, r.b), a.setXYZ(44, r.r, r.g, r.b), a.setXYZ(45, r.r, r.g, r.b), a.setXYZ(46, r.r, r.g, r.b), a.setXYZ(47, r.r, r.g, r.b), a.setXYZ(48, r.r, r.g, r.b), a.setXYZ(49, r.r, r.g, r.b), a.needsUpdate = !0;
                }
                update() {
                  const e = this.geometry, t = this.pointMap, n = 1, i = 1;
                  nr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), lr("c", t, e, nr, 0, 0, -1), lr("t", t, e, nr, 0, 0, 1), lr("n1", t, e, nr, -n, -i, -1), lr("n2", t, e, nr, n, -i, -1), lr("n3", t, e, nr, -n, i, -1), lr("n4", t, e, nr, n, i, -1), lr("f1", t, e, nr, -n, -i, 1), lr("f2", t, e, nr, n, -i, 1), lr("f3", t, e, nr, -n, i, 1), lr("f4", t, e, nr, n, i, 1), lr("u1", t, e, nr, n * 0.7, i * 1.1, -1), lr("u2", t, e, nr, -n * 0.7, i * 1.1, -1), lr("u3", t, e, nr, 0, i * 2, -1), lr("cf1", t, e, nr, -n, 0, 1), lr("cf2", t, e, nr, n, 0, 1), lr("cf3", t, e, nr, 0, -i, 1), lr("cf4", t, e, nr, 0, i, 1), lr("cn1", t, e, nr, -n, 0, -1), lr("cn2", t, e, nr, n, 0, -1), lr("cn3", t, e, nr, 0, -i, -1), lr("cn4", t, e, nr, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
              }
              function lr(s, e, t, n, i, r, o) {
                Ic.set(i, r, o).unproject(n);
                const a = e[s];
                if (a !== void 0) {
                  const h = t.getAttribute("position");
                  for (let m = 0, _ = a.length; m < _; m++)
                    h.setXYZ(a[m], Ic.x, Ic.y, Ic.z);
                }
              }
              const Bc = /* @__PURE__ */ new Zi();
              class WE extends bs {
                constructor(e, t = 16776960) {
                  const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), r = new ti();
                  r.setIndex(new Pi(n, 1)), r.setAttribute("position", new Pi(i, 3)), super(r, new Hr({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
                }
                update(e) {
                  if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Bc.setFromObject(this.object), Bc.isEmpty()) return;
                  const t = Bc.min, n = Bc.max, i = this.geometry.attributes.position, r = i.array;
                  r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
                }
                setFromObject(e) {
                  return this.object = e, this.update(), this;
                }
                copy(e, t) {
                  return super.copy(e, t), this.object = e.object, this;
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
              }
              class KE extends bs {
                constructor(e, t = 16776960) {
                  const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new ti();
                  r.setIndex(new Pi(n, 1)), r.setAttribute("position", new gn(i, 3)), super(r, new Hr({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
                }
                updateMatrixWorld(e) {
                  const t = this.box;
                  t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
              }
              class XE extends to {
                constructor(e, t = 1, n = 16776960) {
                  const i = n, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new ti();
                  o.setAttribute("position", new gn(r, 3)), o.computeBoundingSphere(), super(o, new Hr({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
                  const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], h = new ti();
                  h.setAttribute("position", new gn(a, 3)), h.computeBoundingSphere(), this.add(new hr(h, new qs({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
                }
                updateMatrixWorld(e) {
                  this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
                }
              }
              const bp = /* @__PURE__ */ new ye();
              let Rc, Lh;
              class YE extends bi {
                // dir is assumed to be normalized
                constructor(e = new ye(0, 0, 1), t = new ye(0, 0, 0), n = 1, i = 16776960, r = n * 0.2, o = r * 0.2) {
                  super(), this.type = "ArrowHelper", Rc === void 0 && (Rc = new ti(), Rc.setAttribute("position", new gn([0, 0, 0, 0, 1, 0], 3)), Lh = new pa(0, 0.5, 1, 5, 1), Lh.translate(0, -0.5, 0)), this.position.copy(t), this.line = new to(Rc, new Hr({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new hr(Lh, new qs({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, o);
                }
                setDirection(e) {
                  if (e.y > 0.99999)
                    this.quaternion.set(0, 0, 0, 1);
                  else if (e.y < -0.99999)
                    this.quaternion.set(1, 0, 0, 0);
                  else {
                    bp.set(e.z, 0, -e.x).normalize();
                    const t = Math.acos(e.y);
                    this.quaternion.setFromAxisAngle(bp, t);
                  }
                }
                setLength(e, t = e * 0.2, n = t * 0.2) {
                  this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
                }
                setColor(e) {
                  this.line.material.color.set(e), this.cone.material.color.set(e);
                }
                copy(e) {
                  return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
                }
                dispose() {
                  this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
                }
              }
              class qE extends bs {
                constructor(e = 1) {
                  const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], i = new ti();
                  i.setAttribute("position", new gn(t, 3)), i.setAttribute("color", new gn(n, 3));
                  const r = new Hr({ vertexColors: !0, toneMapped: !1 });
                  super(i, r), this.type = "AxesHelper";
                }
                setColors(e, t, n) {
                  const i = new sn(), r = this.geometry.attributes.color.array;
                  return i.set(e), i.toArray(r, 0), i.toArray(r, 3), i.set(t), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
                }
                dispose() {
                  this.geometry.dispose(), this.material.dispose();
                }
              }
              class JE {
                constructor() {
                  this.type = "ShapePath", this.color = new sn(), this.subPaths = [], this.currentPath = null;
                }
                moveTo(e, t) {
                  return this.currentPath = new Ga(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
                }
                lineTo(e, t) {
                  return this.currentPath.lineTo(e, t), this;
                }
                quadraticCurveTo(e, t, n, i) {
                  return this.currentPath.quadraticCurveTo(e, t, n, i), this;
                }
                bezierCurveTo(e, t, n, i, r, o) {
                  return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
                }
                splineThru(e) {
                  return this.currentPath.splineThru(e), this;
                }
                toShapes(e) {
                  function t(P) {
                    const se = [];
                    for (let $ = 0, J = P.length; $ < J; $++) {
                      const Le = P[$], Ee = new Mo();
                      Ee.curves = Le.curves, se.push(Ee);
                    }
                    return se;
                  }
                  function n(P, se) {
                    const $ = se.length;
                    let J = !1;
                    for (let Le = $ - 1, Ee = 0; Ee < $; Le = Ee++) {
                      let Me = se[Le], Re = se[Ee], Ae = Re.x - Me.x, ce = Re.y - Me.y;
                      if (Math.abs(ce) > Number.EPSILON) {
                        if (ce < 0 && (Me = se[Ee], Ae = -Ae, Re = se[Le], ce = -ce), P.y < Me.y || P.y > Re.y) continue;
                        if (P.y === Me.y) {
                          if (P.x === Me.x) return !0;
                        } else {
                          const Ie = ce * (P.x - Me.x) - Ae * (P.y - Me.y);
                          if (Ie === 0) return !0;
                          if (Ie < 0) continue;
                          J = !J;
                        }
                      } else {
                        if (P.y !== Me.y) continue;
                        if (Re.x <= P.x && P.x <= Me.x || Me.x <= P.x && P.x <= Re.x) return !0;
                      }
                    }
                    return J;
                  }
                  const i = _s.isClockWise, r = this.subPaths;
                  if (r.length === 0) return [];
                  let o, a, h;
                  const m = [];
                  if (r.length === 1)
                    return a = r[0], h = new Mo(), h.curves = a.curves, m.push(h), m;
                  let _ = !i(r[0].getPoints());
                  _ = e ? !_ : _;
                  const I = [], B = [];
                  let L = [], N = 0, z;
                  B[N] = void 0, L[N] = [];
                  for (let P = 0, se = r.length; P < se; P++)
                    a = r[P], z = a.getPoints(), o = i(z), o = e ? !o : o, o ? (!_ && B[N] && N++, B[N] = { s: new Mo(), p: z }, B[N].s.curves = a.curves, _ && N++, L[N] = []) : L[N].push({ h: a, p: z[0] });
                  if (!B[0]) return t(r);
                  if (B.length > 1) {
                    let P = !1, se = 0;
                    for (let $ = 0, J = B.length; $ < J; $++)
                      I[$] = [];
                    for (let $ = 0, J = B.length; $ < J; $++) {
                      const Le = L[$];
                      for (let Ee = 0; Ee < Le.length; Ee++) {
                        const Me = Le[Ee];
                        let Re = !0;
                        for (let Ae = 0; Ae < B.length; Ae++)
                          n(Me.p, B[Ae].p) && ($ !== Ae && se++, Re ? (Re = !1, I[Ae].push(Me)) : P = !0);
                        Re && I[$].push(Me);
                      }
                    }
                    se > 0 && P === !1 && (L = I);
                  }
                  let k;
                  for (let P = 0, se = B.length; P < se; P++) {
                    h = B[P].s, m.push(h), k = L[P];
                    for (let $ = 0, J = k.length; $ < J; $++)
                      h.holes.push(k[$].h);
                  }
                  return m;
                }
              }
              class ZE extends zr {
                // @deprecated, r162
                constructor(e = 1, t = 1, n = 1, i = {}) {
                  console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...i, count: n }), this.isWebGLMultipleRenderTargets = !0;
                }
                get texture() {
                  return this.textures;
                }
              }
              typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: C } })), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = C);
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/libs/ktx-parse.module.js": (
            /*!******************************************************************!*\
              !*** ./node_modules/three/examples/jsm/libs/ktx-parse.module.js ***!
              \******************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                KHR_DF_CHANNEL_RGBSDA_ALPHA: () => (
                  /* binding */
                  ei
                ),
                /* harmony export */
                KHR_DF_CHANNEL_RGBSDA_BLUE: () => (
                  /* binding */
                  Et
                ),
                /* harmony export */
                KHR_DF_CHANNEL_RGBSDA_DEPTH: () => (
                  /* binding */
                  $t
                ),
                /* harmony export */
                KHR_DF_CHANNEL_RGBSDA_GREEN: () => (
                  /* binding */
                  Be
                ),
                /* harmony export */
                KHR_DF_CHANNEL_RGBSDA_RED: () => (
                  /* binding */
                  Ni
                ),
                /* harmony export */
                KHR_DF_CHANNEL_RGBSDA_STENCIL: () => (
                  /* binding */
                  Dt
                ),
                /* harmony export */
                KHR_DF_FLAG_ALPHA_PREMULTIPLIED: () => (
                  /* binding */
                  D
                ),
                /* harmony export */
                KHR_DF_FLAG_ALPHA_STRAIGHT: () => (
                  /* binding */
                  b
                ),
                /* harmony export */
                KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT: () => (
                  /* binding */
                  d
                ),
                /* harmony export */
                KHR_DF_MODEL_ASTC: () => (
                  /* binding */
                  x
                ),
                /* harmony export */
                KHR_DF_MODEL_ETC1: () => (
                  /* binding */
                  u
                ),
                /* harmony export */
                KHR_DF_MODEL_ETC1S: () => (
                  /* binding */
                  T
                ),
                /* harmony export */
                KHR_DF_MODEL_ETC2: () => (
                  /* binding */
                  f
                ),
                /* harmony export */
                KHR_DF_MODEL_RGBSDA: () => (
                  /* binding */
                  A
                ),
                /* harmony export */
                KHR_DF_MODEL_UNSPECIFIED: () => (
                  /* binding */
                  g
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_ACES: () => (
                  /* binding */
                  Tn
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_ACESCC: () => (
                  /* binding */
                  wn
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_ADOBERGB: () => (
                  /* binding */
                  ri
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_BT2020: () => (
                  /* binding */
                  cn
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_BT601_EBU: () => (
                  /* binding */
                  Rt
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_BT601_SMPTE: () => (
                  /* binding */
                  Qt
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_BT709: () => (
                  /* binding */
                  ht
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_CIEXYZ: () => (
                  /* binding */
                  Cn
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_DISPLAYP3: () => (
                  /* binding */
                  di
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_NTSC1953: () => (
                  /* binding */
                  rn
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_PAL525: () => (
                  /* binding */
                  Bn
                ),
                /* harmony export */
                KHR_DF_PRIMARIES_UNSPECIFIED: () => (
                  /* binding */
                  It
                ),
                /* harmony export */
                KHR_DF_SAMPLE_DATATYPE_EXPONENT: () => (
                  /* binding */
                  Xe
                ),
                /* harmony export */
                KHR_DF_SAMPLE_DATATYPE_FLOAT: () => (
                  /* binding */
                  Dn
                ),
                /* harmony export */
                KHR_DF_SAMPLE_DATATYPE_LINEAR: () => (
                  /* binding */
                  le
                ),
                /* harmony export */
                KHR_DF_SAMPLE_DATATYPE_SIGNED: () => (
                  /* binding */
                  Yt
                ),
                /* harmony export */
                KHR_DF_TRANSFER_ACESCC: () => (
                  /* binding */
                  Ve
                ),
                /* harmony export */
                KHR_DF_TRANSFER_ACESCCT: () => (
                  /* binding */
                  st
                ),
                /* harmony export */
                KHR_DF_TRANSFER_ADOBERGB: () => (
                  /* binding */
                  ut
                ),
                /* harmony export */
                KHR_DF_TRANSFER_BT1886: () => (
                  /* binding */
                  X
                ),
                /* harmony export */
                KHR_DF_TRANSFER_DCIP3: () => (
                  /* binding */
                  pe
                ),
                /* harmony export */
                KHR_DF_TRANSFER_HLG_EOTF: () => (
                  /* binding */
                  O
                ),
                /* harmony export */
                KHR_DF_TRANSFER_HLG_OETF: () => (
                  /* binding */
                  Q
                ),
                /* harmony export */
                KHR_DF_TRANSFER_ITU: () => (
                  /* binding */
                  Z
                ),
                /* harmony export */
                KHR_DF_TRANSFER_LINEAR: () => (
                  /* binding */
                  U
                ),
                /* harmony export */
                KHR_DF_TRANSFER_NTSC: () => (
                  /* binding */
                  W
                ),
                /* harmony export */
                KHR_DF_TRANSFER_PAL625_EOTF: () => (
                  /* binding */
                  Te
                ),
                /* harmony export */
                KHR_DF_TRANSFER_PAL_OETF: () => (
                  /* binding */
                  be
                ),
                /* harmony export */
                KHR_DF_TRANSFER_PQ_EOTF: () => (
                  /* binding */
                  K
                ),
                /* harmony export */
                KHR_DF_TRANSFER_PQ_OETF: () => (
                  /* binding */
                  ne
                ),
                /* harmony export */
                KHR_DF_TRANSFER_SLOG: () => (
                  /* binding */
                  ie
                ),
                /* harmony export */
                KHR_DF_TRANSFER_SLOG2: () => (
                  /* binding */
                  te
                ),
                /* harmony export */
                KHR_DF_TRANSFER_SRGB: () => (
                  /* binding */
                  G
                ),
                /* harmony export */
                KHR_DF_TRANSFER_ST240: () => (
                  /* binding */
                  ke
                ),
                /* harmony export */
                KHR_DF_TRANSFER_UNSPECIFIED: () => (
                  /* binding */
                  S
                ),
                /* harmony export */
                KHR_DF_VENDORID_KHRONOS: () => (
                  /* binding */
                  p
                ),
                /* harmony export */
                KHR_DF_VERSION: () => (
                  /* binding */
                  c
                ),
                /* harmony export */
                KHR_SUPERCOMPRESSION_BASISLZ: () => (
                  /* binding */
                  E
                ),
                /* harmony export */
                KHR_SUPERCOMPRESSION_NONE: () => (
                  /* binding */
                  w
                ),
                /* harmony export */
                KHR_SUPERCOMPRESSION_ZLIB: () => (
                  /* binding */
                  l
                ),
                /* harmony export */
                KHR_SUPERCOMPRESSION_ZSTD: () => (
                  /* binding */
                  y
                ),
                /* harmony export */
                KTX2Container: () => (
                  /* binding */
                  Rs
                ),
                /* harmony export */
                VK_FORMAT_A1R5G5B5_UNORM_PACK16: () => (
                  /* binding */
                  ee
                ),
                /* harmony export */
                VK_FORMAT_A2B10G10R10_SINT_PACK32: () => (
                  /* binding */
                  mn
                ),
                /* harmony export */
                VK_FORMAT_A2B10G10R10_SNORM_PACK32: () => (
                  /* binding */
                  jt
                ),
                /* harmony export */
                VK_FORMAT_A2B10G10R10_UINT_PACK32: () => (
                  /* binding */
                  at
                ),
                /* harmony export */
                VK_FORMAT_A2B10G10R10_UNORM_PACK32: () => (
                  /* binding */
                  ln
                ),
                /* harmony export */
                VK_FORMAT_A2R10G10B10_SINT_PACK32: () => (
                  /* binding */
                  bt
                ),
                /* harmony export */
                VK_FORMAT_A2R10G10B10_SNORM_PACK32: () => (
                  /* binding */
                  Ke
                ),
                /* harmony export */
                VK_FORMAT_A2R10G10B10_UINT_PACK32: () => (
                  /* binding */
                  rt
                ),
                /* harmony export */
                VK_FORMAT_A2R10G10B10_UNORM_PACK32: () => (
                  /* binding */
                  Ye
                ),
                /* harmony export */
                VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: () => (
                  /* binding */
                  xa
                ),
                /* harmony export */
                VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: () => (
                  /* binding */
                  js
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  No
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x10_SRGB_BLOCK: () => (
                  /* binding */
                  Yi
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x10_UNORM_BLOCK: () => (
                  /* binding */
                  kr
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  fl
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x5_SRGB_BLOCK: () => (
                  /* binding */
                  Nr
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x5_UNORM_BLOCK: () => (
                  /* binding */
                  fo
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  pl
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x6_SRGB_BLOCK: () => (
                  /* binding */
                  cl
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x6_UNORM_BLOCK: () => (
                  /* binding */
                  br
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  Al
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x8_SRGB_BLOCK: () => (
                  /* binding */
                  Hs
                ),
                /* harmony export */
                VK_FORMAT_ASTC_10x8_UNORM_BLOCK: () => (
                  /* binding */
                  Bs
                ),
                /* harmony export */
                VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  Cu
                ),
                /* harmony export */
                VK_FORMAT_ASTC_12x10_SRGB_BLOCK: () => (
                  /* binding */
                  iu
                ),
                /* harmony export */
                VK_FORMAT_ASTC_12x10_UNORM_BLOCK: () => (
                  /* binding */
                  ya
                ),
                /* harmony export */
                VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  Mi
                ),
                /* harmony export */
                VK_FORMAT_ASTC_12x12_SRGB_BLOCK: () => (
                  /* binding */
                  po
                ),
                /* harmony export */
                VK_FORMAT_ASTC_12x12_UNORM_BLOCK: () => (
                  /* binding */
                  ru
                ),
                /* harmony export */
                VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  Gn
                ),
                /* harmony export */
                VK_FORMAT_ASTC_4x4_SRGB_BLOCK: () => (
                  /* binding */
                  ol
                ),
                /* harmony export */
                VK_FORMAT_ASTC_4x4_UNORM_BLOCK: () => (
                  /* binding */
                  sl
                ),
                /* harmony export */
                VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  Ca
                ),
                /* harmony export */
                VK_FORMAT_ASTC_5x4_SRGB_BLOCK: () => (
                  /* binding */
                  ll
                ),
                /* harmony export */
                VK_FORMAT_ASTC_5x4_UNORM_BLOCK: () => (
                  /* binding */
                  al
                ),
                /* harmony export */
                VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  ul
                ),
                /* harmony export */
                VK_FORMAT_ASTC_5x5_SRGB_BLOCK: () => (
                  /* binding */
                  Xc
                ),
                /* harmony export */
                VK_FORMAT_ASTC_5x5_UNORM_BLOCK: () => (
                  /* binding */
                  ho
                ),
                /* harmony export */
                VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  yu
                ),
                /* harmony export */
                VK_FORMAT_ASTC_6x5_SRGB_BLOCK: () => (
                  /* binding */
                  qc
                ),
                /* harmony export */
                VK_FORMAT_ASTC_6x5_UNORM_BLOCK: () => (
                  /* binding */
                  Yc
                ),
                /* harmony export */
                VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  zs
                ),
                /* harmony export */
                VK_FORMAT_ASTC_6x6_SRGB_BLOCK: () => (
                  /* binding */
                  Zc
                ),
                /* harmony export */
                VK_FORMAT_ASTC_6x6_UNORM_BLOCK: () => (
                  /* binding */
                  Jc
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  Ao
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x5_SRGB_BLOCK: () => (
                  /* binding */
                  eu
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x5_UNORM_BLOCK: () => (
                  /* binding */
                  $c
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  hl
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x6_SRGB_BLOCK: () => (
                  /* binding */
                  nu
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x6_UNORM_BLOCK: () => (
                  /* binding */
                  tu
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: () => (
                  /* binding */
                  dl
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x8_SRGB_BLOCK: () => (
                  /* binding */
                  ss
                ),
                /* harmony export */
                VK_FORMAT_ASTC_8x8_UNORM_BLOCK: () => (
                  /* binding */
                  Ea
                ),
                /* harmony export */
                VK_FORMAT_B10G11R11_UFLOAT_PACK32: () => (
                  /* binding */
                  Ss
                ),
                /* harmony export */
                VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: () => (
                  /* binding */
                  cu
                ),
                /* harmony export */
                VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: () => (
                  /* binding */
                  pu
                ),
                /* harmony export */
                VK_FORMAT_B4G4R4A4_UNORM_PACK16: () => (
                  /* binding */
                  ge
                ),
                /* harmony export */
                VK_FORMAT_B5G5R5A1_UNORM_PACK16: () => (
                  /* binding */
                  R
                ),
                /* harmony export */
                VK_FORMAT_B5G6R5_UNORM_PACK16: () => (
                  /* binding */
                  H
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8A8_SINT: () => (
                  /* binding */
                  _e
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8A8_SNORM: () => (
                  /* binding */
                  jn
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8A8_SRGB: () => (
                  /* binding */
                  Ne
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8A8_UINT: () => (
                  /* binding */
                  de
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8A8_UNORM: () => (
                  /* binding */
                  ai
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8_SINT: () => (
                  /* binding */
                  Y
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8_SNORM: () => (
                  /* binding */
                  ji
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8_SRGB: () => (
                  /* binding */
                  Fe
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8_UINT: () => (
                  /* binding */
                  Cr
                ),
                /* harmony export */
                VK_FORMAT_B8G8R8_UNORM: () => (
                  /* binding */
                  Sr
                ),
                /* harmony export */
                VK_FORMAT_BC1_RGBA_SRGB_BLOCK: () => (
                  /* binding */
                  Fi
                ),
                /* harmony export */
                VK_FORMAT_BC1_RGBA_UNORM_BLOCK: () => (
                  /* binding */
                  lo
                ),
                /* harmony export */
                VK_FORMAT_BC1_RGB_SRGB_BLOCK: () => (
                  /* binding */
                  ao
                ),
                /* harmony export */
                VK_FORMAT_BC1_RGB_UNORM_BLOCK: () => (
                  /* binding */
                  Uo
                ),
                /* harmony export */
                VK_FORMAT_BC2_SRGB_BLOCK: () => (
                  /* binding */
                  uo
                ),
                /* harmony export */
                VK_FORMAT_BC2_UNORM_BLOCK: () => (
                  /* binding */
                  co
                ),
                /* harmony export */
                VK_FORMAT_BC3_SRGB_BLOCK: () => (
                  /* binding */
                  Is
                ),
                /* harmony export */
                VK_FORMAT_BC3_UNORM_BLOCK: () => (
                  /* binding */
                  Pc
                ),
                /* harmony export */
                VK_FORMAT_BC4_SNORM_BLOCK: () => (
                  /* binding */
                  Fc
                ),
                /* harmony export */
                VK_FORMAT_BC4_UNORM_BLOCK: () => (
                  /* binding */
                  Oc
                ),
                /* harmony export */
                VK_FORMAT_BC5_SNORM_BLOCK: () => (
                  /* binding */
                  Nc
                ),
                /* harmony export */
                VK_FORMAT_BC5_UNORM_BLOCK: () => (
                  /* binding */
                  Uc
                ),
                /* harmony export */
                VK_FORMAT_BC6H_SFLOAT_BLOCK: () => (
                  /* binding */
                  Gc
                ),
                /* harmony export */
                VK_FORMAT_BC6H_UFLOAT_BLOCK: () => (
                  /* binding */
                  kc
                ),
                /* harmony export */
                VK_FORMAT_BC7_SRGB_BLOCK: () => (
                  /* binding */
                  Vc
                ),
                /* harmony export */
                VK_FORMAT_BC7_UNORM_BLOCK: () => (
                  /* binding */
                  Qc
                ),
                /* harmony export */
                VK_FORMAT_D16_UNORM: () => (
                  /* binding */
                  vs
                ),
                /* harmony export */
                VK_FORMAT_D16_UNORM_S8_UINT: () => (
                  /* binding */
                  Tr
                ),
                /* harmony export */
                VK_FORMAT_D24_UNORM_S8_UINT: () => (
                  /* binding */
                  mi
                ),
                /* harmony export */
                VK_FORMAT_D32_SFLOAT: () => (
                  /* binding */
                  Rr
                ),
                /* harmony export */
                VK_FORMAT_D32_SFLOAT_S8_UINT: () => (
                  /* binding */
                  hs
                ),
                /* harmony export */
                VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: () => (
                  /* binding */
                  Ts
                ),
                /* harmony export */
                VK_FORMAT_EAC_R11G11_SNORM_BLOCK: () => (
                  /* binding */
                  va
                ),
                /* harmony export */
                VK_FORMAT_EAC_R11G11_UNORM_BLOCK: () => (
                  /* binding */
                  rl
                ),
                /* harmony export */
                VK_FORMAT_EAC_R11_SNORM_BLOCK: () => (
                  /* binding */
                  il
                ),
                /* harmony export */
                VK_FORMAT_EAC_R11_UNORM_BLOCK: () => (
                  /* binding */
                  nl
                ),
                /* harmony export */
                VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: () => (
                  /* binding */
                  Wc
                ),
                /* harmony export */
                VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: () => (
                  /* binding */
                  jc
                ),
                /* harmony export */
                VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: () => (
                  /* binding */
                  ga
                ),
                /* harmony export */
                VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: () => (
                  /* binding */
                  Kc
                ),
                /* harmony export */
                VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: () => (
                  /* binding */
                  zc
                ),
                /* harmony export */
                VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: () => (
                  /* binding */
                  Hc
                ),
                /* harmony export */
                VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: () => (
                  /* binding */
                  lu
                ),
                /* harmony export */
                VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: () => (
                  /* binding */
                  fu
                ),
                /* harmony export */
                VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: () => (
                  /* binding */
                  Ir
                ),
                /* harmony export */
                VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: () => (
                  /* binding */
                  Au
                ),
                /* harmony export */
                VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: () => (
                  /* binding */
                  Hn
                ),
                /* harmony export */
                VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: () => (
                  /* binding */
                  mu
                ),
                /* harmony export */
                VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: () => (
                  /* binding */
                  Eu
                ),
                /* harmony export */
                VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: () => (
                  /* binding */
                  gu
                ),
                /* harmony export */
                VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: () => (
                  /* binding */
                  pt
                ),
                /* harmony export */
                VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: () => (
                  /* binding */
                  vu
                ),
                /* harmony export */
                VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: () => (
                  /* binding */
                  au
                ),
                /* harmony export */
                VK_FORMAT_R10X6G10X6_UNORM_2PACK16: () => (
                  /* binding */
                  ou
                ),
                /* harmony export */
                VK_FORMAT_R10X6_UNORM_PACK16: () => (
                  /* binding */
                  su
                ),
                /* harmony export */
                VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: () => (
                  /* binding */
                  du
                ),
                /* harmony export */
                VK_FORMAT_R12X4G12X4_UNORM_2PACK16: () => (
                  /* binding */
                  hu
                ),
                /* harmony export */
                VK_FORMAT_R12X4_UNORM_PACK16: () => (
                  /* binding */
                  uu
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16A16_SFLOAT: () => (
                  /* binding */
                  ft
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16A16_SINT: () => (
                  /* binding */
                  Ge
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16A16_SNORM: () => (
                  /* binding */
                  me
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16A16_UINT: () => (
                  /* binding */
                  De
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16A16_UNORM: () => (
                  /* binding */
                  oe
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16_SFLOAT: () => (
                  /* binding */
                  q
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16_SINT: () => (
                  /* binding */
                  V
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16_SNORM: () => (
                  /* binding */
                  fi
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16_UINT: () => (
                  /* binding */
                  F
                ),
                /* harmony export */
                VK_FORMAT_R16G16B16_UNORM: () => (
                  /* binding */
                  qi
                ),
                /* harmony export */
                VK_FORMAT_R16G16_SFLOAT: () => (
                  /* binding */
                  Kn
                ),
                /* harmony export */
                VK_FORMAT_R16G16_SINT: () => (
                  /* binding */
                  Wt
                ),
                /* harmony export */
                VK_FORMAT_R16G16_SNORM: () => (
                  /* binding */
                  Gi
                ),
                /* harmony export */
                VK_FORMAT_R16G16_UINT: () => (
                  /* binding */
                  rr
                ),
                /* harmony export */
                VK_FORMAT_R16G16_UNORM: () => (
                  /* binding */
                  li
                ),
                /* harmony export */
                VK_FORMAT_R16_SFLOAT: () => (
                  /* binding */
                  Nn
                ),
                /* harmony export */
                VK_FORMAT_R16_SINT: () => (
                  /* binding */
                  Wn
                ),
                /* harmony export */
                VK_FORMAT_R16_SNORM: () => (
                  /* binding */
                  Rn
                ),
                /* harmony export */
                VK_FORMAT_R16_UINT: () => (
                  /* binding */
                  Bi
                ),
                /* harmony export */
                VK_FORMAT_R16_UNORM: () => (
                  /* binding */
                  _n
                ),
                /* harmony export */
                VK_FORMAT_R32G32B32A32_SFLOAT: () => (
                  /* binding */
                  Ri
                ),
                /* harmony export */
                VK_FORMAT_R32G32B32A32_SINT: () => (
                  /* binding */
                  Ai
                ),
                /* harmony export */
                VK_FORMAT_R32G32B32A32_UINT: () => (
                  /* binding */
                  In
                ),
                /* harmony export */
                VK_FORMAT_R32G32B32_SFLOAT: () => (
                  /* binding */
                  On
                ),
                /* harmony export */
                VK_FORMAT_R32G32B32_SINT: () => (
                  /* binding */
                  Vn
                ),
                /* harmony export */
                VK_FORMAT_R32G32B32_UINT: () => (
                  /* binding */
                  Mn
                ),
                /* harmony export */
                VK_FORMAT_R32G32_SFLOAT: () => (
                  /* binding */
                  dn
                ),
                /* harmony export */
                VK_FORMAT_R32G32_SINT: () => (
                  /* binding */
                  Jt
                ),
                /* harmony export */
                VK_FORMAT_R32G32_UINT: () => (
                  /* binding */
                  xt
                ),
                /* harmony export */
                VK_FORMAT_R32_SFLOAT: () => (
                  /* binding */
                  nt
                ),
                /* harmony export */
                VK_FORMAT_R32_SINT: () => (
                  /* binding */
                  je
                ),
                /* harmony export */
                VK_FORMAT_R32_UINT: () => (
                  /* binding */
                  ct
                ),
                /* harmony export */
                VK_FORMAT_R4G4B4A4_UNORM_PACK16: () => (
                  /* binding */
                  fe
                ),
                /* harmony export */
                VK_FORMAT_R4G4_UNORM_PACK8: () => (
                  /* binding */
                  Ce
                ),
                /* harmony export */
                VK_FORMAT_R5G5B5A1_UNORM_PACK16: () => (
                  /* binding */
                  M
                ),
                /* harmony export */
                VK_FORMAT_R5G6B5_UNORM_PACK16: () => (
                  /* binding */
                  xe
                ),
                /* harmony export */
                VK_FORMAT_R64G64B64A64_SFLOAT: () => (
                  /* binding */
                  Ms
                ),
                /* harmony export */
                VK_FORMAT_R64G64B64A64_SINT: () => (
                  /* binding */
                  us
                ),
                /* harmony export */
                VK_FORMAT_R64G64B64A64_UINT: () => (
                  /* binding */
                  rs
                ),
                /* harmony export */
                VK_FORMAT_R64G64B64_SFLOAT: () => (
                  /* binding */
                  Yr
                ),
                /* harmony export */
                VK_FORMAT_R64G64B64_SINT: () => (
                  /* binding */
                  xr
                ),
                /* harmony export */
                VK_FORMAT_R64G64B64_UINT: () => (
                  /* binding */
                  Ji
                ),
                /* harmony export */
                VK_FORMAT_R64G64_SFLOAT: () => (
                  /* binding */
                  cr
                ),
                /* harmony export */
                VK_FORMAT_R64G64_SINT: () => (
                  /* binding */
                  ar
                ),
                /* harmony export */
                VK_FORMAT_R64G64_UINT: () => (
                  /* binding */
                  or
                ),
                /* harmony export */
                VK_FORMAT_R64_SFLOAT: () => (
                  /* binding */
                  sr
                ),
                /* harmony export */
                VK_FORMAT_R64_SINT: () => (
                  /* binding */
                  Qi
                ),
                /* harmony export */
                VK_FORMAT_R64_UINT: () => (
                  /* binding */
                  Wi
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8A8_SINT: () => (
                  /* binding */
                  hn
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8A8_SNORM: () => (
                  /* binding */
                  lt
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8A8_SRGB: () => (
                  /* binding */
                  zt
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8A8_UINT: () => (
                  /* binding */
                  Ut
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8A8_UNORM: () => (
                  /* binding */
                  tt
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8_SINT: () => (
                  /* binding */
                  fr
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8_SNORM: () => (
                  /* binding */
                  ui
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8_SRGB: () => (
                  /* binding */
                  Ii
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8_UINT: () => (
                  /* binding */
                  Ei
                ),
                /* harmony export */
                VK_FORMAT_R8G8B8_UNORM: () => (
                  /* binding */
                  Oi
                ),
                /* harmony export */
                VK_FORMAT_R8G8_SINT: () => (
                  /* binding */
                  ki
                ),
                /* harmony export */
                VK_FORMAT_R8G8_SNORM: () => (
                  /* binding */
                  St
                ),
                /* harmony export */
                VK_FORMAT_R8G8_SRGB: () => (
                  /* binding */
                  vn
                ),
                /* harmony export */
                VK_FORMAT_R8G8_UINT: () => (
                  /* binding */
                  qt
                ),
                /* harmony export */
                VK_FORMAT_R8G8_UNORM: () => (
                  /* binding */
                  _t
                ),
                /* harmony export */
                VK_FORMAT_R8_SINT: () => (
                  /* binding */
                  Ct
                ),
                /* harmony export */
                VK_FORMAT_R8_SNORM: () => (
                  /* binding */
                  we
                ),
                /* harmony export */
                VK_FORMAT_R8_SRGB: () => (
                  /* binding */
                  Pt
                ),
                /* harmony export */
                VK_FORMAT_R8_UINT: () => (
                  /* binding */
                  Oe
                ),
                /* harmony export */
                VK_FORMAT_R8_UNORM: () => (
                  /* binding */
                  he
                ),
                /* harmony export */
                VK_FORMAT_S8_UINT: () => (
                  /* binding */
                  ys
                ),
                /* harmony export */
                VK_FORMAT_UNDEFINED: () => (
                  /* binding */
                  ae
                ),
                /* harmony export */
                VK_FORMAT_X8_D24_UNORM_PACK32: () => (
                  /* binding */
                  Es
                ),
                /* harmony export */
                read: () => (
                  /* binding */
                  yi
                ),
                /* harmony export */
                write: () => (
                  /* binding */
                  Qo
                )
                /* harmony export */
              });
              var C = v(
                /*! buffer */
                "./node_modules/buffer/index.js"
              ).Buffer;
              const w = 0, E = 1, y = 2, l = 3, d = 0, p = 0, c = 2, g = 0, A = 1, u = 160, f = 161, x = 162, T = 163, b = 0, D = 1, S = 0, U = 1, G = 2, Z = 3, W = 4, ie = 5, te = 6, X = 7, Q = 8, O = 9, K = 10, ne = 11, pe = 12, be = 13, Te = 14, ke = 15, Ve = 16, st = 17, ut = 18, It = 0, ht = 1, Rt = 2, Qt = 3, cn = 4, Cn = 5, Tn = 6, wn = 7, rn = 8, Bn = 9, di = 10, ri = 11, Ni = 0, Be = 1, Et = 2, Dt = 13, $t = 14, ei = 15, Dn = 128, Yt = 64, Xe = 32, le = 16, ae = 0, Ce = 1, fe = 2, ge = 3, xe = 4, H = 5, M = 6, R = 7, ee = 8, he = 9, we = 10, Oe = 13, Ct = 14, Pt = 15, _t = 16, St = 17, qt = 20, ki = 21, vn = 22, Oi = 23, ui = 24, Ei = 27, fr = 28, Ii = 29, Sr = 30, ji = 31, Cr = 34, Y = 35, Fe = 36, tt = 37, lt = 38, Ut = 41, hn = 42, zt = 43, ai = 44, jn = 45, de = 48, _e = 49, Ne = 50, Ye = 58, Ke = 59, rt = 62, bt = 63, ln = 64, jt = 65, at = 68, mn = 69, _n = 70, Rn = 71, Bi = 74, Wn = 75, Nn = 76, li = 77, Gi = 78, rr = 81, Wt = 82, Kn = 83, qi = 84, fi = 85, F = 88, V = 89, q = 90, oe = 91, me = 92, De = 95, Ge = 96, ft = 97, ct = 98, je = 99, nt = 100, xt = 101, Jt = 102, dn = 103, Mn = 104, Vn = 105, On = 106, In = 107, Ai = 108, Ri = 109, Wi = 110, Qi = 111, sr = 112, or = 113, ar = 114, cr = 115, Ji = 116, xr = 117, Yr = 118, rs = 119, us = 120, Ms = 121, Ss = 122, Ts = 123, vs = 124, Es = 125, Rr = 126, ys = 127, Tr = 128, mi = 129, hs = 130, Uo = 131, ao = 132, lo = 133, Fi = 134, co = 135, uo = 136, Pc = 137, Is = 138, Oc = 139, Fc = 140, Uc = 141, Nc = 142, kc = 143, Gc = 144, Qc = 145, Vc = 146, Hc = 147, zc = 148, jc = 149, Wc = 150, Kc = 151, ga = 152, nl = 153, il = 154, rl = 155, va = 156, sl = 157, ol = 158, al = 159, ll = 160, ho = 161, Xc = 162, Yc = 163, qc = 164, Jc = 165, Zc = 166, $c = 167, eu = 168, tu = 169, nu = 170, Ea = 171, ss = 172, fo = 173, Nr = 174, br = 175, cl = 176, Bs = 177, Hs = 178, kr = 179, Yi = 180, ya = 181, iu = 182, ru = 183, po = 184, su = 1000156007, ou = 1000156008, au = 1000156009, lu = 1000156010, cu = 1000156011, uu = 1000156017, hu = 1000156018, du = 1000156019, fu = 1000156020, pu = 1000156021, Au = 1000054e3, mu = 1000054001, gu = 1000054002, vu = 1000054003, Ir = 1000054004, Hn = 1000054005, Eu = 1000054006, pt = 1000054007, Gn = 1000066e3, Ca = 1000066001, ul = 1000066002, yu = 1000066003, zs = 1000066004, Ao = 1000066005, hl = 1000066006, dl = 1000066007, fl = 1000066008, pl = 1000066009, Al = 1000066010, No = 1000066011, Cu = 1000066012, Mi = 1000066013, js = 100034e4, xa = 1000340001;
              class Rs {
                constructor() {
                  this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                    vendorId: 0,
                    descriptorType: 0,
                    descriptorBlockSize: 0,
                    versionNumber: 2,
                    colorModel: 0,
                    colorPrimaries: 1,
                    transferFunction: 2,
                    flags: 0,
                    texelBlockDimension: [0, 0, 0, 0],
                    bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                    samples: []
                  }], this.keyValue = {}, this.globalData = null;
                }
              }
              class Ws {
                constructor(Qn, pi, xi, ye) {
                  this._dataView = new DataView(Qn.buffer, Qn.byteOffset + pi, xi), this._littleEndian = ye, this._offset = 0;
                }
                _nextUint8() {
                  const Qn = this._dataView.getUint8(this._offset);
                  return this._offset += 1, Qn;
                }
                _nextUint16() {
                  const Qn = this._dataView.getUint16(this._offset, this._littleEndian);
                  return this._offset += 2, Qn;
                }
                _nextUint32() {
                  const Qn = this._dataView.getUint32(this._offset, this._littleEndian);
                  return this._offset += 4, Qn;
                }
                _nextUint64() {
                  const Qn = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                  return this._offset += 8, Qn;
                }
                _nextInt32() {
                  const Qn = this._dataView.getInt32(this._offset, this._littleEndian);
                  return this._offset += 4, Qn;
                }
                _skip(Qn) {
                  return this._offset += Qn, this;
                }
                _scan(Qn, pi = 0) {
                  const xi = this._offset;
                  let ye = 0;
                  for (; this._dataView.getUint8(this._offset) !== pi && ye < Qn; ) ye++, this._offset++;
                  return ye < Qn && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + xi, ye);
                }
              }
              const ml = new Uint8Array([0]), Ki = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
              function ko(un) {
                return typeof TextEncoder < "u" ? new TextEncoder().encode(un) : C.from(un);
              }
              function gl(un) {
                return typeof TextDecoder < "u" ? new TextDecoder().decode(un) : C.from(un).toString("utf8");
              }
              function Vi(un) {
                let Qn = 0;
                for (const ye of un) Qn += ye.byteLength;
                const pi = new Uint8Array(Qn);
                let xi = 0;
                for (const ye of un) pi.set(new Uint8Array(ye), xi), xi += ye.byteLength;
                return pi;
              }
              function yi(un) {
                const Qn = new Uint8Array(un.buffer, un.byteOffset, Ki.length);
                if (Qn[0] !== Ki[0] || Qn[1] !== Ki[1] || Qn[2] !== Ki[2] || Qn[3] !== Ki[3] || Qn[4] !== Ki[4] || Qn[5] !== Ki[5] || Qn[6] !== Ki[6] || Qn[7] !== Ki[7] || Qn[8] !== Ki[8] || Qn[9] !== Ki[9] || Qn[10] !== Ki[10] || Qn[11] !== Ki[11]) throw new Error("Missing KTX 2.0 identifier.");
                const pi = new Rs(), xi = 17 * Uint32Array.BYTES_PER_ELEMENT, ye = new Ws(un, Ki.length, xi, !0);
                pi.vkFormat = ye._nextUint32(), pi.typeSize = ye._nextUint32(), pi.pixelWidth = ye._nextUint32(), pi.pixelHeight = ye._nextUint32(), pi.pixelDepth = ye._nextUint32(), pi.layerCount = ye._nextUint32(), pi.faceCount = ye._nextUint32();
                const qr = ye._nextUint32();
                pi.supercompressionScheme = ye._nextUint32();
                const tr = ye._nextUint32(), Zi = ye._nextUint32(), hi = ye._nextUint32(), Lr = ye._nextUint32(), Cs = ye._nextUint64(), jr = ye._nextUint64(), _r = new Ws(un, Ki.length + xi, 3 * qr * 8, !0);
                for (let Ar = 0; Ar < qr; Ar++) pi.levels.push({
                  levelData: new Uint8Array(un.buffer, un.byteOffset + _r._nextUint64(), _r._nextUint64()),
                  uncompressedByteLength: _r._nextUint64()
                });
                const Yn = new Ws(un, tr, Zi, !0), Br = {
                  vendorId: Yn._skip(4)._nextUint16(),
                  descriptorType: Yn._nextUint16(),
                  versionNumber: Yn._nextUint16(),
                  descriptorBlockSize: Yn._nextUint16(),
                  colorModel: Yn._nextUint8(),
                  colorPrimaries: Yn._nextUint8(),
                  transferFunction: Yn._nextUint8(),
                  flags: Yn._nextUint8(),
                  texelBlockDimension: [Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8()],
                  bytesPlane: [Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8()],
                  samples: []
                }, Jr = (Br.descriptorBlockSize / 4 - 6) / 4;
                for (let Ar = 0; Ar < Jr; Ar++) {
                  const pn = {
                    bitOffset: Yn._nextUint16(),
                    bitLength: Yn._nextUint8(),
                    channelType: Yn._nextUint8(),
                    samplePosition: [Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8(), Yn._nextUint8()],
                    sampleLower: -1 / 0,
                    sampleUpper: 1 / 0
                  };
                  64 & pn.channelType ? (pn.sampleLower = Yn._nextInt32(), pn.sampleUpper = Yn._nextInt32()) : (pn.sampleLower = Yn._nextUint32(), pn.sampleUpper = Yn._nextUint32()), Br.samples[Ar] = pn;
                }
                pi.dataFormatDescriptor.length = 0, pi.dataFormatDescriptor.push(Br);
                const wr = new Ws(un, hi, Lr, !0);
                for (; wr._offset < Lr; ) {
                  const Ar = wr._nextUint32(), pn = wr._scan(Ar), Ds = gl(pn), Wr = wr._scan(Ar - pn.byteLength);
                  pi.keyValue[Ds] = Ds.match(/^ktx/i) ? gl(Wr) : Wr, wr._offset % 4 && wr._skip(4 - wr._offset % 4);
                }
                if (jr <= 0) return pi;
                const gi = new Ws(un, Cs, jr, !0), Di = gi._nextUint16(), qn = gi._nextUint16(), vi = gi._nextUint32(), Gr = gi._nextUint32(), Ks = gi._nextUint32(), Ls = gi._nextUint32(), Vo = [];
                for (let Ar = 0; Ar < qr; Ar++) Vo.push({
                  imageFlags: gi._nextUint32(),
                  rgbSliceByteOffset: gi._nextUint32(),
                  rgbSliceByteLength: gi._nextUint32(),
                  alphaSliceByteOffset: gi._nextUint32(),
                  alphaSliceByteLength: gi._nextUint32()
                });
                const pr = Cs + gi._offset, os = pr + vi, Ho = os + Gr, zo = Ho + Ks, xs = new Uint8Array(un.buffer, un.byteOffset + pr, vi), ba = new Uint8Array(un.buffer, un.byteOffset + os, Gr), jo = new Uint8Array(un.buffer, un.byteOffset + Ho, Ks), _a = new Uint8Array(un.buffer, un.byteOffset + zo, Ls);
                return pi.globalData = {
                  endpointCount: Di,
                  selectorCount: qn,
                  imageDescs: Vo,
                  endpointsData: xs,
                  selectorsData: ba,
                  tablesData: jo,
                  extendedData: _a
                }, pi;
              }
              function Go() {
                return (Go = Object.assign || function(un) {
                  for (var Qn = 1; Qn < arguments.length; Qn++) {
                    var pi = arguments[Qn];
                    for (var xi in pi) Object.prototype.hasOwnProperty.call(pi, xi) && (un[xi] = pi[xi]);
                  }
                  return un;
                }).apply(this, arguments);
              }
              const zr = {
                keepWriter: !1
              };
              function Qo(un, Qn = {}) {
                Qn = Go({}, zr, Qn);
                let pi = new ArrayBuffer(0);
                if (un.globalData) {
                  const Di = new ArrayBuffer(20 + 5 * un.globalData.imageDescs.length * 4), qn = new DataView(Di);
                  qn.setUint16(0, un.globalData.endpointCount, !0), qn.setUint16(2, un.globalData.selectorCount, !0), qn.setUint32(4, un.globalData.endpointsData.byteLength, !0), qn.setUint32(8, un.globalData.selectorsData.byteLength, !0), qn.setUint32(12, un.globalData.tablesData.byteLength, !0), qn.setUint32(16, un.globalData.extendedData.byteLength, !0);
                  for (let vi = 0; vi < un.globalData.imageDescs.length; vi++) {
                    const Gr = un.globalData.imageDescs[vi];
                    qn.setUint32(20 + 5 * vi * 4 + 0, Gr.imageFlags, !0), qn.setUint32(20 + 5 * vi * 4 + 4, Gr.rgbSliceByteOffset, !0), qn.setUint32(20 + 5 * vi * 4 + 8, Gr.rgbSliceByteLength, !0), qn.setUint32(20 + 5 * vi * 4 + 12, Gr.alphaSliceByteOffset, !0), qn.setUint32(20 + 5 * vi * 4 + 16, Gr.alphaSliceByteLength, !0);
                  }
                  pi = Vi([Di, un.globalData.endpointsData, un.globalData.selectorsData, un.globalData.tablesData, un.globalData.extendedData]);
                }
                const xi = [];
                let ye = un.keyValue;
                Qn.keepWriter || (ye = Go({}, un.keyValue, {
                  KTXwriter: "KTX-Parse v0.3.1"
                }));
                for (const Di in ye) {
                  const qn = ye[Di], vi = ko(Di), Gr = typeof qn == "string" ? ko(qn) : qn, Ks = vi.byteLength + 1 + Gr.byteLength + 1, Ls = Ks % 4 ? 4 - Ks % 4 : 0;
                  xi.push(Vi([new Uint32Array([Ks]), vi, ml, Gr, ml, new Uint8Array(Ls).fill(0)]));
                }
                const qr = Vi(xi);
                if (un.dataFormatDescriptor.length !== 1 || un.dataFormatDescriptor[0].descriptorType !== 0) throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");
                const tr = un.dataFormatDescriptor[0], Zi = new ArrayBuffer(28 + 16 * tr.samples.length), hi = new DataView(Zi), Lr = 24 + 16 * tr.samples.length;
                if (hi.setUint32(0, Zi.byteLength, !0), hi.setUint16(4, tr.vendorId, !0), hi.setUint16(6, tr.descriptorType, !0), hi.setUint16(8, tr.versionNumber, !0), hi.setUint16(10, Lr, !0), hi.setUint8(12, tr.colorModel), hi.setUint8(13, tr.colorPrimaries), hi.setUint8(14, tr.transferFunction), hi.setUint8(15, tr.flags), !Array.isArray(tr.texelBlockDimension)) throw new Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
                hi.setUint8(16, tr.texelBlockDimension[0]), hi.setUint8(17, tr.texelBlockDimension[1]), hi.setUint8(18, tr.texelBlockDimension[2]), hi.setUint8(19, tr.texelBlockDimension[3]);
                for (let Di = 0; Di < 8; Di++) hi.setUint8(20 + Di, tr.bytesPlane[Di]);
                for (let Di = 0; Di < tr.samples.length; Di++) {
                  const qn = tr.samples[Di], vi = 28 + 16 * Di;
                  if (qn.channelID) throw new Error("channelID has been renamed to channelType.");
                  hi.setUint16(vi + 0, qn.bitOffset, !0), hi.setUint8(vi + 2, qn.bitLength), hi.setUint8(vi + 3, qn.channelType), hi.setUint8(vi + 4, qn.samplePosition[0]), hi.setUint8(vi + 5, qn.samplePosition[1]), hi.setUint8(vi + 6, qn.samplePosition[2]), hi.setUint8(vi + 7, qn.samplePosition[3]), 64 & qn.channelType ? (hi.setInt32(vi + 8, qn.sampleLower, !0), hi.setInt32(vi + 12, qn.sampleUpper, !0)) : (hi.setUint32(vi + 8, qn.sampleLower, !0), hi.setUint32(vi + 12, qn.sampleUpper, !0));
                }
                const Cs = Ki.length + 68 + 3 * un.levels.length * 8, jr = Cs + Zi.byteLength;
                let _r = pi.byteLength > 0 ? jr + qr.byteLength : 0;
                _r % 8 && (_r += 8 - _r % 8);
                const Yn = [], Br = new DataView(new ArrayBuffer(3 * un.levels.length * 8));
                let Jr = (_r || jr + qr.byteLength) + pi.byteLength;
                for (let Di = 0; Di < un.levels.length; Di++) {
                  const qn = un.levels[Di];
                  Yn.push(qn.levelData), Br.setBigUint64(24 * Di + 0, BigInt(Jr), !0), Br.setBigUint64(24 * Di + 8, BigInt(qn.levelData.byteLength), !0), Br.setBigUint64(24 * Di + 16, BigInt(qn.uncompressedByteLength), !0), Jr += qn.levelData.byteLength;
                }
                const wr = new ArrayBuffer(68), gi = new DataView(wr);
                return gi.setUint32(0, un.vkFormat, !0), gi.setUint32(4, un.typeSize, !0), gi.setUint32(8, un.pixelWidth, !0), gi.setUint32(12, un.pixelHeight, !0), gi.setUint32(16, un.pixelDepth, !0), gi.setUint32(20, un.layerCount, !0), gi.setUint32(24, un.faceCount, !0), gi.setUint32(28, un.levels.length, !0), gi.setUint32(32, un.supercompressionScheme, !0), gi.setUint32(36, Cs, !0), gi.setUint32(40, Zi.byteLength, !0), gi.setUint32(44, jr, !0), gi.setUint32(48, qr.byteLength, !0), gi.setBigUint64(52, BigInt(pi.byteLength > 0 ? _r : 0), !0), gi.setBigUint64(60, BigInt(pi.byteLength), !0), new Uint8Array(Vi([new Uint8Array(Ki).buffer, wr, Br.buffer, Zi, qr, _r > 0 ? new ArrayBuffer(_r - (jr + qr.byteLength)) : new ArrayBuffer(0), pi, ...Yn]));
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/libs/zstddec.module.js": (
            /*!****************************************************************!*\
              !*** ./node_modules/three/examples/jsm/libs/zstddec.module.js ***!
              \****************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                ZSTDDecoder: () => (
                  /* binding */
                  d
                )
                /* harmony export */
              });
              var C = v(
                /*! buffer */
                "./node_modules/buffer/index.js"
              ).Buffer;
              let w, E, y;
              const l = {
                env: {
                  emscripten_notify_memory_growth: function(c) {
                    y = new Uint8Array(E.exports.memory.buffer);
                  }
                }
              };
              class d {
                init() {
                  return w || (w = typeof fetch < "u" ? fetch("data:application/wasm;base64," + p).then((g) => g.arrayBuffer()).then((g) => WebAssembly.instantiate(g, l)).then(this._init) : WebAssembly.instantiate(C.from(p, "base64"), l).then(this._init), w);
                }
                _init(g) {
                  E = g.instance, l.env.emscripten_notify_memory_growth(0);
                }
                decode(g, A = 0) {
                  if (!E) throw new Error("ZSTDDecoder: Await .init() before decoding.");
                  const u = g.byteLength, f = E.exports.malloc(u);
                  y.set(g, f), A = A || Number(E.exports.ZSTD_findDecompressedSize(f, u));
                  const x = E.exports.malloc(A), T = E.exports.ZSTD_decompress(x, A, f, u), b = y.slice(x, x + T);
                  return E.exports.free(f), E.exports.free(x), b;
                }
              }
              const p = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/lights/LightProbeGenerator.js": (
            /*!***********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/lights/LightProbeGenerator.js ***!
              \***********************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                LightProbeGenerator: () => (
                  /* binding */
                  w
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              );
              class w {
                // https://www.ppsloan.org/publications/StupidSH36.pdf
                static fromCubeTexture(l) {
                  let d = 0;
                  const p = new C.Vector3(), c = new C.Vector3(), g = new C.Color(), A = [0, 0, 0, 0, 0, 0, 0, 0, 0], u = new C.SphericalHarmonics3(), f = u.coefficients;
                  for (let T = 0; T < 6; T++) {
                    const b = l.image[T], D = b.width, S = b.height, U = document.createElement("canvas");
                    U.width = D, U.height = S;
                    const G = U.getContext("2d");
                    G.drawImage(b, 0, 0, D, S);
                    const Z = G.getImageData(0, 0, D, S), W = Z.data, ie = Z.width, te = 2 / ie;
                    for (let X = 0, Q = W.length; X < Q; X += 4) {
                      g.setRGB(W[X] / 255, W[X + 1] / 255, W[X + 2] / 255), E(g, l.colorSpace);
                      const O = X / 4, K = -1 + (O % ie + 0.5) * te, ne = 1 - (Math.floor(O / ie) + 0.5) * te;
                      switch (T) {
                        case 0:
                          p.set(-1, ne, -K);
                          break;
                        case 1:
                          p.set(1, ne, K);
                          break;
                        case 2:
                          p.set(-K, 1, -ne);
                          break;
                        case 3:
                          p.set(-K, -1, ne);
                          break;
                        case 4:
                          p.set(-K, ne, 1);
                          break;
                        case 5:
                          p.set(K, ne, -1);
                          break;
                      }
                      const pe = p.lengthSq(), be = 4 / (Math.sqrt(pe) * pe);
                      d += be, c.copy(p).normalize(), C.SphericalHarmonics3.getBasisAt(c, A);
                      for (let Te = 0; Te < 9; Te++)
                        f[Te].x += A[Te] * g.r * be, f[Te].y += A[Te] * g.g * be, f[Te].z += A[Te] * g.b * be;
                    }
                  }
                  const x = 4 * Math.PI / d;
                  for (let T = 0; T < 9; T++)
                    f[T].x *= x, f[T].y *= x, f[T].z *= x;
                  return new C.LightProbe(u);
                }
                static fromCubeRenderTarget(l, d) {
                  let p = 0;
                  const c = new C.Vector3(), g = new C.Vector3(), A = new C.Color(), u = [0, 0, 0, 0, 0, 0, 0, 0, 0], f = new C.SphericalHarmonics3(), x = f.coefficients, T = d.texture.type;
                  for (let D = 0; D < 6; D++) {
                    const S = d.width;
                    let U;
                    T === C.HalfFloatType ? U = new Uint16Array(S * S * 4) : U = new Uint8Array(S * S * 4), l.readRenderTargetPixels(d, 0, 0, S, S, U, D);
                    const G = 2 / S;
                    for (let Z = 0, W = U.length; Z < W; Z += 4) {
                      let ie, te, X;
                      T === C.HalfFloatType ? (ie = C.DataUtils.fromHalfFloat(U[Z]), te = C.DataUtils.fromHalfFloat(U[Z + 1]), X = C.DataUtils.fromHalfFloat(U[Z + 2])) : (ie = U[Z] / 255, te = U[Z + 1] / 255, X = U[Z + 2] / 255), A.setRGB(ie, te, X), E(A, d.texture.colorSpace);
                      const Q = Z / 4, O = -1 + (Q % S + 0.5) * G, K = 1 - (Math.floor(Q / S) + 0.5) * G;
                      switch (D) {
                        case 0:
                          c.set(1, K, -O);
                          break;
                        case 1:
                          c.set(-1, K, O);
                          break;
                        case 2:
                          c.set(O, 1, -K);
                          break;
                        case 3:
                          c.set(O, -1, K);
                          break;
                        case 4:
                          c.set(O, K, 1);
                          break;
                        case 5:
                          c.set(-O, K, -1);
                          break;
                      }
                      const ne = c.lengthSq(), pe = 4 / (Math.sqrt(ne) * ne);
                      p += pe, g.copy(c).normalize(), C.SphericalHarmonics3.getBasisAt(g, u);
                      for (let be = 0; be < 9; be++)
                        x[be].x += u[be] * A.r * pe, x[be].y += u[be] * A.g * pe, x[be].z += u[be] * A.b * pe;
                    }
                  }
                  const b = 4 * Math.PI / p;
                  for (let D = 0; D < 9; D++)
                    x[D].x *= b, x[D].y *= b, x[D].z *= b;
                  return new C.LightProbe(f);
                }
              }
              function E(y, l) {
                switch (l) {
                  case C.SRGBColorSpace:
                    y.convertSRGBToLinear();
                    break;
                  case C.LinearSRGBColorSpace:
                  case C.NoColorSpace:
                    break;
                  default:
                    console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.");
                    break;
                }
                return y;
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/loaders/DRACOLoader.js": (
            /*!****************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/DRACOLoader.js ***!
              \****************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                DRACOLoader: () => (
                  /* binding */
                  E
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              );
              const w = /* @__PURE__ */ new WeakMap();
              class E extends C.Loader {
                constructor(d) {
                  super(d), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                  }, this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                  };
                }
                setDecoderPath(d) {
                  return this.decoderPath = d, this;
                }
                setDecoderConfig(d) {
                  return this.decoderConfig = d, this;
                }
                setWorkerLimit(d) {
                  return this.workerLimit = d, this;
                }
                load(d, p, c, g) {
                  const A = new C.FileLoader(this.manager);
                  A.setPath(this.path), A.setResponseType("arraybuffer"), A.setRequestHeader(this.requestHeader), A.setWithCredentials(this.withCredentials), A.load(d, (u) => {
                    this.parse(u, p, g);
                  }, c, g);
                }
                parse(d, p, c = () => {
                }) {
                  this.decodeDracoFile(d, p, null, null, C.SRGBColorSpace).catch(c);
                }
                decodeDracoFile(d, p, c, g, A = C.LinearSRGBColorSpace, u = () => {
                }) {
                  const f = {
                    attributeIDs: c || this.defaultAttributeIDs,
                    attributeTypes: g || this.defaultAttributeTypes,
                    useUniqueIDs: !!c,
                    vertexColorSpace: A
                  };
                  return this.decodeGeometry(d, f).then(p).catch(u);
                }
                decodeGeometry(d, p) {
                  const c = JSON.stringify(p);
                  if (w.has(d)) {
                    const x = w.get(d);
                    if (x.key === c)
                      return x.promise;
                    if (d.byteLength === 0)
                      throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
                  }
                  let g;
                  const A = this.workerNextTaskID++, u = d.byteLength, f = this._getWorker(A, u).then((x) => (g = x, new Promise((T, b) => {
                    g._callbacks[A] = {
                      resolve: T,
                      reject: b
                    }, g.postMessage({
                      type: "decode",
                      id: A,
                      taskConfig: p,
                      buffer: d
                    }, [d]);
                  }))).then((x) => this._createGeometry(x.geometry));
                  return f.catch(() => !0).then(() => {
                    g && A && this._releaseTask(g, A);
                  }), w.set(d, {
                    key: c,
                    promise: f
                  }), f;
                }
                _createGeometry(d) {
                  const p = new C.BufferGeometry();
                  d.index && p.setIndex(new C.BufferAttribute(d.index.array, 1));
                  for (let c = 0; c < d.attributes.length; c++) {
                    const g = d.attributes[c], A = g.name, u = g.array, f = g.itemSize, x = new C.BufferAttribute(u, f);
                    A === "color" && (this._assignVertexColorSpace(x, g.vertexColorSpace), x.normalized = !(u instanceof Float32Array)), p.setAttribute(A, x);
                  }
                  return p;
                }
                _assignVertexColorSpace(d, p) {
                  if (p !== C.SRGBColorSpace) return;
                  const c = new C.Color();
                  for (let g = 0, A = d.count; g < A; g++)
                    c.fromBufferAttribute(d, g).convertSRGBToLinear(), d.setXYZ(g, c.r, c.g, c.b);
                }
                _loadLibrary(d, p) {
                  const c = new C.FileLoader(this.manager);
                  return c.setPath(this.decoderPath), c.setResponseType(p), c.setWithCredentials(this.withCredentials), new Promise((g, A) => {
                    c.load(d, g, void 0, A);
                  });
                }
                preload() {
                  return this._initDecoder(), this;
                }
                _initDecoder() {
                  if (this.decoderPending) return this.decoderPending;
                  const d = typeof WebAssembly != "object" || this.decoderConfig.type === "js", p = [];
                  return d ? p.push(this._loadLibrary("draco_decoder.js", "text")) : (p.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), p.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(p).then((c) => {
                    const g = c[0];
                    d || (this.decoderConfig.wasmBinary = c[1]);
                    const A = y.toString(), u = ["/* draco decoder */", g, "", "/* worker */", A.substring(A.indexOf("{") + 1, A.lastIndexOf("}"))].join(`
`);
                    this.workerSourceURL = URL.createObjectURL(new Blob([u]));
                  }), this.decoderPending;
                }
                _getWorker(d, p) {
                  return this._initDecoder().then(() => {
                    if (this.workerPool.length < this.workerLimit) {
                      const g = new Worker(this.workerSourceURL);
                      g._callbacks = {}, g._taskCosts = {}, g._taskLoad = 0, g.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                      }), g.onmessage = function(A) {
                        const u = A.data;
                        switch (u.type) {
                          case "decode":
                            g._callbacks[u.id].resolve(u);
                            break;
                          case "error":
                            g._callbacks[u.id].reject(u);
                            break;
                          default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + u.type + '"');
                        }
                      }, this.workerPool.push(g);
                    } else
                      this.workerPool.sort(function(g, A) {
                        return g._taskLoad > A._taskLoad ? -1 : 1;
                      });
                    const c = this.workerPool[this.workerPool.length - 1];
                    return c._taskCosts[d] = p, c._taskLoad += p, c;
                  });
                }
                _releaseTask(d, p) {
                  d._taskLoad -= d._taskCosts[p], delete d._callbacks[p], delete d._taskCosts[p];
                }
                debug() {
                  console.log("Task load: ", this.workerPool.map((d) => d._taskLoad));
                }
                dispose() {
                  for (let d = 0; d < this.workerPool.length; ++d)
                    this.workerPool[d].terminate();
                  return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
                }
              }
              function y() {
                let l, d;
                onmessage = function(u) {
                  const f = u.data;
                  switch (f.type) {
                    case "init":
                      l = f.decoderConfig, d = new Promise(function(b) {
                        l.onModuleLoaded = function(D) {
                          b({
                            draco: D
                          });
                        }, DracoDecoderModule(l);
                      });
                      break;
                    case "decode":
                      const x = f.buffer, T = f.taskConfig;
                      d.then((b) => {
                        const D = b.draco, S = new D.Decoder();
                        try {
                          const U = p(D, S, new Int8Array(x), T), G = U.attributes.map((Z) => Z.array.buffer);
                          U.index && G.push(U.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: f.id,
                            geometry: U
                          }, G);
                        } catch (U) {
                          console.error(U), self.postMessage({
                            type: "error",
                            id: f.id,
                            error: U.message
                          });
                        } finally {
                          D.destroy(S);
                        }
                      });
                      break;
                  }
                };
                function p(u, f, x, T) {
                  const b = T.attributeIDs, D = T.attributeTypes;
                  let S, U;
                  const G = f.GetEncodedGeometryType(x);
                  if (G === u.TRIANGULAR_MESH)
                    S = new u.Mesh(), U = f.DecodeArrayToMesh(x, x.byteLength, S);
                  else if (G === u.POINT_CLOUD)
                    S = new u.PointCloud(), U = f.DecodeArrayToPointCloud(x, x.byteLength, S);
                  else
                    throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                  if (!U.ok() || S.ptr === 0)
                    throw new Error("THREE.DRACOLoader: Decoding failed: " + U.error_msg());
                  const Z = {
                    index: null,
                    attributes: []
                  };
                  for (const W in b) {
                    const ie = self[D[W]];
                    let te, X;
                    if (T.useUniqueIDs)
                      X = b[W], te = f.GetAttributeByUniqueId(S, X);
                    else {
                      if (X = f.GetAttributeId(S, u[b[W]]), X === -1) continue;
                      te = f.GetAttribute(S, X);
                    }
                    const Q = g(u, f, S, W, ie, te);
                    W === "color" && (Q.vertexColorSpace = T.vertexColorSpace), Z.attributes.push(Q);
                  }
                  return G === u.TRIANGULAR_MESH && (Z.index = c(u, f, S)), u.destroy(S), Z;
                }
                function c(u, f, x) {
                  const b = x.num_faces() * 3, D = b * 4, S = u._malloc(D);
                  f.GetTrianglesUInt32Array(x, D, S);
                  const U = new Uint32Array(u.HEAPF32.buffer, S, b).slice();
                  return u._free(S), {
                    array: U,
                    itemSize: 1
                  };
                }
                function g(u, f, x, T, b, D) {
                  const S = D.num_components(), G = x.num_points() * S, Z = G * b.BYTES_PER_ELEMENT, W = A(u, b), ie = u._malloc(Z);
                  f.GetAttributeDataArrayForAllPoints(x, D, W, Z, ie);
                  const te = new b(u.HEAPF32.buffer, ie, G).slice();
                  return u._free(ie), {
                    name: T,
                    array: te,
                    itemSize: S
                  };
                }
                function A(u, f) {
                  switch (f) {
                    case Float32Array:
                      return u.DT_FLOAT32;
                    case Int8Array:
                      return u.DT_INT8;
                    case Int16Array:
                      return u.DT_INT16;
                    case Int32Array:
                      return u.DT_INT32;
                    case Uint8Array:
                      return u.DT_UINT8;
                    case Uint16Array:
                      return u.DT_UINT16;
                    case Uint32Array:
                      return u.DT_UINT32;
                  }
                }
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/loaders/GLTFLoader.js": (
            /*!***************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
              \***************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                GLTFLoader: () => (
                  /* binding */
                  E
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              ), w = v(
                /*! ../utils/BufferGeometryUtils.js */
                "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"
              );
              class E extends C.Loader {
                constructor(le) {
                  super(le), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(ae) {
                    return new g(ae);
                  }), this.register(function(ae) {
                    return new A(ae);
                  }), this.register(function(ae) {
                    return new G(ae);
                  }), this.register(function(ae) {
                    return new Z(ae);
                  }), this.register(function(ae) {
                    return new W(ae);
                  }), this.register(function(ae) {
                    return new f(ae);
                  }), this.register(function(ae) {
                    return new x(ae);
                  }), this.register(function(ae) {
                    return new T(ae);
                  }), this.register(function(ae) {
                    return new b(ae);
                  }), this.register(function(ae) {
                    return new c(ae);
                  }), this.register(function(ae) {
                    return new D(ae);
                  }), this.register(function(ae) {
                    return new u(ae);
                  }), this.register(function(ae) {
                    return new U(ae);
                  }), this.register(function(ae) {
                    return new S(ae);
                  }), this.register(function(ae) {
                    return new d(ae);
                  }), this.register(function(ae) {
                    return new ie(ae);
                  }), this.register(function(ae) {
                    return new te(ae);
                  });
                }
                load(le, ae, Ce, fe) {
                  const ge = this;
                  let xe;
                  if (this.resourcePath !== "")
                    xe = this.resourcePath;
                  else if (this.path !== "") {
                    const R = C.LoaderUtils.extractUrlBase(le);
                    xe = C.LoaderUtils.resolveURL(R, this.path);
                  } else
                    xe = C.LoaderUtils.extractUrlBase(le);
                  this.manager.itemStart(le);
                  const H = function(R) {
                    fe ? fe(R) : console.error(R), ge.manager.itemError(le), ge.manager.itemEnd(le);
                  }, M = new C.FileLoader(this.manager);
                  M.setPath(this.path), M.setResponseType("arraybuffer"), M.setRequestHeader(this.requestHeader), M.setWithCredentials(this.withCredentials), M.load(le, function(R) {
                    try {
                      ge.parse(R, xe, function(ee) {
                        ae(ee), ge.manager.itemEnd(le);
                      }, H);
                    } catch (ee) {
                      H(ee);
                    }
                  }, Ce, H);
                }
                setDRACOLoader(le) {
                  return this.dracoLoader = le, this;
                }
                setDDSLoader() {
                  throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
                }
                setKTX2Loader(le) {
                  return this.ktx2Loader = le, this;
                }
                setMeshoptDecoder(le) {
                  return this.meshoptDecoder = le, this;
                }
                register(le) {
                  return this.pluginCallbacks.indexOf(le) === -1 && this.pluginCallbacks.push(le), this;
                }
                unregister(le) {
                  return this.pluginCallbacks.indexOf(le) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(le), 1), this;
                }
                parse(le, ae, Ce, fe) {
                  let ge;
                  const xe = {}, H = {}, M = new TextDecoder();
                  if (typeof le == "string")
                    ge = JSON.parse(le);
                  else if (le instanceof ArrayBuffer)
                    if (M.decode(new Uint8Array(le, 0, 4)) === X) {
                      try {
                        xe[l.KHR_BINARY_GLTF] = new K(le);
                      } catch (he) {
                        fe && fe(he);
                        return;
                      }
                      ge = JSON.parse(xe[l.KHR_BINARY_GLTF].content);
                    } else
                      ge = JSON.parse(M.decode(le));
                  else
                    ge = le;
                  if (ge.asset === void 0 || ge.asset.version[0] < 2) {
                    fe && fe(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    return;
                  }
                  const R = new ei(ge, {
                    path: ae || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                  });
                  R.fileLoader.setRequestHeader(this.requestHeader);
                  for (let ee = 0; ee < this.pluginCallbacks.length; ee++) {
                    const he = this.pluginCallbacks[ee](R);
                    he.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), H[he.name] = he, xe[he.name] = !0;
                  }
                  if (ge.extensionsUsed)
                    for (let ee = 0; ee < ge.extensionsUsed.length; ++ee) {
                      const he = ge.extensionsUsed[ee], we = ge.extensionsRequired || [];
                      switch (he) {
                        case l.KHR_MATERIALS_UNLIT:
                          xe[he] = new p();
                          break;
                        case l.KHR_DRACO_MESH_COMPRESSION:
                          xe[he] = new ne(ge, this.dracoLoader);
                          break;
                        case l.KHR_TEXTURE_TRANSFORM:
                          xe[he] = new pe();
                          break;
                        case l.KHR_MESH_QUANTIZATION:
                          xe[he] = new be();
                          break;
                        default:
                          we.indexOf(he) >= 0 && H[he] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + he + '".');
                      }
                    }
                  R.setExtensions(xe), R.setPlugins(H), R.parse(Ce, fe);
                }
                parseAsync(le, ae) {
                  const Ce = this;
                  return new Promise(function(fe, ge) {
                    Ce.parse(le, ae, fe, ge);
                  });
                }
              }
              function y() {
                let Xe = {};
                return {
                  get: function(le) {
                    return Xe[le];
                  },
                  add: function(le, ae) {
                    Xe[le] = ae;
                  },
                  remove: function(le) {
                    delete Xe[le];
                  },
                  removeAll: function() {
                    Xe = {};
                  }
                };
              }
              const l = {
                KHR_BINARY_GLTF: "KHR_binary_glTF",
                KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
                KHR_MATERIALS_IOR: "KHR_materials_ior",
                KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
                KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
                EXT_MATERIALS_BUMP: "EXT_materials_bump",
                EXT_TEXTURE_WEBP: "EXT_texture_webp",
                EXT_TEXTURE_AVIF: "EXT_texture_avif",
                EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
              };
              class d {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                  };
                }
                _markDefs() {
                  const le = this.parser, ae = this.parser.json.nodes || [];
                  for (let Ce = 0, fe = ae.length; Ce < fe; Ce++) {
                    const ge = ae[Ce];
                    ge.extensions && ge.extensions[this.name] && ge.extensions[this.name].light !== void 0 && le._addNodeRef(this.cache, ge.extensions[this.name].light);
                  }
                }
                _loadLight(le) {
                  const ae = this.parser, Ce = "light:" + le;
                  let fe = ae.cache.get(Ce);
                  if (fe) return fe;
                  const ge = ae.json, M = ((ge.extensions && ge.extensions[this.name] || {}).lights || [])[le];
                  let R;
                  const ee = new C.Color(16777215);
                  M.color !== void 0 && ee.setRGB(M.color[0], M.color[1], M.color[2], C.LinearSRGBColorSpace);
                  const he = M.range !== void 0 ? M.range : 0;
                  switch (M.type) {
                    case "directional":
                      R = new C.DirectionalLight(ee), R.target.position.set(0, 0, -1), R.add(R.target);
                      break;
                    case "point":
                      R = new C.PointLight(ee), R.distance = he;
                      break;
                    case "spot":
                      R = new C.SpotLight(ee), R.distance = he, M.spot = M.spot || {}, M.spot.innerConeAngle = M.spot.innerConeAngle !== void 0 ? M.spot.innerConeAngle : 0, M.spot.outerConeAngle = M.spot.outerConeAngle !== void 0 ? M.spot.outerConeAngle : Math.PI / 4, R.angle = M.spot.outerConeAngle, R.penumbra = 1 - M.spot.innerConeAngle / M.spot.outerConeAngle, R.target.position.set(0, 0, -1), R.add(R.target);
                      break;
                    default:
                      throw new Error("THREE.GLTFLoader: Unexpected light type: " + M.type);
                  }
                  return R.position.set(0, 0, 0), R.decay = 2, Bn(R, M), M.intensity !== void 0 && (R.intensity = M.intensity), R.name = ae.createUniqueName(M.name || "light_" + le), fe = Promise.resolve(R), ae.cache.add(Ce, fe), fe;
                }
                getDependency(le, ae) {
                  if (le === "light")
                    return this._loadLight(ae);
                }
                createNodeAttachment(le) {
                  const ae = this, Ce = this.parser, ge = Ce.json.nodes[le], H = (ge.extensions && ge.extensions[this.name] || {}).light;
                  return H === void 0 ? null : this._loadLight(H).then(function(M) {
                    return Ce._getNodeRef(ae.cache, H, M);
                  });
                }
              }
              class p {
                constructor() {
                  this.name = l.KHR_MATERIALS_UNLIT;
                }
                getMaterialType() {
                  return C.MeshBasicMaterial;
                }
                extendParams(le, ae, Ce) {
                  const fe = [];
                  le.color = new C.Color(1, 1, 1), le.opacity = 1;
                  const ge = ae.pbrMetallicRoughness;
                  if (ge) {
                    if (Array.isArray(ge.baseColorFactor)) {
                      const xe = ge.baseColorFactor;
                      le.color.setRGB(xe[0], xe[1], xe[2], C.LinearSRGBColorSpace), le.opacity = xe[3];
                    }
                    ge.baseColorTexture !== void 0 && fe.push(Ce.assignTexture(le, "map", ge.baseColorTexture, C.SRGBColorSpace));
                  }
                  return Promise.all(fe);
                }
              }
              class c {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_EMISSIVE_STRENGTH;
                }
                extendMaterialParams(le, ae) {
                  const fe = this.parser.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = fe.extensions[this.name].emissiveStrength;
                  return ge !== void 0 && (ae.emissiveIntensity = ge), Promise.resolve();
                }
              }
              class g {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_CLEARCOAT;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [], xe = fe.extensions[this.name];
                  if (xe.clearcoatFactor !== void 0 && (ae.clearcoat = xe.clearcoatFactor), xe.clearcoatTexture !== void 0 && ge.push(Ce.assignTexture(ae, "clearcoatMap", xe.clearcoatTexture)), xe.clearcoatRoughnessFactor !== void 0 && (ae.clearcoatRoughness = xe.clearcoatRoughnessFactor), xe.clearcoatRoughnessTexture !== void 0 && ge.push(Ce.assignTexture(ae, "clearcoatRoughnessMap", xe.clearcoatRoughnessTexture)), xe.clearcoatNormalTexture !== void 0 && (ge.push(Ce.assignTexture(ae, "clearcoatNormalMap", xe.clearcoatNormalTexture)), xe.clearcoatNormalTexture.scale !== void 0)) {
                    const H = xe.clearcoatNormalTexture.scale;
                    ae.clearcoatNormalScale = new C.Vector2(H, H);
                  }
                  return Promise.all(ge);
                }
              }
              class A {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_DISPERSION;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const fe = this.parser.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = fe.extensions[this.name];
                  return ae.dispersion = ge.dispersion !== void 0 ? ge.dispersion : 0, Promise.resolve();
                }
              }
              class u {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_IRIDESCENCE;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [], xe = fe.extensions[this.name];
                  return xe.iridescenceFactor !== void 0 && (ae.iridescence = xe.iridescenceFactor), xe.iridescenceTexture !== void 0 && ge.push(Ce.assignTexture(ae, "iridescenceMap", xe.iridescenceTexture)), xe.iridescenceIor !== void 0 && (ae.iridescenceIOR = xe.iridescenceIor), ae.iridescenceThicknessRange === void 0 && (ae.iridescenceThicknessRange = [100, 400]), xe.iridescenceThicknessMinimum !== void 0 && (ae.iridescenceThicknessRange[0] = xe.iridescenceThicknessMinimum), xe.iridescenceThicknessMaximum !== void 0 && (ae.iridescenceThicknessRange[1] = xe.iridescenceThicknessMaximum), xe.iridescenceThicknessTexture !== void 0 && ge.push(Ce.assignTexture(ae, "iridescenceThicknessMap", xe.iridescenceThicknessTexture)), Promise.all(ge);
                }
              }
              class f {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_SHEEN;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [];
                  ae.sheenColor = new C.Color(0, 0, 0), ae.sheenRoughness = 0, ae.sheen = 1;
                  const xe = fe.extensions[this.name];
                  if (xe.sheenColorFactor !== void 0) {
                    const H = xe.sheenColorFactor;
                    ae.sheenColor.setRGB(H[0], H[1], H[2], C.LinearSRGBColorSpace);
                  }
                  return xe.sheenRoughnessFactor !== void 0 && (ae.sheenRoughness = xe.sheenRoughnessFactor), xe.sheenColorTexture !== void 0 && ge.push(Ce.assignTexture(ae, "sheenColorMap", xe.sheenColorTexture, C.SRGBColorSpace)), xe.sheenRoughnessTexture !== void 0 && ge.push(Ce.assignTexture(ae, "sheenRoughnessMap", xe.sheenRoughnessTexture)), Promise.all(ge);
                }
              }
              class x {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_TRANSMISSION;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [], xe = fe.extensions[this.name];
                  return xe.transmissionFactor !== void 0 && (ae.transmission = xe.transmissionFactor), xe.transmissionTexture !== void 0 && ge.push(Ce.assignTexture(ae, "transmissionMap", xe.transmissionTexture)), Promise.all(ge);
                }
              }
              class T {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_VOLUME;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [], xe = fe.extensions[this.name];
                  ae.thickness = xe.thicknessFactor !== void 0 ? xe.thicknessFactor : 0, xe.thicknessTexture !== void 0 && ge.push(Ce.assignTexture(ae, "thicknessMap", xe.thicknessTexture)), ae.attenuationDistance = xe.attenuationDistance || 1 / 0;
                  const H = xe.attenuationColor || [1, 1, 1];
                  return ae.attenuationColor = new C.Color().setRGB(H[0], H[1], H[2], C.LinearSRGBColorSpace), Promise.all(ge);
                }
              }
              class b {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_IOR;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const fe = this.parser.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = fe.extensions[this.name];
                  return ae.ior = ge.ior !== void 0 ? ge.ior : 1.5, Promise.resolve();
                }
              }
              class D {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_SPECULAR;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [], xe = fe.extensions[this.name];
                  ae.specularIntensity = xe.specularFactor !== void 0 ? xe.specularFactor : 1, xe.specularTexture !== void 0 && ge.push(Ce.assignTexture(ae, "specularIntensityMap", xe.specularTexture));
                  const H = xe.specularColorFactor || [1, 1, 1];
                  return ae.specularColor = new C.Color().setRGB(H[0], H[1], H[2], C.LinearSRGBColorSpace), xe.specularColorTexture !== void 0 && ge.push(Ce.assignTexture(ae, "specularColorMap", xe.specularColorTexture, C.SRGBColorSpace)), Promise.all(ge);
                }
              }
              class S {
                constructor(le) {
                  this.parser = le, this.name = l.EXT_MATERIALS_BUMP;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [], xe = fe.extensions[this.name];
                  return ae.bumpScale = xe.bumpFactor !== void 0 ? xe.bumpFactor : 1, xe.bumpTexture !== void 0 && ge.push(Ce.assignTexture(ae, "bumpMap", xe.bumpTexture)), Promise.all(ge);
                }
              }
              class U {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_MATERIALS_ANISOTROPY;
                }
                getMaterialType(le) {
                  const Ce = this.parser.json.materials[le];
                  return !Ce.extensions || !Ce.extensions[this.name] ? null : C.MeshPhysicalMaterial;
                }
                extendMaterialParams(le, ae) {
                  const Ce = this.parser, fe = Ce.json.materials[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return Promise.resolve();
                  const ge = [], xe = fe.extensions[this.name];
                  return xe.anisotropyStrength !== void 0 && (ae.anisotropy = xe.anisotropyStrength), xe.anisotropyRotation !== void 0 && (ae.anisotropyRotation = xe.anisotropyRotation), xe.anisotropyTexture !== void 0 && ge.push(Ce.assignTexture(ae, "anisotropyMap", xe.anisotropyTexture)), Promise.all(ge);
                }
              }
              class G {
                constructor(le) {
                  this.parser = le, this.name = l.KHR_TEXTURE_BASISU;
                }
                loadTexture(le) {
                  const ae = this.parser, Ce = ae.json, fe = Ce.textures[le];
                  if (!fe.extensions || !fe.extensions[this.name])
                    return null;
                  const ge = fe.extensions[this.name], xe = ae.options.ktx2Loader;
                  if (!xe) {
                    if (Ce.extensionsRequired && Ce.extensionsRequired.indexOf(this.name) >= 0)
                      throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null;
                  }
                  return ae.loadTextureImage(le, ge.source, xe);
                }
              }
              class Z {
                constructor(le) {
                  this.parser = le, this.name = l.EXT_TEXTURE_WEBP, this.isSupported = null;
                }
                loadTexture(le) {
                  const ae = this.name, Ce = this.parser, fe = Ce.json, ge = fe.textures[le];
                  if (!ge.extensions || !ge.extensions[ae])
                    return null;
                  const xe = ge.extensions[ae], H = fe.images[xe.source];
                  let M = Ce.textureLoader;
                  if (H.uri) {
                    const R = Ce.options.manager.getHandler(H.uri);
                    R !== null && (M = R);
                  }
                  return this.detectSupport().then(function(R) {
                    if (R) return Ce.loadTextureImage(le, xe.source, M);
                    if (fe.extensionsRequired && fe.extensionsRequired.indexOf(ae) >= 0)
                      throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return Ce.loadTexture(le);
                  });
                }
                detectSupport() {
                  return this.isSupported || (this.isSupported = new Promise(function(le) {
                    const ae = new Image();
                    ae.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", ae.onload = ae.onerror = function() {
                      le(ae.height === 1);
                    };
                  })), this.isSupported;
                }
              }
              class W {
                constructor(le) {
                  this.parser = le, this.name = l.EXT_TEXTURE_AVIF, this.isSupported = null;
                }
                loadTexture(le) {
                  const ae = this.name, Ce = this.parser, fe = Ce.json, ge = fe.textures[le];
                  if (!ge.extensions || !ge.extensions[ae])
                    return null;
                  const xe = ge.extensions[ae], H = fe.images[xe.source];
                  let M = Ce.textureLoader;
                  if (H.uri) {
                    const R = Ce.options.manager.getHandler(H.uri);
                    R !== null && (M = R);
                  }
                  return this.detectSupport().then(function(R) {
                    if (R) return Ce.loadTextureImage(le, xe.source, M);
                    if (fe.extensionsRequired && fe.extensionsRequired.indexOf(ae) >= 0)
                      throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return Ce.loadTexture(le);
                  });
                }
                detectSupport() {
                  return this.isSupported || (this.isSupported = new Promise(function(le) {
                    const ae = new Image();
                    ae.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", ae.onload = ae.onerror = function() {
                      le(ae.height === 1);
                    };
                  })), this.isSupported;
                }
              }
              class ie {
                constructor(le) {
                  this.name = l.EXT_MESHOPT_COMPRESSION, this.parser = le;
                }
                loadBufferView(le) {
                  const ae = this.parser.json, Ce = ae.bufferViews[le];
                  if (Ce.extensions && Ce.extensions[this.name]) {
                    const fe = Ce.extensions[this.name], ge = this.parser.getDependency("buffer", fe.buffer), xe = this.parser.options.meshoptDecoder;
                    if (!xe || !xe.supported) {
                      if (ae.extensionsRequired && ae.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                      return null;
                    }
                    return ge.then(function(H) {
                      const M = fe.byteOffset || 0, R = fe.byteLength || 0, ee = fe.count, he = fe.byteStride, we = new Uint8Array(H, M, R);
                      return xe.decodeGltfBufferAsync ? xe.decodeGltfBufferAsync(ee, he, we, fe.mode, fe.filter).then(function(Oe) {
                        return Oe.buffer;
                      }) : xe.ready.then(function() {
                        const Oe = new ArrayBuffer(ee * he);
                        return xe.decodeGltfBuffer(new Uint8Array(Oe), ee, he, we, fe.mode, fe.filter), Oe;
                      });
                    });
                  } else
                    return null;
                }
              }
              class te {
                constructor(le) {
                  this.name = l.EXT_MESH_GPU_INSTANCING, this.parser = le;
                }
                createNodeMesh(le) {
                  const ae = this.parser.json, Ce = ae.nodes[le];
                  if (!Ce.extensions || !Ce.extensions[this.name] || Ce.mesh === void 0)
                    return null;
                  const fe = ae.meshes[Ce.mesh];
                  for (const R of fe.primitives)
                    if (R.mode !== st.TRIANGLES && R.mode !== st.TRIANGLE_STRIP && R.mode !== st.TRIANGLE_FAN && R.mode !== void 0)
                      return null;
                  const xe = Ce.extensions[this.name].attributes, H = [], M = {};
                  for (const R in xe)
                    H.push(this.parser.getDependency("accessor", xe[R]).then((ee) => (M[R] = ee, M[R])));
                  return H.length < 1 ? null : (H.push(this.parser.createNodeMesh(le)), Promise.all(H).then((R) => {
                    const ee = R.pop(), he = ee.isGroup ? ee.children : [ee], we = R[0].count, Oe = [];
                    for (const Ct of he) {
                      const Pt = new C.Matrix4(), _t = new C.Vector3(), St = new C.Quaternion(), qt = new C.Vector3(1, 1, 1), ki = new C.InstancedMesh(Ct.geometry, Ct.material, we);
                      for (let vn = 0; vn < we; vn++)
                        M.TRANSLATION && _t.fromBufferAttribute(M.TRANSLATION, vn), M.ROTATION && St.fromBufferAttribute(M.ROTATION, vn), M.SCALE && qt.fromBufferAttribute(M.SCALE, vn), ki.setMatrixAt(vn, Pt.compose(_t, St, qt));
                      for (const vn in M)
                        if (vn === "_COLOR_0") {
                          const Oi = M[vn];
                          ki.instanceColor = new C.InstancedBufferAttribute(Oi.array, Oi.itemSize, Oi.normalized);
                        } else vn !== "TRANSLATION" && vn !== "ROTATION" && vn !== "SCALE" && Ct.geometry.setAttribute(vn, M[vn]);
                      C.Object3D.prototype.copy.call(ki, Ct), this.parser.assignFinalMaterial(ki), Oe.push(ki);
                    }
                    return ee.isGroup ? (ee.clear(), ee.add(...Oe), ee) : Oe[0];
                  }));
                }
              }
              const X = "glTF", Q = 12, O = {
                JSON: 1313821514,
                BIN: 5130562
              };
              class K {
                constructor(le) {
                  this.name = l.KHR_BINARY_GLTF, this.content = null, this.body = null;
                  const ae = new DataView(le, 0, Q), Ce = new TextDecoder();
                  if (this.header = {
                    magic: Ce.decode(new Uint8Array(le.slice(0, 4))),
                    version: ae.getUint32(4, !0),
                    length: ae.getUint32(8, !0)
                  }, this.header.magic !== X)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                  if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                  const fe = this.header.length - Q, ge = new DataView(le, Q);
                  let xe = 0;
                  for (; xe < fe; ) {
                    const H = ge.getUint32(xe, !0);
                    xe += 4;
                    const M = ge.getUint32(xe, !0);
                    if (xe += 4, M === O.JSON) {
                      const R = new Uint8Array(le, Q + xe, H);
                      this.content = Ce.decode(R);
                    } else if (M === O.BIN) {
                      const R = Q + xe;
                      this.body = le.slice(R, R + H);
                    }
                    xe += H;
                  }
                  if (this.content === null)
                    throw new Error("THREE.GLTFLoader: JSON content not found.");
                }
              }
              class ne {
                constructor(le, ae) {
                  if (!ae)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                  this.name = l.KHR_DRACO_MESH_COMPRESSION, this.json = le, this.dracoLoader = ae, this.dracoLoader.preload();
                }
                decodePrimitive(le, ae) {
                  const Ce = this.json, fe = this.dracoLoader, ge = le.extensions[this.name].bufferView, xe = le.extensions[this.name].attributes, H = {}, M = {}, R = {};
                  for (const ee in xe) {
                    const he = Qt[ee] || ee.toLowerCase();
                    H[he] = xe[ee];
                  }
                  for (const ee in le.attributes) {
                    const he = Qt[ee] || ee.toLowerCase();
                    if (xe[ee] !== void 0) {
                      const we = Ce.accessors[le.attributes[ee]], Oe = ut[we.componentType];
                      R[he] = Oe.name, M[he] = we.normalized === !0;
                    }
                  }
                  return ae.getDependency("bufferView", ge).then(function(ee) {
                    return new Promise(function(he, we) {
                      fe.decodeDracoFile(ee, function(Oe) {
                        for (const Ct in Oe.attributes) {
                          const Pt = Oe.attributes[Ct], _t = M[Ct];
                          _t !== void 0 && (Pt.normalized = _t);
                        }
                        he(Oe);
                      }, H, R, C.LinearSRGBColorSpace, we);
                    });
                  });
                }
              }
              class pe {
                constructor() {
                  this.name = l.KHR_TEXTURE_TRANSFORM;
                }
                extendTexture(le, ae) {
                  return (ae.texCoord === void 0 || ae.texCoord === le.channel) && ae.offset === void 0 && ae.rotation === void 0 && ae.scale === void 0 || (le = le.clone(), ae.texCoord !== void 0 && (le.channel = ae.texCoord), ae.offset !== void 0 && le.offset.fromArray(ae.offset), ae.rotation !== void 0 && (le.rotation = ae.rotation), ae.scale !== void 0 && le.repeat.fromArray(ae.scale), le.needsUpdate = !0), le;
                }
              }
              class be {
                constructor() {
                  this.name = l.KHR_MESH_QUANTIZATION;
                }
              }
              class Te extends C.Interpolant {
                constructor(le, ae, Ce, fe) {
                  super(le, ae, Ce, fe);
                }
                copySampleValue_(le) {
                  const ae = this.resultBuffer, Ce = this.sampleValues, fe = this.valueSize, ge = le * fe * 3 + fe;
                  for (let xe = 0; xe !== fe; xe++)
                    ae[xe] = Ce[ge + xe];
                  return ae;
                }
                interpolate_(le, ae, Ce, fe) {
                  const ge = this.resultBuffer, xe = this.sampleValues, H = this.valueSize, M = H * 2, R = H * 3, ee = fe - ae, he = (Ce - ae) / ee, we = he * he, Oe = we * he, Ct = le * R, Pt = Ct - R, _t = -2 * Oe + 3 * we, St = Oe - we, qt = 1 - _t, ki = St - we + he;
                  for (let vn = 0; vn !== H; vn++) {
                    const Oi = xe[Pt + vn + H], ui = xe[Pt + vn + M] * ee, Ei = xe[Ct + vn + H], fr = xe[Ct + vn] * ee;
                    ge[vn] = qt * Oi + ki * ui + _t * Ei + St * fr;
                  }
                  return ge;
                }
              }
              const ke = new C.Quaternion();
              class Ve extends Te {
                interpolate_(le, ae, Ce, fe) {
                  const ge = super.interpolate_(le, ae, Ce, fe);
                  return ke.fromArray(ge).normalize().toArray(ge), ge;
                }
              }
              const st = {
                FLOAT: 5126,
                //FLOAT_MAT2: 35674,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
              }, ut = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
              }, It = {
                9728: C.NearestFilter,
                9729: C.LinearFilter,
                9984: C.NearestMipmapNearestFilter,
                9985: C.LinearMipmapNearestFilter,
                9986: C.NearestMipmapLinearFilter,
                9987: C.LinearMipmapLinearFilter
              }, ht = {
                33071: C.ClampToEdgeWrapping,
                33648: C.MirroredRepeatWrapping,
                10497: C.RepeatWrapping
              }, Rt = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
              }, Qt = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv1",
                TEXCOORD_2: "uv2",
                TEXCOORD_3: "uv3",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
              }, cn = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
              }, Cn = {
                CUBICSPLINE: void 0,
                // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
                // keyframe track will be initialized with a default interpolation type, then modified.
                LINEAR: C.InterpolateLinear,
                STEP: C.InterpolateDiscrete
              }, Tn = {
                OPAQUE: "OPAQUE",
                MASK: "MASK",
                BLEND: "BLEND"
              };
              function wn(Xe) {
                return Xe.DefaultMaterial === void 0 && (Xe.DefaultMaterial = new C.MeshStandardMaterial({
                  color: 16777215,
                  emissive: 0,
                  metalness: 1,
                  roughness: 1,
                  transparent: !1,
                  depthTest: !0,
                  side: C.FrontSide
                })), Xe.DefaultMaterial;
              }
              function rn(Xe, le, ae) {
                for (const Ce in ae.extensions)
                  Xe[Ce] === void 0 && (le.userData.gltfExtensions = le.userData.gltfExtensions || {}, le.userData.gltfExtensions[Ce] = ae.extensions[Ce]);
              }
              function Bn(Xe, le) {
                le.extras !== void 0 && (typeof le.extras == "object" ? Object.assign(Xe.userData, le.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + le.extras));
              }
              function di(Xe, le, ae) {
                let Ce = !1, fe = !1, ge = !1;
                for (let R = 0, ee = le.length; R < ee; R++) {
                  const he = le[R];
                  if (he.POSITION !== void 0 && (Ce = !0), he.NORMAL !== void 0 && (fe = !0), he.COLOR_0 !== void 0 && (ge = !0), Ce && fe && ge) break;
                }
                if (!Ce && !fe && !ge) return Promise.resolve(Xe);
                const xe = [], H = [], M = [];
                for (let R = 0, ee = le.length; R < ee; R++) {
                  const he = le[R];
                  if (Ce) {
                    const we = he.POSITION !== void 0 ? ae.getDependency("accessor", he.POSITION) : Xe.attributes.position;
                    xe.push(we);
                  }
                  if (fe) {
                    const we = he.NORMAL !== void 0 ? ae.getDependency("accessor", he.NORMAL) : Xe.attributes.normal;
                    H.push(we);
                  }
                  if (ge) {
                    const we = he.COLOR_0 !== void 0 ? ae.getDependency("accessor", he.COLOR_0) : Xe.attributes.color;
                    M.push(we);
                  }
                }
                return Promise.all([Promise.all(xe), Promise.all(H), Promise.all(M)]).then(function(R) {
                  const ee = R[0], he = R[1], we = R[2];
                  return Ce && (Xe.morphAttributes.position = ee), fe && (Xe.morphAttributes.normal = he), ge && (Xe.morphAttributes.color = we), Xe.morphTargetsRelative = !0, Xe;
                });
              }
              function ri(Xe, le) {
                if (Xe.updateMorphTargets(), le.weights !== void 0)
                  for (let ae = 0, Ce = le.weights.length; ae < Ce; ae++)
                    Xe.morphTargetInfluences[ae] = le.weights[ae];
                if (le.extras && Array.isArray(le.extras.targetNames)) {
                  const ae = le.extras.targetNames;
                  if (Xe.morphTargetInfluences.length === ae.length) {
                    Xe.morphTargetDictionary = {};
                    for (let Ce = 0, fe = ae.length; Ce < fe; Ce++)
                      Xe.morphTargetDictionary[ae[Ce]] = Ce;
                  } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
                }
              }
              function Ni(Xe) {
                let le;
                const ae = Xe.extensions && Xe.extensions[l.KHR_DRACO_MESH_COMPRESSION];
                if (ae ? le = "draco:" + ae.bufferView + ":" + ae.indices + ":" + Be(ae.attributes) : le = Xe.indices + ":" + Be(Xe.attributes) + ":" + Xe.mode, Xe.targets !== void 0)
                  for (let Ce = 0, fe = Xe.targets.length; Ce < fe; Ce++)
                    le += ":" + Be(Xe.targets[Ce]);
                return le;
              }
              function Be(Xe) {
                let le = "";
                const ae = Object.keys(Xe).sort();
                for (let Ce = 0, fe = ae.length; Ce < fe; Ce++)
                  le += ae[Ce] + ":" + Xe[ae[Ce]] + ";";
                return le;
              }
              function Et(Xe) {
                switch (Xe) {
                  case Int8Array:
                    return 0.007874015748031496;
                  case Uint8Array:
                    return 0.00392156862745098;
                  case Int16Array:
                    return 3051850947599719e-20;
                  case Uint16Array:
                    return 15259021896696422e-21;
                  default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
                }
              }
              function Dt(Xe) {
                return Xe.search(/\.jpe?g($|\?)/i) > 0 || Xe.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : Xe.search(/\.webp($|\?)/i) > 0 || Xe.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
              }
              const $t = new C.Matrix4();
              class ei {
                constructor(le = {}, ae = {}) {
                  this.json = le, this.extensions = {}, this.plugins = {}, this.options = ae, this.cache = new y(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                  }, this.cameraCache = {
                    refs: {},
                    uses: {}
                  }, this.lightCache = {
                    refs: {},
                    uses: {}
                  }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                  let Ce = !1, fe = !1, ge = -1;
                  typeof navigator < "u" && (Ce = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, fe = navigator.userAgent.indexOf("Firefox") > -1, ge = fe ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || Ce || fe && ge < 98 ? this.textureLoader = new C.TextureLoader(this.options.manager) : this.textureLoader = new C.ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new C.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
                }
                setExtensions(le) {
                  this.extensions = le;
                }
                setPlugins(le) {
                  this.plugins = le;
                }
                parse(le, ae) {
                  const Ce = this, fe = this.json, ge = this.extensions;
                  this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(xe) {
                    return xe._markDefs && xe._markDefs();
                  }), Promise.all(this._invokeAll(function(xe) {
                    return xe.beforeRoot && xe.beforeRoot();
                  })).then(function() {
                    return Promise.all([Ce.getDependencies("scene"), Ce.getDependencies("animation"), Ce.getDependencies("camera")]);
                  }).then(function(xe) {
                    const H = {
                      scene: xe[0][fe.scene || 0],
                      scenes: xe[0],
                      animations: xe[1],
                      cameras: xe[2],
                      asset: fe.asset,
                      parser: Ce,
                      userData: {}
                    };
                    return rn(ge, H, fe), Bn(H, fe), Promise.all(Ce._invokeAll(function(M) {
                      return M.afterRoot && M.afterRoot(H);
                    })).then(function() {
                      for (const M of H.scenes)
                        M.updateMatrixWorld();
                      le(H);
                    });
                  }).catch(ae);
                }
                /**
                 * Marks the special nodes/meshes in json for efficient parse.
                 */
                _markDefs() {
                  const le = this.json.nodes || [], ae = this.json.skins || [], Ce = this.json.meshes || [];
                  for (let fe = 0, ge = ae.length; fe < ge; fe++) {
                    const xe = ae[fe].joints;
                    for (let H = 0, M = xe.length; H < M; H++)
                      le[xe[H]].isBone = !0;
                  }
                  for (let fe = 0, ge = le.length; fe < ge; fe++) {
                    const xe = le[fe];
                    xe.mesh !== void 0 && (this._addNodeRef(this.meshCache, xe.mesh), xe.skin !== void 0 && (Ce[xe.mesh].isSkinnedMesh = !0)), xe.camera !== void 0 && this._addNodeRef(this.cameraCache, xe.camera);
                  }
                }
                /**
                 * Counts references to shared node / Object3D resources. These resources
                 * can be reused, or "instantiated", at multiple nodes in the scene
                 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
                 * be marked. Non-scenegraph resources (like Materials, Geometries, and
                 * Textures) can be reused directly and are not marked here.
                 *
                 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
                 */
                _addNodeRef(le, ae) {
                  ae !== void 0 && (le.refs[ae] === void 0 && (le.refs[ae] = le.uses[ae] = 0), le.refs[ae]++);
                }
                /** Returns a reference to a shared resource, cloning it if necessary. */
                _getNodeRef(le, ae, Ce) {
                  if (le.refs[ae] <= 1) return Ce;
                  const fe = Ce.clone(), ge = (xe, H) => {
                    const M = this.associations.get(xe);
                    M != null && this.associations.set(H, M);
                    for (const [R, ee] of xe.children.entries())
                      ge(ee, H.children[R]);
                  };
                  return ge(Ce, fe), fe.name += "_instance_" + le.uses[ae]++, fe;
                }
                _invokeOne(le) {
                  const ae = Object.values(this.plugins);
                  ae.push(this);
                  for (let Ce = 0; Ce < ae.length; Ce++) {
                    const fe = le(ae[Ce]);
                    if (fe) return fe;
                  }
                  return null;
                }
                _invokeAll(le) {
                  const ae = Object.values(this.plugins);
                  ae.unshift(this);
                  const Ce = [];
                  for (let fe = 0; fe < ae.length; fe++) {
                    const ge = le(ae[fe]);
                    ge && Ce.push(ge);
                  }
                  return Ce;
                }
                /**
                 * Requests the specified dependency asynchronously, with caching.
                 * @param {string} type
                 * @param {number} index
                 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
                 */
                getDependency(le, ae) {
                  const Ce = le + ":" + ae;
                  let fe = this.cache.get(Ce);
                  if (!fe) {
                    switch (le) {
                      case "scene":
                        fe = this.loadScene(ae);
                        break;
                      case "node":
                        fe = this._invokeOne(function(ge) {
                          return ge.loadNode && ge.loadNode(ae);
                        });
                        break;
                      case "mesh":
                        fe = this._invokeOne(function(ge) {
                          return ge.loadMesh && ge.loadMesh(ae);
                        });
                        break;
                      case "accessor":
                        fe = this.loadAccessor(ae);
                        break;
                      case "bufferView":
                        fe = this._invokeOne(function(ge) {
                          return ge.loadBufferView && ge.loadBufferView(ae);
                        });
                        break;
                      case "buffer":
                        fe = this.loadBuffer(ae);
                        break;
                      case "material":
                        fe = this._invokeOne(function(ge) {
                          return ge.loadMaterial && ge.loadMaterial(ae);
                        });
                        break;
                      case "texture":
                        fe = this._invokeOne(function(ge) {
                          return ge.loadTexture && ge.loadTexture(ae);
                        });
                        break;
                      case "skin":
                        fe = this.loadSkin(ae);
                        break;
                      case "animation":
                        fe = this._invokeOne(function(ge) {
                          return ge.loadAnimation && ge.loadAnimation(ae);
                        });
                        break;
                      case "camera":
                        fe = this.loadCamera(ae);
                        break;
                      default:
                        if (fe = this._invokeOne(function(ge) {
                          return ge != this && ge.getDependency && ge.getDependency(le, ae);
                        }), !fe)
                          throw new Error("Unknown type: " + le);
                        break;
                    }
                    this.cache.add(Ce, fe);
                  }
                  return fe;
                }
                /**
                 * Requests all dependencies of the specified type asynchronously, with caching.
                 * @param {string} type
                 * @return {Promise<Array<Object>>}
                 */
                getDependencies(le) {
                  let ae = this.cache.get(le);
                  if (!ae) {
                    const Ce = this, fe = this.json[le + (le === "mesh" ? "es" : "s")] || [];
                    ae = Promise.all(fe.map(function(ge, xe) {
                      return Ce.getDependency(le, xe);
                    })), this.cache.add(le, ae);
                  }
                  return ae;
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
                 * @param {number} bufferIndex
                 * @return {Promise<ArrayBuffer>}
                 */
                loadBuffer(le) {
                  const ae = this.json.buffers[le], Ce = this.fileLoader;
                  if (ae.type && ae.type !== "arraybuffer")
                    throw new Error("THREE.GLTFLoader: " + ae.type + " buffer type is not supported.");
                  if (ae.uri === void 0 && le === 0)
                    return Promise.resolve(this.extensions[l.KHR_BINARY_GLTF].body);
                  const fe = this.options;
                  return new Promise(function(ge, xe) {
                    Ce.load(C.LoaderUtils.resolveURL(ae.uri, fe.path), ge, void 0, function() {
                      xe(new Error('THREE.GLTFLoader: Failed to load buffer "' + ae.uri + '".'));
                    });
                  });
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
                 * @param {number} bufferViewIndex
                 * @return {Promise<ArrayBuffer>}
                 */
                loadBufferView(le) {
                  const ae = this.json.bufferViews[le];
                  return this.getDependency("buffer", ae.buffer).then(function(Ce) {
                    const fe = ae.byteLength || 0, ge = ae.byteOffset || 0;
                    return Ce.slice(ge, ge + fe);
                  });
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
                 * @param {number} accessorIndex
                 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
                 */
                loadAccessor(le) {
                  const ae = this, Ce = this.json, fe = this.json.accessors[le];
                  if (fe.bufferView === void 0 && fe.sparse === void 0) {
                    const xe = Rt[fe.type], H = ut[fe.componentType], M = fe.normalized === !0, R = new H(fe.count * xe);
                    return Promise.resolve(new C.BufferAttribute(R, xe, M));
                  }
                  const ge = [];
                  return fe.bufferView !== void 0 ? ge.push(this.getDependency("bufferView", fe.bufferView)) : ge.push(null), fe.sparse !== void 0 && (ge.push(this.getDependency("bufferView", fe.sparse.indices.bufferView)), ge.push(this.getDependency("bufferView", fe.sparse.values.bufferView))), Promise.all(ge).then(function(xe) {
                    const H = xe[0], M = Rt[fe.type], R = ut[fe.componentType], ee = R.BYTES_PER_ELEMENT, he = ee * M, we = fe.byteOffset || 0, Oe = fe.bufferView !== void 0 ? Ce.bufferViews[fe.bufferView].byteStride : void 0, Ct = fe.normalized === !0;
                    let Pt, _t;
                    if (Oe && Oe !== he) {
                      const St = Math.floor(we / Oe), qt = "InterleavedBuffer:" + fe.bufferView + ":" + fe.componentType + ":" + St + ":" + fe.count;
                      let ki = ae.cache.get(qt);
                      ki || (Pt = new R(H, St * Oe, fe.count * Oe / ee), ki = new C.InterleavedBuffer(Pt, Oe / ee), ae.cache.add(qt, ki)), _t = new C.InterleavedBufferAttribute(ki, M, we % Oe / ee, Ct);
                    } else
                      H === null ? Pt = new R(fe.count * M) : Pt = new R(H, we, fe.count * M), _t = new C.BufferAttribute(Pt, M, Ct);
                    if (fe.sparse !== void 0) {
                      const St = Rt.SCALAR, qt = ut[fe.sparse.indices.componentType], ki = fe.sparse.indices.byteOffset || 0, vn = fe.sparse.values.byteOffset || 0, Oi = new qt(xe[1], ki, fe.sparse.count * St), ui = new R(xe[2], vn, fe.sparse.count * M);
                      H !== null && (_t = new C.BufferAttribute(_t.array.slice(), _t.itemSize, _t.normalized));
                      for (let Ei = 0, fr = Oi.length; Ei < fr; Ei++) {
                        const Ii = Oi[Ei];
                        if (_t.setX(Ii, ui[Ei * M]), M >= 2 && _t.setY(Ii, ui[Ei * M + 1]), M >= 3 && _t.setZ(Ii, ui[Ei * M + 2]), M >= 4 && _t.setW(Ii, ui[Ei * M + 3]), M >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                      }
                    }
                    return _t;
                  });
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
                 * @param {number} textureIndex
                 * @return {Promise<THREE.Texture|null>}
                 */
                loadTexture(le) {
                  const ae = this.json, Ce = this.options, ge = ae.textures[le].source, xe = ae.images[ge];
                  let H = this.textureLoader;
                  if (xe.uri) {
                    const M = Ce.manager.getHandler(xe.uri);
                    M !== null && (H = M);
                  }
                  return this.loadTextureImage(le, ge, H);
                }
                loadTextureImage(le, ae, Ce) {
                  const fe = this, ge = this.json, xe = ge.textures[le], H = ge.images[ae], M = (H.uri || H.bufferView) + ":" + xe.sampler;
                  if (this.textureCache[M])
                    return this.textureCache[M];
                  const R = this.loadImageSource(ae, Ce).then(function(ee) {
                    ee.flipY = !1, ee.name = xe.name || H.name || "", ee.name === "" && typeof H.uri == "string" && H.uri.startsWith("data:image/") === !1 && (ee.name = H.uri);
                    const we = (ge.samplers || {})[xe.sampler] || {};
                    return ee.magFilter = It[we.magFilter] || C.LinearFilter, ee.minFilter = It[we.minFilter] || C.LinearMipmapLinearFilter, ee.wrapS = ht[we.wrapS] || C.RepeatWrapping, ee.wrapT = ht[we.wrapT] || C.RepeatWrapping, fe.associations.set(ee, {
                      textures: le
                    }), ee;
                  }).catch(function() {
                    return null;
                  });
                  return this.textureCache[M] = R, R;
                }
                loadImageSource(le, ae) {
                  const Ce = this, fe = this.json, ge = this.options;
                  if (this.sourceCache[le] !== void 0)
                    return this.sourceCache[le].then((he) => he.clone());
                  const xe = fe.images[le], H = self.URL || self.webkitURL;
                  let M = xe.uri || "", R = !1;
                  if (xe.bufferView !== void 0)
                    M = Ce.getDependency("bufferView", xe.bufferView).then(function(he) {
                      R = !0;
                      const we = new Blob([he], {
                        type: xe.mimeType
                      });
                      return M = H.createObjectURL(we), M;
                    });
                  else if (xe.uri === void 0)
                    throw new Error("THREE.GLTFLoader: Image " + le + " is missing URI and bufferView");
                  const ee = Promise.resolve(M).then(function(he) {
                    return new Promise(function(we, Oe) {
                      let Ct = we;
                      ae.isImageBitmapLoader === !0 && (Ct = function(Pt) {
                        const _t = new C.Texture(Pt);
                        _t.needsUpdate = !0, we(_t);
                      }), ae.load(C.LoaderUtils.resolveURL(he, ge.path), Ct, void 0, Oe);
                    });
                  }).then(function(he) {
                    return R === !0 && H.revokeObjectURL(M), he.userData.mimeType = xe.mimeType || Dt(xe.uri), he;
                  }).catch(function(he) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", M), he;
                  });
                  return this.sourceCache[le] = ee, ee;
                }
                /**
                 * Asynchronously assigns a texture to the given material parameters.
                 * @param {Object} materialParams
                 * @param {string} mapName
                 * @param {Object} mapDef
                 * @return {Promise<Texture>}
                 */
                assignTexture(le, ae, Ce, fe) {
                  const ge = this;
                  return this.getDependency("texture", Ce.index).then(function(xe) {
                    if (!xe) return null;
                    if (Ce.texCoord !== void 0 && Ce.texCoord > 0 && (xe = xe.clone(), xe.channel = Ce.texCoord), ge.extensions[l.KHR_TEXTURE_TRANSFORM]) {
                      const H = Ce.extensions !== void 0 ? Ce.extensions[l.KHR_TEXTURE_TRANSFORM] : void 0;
                      if (H) {
                        const M = ge.associations.get(xe);
                        xe = ge.extensions[l.KHR_TEXTURE_TRANSFORM].extendTexture(xe, H), ge.associations.set(xe, M);
                      }
                    }
                    return fe !== void 0 && (xe.colorSpace = fe), le[ae] = xe, xe;
                  });
                }
                /**
                 * Assigns final material to a Mesh, Line, or Points instance. The instance
                 * already has a material (generated from the glTF material options alone)
                 * but reuse of the same glTF material may require multiple threejs materials
                 * to accommodate different primitive types, defines, etc. New materials will
                 * be created if necessary, and reused from a cache.
                 * @param  {Object3D} mesh Mesh, Line, or Points instance.
                 */
                assignFinalMaterial(le) {
                  const ae = le.geometry;
                  let Ce = le.material;
                  const fe = ae.attributes.tangent === void 0, ge = ae.attributes.color !== void 0, xe = ae.attributes.normal === void 0;
                  if (le.isPoints) {
                    const H = "PointsMaterial:" + Ce.uuid;
                    let M = this.cache.get(H);
                    M || (M = new C.PointsMaterial(), C.Material.prototype.copy.call(M, Ce), M.color.copy(Ce.color), M.map = Ce.map, M.sizeAttenuation = !1, this.cache.add(H, M)), Ce = M;
                  } else if (le.isLine) {
                    const H = "LineBasicMaterial:" + Ce.uuid;
                    let M = this.cache.get(H);
                    M || (M = new C.LineBasicMaterial(), C.Material.prototype.copy.call(M, Ce), M.color.copy(Ce.color), M.map = Ce.map, this.cache.add(H, M)), Ce = M;
                  }
                  if (fe || ge || xe) {
                    let H = "ClonedMaterial:" + Ce.uuid + ":";
                    fe && (H += "derivative-tangents:"), ge && (H += "vertex-colors:"), xe && (H += "flat-shading:");
                    let M = this.cache.get(H);
                    M || (M = Ce.clone(), ge && (M.vertexColors = !0), xe && (M.flatShading = !0), fe && (M.normalScale && (M.normalScale.y *= -1), M.clearcoatNormalScale && (M.clearcoatNormalScale.y *= -1)), this.cache.add(H, M), this.associations.set(M, this.associations.get(Ce))), Ce = M;
                  }
                  le.material = Ce;
                }
                getMaterialType() {
                  return C.MeshStandardMaterial;
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
                 * @param {number} materialIndex
                 * @return {Promise<Material>}
                 */
                loadMaterial(le) {
                  const ae = this, Ce = this.json, fe = this.extensions, ge = Ce.materials[le];
                  let xe;
                  const H = {}, M = ge.extensions || {}, R = [];
                  if (M[l.KHR_MATERIALS_UNLIT]) {
                    const he = fe[l.KHR_MATERIALS_UNLIT];
                    xe = he.getMaterialType(), R.push(he.extendParams(H, ge, ae));
                  } else {
                    const he = ge.pbrMetallicRoughness || {};
                    if (H.color = new C.Color(1, 1, 1), H.opacity = 1, Array.isArray(he.baseColorFactor)) {
                      const we = he.baseColorFactor;
                      H.color.setRGB(we[0], we[1], we[2], C.LinearSRGBColorSpace), H.opacity = we[3];
                    }
                    he.baseColorTexture !== void 0 && R.push(ae.assignTexture(H, "map", he.baseColorTexture, C.SRGBColorSpace)), H.metalness = he.metallicFactor !== void 0 ? he.metallicFactor : 1, H.roughness = he.roughnessFactor !== void 0 ? he.roughnessFactor : 1, he.metallicRoughnessTexture !== void 0 && (R.push(ae.assignTexture(H, "metalnessMap", he.metallicRoughnessTexture)), R.push(ae.assignTexture(H, "roughnessMap", he.metallicRoughnessTexture))), xe = this._invokeOne(function(we) {
                      return we.getMaterialType && we.getMaterialType(le);
                    }), R.push(Promise.all(this._invokeAll(function(we) {
                      return we.extendMaterialParams && we.extendMaterialParams(le, H);
                    })));
                  }
                  ge.doubleSided === !0 && (H.side = C.DoubleSide);
                  const ee = ge.alphaMode || Tn.OPAQUE;
                  if (ee === Tn.BLEND ? (H.transparent = !0, H.depthWrite = !1) : (H.transparent = !1, ee === Tn.MASK && (H.alphaTest = ge.alphaCutoff !== void 0 ? ge.alphaCutoff : 0.5)), ge.normalTexture !== void 0 && xe !== C.MeshBasicMaterial && (R.push(ae.assignTexture(H, "normalMap", ge.normalTexture)), H.normalScale = new C.Vector2(1, 1), ge.normalTexture.scale !== void 0)) {
                    const he = ge.normalTexture.scale;
                    H.normalScale.set(he, he);
                  }
                  if (ge.occlusionTexture !== void 0 && xe !== C.MeshBasicMaterial && (R.push(ae.assignTexture(H, "aoMap", ge.occlusionTexture)), ge.occlusionTexture.strength !== void 0 && (H.aoMapIntensity = ge.occlusionTexture.strength)), ge.emissiveFactor !== void 0 && xe !== C.MeshBasicMaterial) {
                    const he = ge.emissiveFactor;
                    H.emissive = new C.Color().setRGB(he[0], he[1], he[2], C.LinearSRGBColorSpace);
                  }
                  return ge.emissiveTexture !== void 0 && xe !== C.MeshBasicMaterial && R.push(ae.assignTexture(H, "emissiveMap", ge.emissiveTexture, C.SRGBColorSpace)), Promise.all(R).then(function() {
                    const he = new xe(H);
                    return ge.name && (he.name = ge.name), Bn(he, ge), ae.associations.set(he, {
                      materials: le
                    }), ge.extensions && rn(fe, he, ge), he;
                  });
                }
                /** When Object3D instances are targeted by animation, they need unique names. */
                createUniqueName(le) {
                  const ae = C.PropertyBinding.sanitizeNodeName(le || "");
                  return ae in this.nodeNamesUsed ? ae + "_" + ++this.nodeNamesUsed[ae] : (this.nodeNamesUsed[ae] = 0, ae);
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
                 *
                 * Creates BufferGeometries from primitives.
                 *
                 * @param {Array<GLTF.Primitive>} primitives
                 * @return {Promise<Array<BufferGeometry>>}
                 */
                loadGeometries(le) {
                  const ae = this, Ce = this.extensions, fe = this.primitiveCache;
                  function ge(H) {
                    return Ce[l.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(H, ae).then(function(M) {
                      return Yt(M, H, ae);
                    });
                  }
                  const xe = [];
                  for (let H = 0, M = le.length; H < M; H++) {
                    const R = le[H], ee = Ni(R), he = fe[ee];
                    if (he)
                      xe.push(he.promise);
                    else {
                      let we;
                      R.extensions && R.extensions[l.KHR_DRACO_MESH_COMPRESSION] ? we = ge(R) : we = Yt(new C.BufferGeometry(), R, ae), fe[ee] = {
                        primitive: R,
                        promise: we
                      }, xe.push(we);
                    }
                  }
                  return Promise.all(xe);
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
                 * @param {number} meshIndex
                 * @return {Promise<Group|Mesh|SkinnedMesh>}
                 */
                loadMesh(le) {
                  const ae = this, Ce = this.json, fe = this.extensions, ge = Ce.meshes[le], xe = ge.primitives, H = [];
                  for (let M = 0, R = xe.length; M < R; M++) {
                    const ee = xe[M].material === void 0 ? wn(this.cache) : this.getDependency("material", xe[M].material);
                    H.push(ee);
                  }
                  return H.push(ae.loadGeometries(xe)), Promise.all(H).then(function(M) {
                    const R = M.slice(0, M.length - 1), ee = M[M.length - 1], he = [];
                    for (let Oe = 0, Ct = ee.length; Oe < Ct; Oe++) {
                      const Pt = ee[Oe], _t = xe[Oe];
                      let St;
                      const qt = R[Oe];
                      if (_t.mode === st.TRIANGLES || _t.mode === st.TRIANGLE_STRIP || _t.mode === st.TRIANGLE_FAN || _t.mode === void 0)
                        St = ge.isSkinnedMesh === !0 ? new C.SkinnedMesh(Pt, qt) : new C.Mesh(Pt, qt), St.isSkinnedMesh === !0 && St.normalizeSkinWeights(), _t.mode === st.TRIANGLE_STRIP ? St.geometry = (0, w.toTrianglesDrawMode)(St.geometry, C.TriangleStripDrawMode) : _t.mode === st.TRIANGLE_FAN && (St.geometry = (0, w.toTrianglesDrawMode)(St.geometry, C.TriangleFanDrawMode));
                      else if (_t.mode === st.LINES)
                        St = new C.LineSegments(Pt, qt);
                      else if (_t.mode === st.LINE_STRIP)
                        St = new C.Line(Pt, qt);
                      else if (_t.mode === st.LINE_LOOP)
                        St = new C.LineLoop(Pt, qt);
                      else if (_t.mode === st.POINTS)
                        St = new C.Points(Pt, qt);
                      else
                        throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + _t.mode);
                      Object.keys(St.geometry.morphAttributes).length > 0 && ri(St, ge), St.name = ae.createUniqueName(ge.name || "mesh_" + le), Bn(St, ge), _t.extensions && rn(fe, St, _t), ae.assignFinalMaterial(St), he.push(St);
                    }
                    for (let Oe = 0, Ct = he.length; Oe < Ct; Oe++)
                      ae.associations.set(he[Oe], {
                        meshes: le,
                        primitives: Oe
                      });
                    if (he.length === 1)
                      return ge.extensions && rn(fe, he[0], ge), he[0];
                    const we = new C.Group();
                    ge.extensions && rn(fe, we, ge), ae.associations.set(we, {
                      meshes: le
                    });
                    for (let Oe = 0, Ct = he.length; Oe < Ct; Oe++)
                      we.add(he[Oe]);
                    return we;
                  });
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
                 * @param {number} cameraIndex
                 * @return {Promise<THREE.Camera>}
                 */
                loadCamera(le) {
                  let ae;
                  const Ce = this.json.cameras[le], fe = Ce[Ce.type];
                  if (!fe) {
                    console.warn("THREE.GLTFLoader: Missing camera parameters.");
                    return;
                  }
                  return Ce.type === "perspective" ? ae = new C.PerspectiveCamera(C.MathUtils.radToDeg(fe.yfov), fe.aspectRatio || 1, fe.znear || 1, fe.zfar || 2e6) : Ce.type === "orthographic" && (ae = new C.OrthographicCamera(-fe.xmag, fe.xmag, fe.ymag, -fe.ymag, fe.znear, fe.zfar)), Ce.name && (ae.name = this.createUniqueName(Ce.name)), Bn(ae, Ce), Promise.resolve(ae);
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
                 * @param {number} skinIndex
                 * @return {Promise<Skeleton>}
                 */
                loadSkin(le) {
                  const ae = this.json.skins[le], Ce = [];
                  for (let fe = 0, ge = ae.joints.length; fe < ge; fe++)
                    Ce.push(this._loadNodeShallow(ae.joints[fe]));
                  return ae.inverseBindMatrices !== void 0 ? Ce.push(this.getDependency("accessor", ae.inverseBindMatrices)) : Ce.push(null), Promise.all(Ce).then(function(fe) {
                    const ge = fe.pop(), xe = fe, H = [], M = [];
                    for (let R = 0, ee = xe.length; R < ee; R++) {
                      const he = xe[R];
                      if (he) {
                        H.push(he);
                        const we = new C.Matrix4();
                        ge !== null && we.fromArray(ge.array, R * 16), M.push(we);
                      } else
                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', ae.joints[R]);
                    }
                    return new C.Skeleton(H, M);
                  });
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
                 * @param {number} animationIndex
                 * @return {Promise<AnimationClip>}
                 */
                loadAnimation(le) {
                  const ae = this.json, Ce = this, fe = ae.animations[le], ge = fe.name ? fe.name : "animation_" + le, xe = [], H = [], M = [], R = [], ee = [];
                  for (let he = 0, we = fe.channels.length; he < we; he++) {
                    const Oe = fe.channels[he], Ct = fe.samplers[Oe.sampler], Pt = Oe.target, _t = Pt.node, St = fe.parameters !== void 0 ? fe.parameters[Ct.input] : Ct.input, qt = fe.parameters !== void 0 ? fe.parameters[Ct.output] : Ct.output;
                    Pt.node !== void 0 && (xe.push(this.getDependency("node", _t)), H.push(this.getDependency("accessor", St)), M.push(this.getDependency("accessor", qt)), R.push(Ct), ee.push(Pt));
                  }
                  return Promise.all([Promise.all(xe), Promise.all(H), Promise.all(M), Promise.all(R), Promise.all(ee)]).then(function(he) {
                    const we = he[0], Oe = he[1], Ct = he[2], Pt = he[3], _t = he[4], St = [];
                    for (let qt = 0, ki = we.length; qt < ki; qt++) {
                      const vn = we[qt], Oi = Oe[qt], ui = Ct[qt], Ei = Pt[qt], fr = _t[qt];
                      if (vn === void 0) continue;
                      vn.updateMatrix && vn.updateMatrix();
                      const Ii = Ce._createAnimationTracks(vn, Oi, ui, Ei, fr);
                      if (Ii)
                        for (let Sr = 0; Sr < Ii.length; Sr++)
                          St.push(Ii[Sr]);
                    }
                    return new C.AnimationClip(ge, void 0, St);
                  });
                }
                createNodeMesh(le) {
                  const ae = this.json, Ce = this, fe = ae.nodes[le];
                  return fe.mesh === void 0 ? null : Ce.getDependency("mesh", fe.mesh).then(function(ge) {
                    const xe = Ce._getNodeRef(Ce.meshCache, fe.mesh, ge);
                    return fe.weights !== void 0 && xe.traverse(function(H) {
                      if (H.isMesh)
                        for (let M = 0, R = fe.weights.length; M < R; M++)
                          H.morphTargetInfluences[M] = fe.weights[M];
                    }), xe;
                  });
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
                 * @param {number} nodeIndex
                 * @return {Promise<Object3D>}
                 */
                loadNode(le) {
                  const ae = this.json, Ce = this, fe = ae.nodes[le], ge = Ce._loadNodeShallow(le), xe = [], H = fe.children || [];
                  for (let R = 0, ee = H.length; R < ee; R++)
                    xe.push(Ce.getDependency("node", H[R]));
                  const M = fe.skin === void 0 ? Promise.resolve(null) : Ce.getDependency("skin", fe.skin);
                  return Promise.all([ge, Promise.all(xe), M]).then(function(R) {
                    const ee = R[0], he = R[1], we = R[2];
                    we !== null && ee.traverse(function(Oe) {
                      Oe.isSkinnedMesh && Oe.bind(we, $t);
                    });
                    for (let Oe = 0, Ct = he.length; Oe < Ct; Oe++)
                      ee.add(he[Oe]);
                    return ee;
                  });
                }
                // ._loadNodeShallow() parses a single node.
                // skin and child nodes are created and added in .loadNode() (no '_' prefix).
                _loadNodeShallow(le) {
                  const ae = this.json, Ce = this.extensions, fe = this;
                  if (this.nodeCache[le] !== void 0)
                    return this.nodeCache[le];
                  const ge = ae.nodes[le], xe = ge.name ? fe.createUniqueName(ge.name) : "", H = [], M = fe._invokeOne(function(R) {
                    return R.createNodeMesh && R.createNodeMesh(le);
                  });
                  return M && H.push(M), ge.camera !== void 0 && H.push(fe.getDependency("camera", ge.camera).then(function(R) {
                    return fe._getNodeRef(fe.cameraCache, ge.camera, R);
                  })), fe._invokeAll(function(R) {
                    return R.createNodeAttachment && R.createNodeAttachment(le);
                  }).forEach(function(R) {
                    H.push(R);
                  }), this.nodeCache[le] = Promise.all(H).then(function(R) {
                    let ee;
                    if (ge.isBone === !0 ? ee = new C.Bone() : R.length > 1 ? ee = new C.Group() : R.length === 1 ? ee = R[0] : ee = new C.Object3D(), ee !== R[0])
                      for (let he = 0, we = R.length; he < we; he++)
                        ee.add(R[he]);
                    if (ge.name && (ee.userData.name = ge.name, ee.name = xe), Bn(ee, ge), ge.extensions && rn(Ce, ee, ge), ge.matrix !== void 0) {
                      const he = new C.Matrix4();
                      he.fromArray(ge.matrix), ee.applyMatrix4(he);
                    } else
                      ge.translation !== void 0 && ee.position.fromArray(ge.translation), ge.rotation !== void 0 && ee.quaternion.fromArray(ge.rotation), ge.scale !== void 0 && ee.scale.fromArray(ge.scale);
                    return fe.associations.has(ee) || fe.associations.set(ee, {}), fe.associations.get(ee).nodes = le, ee;
                  }), this.nodeCache[le];
                }
                /**
                 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
                 * @param {number} sceneIndex
                 * @return {Promise<Group>}
                 */
                loadScene(le) {
                  const ae = this.extensions, Ce = this.json.scenes[le], fe = this, ge = new C.Group();
                  Ce.name && (ge.name = fe.createUniqueName(Ce.name)), Bn(ge, Ce), Ce.extensions && rn(ae, ge, Ce);
                  const xe = Ce.nodes || [], H = [];
                  for (let M = 0, R = xe.length; M < R; M++)
                    H.push(fe.getDependency("node", xe[M]));
                  return Promise.all(H).then(function(M) {
                    for (let ee = 0, he = M.length; ee < he; ee++)
                      ge.add(M[ee]);
                    const R = (ee) => {
                      const he = /* @__PURE__ */ new Map();
                      for (const [we, Oe] of fe.associations)
                        (we instanceof C.Material || we instanceof C.Texture) && he.set(we, Oe);
                      return ee.traverse((we) => {
                        const Oe = fe.associations.get(we);
                        Oe != null && he.set(we, Oe);
                      }), he;
                    };
                    return fe.associations = R(ge), ge;
                  });
                }
                _createAnimationTracks(le, ae, Ce, fe, ge) {
                  const xe = [], H = le.name ? le.name : le.uuid, M = [];
                  cn[ge.path] === cn.weights ? le.traverse(function(we) {
                    we.morphTargetInfluences && M.push(we.name ? we.name : we.uuid);
                  }) : M.push(H);
                  let R;
                  switch (cn[ge.path]) {
                    case cn.weights:
                      R = C.NumberKeyframeTrack;
                      break;
                    case cn.rotation:
                      R = C.QuaternionKeyframeTrack;
                      break;
                    case cn.position:
                    case cn.scale:
                      R = C.VectorKeyframeTrack;
                      break;
                    default:
                      switch (Ce.itemSize) {
                        case 1:
                          R = C.NumberKeyframeTrack;
                          break;
                        case 2:
                        case 3:
                        default:
                          R = C.VectorKeyframeTrack;
                          break;
                      }
                      break;
                  }
                  const ee = fe.interpolation !== void 0 ? Cn[fe.interpolation] : C.InterpolateLinear, he = this._getArrayFromAccessor(Ce);
                  for (let we = 0, Oe = M.length; we < Oe; we++) {
                    const Ct = new R(M[we] + "." + cn[ge.path], ae.array, he, ee);
                    fe.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(Ct), xe.push(Ct);
                  }
                  return xe;
                }
                _getArrayFromAccessor(le) {
                  let ae = le.array;
                  if (le.normalized) {
                    const Ce = Et(ae.constructor), fe = new Float32Array(ae.length);
                    for (let ge = 0, xe = ae.length; ge < xe; ge++)
                      fe[ge] = ae[ge] * Ce;
                    ae = fe;
                  }
                  return ae;
                }
                _createCubicSplineTrackInterpolant(le) {
                  le.createInterpolant = function(Ce) {
                    const fe = this instanceof C.QuaternionKeyframeTrack ? Ve : Te;
                    return new fe(this.times, this.values, this.getValueSize() / 3, Ce);
                  }, le.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
                }
              }
              function Dn(Xe, le, ae) {
                const Ce = le.attributes, fe = new C.Box3();
                if (Ce.POSITION !== void 0) {
                  const H = ae.json.accessors[Ce.POSITION], M = H.min, R = H.max;
                  if (M !== void 0 && R !== void 0) {
                    if (fe.set(new C.Vector3(M[0], M[1], M[2]), new C.Vector3(R[0], R[1], R[2])), H.normalized) {
                      const ee = Et(ut[H.componentType]);
                      fe.min.multiplyScalar(ee), fe.max.multiplyScalar(ee);
                    }
                  } else {
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    return;
                  }
                } else
                  return;
                const ge = le.targets;
                if (ge !== void 0) {
                  const H = new C.Vector3(), M = new C.Vector3();
                  for (let R = 0, ee = ge.length; R < ee; R++) {
                    const he = ge[R];
                    if (he.POSITION !== void 0) {
                      const we = ae.json.accessors[he.POSITION], Oe = we.min, Ct = we.max;
                      if (Oe !== void 0 && Ct !== void 0) {
                        if (M.setX(Math.max(Math.abs(Oe[0]), Math.abs(Ct[0]))), M.setY(Math.max(Math.abs(Oe[1]), Math.abs(Ct[1]))), M.setZ(Math.max(Math.abs(Oe[2]), Math.abs(Ct[2]))), we.normalized) {
                          const Pt = Et(ut[we.componentType]);
                          M.multiplyScalar(Pt);
                        }
                        H.max(M);
                      } else
                        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    }
                  }
                  fe.expandByVector(H);
                }
                Xe.boundingBox = fe;
                const xe = new C.Sphere();
                fe.getCenter(xe.center), xe.radius = fe.min.distanceTo(fe.max) / 2, Xe.boundingSphere = xe;
              }
              function Yt(Xe, le, ae) {
                const Ce = le.attributes, fe = [];
                function ge(xe, H) {
                  return ae.getDependency("accessor", xe).then(function(M) {
                    Xe.setAttribute(H, M);
                  });
                }
                for (const xe in Ce) {
                  const H = Qt[xe] || xe.toLowerCase();
                  H in Xe.attributes || fe.push(ge(Ce[xe], H));
                }
                if (le.indices !== void 0 && !Xe.index) {
                  const xe = ae.getDependency("accessor", le.indices).then(function(H) {
                    Xe.setIndex(H);
                  });
                  fe.push(xe);
                }
                return C.ColorManagement.workingColorSpace !== C.LinearSRGBColorSpace && "COLOR_0" in Ce && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${C.ColorManagement.workingColorSpace}" not supported.`), Bn(Xe, le), Dn(Xe, le, ae), Promise.all(fe).then(function() {
                  return le.targets !== void 0 ? di(Xe, le.targets, ae) : Xe;
                });
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/loaders/KTX2Loader.js": (
            /*!***************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/KTX2Loader.js ***!
              \***************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                KTX2Loader: () => (
                  /* binding */
                  c
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              ), w = v(
                /*! ../utils/WorkerPool.js */
                "./node_modules/three/examples/jsm/utils/WorkerPool.js"
              ), E = v(
                /*! ../libs/ktx-parse.module.js */
                "./node_modules/three/examples/jsm/libs/ktx-parse.module.js"
              ), y = v(
                /*! ../libs/zstddec.module.js */
                "./node_modules/three/examples/jsm/libs/zstddec.module.js"
              );
              const l = /* @__PURE__ */ new WeakMap();
              let d = 0, p;
              class c extends C.Loader {
                constructor(b) {
                  super(b), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new w.WorkerPool(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
                }
                setTranscoderPath(b) {
                  return this.transcoderPath = b, this;
                }
                setWorkerLimit(b) {
                  return this.workerPool.setWorkerLimit(b), this;
                }
                async detectSupportAsync(b) {
                  return this.workerConfig = {
                    astcSupported: await b.hasFeatureAsync("texture-compression-astc"),
                    etc1Supported: await b.hasFeatureAsync("texture-compression-etc1"),
                    etc2Supported: await b.hasFeatureAsync("texture-compression-etc2"),
                    dxtSupported: await b.hasFeatureAsync("texture-compression-bc"),
                    bptcSupported: await b.hasFeatureAsync("texture-compression-bptc"),
                    pvrtcSupported: await b.hasFeatureAsync("texture-compression-pvrtc")
                  }, this;
                }
                detectSupport(b) {
                  return b.isWebGPURenderer === !0 ? this.workerConfig = {
                    astcSupported: b.hasFeature("texture-compression-astc"),
                    etc1Supported: b.hasFeature("texture-compression-etc1"),
                    etc2Supported: b.hasFeature("texture-compression-etc2"),
                    dxtSupported: b.hasFeature("texture-compression-bc"),
                    bptcSupported: b.hasFeature("texture-compression-bptc"),
                    pvrtcSupported: b.hasFeature("texture-compression-pvrtc")
                  } : this.workerConfig = {
                    astcSupported: b.extensions.has("WEBGL_compressed_texture_astc"),
                    etc1Supported: b.extensions.has("WEBGL_compressed_texture_etc1"),
                    etc2Supported: b.extensions.has("WEBGL_compressed_texture_etc"),
                    dxtSupported: b.extensions.has("WEBGL_compressed_texture_s3tc"),
                    bptcSupported: b.extensions.has("EXT_texture_compression_bptc"),
                    pvrtcSupported: b.extensions.has("WEBGL_compressed_texture_pvrtc") || b.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                  }, this;
                }
                init() {
                  if (!this.transcoderPending) {
                    const b = new C.FileLoader(this.manager);
                    b.setPath(this.transcoderPath), b.setWithCredentials(this.withCredentials);
                    const D = b.loadAsync("basis_transcoder.js"), S = new C.FileLoader(this.manager);
                    S.setPath(this.transcoderPath), S.setResponseType("arraybuffer"), S.setWithCredentials(this.withCredentials);
                    const U = S.loadAsync("basis_transcoder.wasm");
                    this.transcoderPending = Promise.all([D, U]).then(([G, Z]) => {
                      const W = c.BasisWorker.toString(), ie = ["/* constants */", "let _EngineFormat = " + JSON.stringify(c.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(c.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(c.BasisFormat), "/* basis_transcoder.js */", G, "/* worker */", W.substring(W.indexOf("{") + 1, W.lastIndexOf("}"))].join(`
`);
                      this.workerSourceURL = URL.createObjectURL(new Blob([ie])), this.transcoderBinary = Z, this.workerPool.setWorkerCreator(() => {
                        const te = new Worker(this.workerSourceURL), X = this.transcoderBinary.slice(0);
                        return te.postMessage({
                          type: "init",
                          config: this.workerConfig,
                          transcoderBinary: X
                        }, [X]), te;
                      });
                    }), d > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), d++;
                  }
                  return this.transcoderPending;
                }
                load(b, D, S, U) {
                  if (this.workerConfig === null)
                    throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                  const G = new C.FileLoader(this.manager);
                  G.setResponseType("arraybuffer"), G.setWithCredentials(this.withCredentials), G.load(b, (Z) => {
                    if (l.has(Z))
                      return l.get(Z).promise.then(D).catch(U);
                    this._createTexture(Z).then((W) => D ? D(W) : null).catch(U);
                  }, S, U);
                }
                _createTextureFrom(b, D) {
                  const {
                    faces: S,
                    width: U,
                    height: G,
                    format: Z,
                    type: W,
                    error: ie,
                    dfdFlags: te
                  } = b;
                  if (W === "error") return Promise.reject(ie);
                  let X;
                  if (D.faceCount === 6)
                    X = new C.CompressedCubeTexture(S, Z, C.UnsignedByteType);
                  else {
                    const Q = S[0].mipmaps;
                    X = D.layerCount > 1 ? new C.CompressedArrayTexture(Q, U, G, D.layerCount, Z, C.UnsignedByteType) : new C.CompressedTexture(Q, U, G, Z, C.UnsignedByteType);
                  }
                  return X.minFilter = S[0].mipmaps.length === 1 ? C.LinearFilter : C.LinearMipmapLinearFilter, X.magFilter = C.LinearFilter, X.generateMipmaps = !1, X.needsUpdate = !0, X.colorSpace = x(D), X.premultiplyAlpha = !!(te & E.KHR_DF_FLAG_ALPHA_PREMULTIPLIED), X;
                }
                /**
                 * @param {ArrayBuffer} buffer
                 * @param {object?} config
                 * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
                 */
                async _createTexture(b, D = {}) {
                  const S = (0, E.read)(new Uint8Array(b));
                  if (S.vkFormat !== E.VK_FORMAT_UNDEFINED)
                    return f(S);
                  const U = D, G = this.init().then(() => this.workerPool.postMessage({
                    type: "transcode",
                    buffer: b,
                    taskConfig: U
                  }, [b])).then((Z) => this._createTextureFrom(Z.data, S));
                  return l.set(b, {
                    promise: G
                  }), G;
                }
                dispose() {
                  return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), d--, this;
                }
              }
              c.BasisFormat = {
                ETC1S: 0,
                UASTC_4x4: 1
              }, c.TranscoderFormat = {
                ETC1: 0,
                ETC2: 1,
                BC1: 2,
                BC3: 3,
                BC4: 4,
                BC5: 5,
                BC7_M6_OPAQUE_ONLY: 6,
                BC7_M5: 7,
                PVRTC1_4_RGB: 8,
                PVRTC1_4_RGBA: 9,
                ASTC_4x4: 10,
                ATC_RGB: 11,
                ATC_RGBA_INTERPOLATED_ALPHA: 12,
                RGBA32: 13,
                RGB565: 14,
                BGR565: 15,
                RGBA4444: 16
              }, c.EngineFormat = {
                RGBAFormat: C.RGBAFormat,
                RGBA_ASTC_4x4_Format: C.RGBA_ASTC_4x4_Format,
                RGBA_BPTC_Format: C.RGBA_BPTC_Format,
                RGBA_ETC2_EAC_Format: C.RGBA_ETC2_EAC_Format,
                RGBA_PVRTC_4BPPV1_Format: C.RGBA_PVRTC_4BPPV1_Format,
                RGBA_S3TC_DXT5_Format: C.RGBA_S3TC_DXT5_Format,
                RGB_ETC1_Format: C.RGB_ETC1_Format,
                RGB_ETC2_Format: C.RGB_ETC2_Format,
                RGB_PVRTC_4BPPV1_Format: C.RGB_PVRTC_4BPPV1_Format,
                RGBA_S3TC_DXT1_Format: C.RGBA_S3TC_DXT1_Format
              }, c.BasisWorker = function() {
                let T, b, D;
                const S = _EngineFormat, U = _TranscoderFormat, G = _BasisFormat;
                self.addEventListener("message", function(ne) {
                  const pe = ne.data;
                  switch (pe.type) {
                    case "init":
                      T = pe.config, Z(pe.transcoderBinary);
                      break;
                    case "transcode":
                      b.then(() => {
                        try {
                          const {
                            faces: be,
                            buffers: Te,
                            width: ke,
                            height: Ve,
                            hasAlpha: st,
                            format: ut,
                            dfdFlags: It
                          } = W(pe.buffer);
                          self.postMessage({
                            type: "transcode",
                            id: pe.id,
                            faces: be,
                            width: ke,
                            height: Ve,
                            hasAlpha: st,
                            format: ut,
                            dfdFlags: It
                          }, Te);
                        } catch (be) {
                          console.error(be), self.postMessage({
                            type: "error",
                            id: pe.id,
                            error: be.message
                          });
                        }
                      });
                      break;
                  }
                });
                function Z(ne) {
                  b = new Promise((pe) => {
                    D = {
                      wasmBinary: ne,
                      onRuntimeInitialized: pe
                    }, BASIS(D);
                  }).then(() => {
                    D.initializeBasis(), D.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
                  });
                }
                function W(ne) {
                  const pe = new D.KTX2File(new Uint8Array(ne));
                  function be() {
                    pe.close(), pe.delete();
                  }
                  if (!pe.isValid())
                    throw be(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
                  const Te = pe.isUASTC() ? G.UASTC_4x4 : G.ETC1S, ke = pe.getWidth(), Ve = pe.getHeight(), st = pe.getLayers() || 1, ut = pe.getLevels(), It = pe.getFaces(), ht = pe.getHasAlpha(), Rt = pe.getDFDFlags(), {
                    transcoderFormat: Qt,
                    engineFormat: cn
                  } = Q(Te, ke, Ve, ht);
                  if (!ke || !Ve || !ut)
                    throw be(), new Error("THREE.KTX2Loader:	Invalid texture");
                  if (!pe.startTranscoding())
                    throw be(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                  const Cn = [], Tn = [];
                  for (let wn = 0; wn < It; wn++) {
                    const rn = [];
                    for (let Bn = 0; Bn < ut; Bn++) {
                      const di = [];
                      let ri, Ni;
                      for (let Et = 0; Et < st; Et++) {
                        const Dt = pe.getImageLevelInfo(Bn, Et, wn);
                        wn === 0 && Bn === 0 && Et === 0 && (Dt.origWidth % 4 !== 0 || Dt.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), ut > 1 ? (ri = Dt.origWidth, Ni = Dt.origHeight) : (ri = Dt.width, Ni = Dt.height);
                        const $t = new Uint8Array(pe.getImageTranscodedSizeInBytes(Bn, Et, 0, Qt));
                        if (!pe.transcodeImage($t, Bn, Et, wn, Qt, 0, -1, -1))
                          throw be(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                        di.push($t);
                      }
                      const Be = K(di);
                      rn.push({
                        data: Be,
                        width: ri,
                        height: Ni
                      }), Tn.push(Be.buffer);
                    }
                    Cn.push({
                      mipmaps: rn,
                      width: ke,
                      height: Ve,
                      format: cn
                    });
                  }
                  return be(), {
                    faces: Cn,
                    buffers: Tn,
                    width: ke,
                    height: Ve,
                    hasAlpha: ht,
                    format: cn,
                    dfdFlags: Rt
                  };
                }
                const ie = [{
                  if: "astcSupported",
                  basisFormat: [G.UASTC_4x4],
                  transcoderFormat: [U.ASTC_4x4, U.ASTC_4x4],
                  engineFormat: [S.RGBA_ASTC_4x4_Format, S.RGBA_ASTC_4x4_Format],
                  priorityETC1S: 1 / 0,
                  priorityUASTC: 1,
                  needsPowerOfTwo: !1
                }, {
                  if: "bptcSupported",
                  basisFormat: [G.ETC1S, G.UASTC_4x4],
                  transcoderFormat: [U.BC7_M5, U.BC7_M5],
                  engineFormat: [S.RGBA_BPTC_Format, S.RGBA_BPTC_Format],
                  priorityETC1S: 3,
                  priorityUASTC: 2,
                  needsPowerOfTwo: !1
                }, {
                  if: "dxtSupported",
                  basisFormat: [G.ETC1S, G.UASTC_4x4],
                  transcoderFormat: [U.BC1, U.BC3],
                  engineFormat: [S.RGBA_S3TC_DXT1_Format, S.RGBA_S3TC_DXT5_Format],
                  priorityETC1S: 4,
                  priorityUASTC: 5,
                  needsPowerOfTwo: !1
                }, {
                  if: "etc2Supported",
                  basisFormat: [G.ETC1S, G.UASTC_4x4],
                  transcoderFormat: [U.ETC1, U.ETC2],
                  engineFormat: [S.RGB_ETC2_Format, S.RGBA_ETC2_EAC_Format],
                  priorityETC1S: 1,
                  priorityUASTC: 3,
                  needsPowerOfTwo: !1
                }, {
                  if: "etc1Supported",
                  basisFormat: [G.ETC1S, G.UASTC_4x4],
                  transcoderFormat: [U.ETC1],
                  engineFormat: [S.RGB_ETC1_Format],
                  priorityETC1S: 2,
                  priorityUASTC: 4,
                  needsPowerOfTwo: !1
                }, {
                  if: "pvrtcSupported",
                  basisFormat: [G.ETC1S, G.UASTC_4x4],
                  transcoderFormat: [U.PVRTC1_4_RGB, U.PVRTC1_4_RGBA],
                  engineFormat: [S.RGB_PVRTC_4BPPV1_Format, S.RGBA_PVRTC_4BPPV1_Format],
                  priorityETC1S: 5,
                  priorityUASTC: 6,
                  needsPowerOfTwo: !0
                }], te = ie.sort(function(ne, pe) {
                  return ne.priorityETC1S - pe.priorityETC1S;
                }), X = ie.sort(function(ne, pe) {
                  return ne.priorityUASTC - pe.priorityUASTC;
                });
                function Q(ne, pe, be, Te) {
                  let ke, Ve;
                  const st = ne === G.ETC1S ? te : X;
                  for (let ut = 0; ut < st.length; ut++) {
                    const It = st[ut];
                    if (T[It.if] && It.basisFormat.includes(ne) && !(Te && It.transcoderFormat.length < 2) && !(It.needsPowerOfTwo && !(O(pe) && O(be))))
                      return ke = It.transcoderFormat[Te ? 1 : 0], Ve = It.engineFormat[Te ? 1 : 0], {
                        transcoderFormat: ke,
                        engineFormat: Ve
                      };
                  }
                  return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), ke = U.RGBA32, Ve = S.RGBAFormat, {
                    transcoderFormat: ke,
                    engineFormat: Ve
                  };
                }
                function O(ne) {
                  return ne <= 2 ? !0 : (ne & ne - 1) === 0 && ne !== 0;
                }
                function K(ne) {
                  if (ne.length === 1) return ne[0];
                  let pe = 0;
                  for (let ke = 0; ke < ne.length; ke++) {
                    const Ve = ne[ke];
                    pe += Ve.byteLength;
                  }
                  const be = new Uint8Array(pe);
                  let Te = 0;
                  for (let ke = 0; ke < ne.length; ke++) {
                    const Ve = ne[ke];
                    be.set(Ve, Te), Te += Ve.byteLength;
                  }
                  return be;
                }
              };
              const g = /* @__PURE__ */ new Set([C.RGBAFormat, C.RGFormat, C.RedFormat]), A = {
                [E.VK_FORMAT_R32G32B32A32_SFLOAT]: C.RGBAFormat,
                [E.VK_FORMAT_R16G16B16A16_SFLOAT]: C.RGBAFormat,
                [E.VK_FORMAT_R8G8B8A8_UNORM]: C.RGBAFormat,
                [E.VK_FORMAT_R8G8B8A8_SRGB]: C.RGBAFormat,
                [E.VK_FORMAT_R32G32_SFLOAT]: C.RGFormat,
                [E.VK_FORMAT_R16G16_SFLOAT]: C.RGFormat,
                [E.VK_FORMAT_R8G8_UNORM]: C.RGFormat,
                [E.VK_FORMAT_R8G8_SRGB]: C.RGFormat,
                [E.VK_FORMAT_R32_SFLOAT]: C.RedFormat,
                [E.VK_FORMAT_R16_SFLOAT]: C.RedFormat,
                [E.VK_FORMAT_R8_SRGB]: C.RedFormat,
                [E.VK_FORMAT_R8_UNORM]: C.RedFormat,
                [E.VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: C.RGBA_ASTC_6x6_Format,
                [E.VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: C.RGBA_ASTC_6x6_Format
              }, u = {
                [E.VK_FORMAT_R32G32B32A32_SFLOAT]: C.FloatType,
                [E.VK_FORMAT_R16G16B16A16_SFLOAT]: C.HalfFloatType,
                [E.VK_FORMAT_R8G8B8A8_UNORM]: C.UnsignedByteType,
                [E.VK_FORMAT_R8G8B8A8_SRGB]: C.UnsignedByteType,
                [E.VK_FORMAT_R32G32_SFLOAT]: C.FloatType,
                [E.VK_FORMAT_R16G16_SFLOAT]: C.HalfFloatType,
                [E.VK_FORMAT_R8G8_UNORM]: C.UnsignedByteType,
                [E.VK_FORMAT_R8G8_SRGB]: C.UnsignedByteType,
                [E.VK_FORMAT_R32_SFLOAT]: C.FloatType,
                [E.VK_FORMAT_R16_SFLOAT]: C.HalfFloatType,
                [E.VK_FORMAT_R8_SRGB]: C.UnsignedByteType,
                [E.VK_FORMAT_R8_UNORM]: C.UnsignedByteType,
                [E.VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: C.UnsignedByteType,
                [E.VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: C.UnsignedByteType
              };
              async function f(T) {
                const {
                  vkFormat: b
                } = T;
                if (A[b] === void 0)
                  throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                let D;
                T.supercompressionScheme === E.KHR_SUPERCOMPRESSION_ZSTD && (p || (p = new Promise(async (G) => {
                  const Z = new y.ZSTDDecoder();
                  await Z.init(), G(Z);
                })), D = await p);
                const S = [];
                for (let G = 0; G < T.levels.length; G++) {
                  const Z = Math.max(1, T.pixelWidth >> G), W = Math.max(1, T.pixelHeight >> G), ie = T.pixelDepth ? Math.max(1, T.pixelDepth >> G) : 0, te = T.levels[G];
                  let X;
                  if (T.supercompressionScheme === E.KHR_SUPERCOMPRESSION_NONE)
                    X = te.levelData;
                  else if (T.supercompressionScheme === E.KHR_SUPERCOMPRESSION_ZSTD)
                    X = D.decode(te.levelData, te.uncompressedByteLength);
                  else
                    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                  let Q;
                  u[b] === C.FloatType ? Q = new Float32Array(X.buffer, X.byteOffset, X.byteLength / Float32Array.BYTES_PER_ELEMENT) : u[b] === C.HalfFloatType ? Q = new Uint16Array(X.buffer, X.byteOffset, X.byteLength / Uint16Array.BYTES_PER_ELEMENT) : Q = X, S.push({
                    data: Q,
                    width: Z,
                    height: W,
                    depth: ie
                  });
                }
                let U;
                if (g.has(A[b]))
                  U = T.pixelDepth === 0 ? new C.DataTexture(S[0].data, T.pixelWidth, T.pixelHeight) : new C.Data3DTexture(S[0].data, T.pixelWidth, T.pixelHeight, T.pixelDepth);
                else {
                  if (T.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                  U = new C.CompressedTexture(S, T.pixelWidth, T.pixelHeight);
                }
                return U.mipmaps = S, U.type = u[b], U.format = A[b], U.colorSpace = x(T), U.needsUpdate = !0, Promise.resolve(U);
              }
              function x(T) {
                const b = T.dataFormatDescriptor[0];
                return b.colorPrimaries === E.KHR_DF_PRIMARIES_BT709 ? b.transferFunction === E.KHR_DF_TRANSFER_SRGB ? C.SRGBColorSpace : C.LinearSRGBColorSpace : b.colorPrimaries === E.KHR_DF_PRIMARIES_DISPLAYP3 ? b.transferFunction === E.KHR_DF_TRANSFER_SRGB ? C.DisplayP3ColorSpace : C.LinearDisplayP3ColorSpace : (b.colorPrimaries === E.KHR_DF_PRIMARIES_UNSPECIFIED || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${b.colorPrimaries}"`), C.NoColorSpace);
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/loaders/MTLLoader.js": (
            /*!**************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/MTLLoader.js ***!
              \**************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                MTLLoader: () => (
                  /* binding */
                  w
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              );
              class w extends C.Loader {
                constructor(l) {
                  super(l);
                }
                /**
                 * Loads and parses a MTL asset from a URL.
                 *
                 * @param {String} url - URL to the MTL file.
                 * @param {Function} [onLoad] - Callback invoked with the loaded object.
                 * @param {Function} [onProgress] - Callback for download progress.
                 * @param {Function} [onError] - Callback for download errors.
                 *
                 * @see setPath setResourcePath
                 *
                 * @note In order for relative texture references to resolve correctly
                 * you must call setResourcePath() explicitly prior to load.
                 */
                load(l, d, p, c) {
                  const g = this, A = this.path === "" ? C.LoaderUtils.extractUrlBase(l) : this.path, u = new C.FileLoader(this.manager);
                  u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials), u.load(l, function(f) {
                    try {
                      d(g.parse(f, A));
                    } catch (x) {
                      c ? c(x) : console.error(x), g.manager.itemError(l);
                    }
                  }, p, c);
                }
                setMaterialOptions(l) {
                  return this.materialOptions = l, this;
                }
                /**
                 * Parses a MTL file.
                 *
                 * @param {String} text - Content of MTL file
                 * @return {MaterialCreator}
                 *
                 * @see setPath setResourcePath
                 *
                 * @note In order for relative texture references to resolve correctly
                 * you must call setResourcePath() explicitly prior to parse.
                 */
                parse(l, d) {
                  const p = l.split(`
`);
                  let c = {};
                  const g = /\s+/, A = {};
                  for (let f = 0; f < p.length; f++) {
                    let x = p[f];
                    if (x = x.trim(), x.length === 0 || x.charAt(0) === "#")
                      continue;
                    const T = x.indexOf(" ");
                    let b = T >= 0 ? x.substring(0, T) : x;
                    b = b.toLowerCase();
                    let D = T >= 0 ? x.substring(T + 1) : "";
                    if (D = D.trim(), b === "newmtl")
                      c = {
                        name: D
                      }, A[D] = c;
                    else if (b === "ka" || b === "kd" || b === "ks" || b === "ke") {
                      const S = D.split(g, 3);
                      c[b] = [parseFloat(S[0]), parseFloat(S[1]), parseFloat(S[2])];
                    } else
                      c[b] = D;
                  }
                  const u = new E(this.resourcePath || d, this.materialOptions);
                  return u.setCrossOrigin(this.crossOrigin), u.setManager(this.manager), u.setMaterials(A), u;
                }
              }
              class E {
                constructor(l = "", d = {}) {
                  this.baseUrl = l, this.options = d, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : C.FrontSide, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : C.RepeatWrapping;
                }
                setCrossOrigin(l) {
                  return this.crossOrigin = l, this;
                }
                setManager(l) {
                  this.manager = l;
                }
                setMaterials(l) {
                  this.materialsInfo = this.convert(l), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
                }
                convert(l) {
                  if (!this.options) return l;
                  const d = {};
                  for (const p in l) {
                    const c = l[p], g = {};
                    d[p] = g;
                    for (const A in c) {
                      let u = !0, f = c[A];
                      const x = A.toLowerCase();
                      switch (x) {
                        case "kd":
                        case "ka":
                        case "ks":
                          this.options && this.options.normalizeRGB && (f = [f[0] / 255, f[1] / 255, f[2] / 255]), this.options && this.options.ignoreZeroRGBs && f[0] === 0 && f[1] === 0 && f[2] === 0 && (u = !1);
                          break;
                      }
                      u && (g[x] = f);
                    }
                  }
                  return d;
                }
                preload() {
                  for (const l in this.materialsInfo)
                    this.create(l);
                }
                getIndex(l) {
                  return this.nameLookup[l];
                }
                getAsArray() {
                  let l = 0;
                  for (const d in this.materialsInfo)
                    this.materialsArray[l] = this.create(d), this.nameLookup[d] = l, l++;
                  return this.materialsArray;
                }
                create(l) {
                  return this.materials[l] === void 0 && this.createMaterial_(l), this.materials[l];
                }
                createMaterial_(l) {
                  const d = this, p = this.materialsInfo[l], c = {
                    name: l,
                    side: this.side
                  };
                  function g(u, f) {
                    return typeof f != "string" || f === "" ? "" : /^https?:\/\//i.test(f) ? f : u + f;
                  }
                  function A(u, f) {
                    if (c[u]) return;
                    const x = d.getTextureParams(f, c), T = d.loadTexture(g(d.baseUrl, x.url));
                    T.repeat.copy(x.scale), T.offset.copy(x.offset), T.wrapS = d.wrap, T.wrapT = d.wrap, (u === "map" || u === "emissiveMap") && (T.colorSpace = C.SRGBColorSpace), c[u] = T;
                  }
                  for (const u in p) {
                    const f = p[u];
                    let x;
                    if (f !== "")
                      switch (u.toLowerCase()) {
                        // Ns is material specular exponent
                        case "kd":
                          c.color = new C.Color().fromArray(f).convertSRGBToLinear();
                          break;
                        case "ks":
                          c.specular = new C.Color().fromArray(f).convertSRGBToLinear();
                          break;
                        case "ke":
                          c.emissive = new C.Color().fromArray(f).convertSRGBToLinear();
                          break;
                        case "map_kd":
                          A("map", f);
                          break;
                        case "map_ks":
                          A("specularMap", f);
                          break;
                        case "map_ke":
                          A("emissiveMap", f);
                          break;
                        case "norm":
                          A("normalMap", f);
                          break;
                        case "map_bump":
                        case "bump":
                          A("bumpMap", f);
                          break;
                        case "map_d":
                          A("alphaMap", f), c.transparent = !0;
                          break;
                        case "ns":
                          c.shininess = parseFloat(f);
                          break;
                        case "d":
                          x = parseFloat(f), x < 1 && (c.opacity = x, c.transparent = !0);
                          break;
                        case "tr":
                          x = parseFloat(f), this.options && this.options.invertTrProperty && (x = 1 - x), x > 0 && (c.opacity = 1 - x, c.transparent = !0);
                          break;
                      }
                  }
                  return this.materials[l] = new C.MeshPhongMaterial(c), this.materials[l];
                }
                getTextureParams(l, d) {
                  const p = {
                    scale: new C.Vector2(1, 1),
                    offset: new C.Vector2(0, 0)
                  }, c = l.split(/\s+/);
                  let g;
                  return g = c.indexOf("-bm"), g >= 0 && (d.bumpScale = parseFloat(c[g + 1]), c.splice(g, 2)), g = c.indexOf("-s"), g >= 0 && (p.scale.set(parseFloat(c[g + 1]), parseFloat(c[g + 2])), c.splice(g, 4)), g = c.indexOf("-o"), g >= 0 && (p.offset.set(parseFloat(c[g + 1]), parseFloat(c[g + 2])), c.splice(g, 4)), p.url = c.join(" ").trim(), p;
                }
                loadTexture(l, d, p, c, g) {
                  const A = this.manager !== void 0 ? this.manager : C.DefaultLoadingManager;
                  let u = A.getHandler(l);
                  u === null && (u = new C.TextureLoader(A)), u.setCrossOrigin && u.setCrossOrigin(this.crossOrigin);
                  const f = u.load(l, p, c, g);
                  return d !== void 0 && (f.mapping = d), f;
                }
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/loaders/OBJLoader.js": (
            /*!**************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/OBJLoader.js ***!
              \**************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                OBJLoader: () => (
                  /* binding */
                  T
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              );
              const w = /^[og]\s*(.+)?/, E = /^mtllib /, y = /^usemtl /, l = /^usemap /, d = /\s+/, p = new C.Vector3(), c = new C.Vector3(), g = new C.Vector3(), A = new C.Vector3(), u = new C.Vector3(), f = new C.Color();
              function x() {
                const b = {
                  objects: [],
                  object: {},
                  vertices: [],
                  normals: [],
                  colors: [],
                  uvs: [],
                  materials: {},
                  materialLibraries: [],
                  startObject: function(D, S) {
                    if (this.object && this.object.fromDeclaration === !1) {
                      this.object.name = D, this.object.fromDeclaration = S !== !1;
                      return;
                    }
                    const U = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
                    if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
                      name: D || "",
                      fromDeclaration: S !== !1,
                      geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                        hasUVIndices: !1
                      },
                      materials: [],
                      smooth: !0,
                      startMaterial: function(G, Z) {
                        const W = this._finalize(!1);
                        W && (W.inherited || W.groupCount <= 0) && this.materials.splice(W.index, 1);
                        const ie = {
                          index: this.materials.length,
                          name: G || "",
                          mtllib: Array.isArray(Z) && Z.length > 0 ? Z[Z.length - 1] : "",
                          smooth: W !== void 0 ? W.smooth : this.smooth,
                          groupStart: W !== void 0 ? W.groupEnd : 0,
                          groupEnd: -1,
                          groupCount: -1,
                          inherited: !1,
                          clone: function(te) {
                            const X = {
                              index: typeof te == "number" ? te : this.index,
                              name: this.name,
                              mtllib: this.mtllib,
                              smooth: this.smooth,
                              groupStart: 0,
                              groupEnd: -1,
                              groupCount: -1,
                              inherited: !1
                            };
                            return X.clone = this.clone.bind(X), X;
                          }
                        };
                        return this.materials.push(ie), ie;
                      },
                      currentMaterial: function() {
                        if (this.materials.length > 0)
                          return this.materials[this.materials.length - 1];
                      },
                      _finalize: function(G) {
                        const Z = this.currentMaterial();
                        if (Z && Z.groupEnd === -1 && (Z.groupEnd = this.geometry.vertices.length / 3, Z.groupCount = Z.groupEnd - Z.groupStart, Z.inherited = !1), G && this.materials.length > 1)
                          for (let W = this.materials.length - 1; W >= 0; W--)
                            this.materials[W].groupCount <= 0 && this.materials.splice(W, 1);
                        return G && this.materials.length === 0 && this.materials.push({
                          name: "",
                          smooth: this.smooth
                        }), Z;
                      }
                    }, U && U.name && typeof U.clone == "function") {
                      const G = U.clone(0);
                      G.inherited = !0, this.object.materials.push(G);
                    }
                    this.objects.push(this.object);
                  },
                  finalize: function() {
                    this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
                  },
                  parseVertexIndex: function(D, S) {
                    const U = parseInt(D, 10);
                    return (U >= 0 ? U - 1 : U + S / 3) * 3;
                  },
                  parseNormalIndex: function(D, S) {
                    const U = parseInt(D, 10);
                    return (U >= 0 ? U - 1 : U + S / 3) * 3;
                  },
                  parseUVIndex: function(D, S) {
                    const U = parseInt(D, 10);
                    return (U >= 0 ? U - 1 : U + S / 2) * 2;
                  },
                  addVertex: function(D, S, U) {
                    const G = this.vertices, Z = this.object.geometry.vertices;
                    Z.push(G[D + 0], G[D + 1], G[D + 2]), Z.push(G[S + 0], G[S + 1], G[S + 2]), Z.push(G[U + 0], G[U + 1], G[U + 2]);
                  },
                  addVertexPoint: function(D) {
                    const S = this.vertices;
                    this.object.geometry.vertices.push(S[D + 0], S[D + 1], S[D + 2]);
                  },
                  addVertexLine: function(D) {
                    const S = this.vertices;
                    this.object.geometry.vertices.push(S[D + 0], S[D + 1], S[D + 2]);
                  },
                  addNormal: function(D, S, U) {
                    const G = this.normals, Z = this.object.geometry.normals;
                    Z.push(G[D + 0], G[D + 1], G[D + 2]), Z.push(G[S + 0], G[S + 1], G[S + 2]), Z.push(G[U + 0], G[U + 1], G[U + 2]);
                  },
                  addFaceNormal: function(D, S, U) {
                    const G = this.vertices, Z = this.object.geometry.normals;
                    p.fromArray(G, D), c.fromArray(G, S), g.fromArray(G, U), u.subVectors(g, c), A.subVectors(p, c), u.cross(A), u.normalize(), Z.push(u.x, u.y, u.z), Z.push(u.x, u.y, u.z), Z.push(u.x, u.y, u.z);
                  },
                  addColor: function(D, S, U) {
                    const G = this.colors, Z = this.object.geometry.colors;
                    G[D] !== void 0 && Z.push(G[D + 0], G[D + 1], G[D + 2]), G[S] !== void 0 && Z.push(G[S + 0], G[S + 1], G[S + 2]), G[U] !== void 0 && Z.push(G[U + 0], G[U + 1], G[U + 2]);
                  },
                  addUV: function(D, S, U) {
                    const G = this.uvs, Z = this.object.geometry.uvs;
                    Z.push(G[D + 0], G[D + 1]), Z.push(G[S + 0], G[S + 1]), Z.push(G[U + 0], G[U + 1]);
                  },
                  addDefaultUV: function() {
                    const D = this.object.geometry.uvs;
                    D.push(0, 0), D.push(0, 0), D.push(0, 0);
                  },
                  addUVLine: function(D) {
                    const S = this.uvs;
                    this.object.geometry.uvs.push(S[D + 0], S[D + 1]);
                  },
                  addFace: function(D, S, U, G, Z, W, ie, te, X) {
                    const Q = this.vertices.length;
                    let O = this.parseVertexIndex(D, Q), K = this.parseVertexIndex(S, Q), ne = this.parseVertexIndex(U, Q);
                    if (this.addVertex(O, K, ne), this.addColor(O, K, ne), ie !== void 0 && ie !== "") {
                      const pe = this.normals.length;
                      O = this.parseNormalIndex(ie, pe), K = this.parseNormalIndex(te, pe), ne = this.parseNormalIndex(X, pe), this.addNormal(O, K, ne);
                    } else
                      this.addFaceNormal(O, K, ne);
                    if (G !== void 0 && G !== "") {
                      const pe = this.uvs.length;
                      O = this.parseUVIndex(G, pe), K = this.parseUVIndex(Z, pe), ne = this.parseUVIndex(W, pe), this.addUV(O, K, ne), this.object.geometry.hasUVIndices = !0;
                    } else
                      this.addDefaultUV();
                  },
                  addPointGeometry: function(D) {
                    this.object.geometry.type = "Points";
                    const S = this.vertices.length;
                    for (let U = 0, G = D.length; U < G; U++) {
                      const Z = this.parseVertexIndex(D[U], S);
                      this.addVertexPoint(Z), this.addColor(Z);
                    }
                  },
                  addLineGeometry: function(D, S) {
                    this.object.geometry.type = "Line";
                    const U = this.vertices.length, G = this.uvs.length;
                    for (let Z = 0, W = D.length; Z < W; Z++)
                      this.addVertexLine(this.parseVertexIndex(D[Z], U));
                    for (let Z = 0, W = S.length; Z < W; Z++)
                      this.addUVLine(this.parseUVIndex(S[Z], G));
                  }
                };
                return b.startObject("", !1), b;
              }
              class T extends C.Loader {
                constructor(D) {
                  super(D), this.materials = null;
                }
                load(D, S, U, G) {
                  const Z = this, W = new C.FileLoader(this.manager);
                  W.setPath(this.path), W.setRequestHeader(this.requestHeader), W.setWithCredentials(this.withCredentials), W.load(D, function(ie) {
                    try {
                      S(Z.parse(ie));
                    } catch (te) {
                      G ? G(te) : console.error(te), Z.manager.itemError(D);
                    }
                  }, U, G);
                }
                setMaterials(D) {
                  return this.materials = D, this;
                }
                parse(D) {
                  const S = new x();
                  D.indexOf(`\r
`) !== -1 && (D = D.replace(/\r\n/g, `
`)), D.indexOf(`\\
`) !== -1 && (D = D.replace(/\\\n/g, ""));
                  const U = D.split(`
`);
                  let G = [];
                  for (let ie = 0, te = U.length; ie < te; ie++) {
                    const X = U[ie].trimStart();
                    if (X.length === 0) continue;
                    const Q = X.charAt(0);
                    if (Q !== "#")
                      if (Q === "v") {
                        const O = X.split(d);
                        switch (O[0]) {
                          case "v":
                            S.vertices.push(parseFloat(O[1]), parseFloat(O[2]), parseFloat(O[3])), O.length >= 7 ? (f.setRGB(parseFloat(O[4]), parseFloat(O[5]), parseFloat(O[6])).convertSRGBToLinear(), S.colors.push(f.r, f.g, f.b)) : S.colors.push(void 0, void 0, void 0);
                            break;
                          case "vn":
                            S.normals.push(parseFloat(O[1]), parseFloat(O[2]), parseFloat(O[3]));
                            break;
                          case "vt":
                            S.uvs.push(parseFloat(O[1]), parseFloat(O[2]));
                            break;
                        }
                      } else if (Q === "f") {
                        const K = X.slice(1).trim().split(d), ne = [];
                        for (let be = 0, Te = K.length; be < Te; be++) {
                          const ke = K[be];
                          if (ke.length > 0) {
                            const Ve = ke.split("/");
                            ne.push(Ve);
                          }
                        }
                        const pe = ne[0];
                        for (let be = 1, Te = ne.length - 1; be < Te; be++) {
                          const ke = ne[be], Ve = ne[be + 1];
                          S.addFace(pe[0], ke[0], Ve[0], pe[1], ke[1], Ve[1], pe[2], ke[2], Ve[2]);
                        }
                      } else if (Q === "l") {
                        const O = X.substring(1).trim().split(" ");
                        let K = [];
                        const ne = [];
                        if (X.indexOf("/") === -1)
                          K = O;
                        else
                          for (let pe = 0, be = O.length; pe < be; pe++) {
                            const Te = O[pe].split("/");
                            Te[0] !== "" && K.push(Te[0]), Te[1] !== "" && ne.push(Te[1]);
                          }
                        S.addLineGeometry(K, ne);
                      } else if (Q === "p") {
                        const K = X.slice(1).trim().split(" ");
                        S.addPointGeometry(K);
                      } else if ((G = w.exec(X)) !== null) {
                        const O = (" " + G[0].slice(1).trim()).slice(1);
                        S.startObject(O);
                      } else if (y.test(X))
                        S.object.startMaterial(X.substring(7).trim(), S.materialLibraries);
                      else if (E.test(X))
                        S.materialLibraries.push(X.substring(7).trim());
                      else if (l.test(X))
                        console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                      else if (Q === "s") {
                        if (G = X.split(" "), G.length > 1) {
                          const K = G[1].trim().toLowerCase();
                          S.object.smooth = K !== "0" && K !== "off";
                        } else
                          S.object.smooth = !0;
                        const O = S.object.currentMaterial();
                        O && (O.smooth = S.object.smooth);
                      } else {
                        if (X === "\0") continue;
                        console.warn('THREE.OBJLoader: Unexpected line: "' + X + '"');
                      }
                  }
                  S.finalize();
                  const Z = new C.Group();
                  if (Z.materialLibraries = [].concat(S.materialLibraries), !(S.objects.length === 1 && S.objects[0].geometry.vertices.length === 0) === !0)
                    for (let ie = 0, te = S.objects.length; ie < te; ie++) {
                      const X = S.objects[ie], Q = X.geometry, O = X.materials, K = Q.type === "Line", ne = Q.type === "Points";
                      let pe = !1;
                      if (Q.vertices.length === 0) continue;
                      const be = new C.BufferGeometry();
                      be.setAttribute("position", new C.Float32BufferAttribute(Q.vertices, 3)), Q.normals.length > 0 && be.setAttribute("normal", new C.Float32BufferAttribute(Q.normals, 3)), Q.colors.length > 0 && (pe = !0, be.setAttribute("color", new C.Float32BufferAttribute(Q.colors, 3))), Q.hasUVIndices === !0 && be.setAttribute("uv", new C.Float32BufferAttribute(Q.uvs, 2));
                      const Te = [];
                      for (let Ve = 0, st = O.length; Ve < st; Ve++) {
                        const ut = O[Ve], It = ut.name + "_" + ut.smooth + "_" + pe;
                        let ht = S.materials[It];
                        if (this.materials !== null) {
                          if (ht = this.materials.create(ut.name), K && ht && !(ht instanceof C.LineBasicMaterial)) {
                            const Rt = new C.LineBasicMaterial();
                            C.Material.prototype.copy.call(Rt, ht), Rt.color.copy(ht.color), ht = Rt;
                          } else if (ne && ht && !(ht instanceof C.PointsMaterial)) {
                            const Rt = new C.PointsMaterial({
                              size: 10,
                              sizeAttenuation: !1
                            });
                            C.Material.prototype.copy.call(Rt, ht), Rt.color.copy(ht.color), Rt.map = ht.map, ht = Rt;
                          }
                        }
                        ht === void 0 && (K ? ht = new C.LineBasicMaterial() : ne ? ht = new C.PointsMaterial({
                          size: 1,
                          sizeAttenuation: !1
                        }) : ht = new C.MeshPhongMaterial(), ht.name = ut.name, ht.flatShading = !ut.smooth, ht.vertexColors = pe, S.materials[It] = ht), Te.push(ht);
                      }
                      let ke;
                      if (Te.length > 1) {
                        for (let Ve = 0, st = O.length; Ve < st; Ve++) {
                          const ut = O[Ve];
                          be.addGroup(ut.groupStart, ut.groupCount, Ve);
                        }
                        K ? ke = new C.LineSegments(be, Te) : ne ? ke = new C.Points(be, Te) : ke = new C.Mesh(be, Te);
                      } else
                        K ? ke = new C.LineSegments(be, Te[0]) : ne ? ke = new C.Points(be, Te[0]) : ke = new C.Mesh(be, Te[0]);
                      ke.name = X.name, Z.add(ke);
                    }
                  else if (S.vertices.length > 0) {
                    const ie = new C.PointsMaterial({
                      size: 1,
                      sizeAttenuation: !1
                    }), te = new C.BufferGeometry();
                    te.setAttribute("position", new C.Float32BufferAttribute(S.vertices, 3)), S.colors.length > 0 && S.colors[0] !== void 0 && (te.setAttribute("color", new C.Float32BufferAttribute(S.colors, 3)), ie.vertexColors = !0);
                    const X = new C.Points(te, ie);
                    Z.add(X);
                  }
                  return Z;
                }
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/math/OBB.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/three/examples/jsm/math/OBB.js ***!
              \*****************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                OBB: () => (
                  /* binding */
                  U
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              );
              const w = {
                c: null,
                // center
                u: [new C.Vector3(), new C.Vector3(), new C.Vector3()],
                // basis vectors
                e: []
                // half width
              }, E = {
                c: null,
                // center
                u: [new C.Vector3(), new C.Vector3(), new C.Vector3()],
                // basis vectors
                e: []
                // half width
              }, y = [[], [], []], l = [[], [], []], d = [], p = new C.Vector3(), c = new C.Vector3(), g = new C.Vector3(), A = new C.Vector3(), u = new C.Vector3(), f = new C.Vector3(), x = new C.Matrix3(), T = new C.Box3(), b = new C.Matrix4(), D = new C.Matrix4(), S = new C.Ray();
              class U {
                constructor(W = new C.Vector3(), ie = new C.Vector3(), te = new C.Matrix3()) {
                  this.center = W, this.halfSize = ie, this.rotation = te;
                }
                set(W, ie, te) {
                  return this.center = W, this.halfSize = ie, this.rotation = te, this;
                }
                copy(W) {
                  return this.center.copy(W.center), this.halfSize.copy(W.halfSize), this.rotation.copy(W.rotation), this;
                }
                clone() {
                  return new this.constructor().copy(this);
                }
                getSize(W) {
                  return W.copy(this.halfSize).multiplyScalar(2);
                }
                /**
                * Reference: Closest Point on OBB to Point in Real-Time Collision Detection
                * by Christer Ericson (chapter 5.1.4)
                */
                clampPoint(W, ie) {
                  const te = this.halfSize;
                  A.subVectors(W, this.center), this.rotation.extractBasis(p, c, g), ie.copy(this.center);
                  const X = C.MathUtils.clamp(A.dot(p), -te.x, te.x);
                  ie.add(p.multiplyScalar(X));
                  const Q = C.MathUtils.clamp(A.dot(c), -te.y, te.y);
                  ie.add(c.multiplyScalar(Q));
                  const O = C.MathUtils.clamp(A.dot(g), -te.z, te.z);
                  return ie.add(g.multiplyScalar(O)), ie;
                }
                containsPoint(W) {
                  return A.subVectors(W, this.center), this.rotation.extractBasis(p, c, g), Math.abs(A.dot(p)) <= this.halfSize.x && Math.abs(A.dot(c)) <= this.halfSize.y && Math.abs(A.dot(g)) <= this.halfSize.z;
                }
                intersectsBox3(W) {
                  return this.intersectsOBB(G.fromBox3(W));
                }
                intersectsSphere(W) {
                  return this.clampPoint(W.center, f), f.distanceToSquared(W.center) <= W.radius * W.radius;
                }
                /**
                * Reference: OBB-OBB Intersection in Real-Time Collision Detection
                * by Christer Ericson (chapter 4.4.1)
                *
                */
                intersectsOBB(W, ie = Number.EPSILON) {
                  w.c = this.center, w.e[0] = this.halfSize.x, w.e[1] = this.halfSize.y, w.e[2] = this.halfSize.z, this.rotation.extractBasis(w.u[0], w.u[1], w.u[2]), E.c = W.center, E.e[0] = W.halfSize.x, E.e[1] = W.halfSize.y, E.e[2] = W.halfSize.z, W.rotation.extractBasis(E.u[0], E.u[1], E.u[2]);
                  for (let Q = 0; Q < 3; Q++)
                    for (let O = 0; O < 3; O++)
                      y[Q][O] = w.u[Q].dot(E.u[O]);
                  A.subVectors(E.c, w.c), d[0] = A.dot(w.u[0]), d[1] = A.dot(w.u[1]), d[2] = A.dot(w.u[2]);
                  for (let Q = 0; Q < 3; Q++)
                    for (let O = 0; O < 3; O++)
                      l[Q][O] = Math.abs(y[Q][O]) + ie;
                  let te, X;
                  for (let Q = 0; Q < 3; Q++)
                    if (te = w.e[Q], X = E.e[0] * l[Q][0] + E.e[1] * l[Q][1] + E.e[2] * l[Q][2], Math.abs(d[Q]) > te + X) return !1;
                  for (let Q = 0; Q < 3; Q++)
                    if (te = w.e[0] * l[0][Q] + w.e[1] * l[1][Q] + w.e[2] * l[2][Q], X = E.e[Q], Math.abs(d[0] * y[0][Q] + d[1] * y[1][Q] + d[2] * y[2][Q]) > te + X) return !1;
                  return te = w.e[1] * l[2][0] + w.e[2] * l[1][0], X = E.e[1] * l[0][2] + E.e[2] * l[0][1], !(Math.abs(d[2] * y[1][0] - d[1] * y[2][0]) > te + X || (te = w.e[1] * l[2][1] + w.e[2] * l[1][1], X = E.e[0] * l[0][2] + E.e[2] * l[0][0], Math.abs(d[2] * y[1][1] - d[1] * y[2][1]) > te + X) || (te = w.e[1] * l[2][2] + w.e[2] * l[1][2], X = E.e[0] * l[0][1] + E.e[1] * l[0][0], Math.abs(d[2] * y[1][2] - d[1] * y[2][2]) > te + X) || (te = w.e[0] * l[2][0] + w.e[2] * l[0][0], X = E.e[1] * l[1][2] + E.e[2] * l[1][1], Math.abs(d[0] * y[2][0] - d[2] * y[0][0]) > te + X) || (te = w.e[0] * l[2][1] + w.e[2] * l[0][1], X = E.e[0] * l[1][2] + E.e[2] * l[1][0], Math.abs(d[0] * y[2][1] - d[2] * y[0][1]) > te + X) || (te = w.e[0] * l[2][2] + w.e[2] * l[0][2], X = E.e[0] * l[1][1] + E.e[1] * l[1][0], Math.abs(d[0] * y[2][2] - d[2] * y[0][2]) > te + X) || (te = w.e[0] * l[1][0] + w.e[1] * l[0][0], X = E.e[1] * l[2][2] + E.e[2] * l[2][1], Math.abs(d[1] * y[0][0] - d[0] * y[1][0]) > te + X) || (te = w.e[0] * l[1][1] + w.e[1] * l[0][1], X = E.e[0] * l[2][2] + E.e[2] * l[2][0], Math.abs(d[1] * y[0][1] - d[0] * y[1][1]) > te + X) || (te = w.e[0] * l[1][2] + w.e[1] * l[0][2], X = E.e[0] * l[2][1] + E.e[1] * l[2][0], Math.abs(d[1] * y[0][2] - d[0] * y[1][2]) > te + X));
                }
                /**
                * Reference: Testing Box Against Plane in Real-Time Collision Detection
                * by Christer Ericson (chapter 5.2.3)
                */
                intersectsPlane(W) {
                  this.rotation.extractBasis(p, c, g);
                  const ie = this.halfSize.x * Math.abs(W.normal.dot(p)) + this.halfSize.y * Math.abs(W.normal.dot(c)) + this.halfSize.z * Math.abs(W.normal.dot(g)), te = W.normal.dot(this.center) - W.constant;
                  return Math.abs(te) <= ie;
                }
                /**
                * Performs a ray/OBB intersection test and stores the intersection point
                * to the given 3D vector. If no intersection is detected, *null* is returned.
                */
                intersectRay(W, ie) {
                  return this.getSize(u), T.setFromCenterAndSize(A.set(0, 0, 0), u), b.setFromMatrix3(this.rotation), b.setPosition(this.center), D.copy(b).invert(), S.copy(W).applyMatrix4(D), S.intersectBox(T, ie) ? ie.applyMatrix4(b) : null;
                }
                /**
                * Performs a ray/OBB intersection test. Returns either true or false if
                * there is a intersection or not.
                */
                intersectsRay(W) {
                  return this.intersectRay(W, A) !== null;
                }
                fromBox3(W) {
                  return W.getCenter(this.center), W.getSize(this.halfSize).multiplyScalar(0.5), this.rotation.identity(), this;
                }
                equals(W) {
                  return W.center.equals(this.center) && W.halfSize.equals(this.halfSize) && W.rotation.equals(this.rotation);
                }
                applyMatrix4(W) {
                  const ie = W.elements;
                  let te = A.set(ie[0], ie[1], ie[2]).length();
                  const X = A.set(ie[4], ie[5], ie[6]).length(), Q = A.set(ie[8], ie[9], ie[10]).length();
                  W.determinant() < 0 && (te = -te), x.setFromMatrix4(W);
                  const K = 1 / te, ne = 1 / X, pe = 1 / Q;
                  return x.elements[0] *= K, x.elements[1] *= K, x.elements[2] *= K, x.elements[3] *= ne, x.elements[4] *= ne, x.elements[5] *= ne, x.elements[6] *= pe, x.elements[7] *= pe, x.elements[8] *= pe, this.rotation.multiply(x), this.halfSize.x *= te, this.halfSize.y *= X, this.halfSize.z *= Q, A.setFromMatrixPosition(W), this.center.add(A), this;
                }
              }
              const G = new U();
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js": (
            /*!**********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js ***!
              \**********************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                computeMikkTSpaceTangents: () => (
                  /* binding */
                  w
                ),
                /* harmony export */
                computeMorphedAttributes: () => (
                  /* binding */
                  f
                ),
                /* harmony export */
                deepCloneAttribute: () => (
                  /* binding */
                  l
                ),
                /* harmony export */
                deinterleaveAttribute: () => (
                  /* binding */
                  p
                ),
                /* harmony export */
                deinterleaveGeometry: () => (
                  /* binding */
                  c
                ),
                /* harmony export */
                estimateBytesUsed: () => (
                  /* binding */
                  g
                ),
                /* harmony export */
                interleaveAttributes: () => (
                  /* binding */
                  d
                ),
                /* harmony export */
                mergeAttributes: () => (
                  /* binding */
                  y
                ),
                /* harmony export */
                mergeGeometries: () => (
                  /* binding */
                  E
                ),
                /* harmony export */
                mergeGroups: () => (
                  /* binding */
                  x
                ),
                /* harmony export */
                mergeVertices: () => (
                  /* binding */
                  A
                ),
                /* harmony export */
                toCreasedNormals: () => (
                  /* binding */
                  T
                ),
                /* harmony export */
                toTrianglesDrawMode: () => (
                  /* binding */
                  u
                )
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              );
              function w(b, D, S = !0) {
                if (!D || !D.isReady)
                  throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
                if (!b.hasAttribute("position") || !b.hasAttribute("normal") || !b.hasAttribute("uv"))
                  throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
                function U(W) {
                  if (W.normalized || W.isInterleavedBufferAttribute) {
                    const ie = new Float32Array(W.count * W.itemSize);
                    for (let te = 0, X = 0; te < W.count; te++)
                      ie[X++] = W.getX(te), ie[X++] = W.getY(te), W.itemSize > 2 && (ie[X++] = W.getZ(te));
                    return ie;
                  }
                  return W.array instanceof Float32Array ? W.array : new Float32Array(W.array);
                }
                const G = b.index ? b.toNonIndexed() : b, Z = D.generateTangents(U(G.attributes.position), U(G.attributes.normal), U(G.attributes.uv));
                if (S)
                  for (let W = 3; W < Z.length; W += 4)
                    Z[W] *= -1;
                return G.setAttribute("tangent", new C.BufferAttribute(Z, 4)), b !== G && b.copy(G), b;
              }
              function E(b, D = !1) {
                const S = b[0].index !== null, U = new Set(Object.keys(b[0].attributes)), G = new Set(Object.keys(b[0].morphAttributes)), Z = {}, W = {}, ie = b[0].morphTargetsRelative, te = new C.BufferGeometry();
                let X = 0;
                for (let Q = 0; Q < b.length; ++Q) {
                  const O = b[Q];
                  let K = 0;
                  if (S !== (O.index !== null))
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Q + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
                  for (const ne in O.attributes) {
                    if (!U.has(ne))
                      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Q + '. All geometries must have compatible attributes; make sure "' + ne + '" attribute exists among all geometries, or in none of them.'), null;
                    Z[ne] === void 0 && (Z[ne] = []), Z[ne].push(O.attributes[ne]), K++;
                  }
                  if (K !== U.size)
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Q + ". Make sure all geometries have the same number of attributes."), null;
                  if (ie !== O.morphTargetsRelative)
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Q + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
                  for (const ne in O.morphAttributes) {
                    if (!G.has(ne))
                      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Q + ".  .morphAttributes must be consistent throughout all geometries."), null;
                    W[ne] === void 0 && (W[ne] = []), W[ne].push(O.morphAttributes[ne]);
                  }
                  if (D) {
                    let ne;
                    if (S)
                      ne = O.index.count;
                    else if (O.attributes.position !== void 0)
                      ne = O.attributes.position.count;
                    else
                      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Q + ". The geometry must have either an index or a position attribute"), null;
                    te.addGroup(X, ne, Q), X += ne;
                  }
                }
                if (S) {
                  let Q = 0;
                  const O = [];
                  for (let K = 0; K < b.length; ++K) {
                    const ne = b[K].index;
                    for (let pe = 0; pe < ne.count; ++pe)
                      O.push(ne.getX(pe) + Q);
                    Q += b[K].attributes.position.count;
                  }
                  te.setIndex(O);
                }
                for (const Q in Z) {
                  const O = y(Z[Q]);
                  if (!O)
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + Q + " attribute."), null;
                  te.setAttribute(Q, O);
                }
                for (const Q in W) {
                  const O = W[Q][0].length;
                  if (O === 0) break;
                  te.morphAttributes = te.morphAttributes || {}, te.morphAttributes[Q] = [];
                  for (let K = 0; K < O; ++K) {
                    const ne = [];
                    for (let be = 0; be < W[Q].length; ++be)
                      ne.push(W[Q][be][K]);
                    const pe = y(ne);
                    if (!pe)
                      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + Q + " morphAttribute."), null;
                    te.morphAttributes[Q].push(pe);
                  }
                }
                return te;
              }
              function y(b) {
                let D, S, U, G = -1, Z = 0;
                for (let X = 0; X < b.length; ++X) {
                  const Q = b[X];
                  if (D === void 0 && (D = Q.array.constructor), D !== Q.array.constructor)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
                  if (S === void 0 && (S = Q.itemSize), S !== Q.itemSize)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
                  if (U === void 0 && (U = Q.normalized), U !== Q.normalized)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
                  if (G === -1 && (G = Q.gpuType), G !== Q.gpuType)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
                  Z += Q.count * S;
                }
                const W = new D(Z), ie = new C.BufferAttribute(W, S, U);
                let te = 0;
                for (let X = 0; X < b.length; ++X) {
                  const Q = b[X];
                  if (Q.isInterleavedBufferAttribute) {
                    const O = te / S;
                    for (let K = 0, ne = Q.count; K < ne; K++)
                      for (let pe = 0; pe < S; pe++) {
                        const be = Q.getComponent(K, pe);
                        ie.setComponent(K + O, pe, be);
                      }
                  } else
                    W.set(Q.array, te);
                  te += Q.count * S;
                }
                return G !== void 0 && (ie.gpuType = G), ie;
              }
              function l(b) {
                return b.isInstancedInterleavedBufferAttribute || b.isInterleavedBufferAttribute ? p(b) : b.isInstancedBufferAttribute ? new C.InstancedBufferAttribute().copy(b) : new C.BufferAttribute().copy(b);
              }
              function d(b) {
                let D, S = 0, U = 0;
                for (let X = 0, Q = b.length; X < Q; ++X) {
                  const O = b[X];
                  if (D === void 0 && (D = O.array.constructor), D !== O.array.constructor)
                    return console.error("AttributeBuffers of different types cannot be interleaved"), null;
                  S += O.array.length, U += O.itemSize;
                }
                const G = new C.InterleavedBuffer(new D(S), U);
                let Z = 0;
                const W = [], ie = ["getX", "getY", "getZ", "getW"], te = ["setX", "setY", "setZ", "setW"];
                for (let X = 0, Q = b.length; X < Q; X++) {
                  const O = b[X], K = O.itemSize, ne = O.count, pe = new C.InterleavedBufferAttribute(G, K, Z, O.normalized);
                  W.push(pe), Z += K;
                  for (let be = 0; be < ne; be++)
                    for (let Te = 0; Te < K; Te++)
                      pe[te[Te]](be, O[ie[Te]](be));
                }
                return W;
              }
              function p(b) {
                const D = b.data.array.constructor, S = b.count, U = b.itemSize, G = b.normalized, Z = new D(S * U);
                let W;
                b.isInstancedInterleavedBufferAttribute ? W = new C.InstancedBufferAttribute(Z, U, G, b.meshPerAttribute) : W = new C.BufferAttribute(Z, U, G);
                for (let ie = 0; ie < S; ie++)
                  W.setX(ie, b.getX(ie)), U >= 2 && W.setY(ie, b.getY(ie)), U >= 3 && W.setZ(ie, b.getZ(ie)), U >= 4 && W.setW(ie, b.getW(ie));
                return W;
              }
              function c(b) {
                const D = b.attributes, S = b.morphTargets, U = /* @__PURE__ */ new Map();
                for (const G in D) {
                  const Z = D[G];
                  Z.isInterleavedBufferAttribute && (U.has(Z) || U.set(Z, p(Z)), D[G] = U.get(Z));
                }
                for (const G in S) {
                  const Z = S[G];
                  Z.isInterleavedBufferAttribute && (U.has(Z) || U.set(Z, p(Z)), S[G] = U.get(Z));
                }
              }
              function g(b) {
                let D = 0;
                for (const U in b.attributes) {
                  const G = b.getAttribute(U);
                  D += G.count * G.itemSize * G.array.BYTES_PER_ELEMENT;
                }
                const S = b.getIndex();
                return D += S ? S.count * S.itemSize * S.array.BYTES_PER_ELEMENT : 0, D;
              }
              function A(b, D = 1e-4) {
                D = Math.max(D, Number.EPSILON);
                const S = {}, U = b.getIndex(), G = b.getAttribute("position"), Z = U ? U.count : G.count;
                let W = 0;
                const ie = Object.keys(b.attributes), te = {}, X = {}, Q = [], O = ["getX", "getY", "getZ", "getW"], K = ["setX", "setY", "setZ", "setW"];
                for (let Ve = 0, st = ie.length; Ve < st; Ve++) {
                  const ut = ie[Ve], It = b.attributes[ut];
                  te[ut] = new C.BufferAttribute(new It.array.constructor(It.count * It.itemSize), It.itemSize, It.normalized);
                  const ht = b.morphAttributes[ut];
                  ht && (X[ut] = new C.BufferAttribute(new ht.array.constructor(ht.count * ht.itemSize), ht.itemSize, ht.normalized));
                }
                const ne = D * 0.5, pe = Math.log10(1 / D), be = Math.pow(10, pe), Te = ne * be;
                for (let Ve = 0; Ve < Z; Ve++) {
                  const st = U ? U.getX(Ve) : Ve;
                  let ut = "";
                  for (let It = 0, ht = ie.length; It < ht; It++) {
                    const Rt = ie[It], Qt = b.getAttribute(Rt), cn = Qt.itemSize;
                    for (let Cn = 0; Cn < cn; Cn++)
                      ut += `${~~(Qt[O[Cn]](st) * be + Te)},`;
                  }
                  if (ut in S)
                    Q.push(S[ut]);
                  else {
                    for (let It = 0, ht = ie.length; It < ht; It++) {
                      const Rt = ie[It], Qt = b.getAttribute(Rt), cn = b.morphAttributes[Rt], Cn = Qt.itemSize, Tn = te[Rt], wn = X[Rt];
                      for (let rn = 0; rn < Cn; rn++) {
                        const Bn = O[rn], di = K[rn];
                        if (Tn[di](W, Qt[Bn](st)), cn)
                          for (let ri = 0, Ni = cn.length; ri < Ni; ri++)
                            wn[ri][di](W, cn[ri][Bn](st));
                      }
                    }
                    S[ut] = W, Q.push(W), W++;
                  }
                }
                const ke = b.clone();
                for (const Ve in b.attributes) {
                  const st = te[Ve];
                  if (ke.setAttribute(Ve, new C.BufferAttribute(st.array.slice(0, W * st.itemSize), st.itemSize, st.normalized)), Ve in X)
                    for (let ut = 0; ut < X[Ve].length; ut++) {
                      const It = X[Ve][ut];
                      ke.morphAttributes[Ve][ut] = new C.BufferAttribute(It.array.slice(0, W * It.itemSize), It.itemSize, It.normalized);
                    }
                }
                return ke.setIndex(Q), ke;
              }
              function u(b, D) {
                if (D === C.TrianglesDrawMode)
                  return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), b;
                if (D === C.TriangleFanDrawMode || D === C.TriangleStripDrawMode) {
                  let S = b.getIndex();
                  if (S === null) {
                    const W = [], ie = b.getAttribute("position");
                    if (ie !== void 0) {
                      for (let te = 0; te < ie.count; te++)
                        W.push(te);
                      b.setIndex(W), S = b.getIndex();
                    } else
                      return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), b;
                  }
                  const U = S.count - 2, G = [];
                  if (D === C.TriangleFanDrawMode)
                    for (let W = 1; W <= U; W++)
                      G.push(S.getX(0)), G.push(S.getX(W)), G.push(S.getX(W + 1));
                  else
                    for (let W = 0; W < U; W++)
                      W % 2 === 0 ? (G.push(S.getX(W)), G.push(S.getX(W + 1)), G.push(S.getX(W + 2))) : (G.push(S.getX(W + 2)), G.push(S.getX(W + 1)), G.push(S.getX(W)));
                  G.length / 3 !== U && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                  const Z = b.clone();
                  return Z.setIndex(G), Z.clearGroups(), Z;
                } else
                  return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", D), b;
              }
              function f(b) {
                const D = new C.Vector3(), S = new C.Vector3(), U = new C.Vector3(), G = new C.Vector3(), Z = new C.Vector3(), W = new C.Vector3(), ie = new C.Vector3(), te = new C.Vector3(), X = new C.Vector3();
                function Q(Et, Dt, $t, ei, Dn, Yt, Xe, le) {
                  D.fromBufferAttribute(Dt, Dn), S.fromBufferAttribute(Dt, Yt), U.fromBufferAttribute(Dt, Xe);
                  const ae = Et.morphTargetInfluences;
                  if ($t && ae) {
                    ie.set(0, 0, 0), te.set(0, 0, 0), X.set(0, 0, 0);
                    for (let Ce = 0, fe = $t.length; Ce < fe; Ce++) {
                      const ge = ae[Ce], xe = $t[Ce];
                      ge !== 0 && (G.fromBufferAttribute(xe, Dn), Z.fromBufferAttribute(xe, Yt), W.fromBufferAttribute(xe, Xe), ei ? (ie.addScaledVector(G, ge), te.addScaledVector(Z, ge), X.addScaledVector(W, ge)) : (ie.addScaledVector(G.sub(D), ge), te.addScaledVector(Z.sub(S), ge), X.addScaledVector(W.sub(U), ge)));
                    }
                    D.add(ie), S.add(te), U.add(X);
                  }
                  Et.isSkinnedMesh && (Et.applyBoneTransform(Dn, D), Et.applyBoneTransform(Yt, S), Et.applyBoneTransform(Xe, U)), le[Dn * 3 + 0] = D.x, le[Dn * 3 + 1] = D.y, le[Dn * 3 + 2] = D.z, le[Yt * 3 + 0] = S.x, le[Yt * 3 + 1] = S.y, le[Yt * 3 + 2] = S.z, le[Xe * 3 + 0] = U.x, le[Xe * 3 + 1] = U.y, le[Xe * 3 + 2] = U.z;
                }
                const O = b.geometry, K = b.material;
                let ne, pe, be;
                const Te = O.index, ke = O.attributes.position, Ve = O.morphAttributes.position, st = O.morphTargetsRelative, ut = O.attributes.normal, It = O.morphAttributes.position, ht = O.groups, Rt = O.drawRange;
                let Qt, cn, Cn, Tn, wn, rn, Bn;
                const di = new Float32Array(ke.count * ke.itemSize), ri = new Float32Array(ut.count * ut.itemSize);
                if (Te !== null)
                  if (Array.isArray(K))
                    for (Qt = 0, Cn = ht.length; Qt < Cn; Qt++)
                      for (wn = ht[Qt], rn = Math.max(wn.start, Rt.start), Bn = Math.min(wn.start + wn.count, Rt.start + Rt.count), cn = rn, Tn = Bn; cn < Tn; cn += 3)
                        ne = Te.getX(cn), pe = Te.getX(cn + 1), be = Te.getX(cn + 2), Q(b, ke, Ve, st, ne, pe, be, di), Q(b, ut, It, st, ne, pe, be, ri);
                  else
                    for (rn = Math.max(0, Rt.start), Bn = Math.min(Te.count, Rt.start + Rt.count), Qt = rn, Cn = Bn; Qt < Cn; Qt += 3)
                      ne = Te.getX(Qt), pe = Te.getX(Qt + 1), be = Te.getX(Qt + 2), Q(b, ke, Ve, st, ne, pe, be, di), Q(b, ut, It, st, ne, pe, be, ri);
                else if (Array.isArray(K))
                  for (Qt = 0, Cn = ht.length; Qt < Cn; Qt++)
                    for (wn = ht[Qt], rn = Math.max(wn.start, Rt.start), Bn = Math.min(wn.start + wn.count, Rt.start + Rt.count), cn = rn, Tn = Bn; cn < Tn; cn += 3)
                      ne = cn, pe = cn + 1, be = cn + 2, Q(b, ke, Ve, st, ne, pe, be, di), Q(b, ut, It, st, ne, pe, be, ri);
                else
                  for (rn = Math.max(0, Rt.start), Bn = Math.min(ke.count, Rt.start + Rt.count), Qt = rn, Cn = Bn; Qt < Cn; Qt += 3)
                    ne = Qt, pe = Qt + 1, be = Qt + 2, Q(b, ke, Ve, st, ne, pe, be, di), Q(b, ut, It, st, ne, pe, be, ri);
                const Ni = new C.Float32BufferAttribute(di, 3), Be = new C.Float32BufferAttribute(ri, 3);
                return {
                  positionAttribute: ke,
                  normalAttribute: ut,
                  morphedPositionAttribute: Ni,
                  morphedNormalAttribute: Be
                };
              }
              function x(b) {
                if (b.groups.length === 0)
                  return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), b;
                let D = b.groups;
                if (D = D.sort((W, ie) => W.materialIndex !== ie.materialIndex ? W.materialIndex - ie.materialIndex : W.start - ie.start), b.getIndex() === null) {
                  const W = b.getAttribute("position"), ie = [];
                  for (let te = 0; te < W.count; te += 3)
                    ie.push(te, te + 1, te + 2);
                  b.setIndex(ie);
                }
                const S = b.getIndex(), U = [];
                for (let W = 0; W < D.length; W++) {
                  const ie = D[W], te = ie.start, X = te + ie.count;
                  for (let Q = te; Q < X; Q++)
                    U.push(S.getX(Q));
                }
                b.dispose(), b.setIndex(U);
                let G = 0;
                for (let W = 0; W < D.length; W++) {
                  const ie = D[W];
                  ie.start = G, G += ie.count;
                }
                let Z = D[0];
                b.groups = [Z];
                for (let W = 1; W < D.length; W++) {
                  const ie = D[W];
                  Z.materialIndex === ie.materialIndex ? Z.count += ie.count : (Z = ie, b.groups.push(Z));
                }
                return b;
              }
              function T(b, D = Math.PI / 3) {
                const S = Math.cos(D), U = (1 + 1e-10) * 100, G = [new C.Vector3(), new C.Vector3(), new C.Vector3()], Z = new C.Vector3(), W = new C.Vector3(), ie = new C.Vector3(), te = new C.Vector3();
                function X(be) {
                  const Te = ~~(be.x * U), ke = ~~(be.y * U), Ve = ~~(be.z * U);
                  return `${Te},${ke},${Ve}`;
                }
                const Q = b.index ? b.toNonIndexed() : b, O = Q.attributes.position, K = {};
                for (let be = 0, Te = O.count / 3; be < Te; be++) {
                  const ke = 3 * be, Ve = G[0].fromBufferAttribute(O, ke + 0), st = G[1].fromBufferAttribute(O, ke + 1), ut = G[2].fromBufferAttribute(O, ke + 2);
                  Z.subVectors(ut, st), W.subVectors(Ve, st);
                  const It = new C.Vector3().crossVectors(Z, W).normalize();
                  for (let ht = 0; ht < 3; ht++) {
                    const Rt = G[ht], Qt = X(Rt);
                    Qt in K || (K[Qt] = []), K[Qt].push(It);
                  }
                }
                const ne = new Float32Array(O.count * 3), pe = new C.BufferAttribute(ne, 3, !1);
                for (let be = 0, Te = O.count / 3; be < Te; be++) {
                  const ke = 3 * be, Ve = G[0].fromBufferAttribute(O, ke + 0), st = G[1].fromBufferAttribute(O, ke + 1), ut = G[2].fromBufferAttribute(O, ke + 2);
                  Z.subVectors(ut, st), W.subVectors(Ve, st), ie.crossVectors(Z, W).normalize();
                  for (let It = 0; It < 3; It++) {
                    const ht = G[It], Rt = X(ht), Qt = K[Rt];
                    te.set(0, 0, 0);
                    for (let cn = 0, Cn = Qt.length; cn < Cn; cn++) {
                      const Tn = Qt[cn];
                      ie.dot(Tn) > S && te.add(Tn);
                    }
                    te.normalize(), pe.setXYZ(ke + It, te.x, te.y, te.z);
                  }
                }
                return Q.setAttribute("normal", pe), Q;
              }
            }
          ),
          /***/
          "./node_modules/three/examples/jsm/utils/WorkerPool.js": (
            /*!*************************************************************!*\
              !*** ./node_modules/three/examples/jsm/utils/WorkerPool.js ***!
              \*************************************************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                WorkerPool: () => (
                  /* binding */
                  C
                )
                /* harmony export */
              });
              class C {
                constructor(E = 4) {
                  this.pool = E, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
                }
                _initWorker(E) {
                  if (!this.workers[E]) {
                    const y = this.workerCreator();
                    y.addEventListener("message", this._onMessage.bind(this, E)), this.workers[E] = y;
                  }
                }
                _getIdleWorker() {
                  for (let E = 0; E < this.pool; E++) if (!(this.workerStatus & 1 << E)) return E;
                  return -1;
                }
                _onMessage(E, y) {
                  const l = this.workersResolve[E];
                  if (l && l(y), this.queue.length) {
                    const {
                      resolve: d,
                      msg: p,
                      transfer: c
                    } = this.queue.shift();
                    this.workersResolve[E] = d, this.workers[E].postMessage(p, c);
                  } else
                    this.workerStatus ^= 1 << E;
                }
                setWorkerCreator(E) {
                  this.workerCreator = E;
                }
                setWorkerLimit(E) {
                  this.pool = E;
                }
                postMessage(E, y) {
                  return new Promise((l) => {
                    const d = this._getIdleWorker();
                    d !== -1 ? (this._initWorker(d), this.workerStatus |= 1 << d, this.workersResolve[d] = l, this.workers[d].postMessage(E, y)) : this.queue.push({
                      resolve: l,
                      msg: E,
                      transfer: y
                    });
                  });
                }
                dispose() {
                  this.workers.forEach((E) => E.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
                }
              }
            }
          ),
          /***/
          "./src/lib/three.mjs": (
            /*!***************************!*\
              !*** ./src/lib/three.mjs ***!
              \***************************/
            /***/
            (j, re, v) => {
              v.r(re), v.d(re, {
                /* harmony export */
                default: () => u
                /* harmony export */
              });
              var C = v(
                /*! three */
                "./node_modules/three/build/three.module.js"
              ), w = v(
                /*! three/examples/jsm/loaders/DRACOLoader.js */
                "./node_modules/three/examples/jsm/loaders/DRACOLoader.js"
              ), E = v(
                /*! three/examples/jsm/loaders/GLTFLoader.js */
                "./node_modules/three/examples/jsm/loaders/GLTFLoader.js"
              ), y = v(
                /*! three/examples/jsm/loaders/KTX2Loader.js */
                "./node_modules/three/examples/jsm/loaders/KTX2Loader.js"
              ), l = v(
                /*! three/addons/math/OBB.js */
                "./node_modules/three/examples/jsm/math/OBB.js"
              ), d = v(
                /*! three/examples/jsm/loaders/OBJLoader.js */
                "./node_modules/three/examples/jsm/loaders/OBJLoader.js"
              ), p = v(
                /*! three/examples/jsm/loaders/MTLLoader.js */
                "./node_modules/three/examples/jsm/loaders/MTLLoader.js"
              ), c = v(
                /*! three/examples/jsm/utils/BufferGeometryUtils.js */
                "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"
              ), g = v(
                /*! three/examples/jsm/lights/LightProbeGenerator.js */
                "./node_modules/three/examples/jsm/lights/LightProbeGenerator.js"
              ), A = { ...C };
              A.DRACOLoader = w.DRACOLoader, A.GLTFLoader = E.GLTFLoader, A.KTX2Loader = y.KTX2Loader, A.OBJLoader = d.OBJLoader, A.MTLLoader = p.MTLLoader, A.OBB = l.OBB, A.BufferGeometryUtils = c, A.LightProbeGenerator = g.LightProbeGenerator;
              const u = A;
            }
          ),
          /***/
          "./package.json": (
            /*!**********************!*\
              !*** ./package.json ***!
              \**********************/
            /***/
            (j) => {
              j.exports = JSON.parse('{"name":"aframe","version":"1.6.0","description":"A web framework for building virtual reality experiences.","homepage":"https://aframe.io/","main":"dist/aframe-master.js","scripts":{"dev":"cross-env INSPECTOR_VERSION=dev webpack serve --port 8080","dist":"node scripts/updateVersionLog.js && npm run dist:min && npm run dist:max","dist:max":"webpack --config webpack.config.js","dist:min":"webpack --config webpack.prod.config.js","docs":"markserv --dir docs --port 9001","preghpages":"node ./scripts/preghpages.js","ghpages":"ghpages -p gh-pages/","lint":"standardx -v | snazzy","lint:fix":"standardx --fix","precommit":"npm run lint","prepush":"node scripts/testOnlyCheck.js","prerelease":"node scripts/release.js 1.5.0 1.6.0","start":"npm run dev","start:https":"npm run dev -- --server-type https","test":"karma start ./tests/karma.conf.js","test:docs":"node scripts/docsLint.js","test:firefox":"npm test -- --browsers Firefox","test:chrome":"npm test -- --browsers Chrome","test:nobrowser":"NO_BROWSER=true npm test","test:node":"node --experimental-require-module ./node_modules/mocha/bin/mocha --ui tdd tests/node"},"repository":"aframevr/aframe","license":"MIT","files":["dist/*","docs/**/*","src/**/*","vendor/**/*"],"dependencies":{"buffer":"^6.0.3","debug":"^4.3.4","deep-assign":"^2.0.0","load-bmfont":"^1.2.3","super-animejs":"^3.1.0","three":"npm:super-three@0.164.0","three-bmfont-text":"dmarcos/three-bmfont-text#eed4878795be9b3e38cf6aec6b903f56acd1f695","webvr-polyfill":"^0.10.12"},"devDependencies":{"@babel/core":"^7.17.10","babel-loader":"^8.2.5","babel-plugin-istanbul":"^6.1.1","chai":"^4.3.6","chai-shallow-deep-equal":"^1.4.0","chalk":"^1.1.3","cross-env":"^7.0.3","css-loader":"^6.7.1","eslint":"^8.45.0","eslint-config-semistandard":"^17.0.0","eslint-config-standard-jsx":"^11.0.0","ghpages":"0.0.8","git-rev":"^0.2.1","glob":"^8.0.3","husky":"^0.11.7","jsdom":"^24.0.0","jsdom-global":"^3.0.2","karma":"^6.4.0","karma-chai-shallow-deep-equal":"0.0.4","karma-chrome-launcher":"^3.1.1","karma-coverage":"^2.2.0","karma-env-preprocessor":"^0.1.1","karma-firefox-launcher":"^2.1.2","karma-mocha":"^2.0.1","karma-mocha-reporter":"^2.2.5","karma-sinon-chai":"^2.0.2","karma-webpack":"^5.0.0","markserv":"github:sukima/markserv#feature/fix-broken-websoketio-link","mocha":"^10.0.0","replace-in-file":"^2.5.3","shelljs":"^0.7.7","shx":"^0.2.2","sinon":"<12.0.0","sinon-chai":"^3.7.0","snazzy":"^5.0.0","standardx":"^7.0.0","style-loader":"^3.3.1","too-wordy":"ngokevin/too-wordy","webpack":"^5.73.0","webpack-cli":"^4.10.0","webpack-dev-server":"^4.11.0","webpack-merge":"^5.8.0","write-good":"^1.0.8"},"link":true,"standardx":{"ignore":["build/**","dist/**","examples/**/shaders/*.js","**/vendor/**"]},"keywords":["3d","aframe","cardboard","components","oculus","three","three.js","rift","vive","vr","quest","meta","web-components","webvr","webxr"],"engines":{"node":">= 4.6.0","npm":">= 2.15.9"}}');
            }
          )
          /******/
        }, is = {};
        function ir(j) {
          var re = is[j];
          if (re !== void 0)
            return re.exports;
          var v = is[j] = {
            /******/
            id: j,
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return gs[j].call(v.exports, v, v.exports, ir), v.exports;
        }
        ir.m = gs, ir.n = (j) => {
          var re = j && j.__esModule ? (
            /******/
            () => j.default
          ) : (
            /******/
            () => j
          );
          return ir.d(re, { a: re }), re;
        }, ir.d = (j, re) => {
          for (var v in re)
            ir.o(re, v) && !ir.o(j, v) && Object.defineProperty(j, v, { enumerable: !0, get: re[v] });
        }, ir.g = function() {
          if (typeof globalThis == "object") return globalThis;
          try {
            return this || new Function("return this")();
          } catch {
            if (typeof window == "object") return window;
          }
        }(), ir.o = (j, re) => Object.prototype.hasOwnProperty.call(j, re), ir.r = (j) => {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(j, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(j, "__esModule", { value: !0 });
        }, ir.b = document.baseURI || self.location.href, ir.nc = void 0;
        var cs = ir("./src/index.js");
        return cs;
      })()
    ));
  }(kh)), kh.exports;
}
var c1 = l1();
class j1 {
  buttons = [];
  // list of elements with "VRify-Button" class.
  scene = null;
  //a-scene element
  setup() {
    console.log(c1.AScene), this.buttons = [], document.getElementById("VRify-Scene") && document.getElementById("VRify-Scene").remove(), this.buttons = document.getElementsByClassName("VRify-Button");
    for (var Ln = 0; Ln < this.buttons.length; Ln++) {
      var gs = this.buttons[Ln];
      gs.onclick = function() {
        this.scene = document.createElement("a-scene"), this.scene.id = "VRify-Scene", this.scene.setAttribute("environment", "preset: tron");
        const is = document.createElement("a-box");
        is.setAttribute("color", "red"), this.scene.appendChild(is), document.body.appendChild(this.scene);
      };
    }
  }
  ready(Ln) {
    document.readyState == "complete" ? Ln() : document.addEventListener("readystatechange", function() {
      document.readyState == "complete" && Ln();
    });
  }
}
export {
  j1 as default
};
